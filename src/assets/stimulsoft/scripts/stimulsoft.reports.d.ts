/*
Stimulsoft.Reports.JS
Version: 2019.3.2
Build date: 2019.06.17
License: https://www.stimulsoft.com/en/licensing/reports
*/
declare module Stimulsoft.System.Collections {
    class CollectionBase<T> implements ICollection<T> {
        protected _list: Array<T>;
        readonly list: Array<T>;
        implements(): string[];
        /** Gets the number of elements contained in the CollectionBase instance. */
        readonly count: number;
        /** Removes all objects from the CollectionBase instance. */
        clear(): void;
        removeAt(index: number): void;
        protected onClear(): void;
        protected onInsertComplete(index: number, value: Object): void;
        protected onRemoveComplete(index: number, value: Object): void;
        protected onClearComplete(): void;
    }
}
declare module Stimulsoft.System.Collections {
    class Dictionary<K, V> {
        constructor();
        keys: K[];
        values: V[];
        readonly count: number;
        readonly pairs: {
            key: K;
            value: V;
        }[];
        contains(key: K): boolean;
        get(key: K): V;
        set(key: K, value: V): void;
        add(key: K, value: V): void;
        remove(key: K): void;
        clear(): void;
        tryGetValue(key: K, out: {
            ref: V;
        }): boolean;
    }
}
declare module Stimulsoft.System.Collections {
    class DictionaryEntry {
        key: any;
        value: any;
    }
}
declare module Stimulsoft.System.Collections {
    class List<T> extends Array<T> {
        constructor(items?: Array<T> | number);
        get(index: number): T;
        getRange(index: number, count: number): List<T>;
        count2(selector?: (value: T) => boolean, __this?: any): number;
        add(item: T): void;
        /** Removes all elements from the List.*/
        clear(): void;
        /** Determines whether an element is in the List.
         * @param item The object to locate in the List. The value can be null for reference types.
         * @returns true if item is found in the List otherwise, false.*/
        contains(item: T): boolean;
        /** Removes the element at the specified index of the Lis.
         * @param index The zero-based index of the element to remove.
         * @throw index is less than 0. -or- index is equal to or greater than Count.*/
        removeAt(index: number): void;
        /**
         * Applies an accumulator function over a sequence.
         * @param func An accumulator function to be invoked on each element.
         * @returns The final accumulator value.
         */
        aggregate(func: (av: T, e: T) => T): T;
        aggregate2(seed: T, func: (av: T, e: T) => T): T;
        /**
         * Projects each element of a sequence into a new form.
         * @param selector A transform function to apply to each element.
         * @returns An List whose elements are the result of invoking the transform function on each element of source.
         */
        
        
        selectMany2<C>(collectionSelector: (value: T) => List<C>, resultSelector: (value1: T, value2: C) => C, __this?: any): List<C>;
        union(second: List<T>): List<T>;
        first(selector?: (value: T) => boolean, __this?: any): T;
        /** Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.
         * @param predicate A function to test each element for a condition.
         * @returns if source is empty or if no element passes the test specified by predicate;
         * otherwise, the first element in source that passes the test specified by predicate.*/
        firstOrDefault(predicate?: (value: T) => boolean): T;
        /** Filters a sequence of values based on a predicate.
        * @param predicate A function to test each element for a condition.
        * @returns An List that contains elements from the input sequence that satisfy the condition.*/
        
        /** Determines whether any element of a sequence satisfies a condition.
         * @param predicate A function to test each element for a condition.
         * @returns true if any elements in the source sequence pass the test in the specified predicate; otherwise, false.*/
        any(predicate?: (value: T) => boolean, __this?: any): boolean;
        all(predicate?: (value: T) => boolean, __this?: any): boolean;
        /** Invokes a transform function on each element of a sequence and returns the maximum value.
         * @param selector A transform function to apply to each element.
         * @returns The maximum value in the sequence.*/
        max2<S>(selector?: (value: T) => S): S;
        /** Invokes a transform function on each element of a sequence and returns the minimum value.
         * @parm selector A transform function to apply to each element.
         * @returns The minimum value in the sequence.*/
        min2<S>(selector?: (value: T) => S): S;
        /** Computes the sum of the sequence of System.Decimal values that are obtained by
         * invoking a transform function on each element of the input sequence.
         * @param selector A transform function to apply to each element.
         * @returns The sum of the projected values.*/
        sum(selector?: (value: T) => number): number;
        /** Returns distinct elements from a sequence by using the default equality comparer to compare values.
         * @returns An List that contains distinct elements from the source sequence.*/
        distinct(): List<T>;
        /** Converts the elements of an List to the specified type.
         * @returns An List that contains each element of the source sequence converted to the specified type.*/
        cast<S>(): List<S>;
        /** Sorts the elements of a sequence in ascending order according to a key or by using a specified comparer.
         * @param keySelector A function to extract a key from an element.
         * @param comparer An System.Collections.Generic.IComparer`1 to compare keys.
         * @returns An System.Linq.IOrderedEnumerable`1 whose elements are sorted according to a key.*/
        
        orderByDescending<K>(keySelector: (value: T) => K, comparer?: IComparer<K>): List<T>;
        exists(predicate: (value: T) => boolean): boolean;
        readonly length: number;
        /** Groups the elements of a sequence according to a specified key selector function
         * and compares the keys by using a specified comparer.
         * @param keySelector A function to extract the key for each element.
         * @param comparer An System.Collections.Generic.IEqualityComparer`1 to compare keys.
         * @returns An IEnumerable<IGrouping<TKey, TSource>> in C# or IEnumerable(Of IGrouping(Of
         * TKey, TSource)) in Visual Basic where each System.Linq.IGrouping`2 object contains
         * a collection of objects and a key.*/
        groupBy<K>(keySelector: (value: T) => K, comparer?: IEqualityComparer<K>, __this?: any): List<Grouping<K, T>>;
        lastOrDefault(): T;
        defaultIfEmpty(): List<T>;
        /** Correlates the elements of two sequences based on matching keys. The default
         * equality comparer is used to compare keys.
         * @param inner The sequence to join to the first sequence.
         * @param outerKeySelector A function to extract the join key from each element of the first sequence.
         * @param innerKeySelector A function to extract the join key from each element of the second sequence.
         * @param resultSelector A function to create a result element from two matching elements.
         * @returns An List that has elements of type V
         * that are obtained by performing an inner join on two sequences.*/
        join2<U, K, V>(inner: List<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: U) => V, __this?: any): List<V>;
        /** Correlates the elements of two sequences based on equality of keys and groups
         * the results. The default equality comparer is used to compare keys.
         * @param inner The sequence to join to the first sequence.
         * @param outerKeySelector A function to extract the join key from each element of the first sequence.
         * @param innerKeySelector A function to extract the join key from each element of the second sequence.
         * @param resultSelector A function to create a result element from an element from the first sequence
         * and a collection of matching elements from the second sequence.
         * @returns An List that contains elements of type V
         * that are obtained by performing a grouped join on two sequences.*/
        groupJoin<U, K, V>(inner: List<U>, outerKeySelector: (value: T) => K, innerKeySelector: (value: U) => K, resultSelector: (value1: T, value2: List<U>) => V, __this?: any): List<V>;
        fullOuterJoin<K>(inner: List<T>, outerKeySelector: (value: T) => K, innerKeySelector: (value: T) => K, resultSelector: (value1: T, value2: T) => T, __this?: any): List<T>;
        /** Creates a Lookup from an List
         * according to a specified key selector function.
         * @param keySelector A function to extract a key from each element.
         * @returns A Lookup that contains keys and values.*/
        toLookup<K>(keySelector: (value: T) => K, __this?: any): Hashtable;
        /** Concatenates two sequences.
         * @param second The sequence to concatenate to the first sequence.
         * @returns An List that contains the concatenated elements
         * of the two input sequences.*/
        
        toList(): List<T>;
        findIndex2(match: (value: T) => boolean): number;
        take(count: number): List<T>;
        except(second: List<T>): List<T>;
        
        zip<S, R>(second: List<S>, resultSelector: (first: T, second: S) => R): List<R>;
        toDictionary<K, V>(keySelector: (item: T) => K, elementSelector: (item: T) => V): Dictionary<K, V>;
        static repeat<T>(element: T, count: number): List<T>;
        whereEqualsTo(values1: any, values2: any): List<any[]>;
        whereArrayItemEqualsTo(itemIndex: number, value: any): List<any[]>;
        whereArrayItemStringEqualsTo(itemIndex: number, value: string): List<any[]>;
        whereFirstOrDefaultArrayItemStringEqualsTo(itemIndex: number, value: string): any[];
        static toString2(value: any): string;
        getArrayItem(itemIndex: number): List<any[]>;
        tryCastValueOrFirstDefaultToNullableNumber(): List<number | null>;
        tryCastToNullableNumber(): List<number | null>;
        tryCastToNumber(): List<number | null>;
        tryCastToBool(): List<boolean | null>;
        tryCastToDateTime(): List<DateTime>;
        tryCastToNullableDateTime(): List<DateTime | null>;
        tryCastToTimeSpan(): List<TimeSpan>;
        tryCastToNullableTimeSpan(): List<TimeSpan | null>;
        tryCastToString(): List<string>;
        firstOrDefaultAsNullableNumber(): number | null;
        firstOrDefaultAsNumber(): number;
        static getValueOrFirstOrDefault(value: any): any;
        static add2(a: any, b: any): List<any>;
        static sub(a: any, b: any): List<any>;
        static mult(a: any, b: any): List<any>;
        static bitwiseAnd(a: any, b: any): List<any>;
        static bitwiseXOr(a: any, b: any): List<any>;
        static bitwiseOr(a: any, b: any): List<any>;
        static div(a: any, b: any): List<any>;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Grouping<K, V> extends List<V> {
        key: K;
    }
}
declare module Stimulsoft.System.Collections {
    class Hashtable {
        private isSimpleKeys;
        keys: any[];
        values: any[];
        private indexObject;
        get(key: any): any;
        set(key: any, value: any): void;
        /** Adds an element with the specified key and value into the Hashtable. */
        add(key: any, value: any): void;
        /** Determines whether the Hashtable contains a specific key. */
        contains(key: any): boolean;
        /** Determines whether the Hashtable contains a specific key. */
        containsKey(key: any): boolean;
        /** Determines whether the Hashtable contains a specific value. */
        containsValue(value: any): boolean;
        /** Removes the element with the specified key from the Hashtable. */
        remove(key: any): void;
        /** Removes all elements from the Hashtable. */
        clear(): void;
        /** Copies the Hashtable elements to a one-dimensional Array instance at the specified index. */
        copyTo(array: Array<any>, arrayIndex: number): void;
        /** Gets the number of key/value pairs contained in the Hashtable. */
        readonly count: number;
        clone(): Hashtable;
    }
}
declare module Stimulsoft.System.Collections {
    var ICollection: string;
    interface ICollection<T> {
        list: Array<T>;
        clear(): any;
        removeAt(index: number): any;
        count: number;
    }
}
declare module Stimulsoft.System.Collections {
    var IComparer: string;
    interface IComparer<T> {
        compare(x: T, y: T): number;
    }
}
declare module Stimulsoft.System.Collections {
    var IEnumerator: string;
    interface IEnumerator {
        current: Object;
        moveNext(): boolean;
        reset(): any;
    }
}
declare module Stimulsoft.System.Collections {
    var IEqualityComparer: string;
    interface IEqualityComparer<T> {
        equals(x: T, y: T): boolean;
        getHashCode(obj: T): number;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Queue<T> {
        dequeue(): T;
        enqueue(item: T): void;
        readonly count: number;
        clear(): void;
    }
}
declare namespace Stimulsoft.System.Collections {
    class Stack<T> {
        pop(): T;
        push(item: T): void;
        clear(): void;
    }
}
declare module Stimulsoft.System.ComponentModel {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class TypeConverter {
        canConvertFrom(context: any, sourceType: Stimulsoft.System.Type): boolean;
        canConvertTo(context: any, sourceType: Stimulsoft.System.Type): boolean;
        convertTo(context: any, culture: CultureInfo, value: any, destinationType: Stimulsoft.System.Type): any;
        convertFrom(context: any, culture: CultureInfo, value: any): any;
        convertToString(value: any): string;
        convertFromString(text: string): any;
    }
}
declare module Stimulsoft.System.Crypt {
    class AES {
        private key;
        private data;
        private nDataBytes;
        private blockSize;
        private iv;
        private prevBlock;
        private SBOX;
        private INV_SBOX;
        private SUB_MIX_0;
        private SUB_MIX_1;
        private SUB_MIX_2;
        private SUB_MIX_3;
        private INV_SUB_MIX_0;
        private INV_SUB_MIX_1;
        private INV_SUB_MIX_2;
        private INV_SUB_MIX_3;
        private RCON;
        private nRounds;
        private invKeySchedule;
        private keySchedule;
        private doReset;
        private process;
        private processBlock;
        private xorBlock;
        private pkcs7pad;
        private pkcs7Unpad;
        private encryptBlock;
        private decryptBlock;
        private doCryptBlock;
        static encrypt(text: string, key: string): string;
        private encrypt;
        static decrypt(text: string, key: string): string;
        private decrypt;
        constructor();
    }
}
declare module Stimulsoft.System.Crypt {
    class BigInteger {
        private static BI_RM;
        private static BI_RC;
        private static canary;
        private static j_lm;
        private static dbits;
        private static lowprimes;
        private static lplim;
        static staticConstructor(): void;
        private static fromInt;
        static ZERO: BigInteger;
        static ONE: BigInteger;
        readonly DV: number;
        readonly DB: number;
        readonly DM: number;
        private BI_FP;
        private readonly FV;
        private readonly F1;
        private readonly F2;
        t: number;
        s: number;
        am(i: number, x: number, w: BigInteger, j: number, c: number, n: number): number;
        static int2char(n: any): string;
        private int2char;
        private intAt;
        copyTo(r: BigInteger): void;
        private fromInt;
        static fromString(s: any, b?: number): BigInteger;
        fromString(s: any, b?: number): void;
        clamp(): void;
        toString(radix: number): string;
        private negate;
        abs(): BigInteger;
        compareTo(a: BigInteger): number;
        private nbits;
        bitLength(): number;
        dlShiftTo(n: number, r: BigInteger): void;
        drShiftTo(n: number, r: BigInteger): void;
        private lShiftTo;
        private rShiftTo;
        subTo(a: BigInteger, r: BigInteger): void;
        multiplyTo(a: BigInteger, r: BigInteger): void;
        squareTo(r: BigInteger): void;
        divRemTo(m: BigInteger, q: BigInteger, r: BigInteger): void;
        mod(a: BigInteger): BigInteger;
        invDigit(): number;
        private isEven;
        private exp;
        modPowInt(e: number, m: BigInteger): BigInteger;
        private clone;
        private intValue;
        private byteValue;
        private shortValue;
        private chunkSize;
        private signum;
        private toRadix;
        private fromRadix;
        static fromNumber(a: number, b: number, c: SecureRandom): BigInteger;
        fromNumber(a: number, b: number, c: SecureRandom): void;
        private fromNumber2;
        toByteArray(): number[];
        private bitwiseTo;
        private op_or;
        private shiftLeft;
        private shiftRight;
        private lbit;
        private getLowestSetBit;
        private testBit;
        private addTo;
        private add;
        subtract(a: BigInteger): BigInteger;
        multiply(a: BigInteger): BigInteger;
        square(): BigInteger;
        divide(a: any): BigInteger;
        private remainder;
        private multiply2;
        addOffset2(n: number, w: number): void;
        multiplyLowerTo(a: BigInteger, n: number, r: BigInteger): void;
        multiplyUpperTo(a: BigInteger, n: number, r: BigInteger): void;
        private modPow;
        gcd(a: BigInteger): BigInteger;
        private modInt;
        modInverse(m: BigInteger): BigInteger;
        isProbablePrime(t: any): boolean;
        private millerRabin;
    }
}
declare module Stimulsoft.System.Crypt {
    class RSAKey {
        private n;
        private e;
        private d;
        private p;
        private q;
        private dmp1;
        private dmq1;
        private coeff;
        verifyString(message: string, signature: string): boolean;
        private base64toHex;
        private parseBigInt;
        private pkcs1pad2;
        private pkcs1unpad2;
        setPublic(N: string, E: string): void;
        setPrivate(N: string, E: string, D: string): void;
        setPrivateEx(N: string, E: string, D: string, P: string, Q: string, DP: string, DQ: string, C: string): void;
        generate(B: number, E: string): void;
        doPublic(x: BigInteger): BigInteger;
        private doPrivate;
        encrypt(text: string): string;
        decrypt(ctext: string): string;
        constructor();
    }
}
declare module Stimulsoft.System.Crypt {
    class SHA1 {
        private blockLength;
        private state;
        private K;
        static signature: string;
        static hex(data: string): string;
        hex(data: string): string;
        private getMD;
        private rotl;
        private round;
        private paddingData;
        private toHex;
        private fromBigEndian32;
        private toBigEndian32;
        private unpack;
        private pack;
    }
}
declare module Stimulsoft.System.Crypt {
    class SecureRandom {
        private state;
        private pool;
        private position;
        private seedInteger;
        private seedTime;
        private getByte;
        nextBytes(ba: number[]): void;
        constructor();
    }
}
declare module Stimulsoft.System.Data {
    class DataStorage {
        values: any[];
        private _column;
        static createStorage(column: DataColumn, type: Type): DataStorage;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class BooleanStorage extends DataStorage {
        private static defaultValue;
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class ByteArrayStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class CharStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    enum CommandType {
        Text = 1,
        StoredProcedure = 4,
        TableDirect = 512
    }
}
declare module Stimulsoft.System.Data {
    class ConnectionState {
        static Closed: number;
        static Open: number;
        static Connecting: number;
        static Executing: number;
        static Fetching: number;
        static Broken: number;
    }
}
declare module Stimulsoft.System.Data {
    class DBNull {
        static value: DBNull;
    }
}
declare module Stimulsoft.System.Data {
    class DataColumn {
        clone(): DataColumn;
        private _caption;
        caption: string;
        storage: DataStorage;
        columnName: string;
        dataType: Type;
        table: DataTable;
        getRecord(record: number): any;
        setRecord(record: number, value: any): void;
        setTable(table: DataTable): void;
        delete(): void;
        private insureStorage;
        constructor(columnName: string, dataType?: Type, caption?: string);
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataColumnCollection extends CollectionBase<DataColumn> {
        private _table;
        readonly table: DataTable;
        private baseAdd;
        private baseRemove;
        add(column: DataColumn): void;
        contains(columnName: string): boolean;
        remove(column: DataColumn): void;
        getByName(name: string): DataColumn;
        getByIndex(index: number): DataColumn;
        getIndexByName(name: string): number;
        constructor(table: DataTable);
    }
}
declare module Stimulsoft.System.Data {
    class DataKey {
        private columns;
        readonly table: DataTable;
        readonly columnsReference: any[];
        getKeyValues(record: number): any[];
        getRows(values: any[]): any[];
        toArray(): any[];
        constructor(columns: DataColumn[], copyColumns: boolean);
    }
}
declare module Stimulsoft.System.Data {
    class DataRelation {
        private _childKey;
        readonly childKey: DataKey;
        private _parentKey;
        readonly parentKey: DataKey;
        private _dataSet;
        readonly dataSet: DataSet;
        private _relationName;
        relationName: string;
        readonly parentTable: DataTable;
        readonly childTable: DataTable;
        readonly parentColumns: any[];
        readonly childColumns: any[];
        private create;
        setDataSet(dataSet: DataSet): void;
        static getChildRows(parentKey: DataKey, childKey: DataKey, parentRow: DataRow): any[];
        static getParentRows(parentKey: DataKey, childKey: DataKey, childRow: DataRow): any[];
        constructor(relationName: string, parentColumns: DataColumn[], childColumns: DataColumn[]);
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRelationCollection extends CollectionBase<DataRelation> {
        addCore(relation: DataRelation): void;
        add(relation: DataRelation): void;
        addRange(relations: any[]): void;
        internalIndexOf(name: string): number;
        contains(name: string): boolean;
        remove(relation: DataRelation): void;
        removeAt(index: number): void;
        getByName(name: string): DataRelation;
        getByIndex(index: number): DataRelation;
        getDataSet(): DataSet;
        constructor();
    }
}
declare module Stimulsoft.System.Data {
    import List = Stimulsoft.System.Collections.List;
    class DataRow {
        recordIndex: number;
        static create(table: DataTable): DataRow;
        columns: DataColumnCollection;
        private _table;
        readonly table: DataTable;
        private getColumnIndex;
        gett(column: any): any;
        sett(column: any, value: any): void;
        readonly itemArray: any[];
        /** Get DataRow value by column identificator **/
        getValue(column: any): any;
        /** Set DataRow value by column identificator **/
        setValue(column: any, value: any): void;
        /** Get DataRow value by column index **/
        getValueByIndex(columnIndex: number): any;
        /** Set DataRow value by column index **/
        setValueByIndex(columnIndex: number, value: any): void;
        getDataColumn(columnName: string): DataColumn;
        getChildRows(relationName: string): any[];
        getParentRow(relationName: string): DataRow;
        getParentRows(relationName: string): any[];
        getKeyValues(key: DataKey): any[];
        static copyToDataTable(source: List<DataRow>): DataTable;
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataRowCollection extends CollectionBase<DataRow> {
        private _table;
        readonly table: DataTable;
        add(row: DataRow): number;
        remove(row: DataRow): void;
        addArray(row: DataRow): number;
        removeArray(row: DataRow): void;
        copyTo(array: any[], startIndex: number): void;
        private replaceValues;
        private quickSort;
        sort(...parameters: any[]): any;
        getByIndex(index: number): DataRow;
        gett(rowIndex: number, columnIndex: number): any;
        constructor(table: DataTable);
    }
}
declare module Stimulsoft.System.Text {
    class XMLConvert {
        static encodeName(name: string): string;
        static decodeName(name: string): string;
        private static fromHex;
        private static toHex;
    }
}
declare module Stimulsoft.System.Xml {
    class XmlNode {
        private _nodeName;
        nodeName: string;
        private _nodeType;
        nodeType: XmlNodeType;
        private _childNodes;
        childNodes: XmlNode[];
        private _localName;
        localName: string;
        private _textContent;
        textContent: string;
        readonly firstChild: XmlNode;
        private _attributes;
        attributes: XmlAttrCollection;
        private _parentNode;
        readonly parentNode: XmlNode;
        setParentNode(node: XmlNode): void;
        getAttribute(name?: string): string;
        item(index: number): XmlNode;
        getNodeByName(name?: string): XmlNode;
        getNodesByName(name?: string): XmlNode[];
    }
}
declare module Stimulsoft.System.Xml {
    enum XmlNodeType {
        ATTRIBUTE_NODE = 0,
        ELEMENT_NODE = 1,
        TEXT_NODE = 2,
        DOCUMENT_NODE = 3
    }
}
declare module Stimulsoft.System.Xml {
    class XmlConverter {
        static toXml(xmlString: string): XmlNode;
        static toXml2(xmlString: string): XmlNode;
        private static toXmlNode2;
        private static toXmlNode;
        static getXmlDocumentFromString(xmlString: string): any;
        static getAttributesArray(xmlDocument: any): any[];
        static getNodeType2(xmlDocument: any): number;
        static getNodeType(xmlDocument: any): number;
        static getNodeName(xmlDocument: any): string;
        static getNodeLocalName2(xmlDocument: any): string;
        static getNodeLocalName(xmlDocument: any): string;
        static getNodeTextContent(xmlDocument: any): string;
        static getChildNodesArray(xmlDocument: any): any[];
    }
}
declare module Stimulsoft.System.Data {
    enum JsonRelationDirection {
        ChildToParent = 0,
        ParentToChild = 1
    }
    class DataSet {
        private dataNode;
        private schemaNode;
        private isRetrieveColumns;
        private _dataSetName;
        dataSetName: string;
        private _tables;
        tables: DataTableCollection;
        private _relations;
        readonly relations: DataRelationCollection;
        private _enforceConstraints;
        enforceConstraints: boolean;
        dispose(): void;
        private correctJsonString;
        private correctJson;
        readJsonFile(filePath: string, jsonRelationDirection?: JsonRelationDirection): void;
        readJson(str: string, jsonRelationDirection?: JsonRelationDirection): any;
        readJson(data: number[], jsonRelationDirection?: JsonRelationDirection): any;
        readJson(data2: Uint8Array, jsonRelationDirection?: JsonRelationDirection): any;
        readJson(obj: Object, jsonRelationDirection?: JsonRelationDirection): any;
        readXmlFile(filePath: string): void;
        readXml(str: string): any;
        readXml(data: number[]): any;
        readXml(data2: Uint8Array): any;
        readXml(obj: Object): any;
        readXmlSchemaFile(filePath: string): void;
        readXmlSchema(str: string): any;
        readXmlSchema(data: number[]): any;
        readXmlSchema(obj: Object): any;
        private processObject2;
        private processObject;
        private processTable;
        private processArray;
        private fillDataSet;
        /** Заполняем структуру всех таблиц из xml-файла */
        private fillDataTables;
        private fillDataTable;
        /** Создаём структуру колонок таблицы из xml-файла */
        private getDataColumnsFromTable;
        /** Создаём и заполняем таблицу и все вложенные таблицы данными */
        private fillTable;
        /** Создаём и заполняем текущую строку данных таблицы */
        private fillRow;
        private parseSchema;
        /** Читаем все таблицы и связи из xsd-схемы */
        private getDataTables;
        /** Вычисление типа данных для хранилища DataColumn */
        private getStorageType;
        /** Читаем все колонки для текущей таблицы из xsd-схемы */
        private getDataColumns;
        /** Читаем все связи таблиц */
        private getRelations;
        /** Ищем нужную таблицу по её имени */
        private findTable;
        /** Ищем колонки в таблице по заданным именам */
        private findColumn;
        constructor(dataSetName?: string);
    }
}
declare module Stimulsoft.System.Data {
    class DataSetRelationCollection extends DataRelationCollection {
        private dataSet;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(dataSet: DataSet);
    }
}
declare module Stimulsoft.System.Data {
    import List = Stimulsoft.System.Collections.List;
    class DataTable {
        private _needCleanCache;
        private _index;
        /** Cache for DataKey.GetRows method */
        readonly index: any[];
        private _columns;
        readonly columns: DataColumnCollection;
        private _rows;
        readonly rows: DataRowCollection;
        private _tableName;
        tableName: string;
        private _dataSet;
        readonly dataSet: DataSet;
        private _defaultView;
        readonly defaultView: DataView;
        private _childRelationsCollection;
        readonly childRelations: DataRelationCollection;
        private _parentRelationsCollection;
        readonly parentRelations: DataRelationCollection;
        setDataSet(dataSet: DataSet): void;
        addRow(row: DataRow): number;
        removeRow(row: DataRow): void;
        addNewRow(): DataRow;
        private _extendedProperties;
        readonly extendedProperties: any;
        newRow(): DataRow;
        clone(): DataTable;
        copy(): DataTable;
        toList(): List<DataColumn>;
        /** Finds and updates a specific row. If no matching row is found, a new row is created
         * using the given values.
         * @param values An array of values used to create the new row.
         * @returns The new DataRow.
         * @throws The array is larger than the number of columns in the table.
         * @throws A value doesn't match its respective column type.*/
        loadDataRow(values: any[], acceptChanges?: boolean): DataRow;
        constructor(tableName?: string);
    }
}
declare module Stimulsoft.System.Data {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class DataTableCollection extends CollectionBase<DataTable> {
        add(table: DataTable): void;
        remove(table: DataTable): void;
        private baseAdd;
        private baseRemove;
        private _dataSet;
        readonly dataSet: DataSet;
        getByName(name: string): DataTable;
        getByIndex(index: number): DataTable;
        private checkTableName;
        constructor(dataSet: DataSet);
    }
}
declare module Stimulsoft.System.Data {
    class DataTableRelationCollection extends DataRelationCollection {
        private table;
        private parentCollection;
        private addCache;
        addCore(relation: DataRelation): void;
        getDataSet(): DataSet;
        constructor(table: DataTable, parentCollection: boolean);
    }
}
declare module Stimulsoft.System.Data {
    class DataView {
        clone(): DataView;
        rowFilter: string;
        table: DataTable;
        private ands;
        toTable(): DataTable;
        private filter;
        private isString;
        private parseConditions;
        private parse;
        constructor(table: DataTable);
    }
}
declare module Stimulsoft.System.Data {
    class DateTimeStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class DecimalStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    var IDbConnection: string;
    interface IDbConnection {
    }
}
declare module Stimulsoft.System.Data {
    class Int32Storage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    class ObjectStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Data {
    enum StorageType {
        ObjectType = 1,
        BooleanType = 3,
        CharType = 4,
        SByteType = 5,
        ByteType = 6,
        Number16Type = 7,
        Unumber16Type = 8,
        NumberType = 9,
        Number32Type = 9,
        Unumber32Type = 10,
        Number64Type = 11,
        Unumber64Type = 12,
        SingleType = 13,
        DoubleType = 14,
        DecimalType = 15,
        DateTimeType = 16,
        TimeSpanType = 17,
        StringType = 18,
        GuidType = 19,
        ByteArrayType = 20,
        IntType = 30,
        Int16Type = 31,
        Int32Type = 32,
        Int64Type = 33,
        UInt16Type = 34,
        UInt32Type = 35,
        UInt64Type = 36
    }
}
declare module Stimulsoft.System.Data {
    class StringStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Globalization {
    enum UnicodeCategory {
        /**
         * Uppercase letter. Signified by the Unicode designation "Lu" (letter, uppercase).
         * The value is 0.
         */
        UppercaseLetter = 0,
        /**
         * Lowercase letter. Signified by the Unicode designation "Ll" (letter, lowercase).
         * The value is 1.
         */
        LowercaseLetter = 1,
        /**
         * Titlecase letter. Signified by the Unicode designation "Lt" (letter, titlecase).
         * The value is 2.
         */
        TitlecaseLetter = 2,
        /**
         * Modifier letter character, which is free-standing spacing character that
         * indicates modifications of a preceding letter. Signified by the Unicode designation
         * "Lm" (letter, modifier). The value is 3.
         */
        ModifierLetter = 3,
        /**
         * Letter that is not an uppercase letter, a lowercase letter, a titlecase letter,
         * or a modifier letter. Signified by the Unicode designation "Lo" (letter,
         * other). The value is 4.
         */
        OtherLetter = 4,
        /**
         * Nonspacing character that indicates modifications of a base character. Signified
         * by the Unicode designation "Mn" (mark, nonspacing). The value is 5.
         */
        NonSpacingMark = 5,
        /**
         * Spacing character that indicates modifications of a base character and affects
         * the width of the glyph for that base character. Signified by the Unicode
         * designation "Mc" (mark, spacing combining). The value is 6.
         */
        SpacingCombiningMark = 6,
        /**
         * Enclosing mark character, which is a nonspacing combining character that
         * surrounds all previous characters up to and including a base character. Signified
         * by the Unicode designation "Me" (mark, enclosing). The value is 7.
         */
        EnclosingMark = 7,
        /**
         * Decimal digit character, that is, a character in the range 0 through 9. Signified
         * by the Unicode designation "Nd" (number, decimal digit). The value is 8.
         */
        DecimalDigitNumber = 8,
        /**
         * Number represented by a letter, instead of a decimal digit, for example,
         * the Roman numeral for five, which is "V". The indicator is signified by the
         * Unicode designation "Nl" (number, letter). The value is 9.
         */
        LetterNumber = 9,
        /**
         * Number that is neither a decimal digit nor a letter number, for example,
         * the fraction 1/2. The indicator is signified by the Unicode designation "No"
         * (number, other). The value is 10.
         */
        OtherNumber = 10,
        /**
         * Space character, which has no glyph but is not a control or format character.
         * Signified by the Unicode designation "Zs" (separator, space). The value is 11.
         */
        SpaceSeparator = 11,
        /**
         * Character that is used to separate lines of text. Signified by the Unicode
         * designation "Zl" (separator, line). The value is 12.
         */
        LineSeparator = 12,
        /**
         * Character used to separate paragraphs. Signified by the Unicode designation
         * "Zp" (separator, paragraph). The value is 13.
         */
        ParagraphSeparator = 13,
        /**
         * Control code character, with a Unicode value of U+007F or in the range U+0000
         * through U+001F or U+0080 through U+009F. Signified by the Unicode designation
         * "Cc" (other, control). The value is 14.
         */
        Control = 14,
        /**
         * Format character that affects the layout of text or the operation of text
         * processes, but is not normally rendered. Signified by the Unicode designation
         * "Cf" (other, format). The value is 15.
         */
        Format = 15,
        /**
         * High surrogate or a low surrogate character. Surrogate code values are in
         * the range U+D800 through U+DFFF. Signified by the Unicode designation "Cs"
         * (other, surrogate). The value is 16.
         */
        Surrogate = 16,
        /**
         * Private-use character, with a Unicode value in the range U+E000 through U+F8FF.
         * Signified by the Unicode designation "Co" (other, private use). The value is 17.
         */
        PrivateUse = 17,
        /**
         * Connector punctuation character that connects two characters. Signified by
         * the Unicode designation "Pc" (punctuation, connector). The value is 18.
         */
        ConnectorPunctuation = 18,
        /**
         * Dash or hyphen character. Signified by the Unicode designation "Pd" (punctuation,
         * dash). The value is 19.
         */
        DashPunctuation = 19,
        /**
         * Opening character of one of the paired punctuation marks, such as parentheses,
         * square brackets, and braces. Signified by the Unicode designation "Ps" (punctuation,
         * open). The value is 20.
         */
        OpenPunctuation = 20,
        /**
         * Closing character of one of the paired punctuation marks, such as parentheses,
         * square brackets, and braces. Signified by the Unicode designation "Pe" (punctuation,
         * close). The value is 21.
         */
        ClosePunctuation = 21,
        /**
         * Opening or initial quotation mark character. Signified by the Unicode designation
         * "Pi" (punctuation, initial quote). The value is 22.
         */
        InitialQuotePunctuation = 22,
        /**
         * Closing or final quotation mark character. Signified by the Unicode designation
         * "Pf" (punctuation, final quote). The value is 23.
         */
        FinalQuotePunctuation = 23,
        /**
         * Punctuation character that is not a connector, a dash, open punctuation,
         * close punctuation, an initial quote, or a final quote. Signified by the Unicode
         * designation "Po" (punctuation, other). The value is 24.
         */
        OtherPunctuation = 24,
        /**
         * Mathematical symbol character, such as "+" or "= ". Signified by the Unicode
         * designation "Sm" (symbol, math). The value is 25.
         */
        MathSymbol = 25,
        /**
         * Currency symbol character. Signified by the Unicode designation "Sc" (symbol,
         * currency). The value is 26.
         */
        CurrencySymbol = 26,
        /**
         * Modifier symbol character, which indicates modifications of surrounding characters.
         * For example, the fraction slash indicates that the number to the left is
         * the numerator and the number to the right is the denominator. The indicator
         * is signified by the Unicode designation "Sk" (symbol, modifier). The value is 27.
         */
        ModifierSymbol = 27,
        /**
         * Symbol character that is not a mathematical symbol, a currency symbol or
         * a modifier symbol. Signified by the Unicode designation "So" (symbol, other).
         * The value is 28.
         */
        OtherSymbol = 28,
        /**
         * Character that is not assigned to any Unicode category. Signified by the
         * Unicode designation "Cn" (other, not assigned). The value is 29.
         */
        OtherNotAssigned = 29
    }
}
declare module Stimulsoft.System {
    class Char {
        static isUpper(char: string, index?: number): boolean;
        static isLower(char: string, index?: number): boolean;
        static isLetter(char: string, index?: number): boolean;
        static isDigit(char: string | number, index?: number): boolean;
        static isLetterOrDigit(char: string, index?: number): boolean;
        static toLower(char: string): string;
        static toUpper(char: string): string;
        static isWhitespace(char: string, index?: number, allowNbsp?: boolean): boolean;
        private static checkLetter;
        static getUnicodeCategory(char: string, index?: number): number;
        static isControl(char: string, index?: number): boolean;
    }
}
declare module Stimulsoft.System {
    class TimeSpan {
        static ticksPerMillisecond: number;
        private static millisecondsPerTick;
        static ticksPerSecond: number;
        private static secondsPerTick;
        static ticksPerMinute: number;
        private static minutesPerTick;
        static ticksPerHour: number;
        private static hoursPerTick;
        static ticksPerDay: number;
        private static daysPerTick;
        private static millisPerSecond;
        private static millisPerMinute;
        private static millisPerHour;
        private static millisPerDay;
        static maxSeconds: number;
        static minSeconds: number;
        static maxMilliSeconds: number;
        static minMilliSeconds: number;
        static ticksPerTenthSecond: number;
        static readonly zero: TimeSpan;
        static getStiNetTypeName(): string;
        private static _minValue;
        static readonly minValue: TimeSpan;
        private static _maxValue;
        static readonly maxValue: TimeSpan;
        private _ticks;
        readonly ticks: number;
        readonly days: number;
        readonly hours: number;
        readonly milliseconds: number;
        readonly minutes: number;
        readonly seconds: number;
        readonly totalDays: number;
        readonly totalHours: number;
        readonly totalMilliseconds: number;
        readonly totalMinutes: number;
        readonly totalSeconds: number;
        static fromString(value: string, format?: string): TimeSpan;
        private static interval;
        static fromTicks(value: number): TimeSpan;
        static fromSeconds(value: number): TimeSpan;
        static fromMilliseconds(value: number): TimeSpan;
        add(value: number): TimeSpan;
        add2(value: TimeSpan): TimeSpan;
        toString(format?: string): string;
        negate(): TimeSpan;
        private static timeToTicks;
        constructor(param1?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
}
declare module Stimulsoft.System.Data {
    class TimeSpanStorage extends DataStorage {
        getValue(recordNo: number): any;
        setValue(recordNo: number, value: any): void;
        setStorage(): void;
        constructor(column: DataColumn);
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    enum DashStyle {
        Solid = 0,
        Dash = 1,
        Dot = 2,
        DashDot = 3,
        DashDotDot = 4,
        Custom = 5
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    enum HatchStyle {
        /** Specifies hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal. */
        Min = 0,
        /** A pattern of horizontal lines. */
        Horizontal = 0,
        /** A pattern of vertical lines. */
        Vertical = 1,
        /** A pattern of lines on a diagonal from upper left to lower right. */
        ForwardDiagonal = 2,
        /** A pattern of lines on a diagonal from upper right to lower left. */
        BackwardDiagonal = 3,
        /** Specifies hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.SolidDiamond. */
        Max = 4,
        /** Specifies horizontal and vertical lines that cross. */
        Cross = 4,
        /** Specifies the hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Cross. */
        LargeGrid = 4,
        /** A pattern of crisscross diagonal lines. */
        DiagonalCross = 5,
        /** Specifies a 5-percent hatch. The ratio of foreground color to background color is 5:95. */
        Percent05 = 6,
        /** Specifies a 10-percent hatch. The ratio of foreground color to background color is 10:90. */
        Percent10 = 7,
        /** Specifies a 20-percent hatch. The ratio of foreground color to background color is 20:80. */
        Percent20 = 8,
        /** Specifies a 25-percent hatch. The ratio of foreground color to background color is 25:75. */
        Percent25 = 9,
        /** Specifies a 30-percent hatch. The ratio of foreground color to background color is 30:70. */
        Percent30 = 10,
        /** Specifies a 40-percent hatch. The ratio of foreground color to background color is 40:60. */
        Percent40 = 11,
        /** Specifies a 50-percent hatch. The ratio of foreground color to background color is 50:50. */
        Percent50 = 12,
        /** Specifies a 60-percent hatch. The ratio of foreground color to background color is 60:40. */
        Percent60 = 13,
        /** Specifies a 70-percent hatch. The ratio of foreground color to background color is 70:30. */
        Percent70 = 14,
        /** Specifies a 75-percent hatch. The ratio of foreground color to background color is 75:25. */
        Percent75 = 15,
        /** Specifies a 80-percent hatch. The ratio of foreground color to background color is 80:100. */
        Percent80 = 16,
        /** Specifies a 90-percent hatch. The ratio of foreground color to background color is 90:10. */
        Percent90 = 17,
        /**
         * Specifies diagonal lines that slant to the right from top points to bottom
         * points and are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal,
         * but are not antialiased.
         */
        LightDownwardDiagonal = 18,
        /**
         * Specifies diagonal lines that slant to the left from top points to bottom
         * points and are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal,
         * but they are not antialiased.
         */
        LightUpwardDiagonal = 19,
        /**
         * Specifies diagonal lines that slant to the right from top points to bottom
         * points, are spaced 50 percent closer together than, and are twice the width
         * of Stimulsoft.System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal. This hatch pattern
         * is not antialiased.
         */
        DarkDownwardDiagonal = 20,
        /**
         * Specifies diagonal lines that slant to the left from top points to bottom
         * points, are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal,
         * and are twice its width, but the lines are not antialiased.
         */
        DarkUpwardDiagonal = 21,
        /**
         * Specifies diagonal lines that slant to the right from top points to bottom
         * points, have the same spacing as hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal,
         * and are triple its width, but are not antialiased.
         */
        WideDownwardDiagonal = 22,
        /**
         * Specifies diagonal lines that slant to the left from top points to bottom
         * points, have the same spacing as hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal,
         * and are triple its width, but are not antialiased.
         */
        WideUpwardDiagonal = 23,
        /** Specifies vertical lines that are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Vertical. */
        LightVertical = 24,
        /** Specifies horizontal lines that are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal. */
        LightHorizontal = 25,
        /**
         * Specifies vertical lines that are spaced 75 percent closer together than
         * hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Vertical (or 25 percent closer
         * together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.LightVertical).
         */
        NarrowVertical = 26,
        /**
         * Specifies horizontal lines that are spaced 75 percent closer together than
         * hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal (or 25 percent
         * closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.LightHorizontal).
         */
        NarrowHorizontal = 27,
        /** Specifies vertical lines that are spaced 50 percent closer together than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Vertical and are twice its width. */
        DarkVertical = 28,
        /**
         * Specifies horizontal lines that are spaced 50 percent closer together than
         * Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal and are twice the width of
         * Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Horizontal.
         */
        DarkHorizontal = 29,
        /** Specifies dashed diagonal lines, that slant to the right from top points to bottom points. */
        DashedDownwardDiagonal = 30,
        /** Specifies dashed diagonal lines, that slant to the left from top points to bottom points. */
        DashedUpwardDiagonal = 31,
        /** Specifies dashed horizontal lines. */
        DashedHorizontal = 32,
        /** Specifies dashed vertical lines. */
        DashedVertical = 33,
        /** Specifies a hatch that has the appearance of confetti. */
        SmallConfetti = 34,
        /**
         * Specifies a hatch that has the appearance of confetti, and is composed of
         * larger pieces than Stimulsoft.System.Drawing.Drawing2D.HatchStyle.SmallConfetti.
         */
        LargeConfetti = 35,
        /** Specifies horizontal lines that are composed of zigzags. */
        ZigZag = 36,
        /** Specifies horizontal lines that are composed of tildes. */
        Wave = 37,
        /** Specifies a hatch that has the appearance of layered bricks that slant to the left from top points to bottom points. */
        DiagonalBrick = 38,
        /** Specifies a hatch that has the appearance of horizontally layered bricks. */
        HorizontalBrick = 39,
        /** Specifies a hatch that has the appearance of a woven material. */
        Weave = 40,
        /** Specifies a hatch that has the appearance of a plaid material. */
        Plaid = 41,
        /** Specifies a hatch that has the appearance of divots. */
        Divot = 42,
        /** Specifies horizontal and vertical lines, each of which is composed of dots, that cross. */
        DottedGrid = 43,
        /** Specifies forward diagonal and backward diagonal lines, each of which is composed of dots, that cross. */
        DottedDiamond = 44,
        /** Specifies a hatch that has the appearance of diagonally layered shingles that slant to the right from top points to bottom points. */
        Shingle = 45,
        /** Specifies a hatch that has the appearance of a trellis. */
        Trellis = 46,
        /** Specifies a hatch that has the appearance of spheres laid adjacent to one another. */
        Sphere = 47,
        /**
         * Specifies horizontal and vertical lines that cross and are spaced 50 percent
         * closer together than hatch style Stimulsoft.System.Drawing.Drawing2D.HatchStyle.Cross.
         */
        SmallGrid = 48,
        /** Specifies a hatch that has the appearance of a checkerboard. */
        SmallCheckerBoard = 49,
        /**
         * Specifies a hatch that has the appearance of a checkerboard with squares
         * that are twice the size of Stimulsoft.System.Drawing.Drawing2D.HatchStyle.SmallCheckerBoard.
         */
        LargeCheckerBoard = 50,
        /** Specifies forward diagonal and backward diagonal lines that cross but are not antialiased. */
        OutlinedDiamond = 51,
        /** Specifies a hatch that has the appearance of a checkerboard placed diagonally. */
        SolidDiamond = 52
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    enum LineCap {
        AnchorMask = 240,
        ArrowAnchor = 20,
        Custom = 255,
        DiamondAnchor = 19,
        Flat = 0,
        NoAnchor = 16,
        Round = 2,
        RoundAnchor = 18,
        Square = 1,
        SquareAnchor = 17,
        Triangle = 3
    }
}
declare module Stimulsoft.System.Drawing.Drawing2D {
    import Point = Stimulsoft.System.Drawing.Point;
    class Matrix {
        a: number;
        c: number;
        b: number;
        d: number;
        tx: number;
        ty: number;
        readonly elements: number[];
        constructor(...arg: any[]);
        private setValues;
        private reset;
        clone(): Matrix;
        toString(): string;
        translate(x: number, y: number): Matrix;
        scale(scaleX: number, scaleY: number): Matrix;
        rotate(angle: number): Matrix;
        isIdentity(): boolean;
        transformPoints(points: Point[]): void;
        multiply(matrix2: Matrix): this;
    }
}
declare module Stimulsoft.System.Drawing.Imaging {
    enum EncoderValue {
        ColorTypeCMYK = 0,
        ColorTypeYCCK = 1,
        CompressionLZW = 2,
        CompressionCCITT3 = 3,
        CompressionCCITT4 = 4,
        CompressionRle = 5,
        CompressionNone = 6,
        ScanMethodInterlaced = 7,
        ScanMethodNonInterlaced = 8,
        VersionGif87 = 9,
        VersionGif89 = 10,
        RenderProgressive = 11,
        RenderNonProgressive = 12,
        TransformRotate90 = 13,
        TransformRotate180 = 14,
        TransformRotate270 = 15,
        TransformFlipHorizontal = 16,
        TransformFlipVertical = 17,
        MultiFrame = 18,
        LastFrame = 19,
        Flush = 20,
        FrameDimensionTime = 21,
        FrameDimensionResolution = 22,
        FrameDimensionPage = 23
    }
}
declare module Stimulsoft.System.Drawing.Imaging {
    class ImageCodecInfo {
        clsid: Guid;
        codecName: string;
        filenameExtension: string;
        formatDescription: string;
        formatID: Guid;
        mimeType: string;
        version: number;
        static getImageDecoders(): ImageCodecInfo[];
        static getImageEncoders(): ImageCodecInfo[];
    }
}
declare module Stimulsoft.System.Drawing.Imaging {
    class ImageFormat {
        private static _tiff;
        static readonly Tiff: ImageFormat;
        private static _png;
        static readonly Png: ImageFormat;
        private static _gif;
        static readonly Gif: ImageFormat;
        private static _jpeg;
        static readonly Jpeg: ImageFormat;
        private static _bmp;
        static readonly Bmp: ImageFormat;
        private static _svg;
        static readonly Svg: ImageFormat;
        static getImageFormat(dataBytes: number[]): ImageFormat;
        private header;
        private guid;
        private checkHeader;
        getWidth(dataBytes: number[], base64?: string): number;
        getHeight(dataBytes: number[], base64?: string): number;
        getHorizontalResolution(dataBytes: number[]): number;
        getVerticalResolution(dataBytes: number[]): number;
        readonly mimeType: string;
        toString(): string;
        constructor(guid: string);
    }
}
declare module Stimulsoft.System.Drawing.Printing.PrinterSettings {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class PaperSizeCollection extends CollectionBase<PaperSize> {
        add(paperSize: PaperSize): void;
    }
}
declare module Stimulsoft.System.Drawing.Printing.PrinterSettings {
    class PrinterSettings {
        readonly paperSizes: PaperSizeCollection;
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    enum PaperKind {
        A2 = 66,
        A3 = 8,
        A3Extra = 63,
        A3ExtraTransverse = 68,
        A3Rotated = 76,
        A3Transverse = 67,
        A4 = 9,
        A4Extra = 53,
        A4Plus = 60,
        A4Rotated = 77,
        A4Small = 10,
        A4Transverse = 55,
        A5 = 11,
        A5Extra = 64,
        A5Rotated = 78,
        A5Transverse = 61,
        A6 = 70,
        A6Rotated = 83,
        APlus = 57,
        B4 = 12,
        B4Envelope = 33,
        B4JisRotated = 79,
        B5 = 13,
        B5Envelope = 34,
        B5Extra = 65,
        B5JisRotated = 80,
        B5Transverse = 62,
        B6Envelope = 35,
        B6Jis = 88,
        B6JisRotated = 89,
        BPlus = 58,
        C3Envelope = 29,
        C4Envelope = 30,
        C5Envelope = 28,
        C65Envelope = 32,
        C6Envelope = 31,
        CSheet = 24,
        Custom = 0,
        DLEnvelope = 27,
        DSheet = 25,
        ESheet = 26,
        Executive = 7,
        Folio = 14,
        GermanLegalFanfold = 41,
        GermanStandardFanfold = 40,
        InviteEnvelope = 47,
        IsoB4 = 42,
        ItalyEnvelope = 36,
        JapaneseDoublePostcard = 69,
        JapaneseDoublePostcardRotated = 82,
        JapaneseEnvelopeChouNumber3 = 73,
        JapaneseEnvelopeChouNumber3Rotated = 86,
        JapaneseEnvelopeChouNumber4 = 74,
        JapaneseEnvelopeChouNumber4Rotated = 87,
        JapaneseEnvelopeKakuNumber2 = 71,
        JapaneseEnvelopeKakuNumber2Rotated = 84,
        JapaneseEnvelopeKakuNumber3 = 72,
        JapaneseEnvelopeKakuNumber3Rotated = 85,
        JapaneseEnvelopeYouNumber4 = 91,
        JapaneseEnvelopeYouNumber4Rotated = 92,
        JapanesePostcard = 43,
        JapanesePostcardRotated = 81,
        Ledger = 4,
        Legal = 5,
        LegalExtra = 51,
        Letter = 1,
        LetterExtra = 50,
        LetterExtraTransverse = 56,
        LetterPlus = 59,
        LetterRotated = 75,
        LetterSmall = 2,
        LetterTransverse = 54,
        MonarchEnvelope = 37,
        Note = 18,
        Number10Envelope = 20,
        Number11Envelope = 21,
        Number12Envelope = 22,
        Number14Envelope = 23,
        Number9Envelope = 19,
        PersonalEnvelope = 38,
        Prc16K = 93,
        Prc16KRotated = 106,
        Prc32K = 94,
        Prc32KBig = 95,
        Prc32KBigRotated = 108,
        Prc32KRotated = 107,
        PrcEnvelopeNumber1 = 96,
        PrcEnvelopeNumber10 = 105,
        PrcEnvelopeNumber10Rotated = 118,
        PrcEnvelopeNumber1Rotated = 109,
        PrcEnvelopeNumber2 = 97,
        PrcEnvelopeNumber2Rotated = 110,
        PrcEnvelopeNumber3 = 98,
        PrcEnvelopeNumber3Rotated = 111,
        PrcEnvelopeNumber4 = 99,
        PrcEnvelopeNumber4Rotated = 112,
        PrcEnvelopeNumber5 = 100,
        PrcEnvelopeNumber5Rotated = 113,
        PrcEnvelopeNumber6 = 101,
        PrcEnvelopeNumber6Rotated = 114,
        PrcEnvelopeNumber7 = 102,
        PrcEnvelopeNumber7Rotated = 115,
        PrcEnvelopeNumber8 = 103,
        PrcEnvelopeNumber8Rotated = 116,
        PrcEnvelopeNumber9 = 104,
        PrcEnvelopeNumber9Rotated = 117,
        Quarto = 15,
        Standard10x11 = 45,
        Standard10x14 = 16,
        Standard11x17 = 17,
        Standard12x11 = 90,
        Standard15x11 = 46,
        Standard9x11 = 44,
        Statement = 6,
        Tabloid = 3,
        TabloidExtra = 52,
        USStandardFanfold = 39
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    class PaperSize {
        private createdByDefaultConstructor;
        private _kind;
        readonly kind: number;
        private _name;
        name: string;
        private _width;
        width: number;
        private _height;
        height: number;
        constructor(kind?: number, name?: string, width?: number, height?: number);
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    enum PrinterUnit {
        Display = 0,
        ThousandthsOfAnInch = 1,
        HundredthsOfAMillimeter = 2,
        TenthsOfAMillimeter = 3
    }
}
declare module Stimulsoft.System.Drawing.Printing {
    class PrinterUnitConvert {
        static convert(value: number, fromUnit: PrinterUnit, toUnit: PrinterUnit): number;
        private static unitsPerDisplay;
    }
}
declare module Stimulsoft.System.Drawing.Text {
    enum HotkeyPrefix {
        Hide = 0,
        None = 1,
        Show = 2
    }
}
declare module Stimulsoft.System.Drawing {
    class Brush {
    }
}
declare module Stimulsoft.System.Drawing {
    class Brushes {
        static readonly aliceBlue: Brush;
        static readonly antiqueWhite: Brush;
        static readonly aqua: Brush;
        static readonly aquamarine: Brush;
        static readonly azure: Brush;
        static readonly beige: Brush;
        static readonly bisque: Brush;
        static readonly black: Brush;
        static readonly blanchedAlmond: Brush;
        static readonly blue: Brush;
        static readonly blueViolet: Brush;
        static readonly brown: Brush;
        static readonly burlyWood: Brush;
        static readonly cadetBlue: Brush;
        static readonly chartreuse: Brush;
        static readonly chocolate: Brush;
        static readonly coral: Brush;
        static readonly cornflowerBlue: Brush;
        static readonly cornsilk: Brush;
        static readonly crimson: Brush;
        static readonly cyan: Brush;
        static readonly darkBlue: Brush;
        static readonly darkCyan: Brush;
        static readonly darkGoldenrod: Brush;
        static readonly darkGray: Brush;
        static readonly darkGreen: Brush;
        static readonly darkKhaki: Brush;
        static readonly darkMagenta: Brush;
        static readonly darkOliveGreen: Brush;
        static readonly darkOrange: Brush;
        static readonly darkOrchid: Brush;
        static readonly darkRed: Brush;
        static readonly darkSalmon: Brush;
        static readonly darkSeaGreen: Brush;
        static readonly darkSlateBlue: Brush;
        static readonly darkSlateGray: Brush;
        static readonly darkTurquoise: Brush;
        static readonly darkViolet: Brush;
        static readonly deepPink: Brush;
        static readonly deepSkyBlue: Brush;
        static readonly dimGray: Brush;
        static readonly dodgerBlue: Brush;
        static readonly firebrick: Brush;
        static readonly floralWhite: Brush;
        static readonly forestGreen: Brush;
        static readonly fuchsia: Brush;
        static readonly gainsboro: Brush;
        static readonly ghostWhite: Brush;
        static readonly gold: Brush;
        static readonly goldenrod: Brush;
        static readonly gray: Brush;
        static readonly green: Brush;
        static readonly greenYellow: Brush;
        static readonly honeydew: Brush;
        static readonly hotPink: Brush;
        static readonly indianRed: Brush;
        static readonly indigo: Brush;
        static readonly ivory: Brush;
        static readonly khaki: Brush;
        static readonly lavender: Brush;
        static readonly lavenderBlush: Brush;
        static readonly lawnGreen: Brush;
        static readonly lemonChiffon: Brush;
        static readonly lightBlue: Brush;
        static readonly lightCoral: Brush;
        static readonly lightCyan: Brush;
        static readonly lightGoldenrodYellow: Brush;
        static readonly lightGray: Brush;
        static readonly lightGreen: Brush;
        static readonly lightPink: Brush;
        static readonly lightSalmon: Brush;
        static readonly lightSeaGreen: Brush;
        static readonly lightSkyBlue: Brush;
        static readonly lightSlateGray: Brush;
        static readonly lightSteelBlue: Brush;
        static readonly lightYellow: Brush;
        static readonly lime: Brush;
        static readonly limeGreen: Brush;
        static readonly linen: Brush;
        static readonly magenta: Brush;
        static readonly maroon: Brush;
        static readonly mediumAquamarine: Brush;
        static readonly mediumBlue: Brush;
        static readonly mediumOrchid: Brush;
        static readonly mediumPurple: Brush;
        static readonly mediumSeaGreen: Brush;
        static readonly mediumSlateBlue: Brush;
        static readonly mediumSpringGreen: Brush;
        static readonly mediumTurquoise: Brush;
        static readonly mediumVioletRed: Brush;
        static readonly midnightBlue: Brush;
        static readonly mintCream: Brush;
        static readonly mistyRose: Brush;
        static readonly moccasin: Brush;
        static readonly navajoWhite: Brush;
        static readonly navy: Brush;
        static readonly oldLace: Brush;
        static readonly olive: Brush;
        static readonly oliveDrab: Brush;
        static readonly orange: Brush;
        static readonly orangeRed: Brush;
        static readonly orchid: Brush;
        static readonly paleGoldenrod: Brush;
        static readonly paleGreen: Brush;
        static readonly paleTurquoise: Brush;
        static readonly paleVioletRed: Brush;
        static readonly papayaWhip: Brush;
        static readonly peachPuff: Brush;
        static readonly peru: Brush;
        static readonly pink: Brush;
        static readonly plum: Brush;
        static readonly powderBlue: Brush;
        static readonly purple: Brush;
        static readonly red: Brush;
        static readonly rosyBrown: Brush;
        static readonly royalBlue: Brush;
        static readonly saddleBrown: Brush;
        static readonly salmon: Brush;
        static readonly sandyBrown: Brush;
        static readonly seaGreen: Brush;
        static readonly seaShell: Brush;
        static readonly sienna: Brush;
        static readonly silver: Brush;
        static readonly skyBlue: Brush;
        static readonly slateBlue: Brush;
        static readonly slateGray: Brush;
        static readonly snow: Brush;
        static readonly springGreen: Brush;
        static readonly steelBlue: Brush;
        static readonly tan: Brush;
        static readonly teal: Brush;
        static readonly thistle: Brush;
        static readonly tomato: Brush;
        static readonly turquoise: Brush;
        static readonly violet: Brush;
        static readonly wheat: Brush;
        static readonly white: Brush;
        static readonly whiteSmoke: Brush;
        static readonly yellow: Brush;
        static readonly yellowGreen: Brush;
    }
}
declare module Stimulsoft.System.Drawing {
    class Color {
        static readonly aliceBlue: Color;
        static readonly antiqueWhite: Color;
        static readonly aqua: Color;
        static readonly aquamarine: Color;
        static readonly azure: Color;
        static readonly beige: Color;
        static readonly bisque: Color;
        static readonly black: Color;
        static readonly blanchedAlmond: Color;
        static readonly blue: Color;
        static readonly blueViolet: Color;
        static readonly brown: Color;
        static readonly burlyWood: Color;
        static readonly cadetBlue: Color;
        static readonly chartreuse: Color;
        static readonly chocolate: Color;
        static readonly coral: Color;
        static readonly cornflowerBlue: Color;
        static readonly cornsilk: Color;
        static readonly crimson: Color;
        static readonly cyan: Color;
        static readonly darkBlue: Color;
        static readonly darkCyan: Color;
        static readonly darkGoldenrod: Color;
        static readonly darkGray: Color;
        static readonly darkGreen: Color;
        static readonly darkKhaki: Color;
        static readonly darkMagenta: Color;
        static readonly darkOliveGreen: Color;
        static readonly darkOrange: Color;
        static readonly darkOrchid: Color;
        static readonly darkRed: Color;
        static readonly darkSalmon: Color;
        static readonly darkSeaGreen: Color;
        static readonly darkSlateBlue: Color;
        static readonly darkSlateGray: Color;
        static readonly darkTurquoise: Color;
        static readonly darkViolet: Color;
        static readonly deepPink: Color;
        static readonly deepSkyBlue: Color;
        static readonly dimGray: Color;
        static readonly dodgerBlue: Color;
        static readonly firebrick: Color;
        static readonly floralWhite: Color;
        static readonly forestGreen: Color;
        static readonly fuchsia: Color;
        static readonly gainsboro: Color;
        static readonly ghostWhite: Color;
        static readonly gold: Color;
        static readonly goldenrod: Color;
        static readonly gray: Color;
        static readonly green: Color;
        static readonly greenYellow: Color;
        static readonly honeydew: Color;
        static readonly hotPink: Color;
        static readonly indianRed: Color;
        static readonly indigo: Color;
        static readonly ivory: Color;
        static readonly khaki: Color;
        static readonly lavender: Color;
        static readonly lavenderBlush: Color;
        static readonly lawnGreen: Color;
        static readonly lemonChiffon: Color;
        static readonly lightBlue: Color;
        static readonly lightCoral: Color;
        static readonly lightCyan: Color;
        static readonly lightGoldenrodYellow: Color;
        static readonly lightGray: Color;
        static readonly lightGreen: Color;
        static readonly lightPink: Color;
        static readonly lightSalmon: Color;
        static readonly lightSeaGreen: Color;
        static readonly lightSkyBlue: Color;
        static readonly lightSlateGray: Color;
        static readonly lightSteelBlue: Color;
        static readonly lightYellow: Color;
        static readonly lime: Color;
        static readonly limeGreen: Color;
        static readonly linen: Color;
        static readonly magenta: Color;
        static readonly maroon: Color;
        static readonly mediumAquamarine: Color;
        static readonly mediumBlue: Color;
        static readonly mediumOrchid: Color;
        static readonly mediumPurple: Color;
        static readonly mediumSeaGreen: Color;
        static readonly mediumSlateBlue: Color;
        static readonly mediumSpringGreen: Color;
        static readonly mediumTurquoise: Color;
        static readonly mediumVioletRed: Color;
        static readonly midnightBlue: Color;
        static readonly mintCream: Color;
        static readonly mistyRose: Color;
        static readonly moccasin: Color;
        static readonly navajoWhite: Color;
        static readonly navy: Color;
        static readonly oldLace: Color;
        static readonly olive: Color;
        static readonly oliveDrab: Color;
        static readonly orange: Color;
        static readonly orangeRed: Color;
        static readonly orchid: Color;
        static readonly paleGoldenrod: Color;
        static readonly paleGreen: Color;
        static readonly paleTurquoise: Color;
        static readonly paleVioletRed: Color;
        static readonly papayaWhip: Color;
        static readonly peachPuff: Color;
        static readonly peru: Color;
        static readonly pink: Color;
        static readonly plum: Color;
        static readonly powderBlue: Color;
        static readonly purple: Color;
        static readonly red: Color;
        static readonly rosyBrown: Color;
        static readonly royalBlue: Color;
        static readonly saddleBrown: Color;
        static readonly salmon: Color;
        static readonly sandyBrown: Color;
        static readonly seaGreen: Color;
        static readonly seaShell: Color;
        static readonly sienna: Color;
        static readonly silver: Color;
        static readonly skyBlue: Color;
        static readonly slateBlue: Color;
        static readonly slateGray: Color;
        static readonly snow: Color;
        static readonly springGreen: Color;
        static readonly steelBlue: Color;
        static readonly tan: Color;
        static readonly teal: Color;
        static readonly thistle: Color;
        static readonly tomato: Color;
        static readonly turquoise: Color;
        static readonly violet: Color;
        static readonly wheat: Color;
        static readonly white: Color;
        static readonly whiteSmoke: Color;
        static readonly yellow: Color;
        static readonly yellowGreen: Color;
        static readonly transparent: Color;
        static readonly empty: Color;
        static fromName(name: string): Color;
        private _a;
        a: number;
        private _r;
        r: number;
        private _g;
        g: number;
        private _b;
        b: number;
        private static customName;
        name: string;
        readonly isNamedColor: boolean;
        stiEquals(color: Color): boolean;
        toString(): string;
        static fromArgb(alpha: number, baseColor: Color): Color;
        static fromArgb(red: number, green: number, blue: number): Color;
        static fromArgb(alpha: number, red: number, green: number, blue: number): Color;
        toArgb(): number;
        getHashCode(): number;
    }
}
declare module Stimulsoft.System.Drawing {
    class ColorTranslator {
        static toHtml(color: Color): string;
        static fromHtml(text: string): Color;
    }
}
declare module Stimulsoft.System.Drawing {
    enum ContentAlignment {
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 16,
        MiddleCenter = 32,
        MiddleRight = 64,
        BottomLeft = 256,
        BottomCenter = 512,
        BottomRight = 1024
    }
}
declare module Stimulsoft.System.Drawing {
    class Font implements ICloneable {
        /** Creates a new object that is a copy of the current instance. */
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        private _fontFamily;
        readonly fontFamily: FontFamily;
        readonly name: string;
        private _size;
        readonly size: number;
        readonly sizeInPoints: number;
        private _style;
        readonly style: FontStyle;
        private _unit;
        readonly unit: GraphicsUnit;
        readonly bold: boolean;
        readonly italic: boolean;
        readonly strikeout: boolean;
        readonly underline: boolean;
        toString(): string;
        getHeight(): number;
        getHashCode(): number;
        constructor(family?: string, emSize?: number, style?: FontStyle, unit?: GraphicsUnit);
    }
}
declare module Stimulsoft.System.Drawing {
    class FontFamily {
        private static _families;
        static readonly families: FontFamily[];
        private _name;
        readonly name: string;
        isStyleAvailable(style: FontStyle): boolean;
        static cleanFamilies(): void;
        constructor(name: string);
    }
}
declare module Stimulsoft.System.Drawing {
    class FontResources {
        static getSize(font: Font, text: string): Size;
        private static _standardFontWidths;
        static readonly standardFontWidths: any[];
        private static _standardFontInfo;
        static readonly standardFontInfo: any[];
        private static family_Helvetica;
        private static family_Courier;
        private static family_Times_Roman;
        private static fontName;
    }
}
declare module Stimulsoft.System.Drawing {
    enum FontStyle {
        Regular = 0,
        Bold = 1,
        Italic = 2,
        Strikeout = 4,
        Underline = 8
    }
}
declare module Stimulsoft.System.Drawing {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class Graphics {
        private context;
        static measureBearingScale: number;
        drawImage(image: Image, point: Point): void;
        drawRectangle(pen: Pen, rect: Rectangle): void;
        fillRectangle(brush: Brush, x: number, y: number, width: number, height: number): void;
        drawLine(pen: Pen, x1: number, y1: number, x2: number, y2: number): void;
        drawString(text: string, font: Font, brush: Brush, x: number, y: number): void;
        translateTransform(dx: number, dy: number): void;
        static opentypeFonts: Hashtable;
        static getOpentypeFont(fontName: string, fontStyle: FontStyle): any;
        static getCustomFontsCss(): string;
        static getCustomFontName(fontName: string, fontStyle: FontStyle): string;
        static allowStyle(fontName: string, fontStyle: FontStyle): boolean;
        private static measureDiv;
        private static measureHash;
        static measureString(text1: string, font: Font, width?: number, useCache?: boolean, multiple?: number, angle?: number): Size;
        private static isWordWrapSymbol;
        static measureChars(chars: Array<number>, count: number, font: Font): Size;
        private static rotate;
        constructor(context: CanvasRenderingContext2D);
    }
}
declare module Stimulsoft.System.Drawing {
    enum GraphicsUnit {
        Pixel = 2,
        Point = 3
    }
}
declare module Stimulsoft.System.Drawing {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    class Image {
        private data;
        private _imageFormat;
        readonly imageFormat: ImageFormat;
        private _width;
        readonly width: number;
        private _height;
        readonly height: number;
        private _horizontalResolution;
        readonly horizontalResolution: number;
        private _verticalResolution;
        readonly verticalResolution: number;
        private _isConverting;
        readonly isConverting: boolean;
        imageData: any;
        base64: string;
        bytes: number[];
        static fromFile(path: string): Image;
        static fromBytes(bytes: number[]): Image;
        private setData;
        convert(imageFormat: ImageFormat, flate?: boolean): Promise<Image>;
        dispose(): void;
        clone(): Image;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: any;
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        url: string;
    }
}
declare module Stimulsoft.System.Drawing {
    import LineCap = Stimulsoft.System.Drawing.Drawing2D.LineCap;
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class Pen {
        brush: Brush;
        color: Color;
        endCap: LineCap;
        startCap: LineCap;
        width: number;
        dashStyle: DashStyle;
        lineJoin: string;
        constructor(color: Color);
    }
}
declare module Stimulsoft.System.Drawing {
    class Point {
        x: number;
        y: number;
        readonly isEmpty: boolean;
        static readonly empty: Point;
        toString(): string;
        stiEquals(point: Point): boolean;
        constructor(x?: number, y?: number);
    }
}
declare module Stimulsoft.System.Drawing {
    class Rectangle {
        clone(): Rectangle;
        static readonly empty: Rectangle;
        static union(a: Rectangle, b: Rectangle): Rectangle;
        inflate(width: number, height: number): Rectangle;
        normalize(): Rectangle;
        multiply(multipleFactor: number): Rectangle;
        offsetRect(offsettingRectangle: Rectangle): Rectangle;
        intersectsWith(rect: Rectangle): boolean;
        alignToGrid(gridSize: number, aligningToGrid: boolean): Rectangle;
        fitToRectangle(rectangle: Rectangle): Rectangle;
        readonly isEmpty: boolean;
        readonly isEmptyF: boolean;
        contains(x: number, y: number): boolean;
        static convertFromXml(text: string): Rectangle;
        x: number;
        y: number;
        width: number;
        height: number;
        left: number;
        top: number;
        right: number;
        bottom: number;
        location: Point;
        size: Size;
        constructor(x?: number, y?: number, width?: number, height?: number);
    }
}
declare module Stimulsoft.System.Drawing {
    class Size {
        static readonly empty: Size;
        width: number;
        height: number;
        readonly isEmpty: boolean;
        readonly isDefault: boolean;
        swap(): Size;
        round(digits?: number): Size;
        static convertFromXml(text: string): Size;
        constructor(size: Size);
        constructor(width: number, height: number);
    }
}
declare module Stimulsoft.System.Drawing {
    class SolidBrush extends Brush {
        color: Color;
        constructor(color: Color);
    }
}
declare module Stimulsoft.System.Drawing {
    enum StringAlignment {
        Near = 0,
        Center = 1,
        Far = 2
    }
}
declare module Stimulsoft.System.Drawing {
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    class StringFormat {
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
    }
}
declare module Stimulsoft.System.Drawing {
    enum StringFormatFlags {
        DirectionRightToLeft = 1,
        DirectionVertical = 2,
        FitBlackBox = 4,
        DisplayFormatControl = 32,
        NoFontFallback = 1024,
        MeasureTrailingSpaces = 2048,
        NoWrap = 4096,
        LineLimit = 8192,
        NoClip = 16384
    }
}
declare module Stimulsoft.System.Drawing {
    enum StringTrimming {
        None = 0,
        Character = 1,
        Word = 2,
        EllipsisCharacter = 3,
        EllipsisWord = 4,
        EllipsisPath = 5
    }
}
declare module Stimulsoft.System.Globalization {
    class Calendar {
        static getWeekOfYear(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
        private static getFirstDayWeekOfYear;
        private static getWeekOfYearFullDays;
        static getDaysInYear(year: number): number;
        static getWeekOfMonth(time: DateTime, rule?: CalendarWeekRule, firstDayOfWeek?: DayOfWeek): number;
    }
}
declare module Stimulsoft.System.Globalization {
    enum CalendarWeekRule {
        /**
         *  Indicates that the first week of the year starts on the first day of the year and ends before the following designated first day of the week. The value is 0.
         */
        FirstDay = 0,
        /**
         * Indicates that the first week of the year begins on the first occurrence of the designated first day of the week on or after the first day of the year. The value is 1.
         */
        FirstFullWeek = 1,
        /**
         * Indicates that the first week of the year is the first week with four or more days before the designated first day of the week. The value is 2.
         */
        FirstFourDayWeek = 2
    }
}
declare module Stimulsoft.System {
    /**
     * @hidden
     */
    class NodeJs {
        private static isInitialize;
        static initialize(onResult?: Function): void;
        private static convert;
        static platform(): any;
        static callRemoteApi(command: any, timeout: number): Promise<string>;
        private static processFirebird;
        private static processMsSql;
        private static processMySql;
        private static processPostgreSQL;
        static stripBom(data: any): any;
        static getFile(filePath: string, binary?: boolean, contentType?: string): any;
        static getFileHttp(filePath: string, binary?: boolean, contentType?: string): any;
        static saveAs(data: any, fileName: string, type?: string): any;
        static saveFile(filePath: string, fileData: string): void;
        static getFilesNames(filesPath: string): string[];
        static getSep(): string;
        private static fromBase64String;
        private static fromBase64StringText;
        private static toBase64String;
        private static fromUnicodeString;
        private static _isNodeJs;
        static isNodeJs(): boolean;
        static useWebKit: boolean;
        static consoleLog: boolean;
        private static fillInfo;
        static localizationPath: string;
        private static getLocalizationInfo;
        private static getSetting;
        private static setSetting;
    }
}
declare module Stimulsoft.System.Globalization {
    class TextInfo {
        toTitleCase(str: string): string;
    }
}
declare module Stimulsoft.System.Globalization {
    import IFormatProvider = System.IFormatProvider;
    import Type = Stimulsoft.System.Type;
    class NumberFormatInfo implements IFormatProvider {
        numberDecimalSeparator: string;
        numberDecimalDigits: number;
        numberGroupSeparator: string;
        numberGroupSizes: number[];
        numberNegativePattern: number;
        currencyDecimalDigits: number;
        currencyDecimalSeparator: string;
        currencyGroupSeparator: string;
        currencyGroupSizes: number[];
        currencyNegativePattern: number;
        currencyPositivePattern: number;
        currencySymbol: string;
        percentDecimalDigits: number;
        percentDecimalSeparator: string;
        percentGroupSeparator: string;
        percentGroupSizes: number[];
        percentNegativePattern: number;
        percentPositivePattern: number;
        percentSymbol: string;
        perMilleSymbol: string;
        positiveInfinitySymbol: string;
        positiveSign: string;
        NaNSymbol: string;
        negativeInfinitySymbol: string;
        negativeSign: string;
        getFormat(formatType: Type): Object;
        constructor(numberDecimalSeparator?: string, numberDecimalDigits?: number, numberGroupSeparator?: string, numberGroupSizes?: number[], numberNegativePattern?: number, currencyDecimalDigits?: number, currencyDecimalSeparator?: string, currencyGroupSeparator?: string, currencyGroupSizes?: number[], currencyNegativePattern?: number, currencyPositivePattern?: number, currencySymbol?: string, percentDecimalDigits?: number, percentDecimalSeparator?: string, percentGroupSeparator?: string, percentGroupSizes?: number[], percentNegativePattern?: number, percentPositivePattern?: number, percentSymbol?: string, perMilleSymbol?: string, positiveInfinitySymbol?: string, positiveSign?: string, NaNSymbol?: string, negativeInfinitySymbol?: string, negativeSign?: string);
    }
}
declare module Stimulsoft.System.Globalization {
    class DateTimeFormatInfo {
        shortDatePattern: string;
        dateSeparator: string;
        longDatePattern: string;
        dayNames: string[];
        monthNames: string[];
        shortestDayNames: string[];
        abbreviatedMonthNames: string[];
        monthGenitiveNames: string[];
        timeSeparator: string;
        AMDesignator: string;
        PMDesignator: string;
        fullDateTimePattern: string;
        shortTimePattern: string;
        longTimePattern: string;
        yearMonthPattern: string;
        constructor(shortDatePattern: string, dateSeparator: string, longDatePattern: string, dayNames: string[], monthNames: string[], shortestDayNames: string[], abbreviatedMonthNames: string[], monthGenitiveNames: string[], timeSeparator: string, AMDesignator: string, PMDesignator: string, fullDateTimePattern: string, shortTimePattern: string, longTimePattern: string, yearMonthPattern: string);
    }
}
declare module Stimulsoft.System.Globalization {
    class CultureInfo {
        numberFormat: NumberFormatInfo;
        dateTimeFormat: DateTimeFormatInfo;
        name: string;
        textInfo: TextInfo;
        private static _cultures;
        private static _currentCulture;
        static currentCulture: CultureInfo;
        static readonly cultures: Object;
        static readonly InvariantCulture: CultureInfo;
        static getCultureInfo(name: string): CultureInfo;
        constructor(name: string, numberFormat?: NumberFormatInfo, dateTimeFormat?: DateTimeFormatInfo);
    }
}
declare module Stimulsoft.System.Globalization {
    class RegionInfo {
        name: string;
        nativeName: string;
        threeLetterISORegionName: string;
        threeLetterWindowsRegionName: string;
        twoLetterISORegionName: string;
        constructor(name: string);
    }
}
declare module Stimulsoft.System.IO {
    /** Provides the fields that represent reference points in streams for seeking. */
    enum SeekOrigin {
        /** Specifies the beginning of a stream. */
        Begin = 0,
        /** Specifies the current position within a stream. */
        Current = 1,
        /** Specifies the end of a stream. */
        End = 2
    }
}
declare module Stimulsoft.System.IO {
    class File {
        static getFile(filePath: string, binary?: boolean, contentType?: string): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string): void;
        static saveFile(filePath: string, fileData: string): void;
        static getFilesNames(filePath: string): string[];
    }
}
declare module Stimulsoft.System.IO {
    class Http {
        static getFile(filePath: string, binary?: boolean, contentType?: string): any;
        static getFileAsync(callback: Function, filePath: string, binary?: boolean, contentType?: string): void;
    }
}
declare module Stimulsoft.System.IO {
    class MemoryStream {
        private static memStreamMaxLength;
        private _origin;
        private _buffer;
        private _position;
        readonly position: number;
        readonly length: number;
        readonly canSeek: boolean;
        readonly canWrite: boolean;
        setLength(length: number): void;
        toArray(): number[];
        writeTo(stream: MemoryStream): void;
        writeByte(byte: number): void;
        write(array: number[], offset?: number, length?: number): void;
        writeBytes(array: Uint8Array, offset?: number, length?: number): void;
        writeLine(inputString?: string, ...values: any[]): void;
        writeString(inputString: string, newLine?: boolean): void;
        read(array: number[], offset?: number, length?: number): number;
        seek(offset: number, origin: SeekOrigin): number;
        flush(): void;
        close(): void;
        copyTo(stream: MemoryStream): void;
        constructor(array?: number[]);
    }
}
declare module Stimulsoft.System.IO {
    class Path {
        static Combine(path1: string, path2: string): string;
        static getFileNameWithoutExtension(path: string): string;
        static getExtension(path: string): string;
        static getSep(): string;
    }
}
declare module Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StreamReader {
        private stream;
        private encoding;
        constructor(stream: MemoryStream, encoding?: Encoding);
        read(): string;
        readLine(): string;
        private readLineInternal;
    }
}
declare module Stimulsoft.System.Text {
    class Encoding {
        private static CodePageDefault;
        private static CodePageNoOEM;
        private static CodePageNoMac;
        private static CodePageNoThread;
        private static CodePageNoSymbol;
        private static CodePageUnicode;
        private static CodePageBigEndian;
        private static CodePageWindows1251;
        private static CodePageWindows1252;
        private static CodePageMacGB2312;
        private static CodePageGB2312;
        private static CodePageMacKorean;
        private static CodePageDLLKorean;
        private static ISO2022JP;
        private static ISO2022JPESC;
        private static ISO2022JPSISO;
        private static ISOKorean;
        private static ISOSimplifiedCN;
        private static EUCJP;
        private static ChineseHZ;
        private static DuplicateEUCCN;
        private static EUCCN;
        private static EUCKR;
        private static CodePageASCII;
        private static ISO_8859_1;
        private static ISCIIAssemese;
        private static ISCIIBengali;
        private static ISCIIDevanagari;
        private static ISCIIGujarathi;
        private static ISCIIKannada;
        private static ISCIIMalayalam;
        private static ISCIIOriya;
        private static ISCIIPanjabi;
        private static ISCIITamil;
        private static ISCIITelugu;
        private static GB18030;
        private static ISO_8859_8I;
        private static ISO_8859_8_Visual;
        private static ENC50229;
        private static CodePageUTF7;
        private static CodePageUTF8;
        private static CodePageUTF32;
        private static CodePageUTF32BE;
        static ASCII: Encoding;
        static BigEndianUnicode: Encoding;
        static Default: Encoding;
        static Unicode: Encoding;
        static UTF32: Encoding;
        static UTF7: Encoding;
        static UTF8: Encoding;
        static Windows1251: Encoding;
        private static _windows_1251;
        private _webName;
        readonly webName: string;
        private _encodingName;
        readonly encodingName: string;
        getBytes(str: string): number[];
        getString(bytes: number[]): string;
        static getEncoding(codepage: number): Encoding;
        private static fromCodePageToUnicode;
        constructor(name: string, webName?: string);
    }
}
declare module Stimulsoft.System.Text {
    class StringBuilder {
        private isNew;
        private partArray;
        private appendSingle;
        appendThese(items: any[]): StringBuilder;
        append(...items: any[]): StringBuilder;
        appendCount(item: any, count?: number): StringBuilder;
        appendLine(...items: any[]): StringBuilder;
        appendLines(items: any[]): StringBuilder;
        appendFormat(str: string, ...values: any[]): StringBuilder;
        insert(index: number, value: string, count?: number): StringBuilder;
        remove(startIndex: number, length: number): StringBuilder;
        readonly isEmpty: boolean;
        length: number;
        private latest;
        toString(): string;
        join(delimiter: string): string;
        clear(): void;
        dispose(): void;
        charAt(index: number): string;
        charCodeAt(index: number): number;
        setByIndex(index: number, value: string): void;
        private formatError;
        appendFormatHelper(provider: IFormatProvider, format: String, args: ParamsArray): StringBuilder;
        replace(searchValue: string, replaceValue: string): StringBuilder;
        constructor(value?: string);
    }
}
declare module Stimulsoft.System.IO {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class TextWriter {
        private sb;
        write(value: any): void;
        writeLine(value?: any): void;
        close(): void;
        flush(): void;
        getStringBuilder(): StringBuilder;
    }
}
declare module Stimulsoft.System.IO {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StreamWriter extends TextWriter {
        private stream;
        private encoding;
        private cn;
        writeLine(value: string): void;
        write(value: string): void;
        close(): void;
        flush(): void;
        constructor(stream: MemoryStream, encoding?: Encoding);
    }
}
declare module Stimulsoft.System.Text {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportObjectStringConverter {
        static convertStringToColorArray(str: string): Color[];
        static convertStringToColor(str: string): Color;
        private static getByName;
    }
}
declare module Stimulsoft.System.Text {
    import Font = Stimulsoft.System.Drawing.Font;
    class TextUtils {
        static splitString(inputString: string, removeControl: boolean): Array<string>;
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        private static isWordWrapSymbol;
        static getWordWrapTextLines(st: string, font: Font, needWidthAlign: boolean, textW: number): string[];
    }
}
declare module Stimulsoft.System.Windows.Forms {
    /** Specifies identifiers to indicate the return value of a dialog box. */
    enum DialogResult {
        None = 0,
        OK = 1,
        Cancel = 2,
        Abort = 3,
        Retry = 4,
        Ignore = 5,
        Yes = 6,
        No = 7
    }
}
declare module Stimulsoft.System.Windows.Forms {
    enum Orientation {
        Horizontal = 0,
        Vertical = 1
    }
}
declare module Stimulsoft.System.Xml {
    enum Formatting {
        None = 0,
        Indented = 1
    }
}
declare module Stimulsoft.System.Xml {
    class XmlAttr {
        private _name;
        name: string;
        private _value;
        value: string;
    }
}
declare module Stimulsoft.System.Xml {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class XmlAttrCollection extends CollectionBase<XmlAttr> {
        readonly length: number;
        add(value: XmlAttr): void;
        getNamedItem(name: string): XmlAttr;
    }
}
declare module Stimulsoft.System.Xml {
    class XmlCharType {
        static fWhitespace: number;
        static fLetter: number;
        static fNCStartName: number;
        static fNCName: number;
        static fCharData: number;
        static fPublicId: number;
        static fText: number;
        static fAttrValue: number;
        private static charPropertiesSize;
        static readonly instance: XmlCharType;
        private static s_CharProperties;
        charProperties: any[];
        private static initInstance;
        private static setProperties;
        private static s_Whitespace;
        private static s_Letter;
        private static s_NCStartName;
        private static s_NCName;
        private static s_CharData;
        private static s_PublicID;
        private static s_Text;
        private static s_AttrValue;
        constructor(charProperties: any[]);
    }
}
declare module Stimulsoft.System.Xml {
    class XmlReservedNs {
        static NsCollationBase: string;
        static NsCollCodePoint: string;
        static NsDataType: string;
        static NsDataTypeAlias: string;
        static NsDataTypeOld: string;
        static NsExsltCommon: string;
        static NsExsltDates: string;
        static NsExsltMath: string;
        static NsExsltRegExps: string;
        static NsExsltSets: string;
        static NsExsltStrings: string;
        static NsMsxsl: string;
        static NsWdXsl: string;
        static NsXdr: string;
        static NsXdrAlias: string;
        static NsXml: string;
        static NsXmlNs: string;
        static NsXQueryDataType: string;
        static NsXQueryFunc: string;
        static NsXs: string;
        static NsXsd: string;
        static NsXsi: string;
        static NsXslDebug: string;
        static NsXslt: string;
        static NsXsltInternal: string;
    }
}
declare module Stimulsoft.System.Xml {
    enum XmlSpace {
        Default = 1,
        None = 0,
        Preserve = 2
    }
}
declare module Stimulsoft.System.Xml {
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    class XmlTextEncoder {
        private textWriter;
        private inAttribute;
        quoteChar: string;
        private attrValue;
        private cacheAttrValue;
        private xmlCharType;
        private surHighStart;
        private surHighEnd;
        private surLowStart;
        private surLowEnd;
        startAttribute(cacheAttrValue: boolean): void;
        endAttribute(): void;
        readonly attributeValue: string;
        private writeSurrogateChar;
        write(text: string): void;
        writeRawWithSurrogateChecking(text: string): void;
        private writeStringFragment;
        private writeCharEntityImpl;
        private writeEntityRefImpl;
        constructor(textWriter: TextWriter);
    }
}
declare module Stimulsoft.System.Xml {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class XmlTextWriter {
        private static stateTableDefault;
        private static stateTableDocument;
        textWriter: TextWriter;
        private xmlEncoder;
        private encoding;
        formatting: Formatting;
        private indented;
        indentation: number;
        private indentChar;
        private stack;
        private top;
        private stateTable;
        private currentState;
        private lastToken;
        private quoteChar;
        private curQuoteChar;
        private namespaces;
        private specialAttr;
        private prefixForXmlNs;
        private _flush;
        private nsStack;
        private nsTop;
        private nsHashtable;
        private useNsHashtable;
        private xmlCharType;
        private namespaceStackInitialSize;
        private maxNamespacesWalkCount;
        writeStartDocument(standalone?: boolean): void;
        writeEndDocument(): void;
        writeDocType(name: string, pubid: string, sysid: string, subset: string): void;
        writeStartElement(localName: string): void;
        private writeStartElement3;
        writeEndElement(): void;
        writeFullEndElement(): void;
        writeStartAttribute(prefix: string, localName: string, ns: string): void;
        writeEndAttribute(): void;
        writeString(text: string): void;
        writeRaw(data: string): void;
        close(): void;
        flush(): void;
        writeName(name: string): void;
        writeQualifiedName(localName: string, ns: string): void;
        private startDocument;
        private autoComplete;
        private autoCompleteAll;
        private internalWriteEndElement;
        private writeEndStartTag;
        private writeEndAttributeQuote;
        private indent;
        private pushNamespace;
        private addNamespace;
        private addToNamespaceHashtable;
        private popNamespaces;
        private generatePrefix;
        private internalWriteProcessingInstruction;
        private lookupNamespace;
        private lookupNamespaceInCurrentScope;
        private findPrefix;
        private internalWriteName;
        private validateName;
        private handleSpecialAttribute;
        private verifyPrefixXml;
        private pushStack;
        private flushEncoders;
        writeAttributeString(localName: string, value: string): void;
        writeElementString(localName: string, value: string): void;
        writeElementString2(localName: string, ns: string, value: string): void;
        writeElementString3(prefix: string, localName: string, ns: string, value: string): void;
        constructor_(encoding: Encoding, w?: MemoryStream): void;
        constructor(encoding: Encoding, w?: MemoryStream);
    }
}
declare module Stimulsoft.System {
    class Activator {
        static createInstance(type: Type): any;
    }
}
/**
 * @hidden
 */
declare function __default<T>(type: Stimulsoft.System.Type): T;
/**
 * @hidden
 */
declare var _default: typeof __default;
/**
 * @hidden
 */
declare var window: Window;
/**
 * @hidden
 */

interface Array<T> {
    count: number;
    count2(selector?: (value: any) => boolean, __this?: any): number;
    contains(item: T): boolean;
    add(item: T): any;
    remove(item: T): any;
    remove(index: number): any;
    insert(index: number, item: T): any;
    clear(): any;
    clone(): T[];
    removeAt(index: number): any;
    addRange(items: T[]): any;
    removeRange(index: number, count: number): any;
    copyTo(array: any[]): any;
    copyTo(array: any[], index: number): any;
    getKeys(): string[];
    getByIndex(index: number, keys: string[]): T;
    removeByIndex(index: number): T;
    first(): T;
    firstOrDefault(funct: any): T;
    lastOrDefault(): T;
    where(funct: any): T[];
    select(funct: any): any[];
    selectMany(funct: any): any[];
    any(funct?: any): boolean;
    all(funct?: any): boolean;
    exists(funct: any): boolean;
    sort2(comparer: Stimulsoft.System.Collections.IComparer<T>): T[];
    getStiLength(dimension: number): number;
    setByIndex(index: number, item: T): any;
    orderBy(funct: any): T[];
    toArray(): any[];
    peek(): T;
    cast<T>(): any;
    sum(): number;
    min(funct?: any): T;
    max(funct?: any): T;
    skip(index: number): T[];
    sti_indexOf(searchElement: any, fromIndex: number): number;
    toList(): Stimulsoft.System.Collections.List<T>;
    getHashCode(): number;
}
interface ArrayConstructor {
    create(type: Stimulsoft.System.Type, ...values: any[]): any[];
    numberSortFunction(): any;
    copy(sourceArray: any[], startIndex: number, destinationArray: any[], count: number): any;
    reverse(array: any[]): any;
    sort(array: any[]): any;
    sort3<T>(keys: number[], items: T[]): any;
    name: string;
    namespace: string;
    fullName: string;
    clear(array: any[], index: number, length: number): any;
    disableAllEnumerable(): any;
}
declare namespace Stimulsoft.System {
    class Attribute {
    }
}
declare module Stimulsoft.System {
    class Base64 {
        private static keyStr;
        static encode(input: string): string;
        static decode(input: string): any;
        private static utf8_encode;
        private static utf8_decode;
    }
}
interface Boolean {
    /** Convert object to the specified interface or class, returns null if not inherited. */
    sti_as(type: any): any;
    getHashCode(): number;
}
interface BooleanConstructor {
    name: string;
    namespace: string;
    fullName: string;
    getStiTypeName(): string;
    getStiNetTypeName(): string;
}
declare module Stimulsoft.System {
    class Chars {
        static getUnicodeCategory(char: number): number;
        private static _table_0;
        private static _table_9fc0;
        private static _table_d780;
        private static _table_fa40;
    }
}
declare module Stimulsoft.System {
    class Convert {
        private static keyStr;
        static changeType(value: any, type: Type): any;
        static changeType2(value: any, typeCode: TypeCode): any;
        static toDateTime(value: any): DateTime;
        static toString(value: any): string;
        static toFont(value: string): Stimulsoft.System.Drawing.Font;
        static sti_toBoolean(value: any): boolean;
        static sti_toNumber(value: any): number;
        static toDouble(value: any): number;
        static toInt32(value: any, radix?: number): number;
        static toInt64(value: any): number;
        static toUInt64(value: any): number;
        static toUInt32(value: any): number;
        static toBase64String(input: string | number[] | Uint8Array): string;
        static fromBase64String(input: string): number[];
        static fromBase64StringText(input: string): string;
    }
}
declare module Stimulsoft.System {
    class DateTime {
        private static ticksPerMillisecond;
        private static ticksPerSecond;
        private static ticksPerMinute;
        private static ticksPerHour;
        private static ticksPerDay;
        private static millisPerSecond;
        private static millisPerMinute;
        private static millisPerHour;
        private static millisPerDay;
        private static daysPerYear;
        private static daysPer4Years;
        private static daysPer100Years;
        private static daysPer400Years;
        private static daysTo1601;
        private static daysTo1899;
        private static daysTo10000;
        private static minTicks;
        private static maxTicks;
        private static maxMillis;
        private static fileTimeOffset;
        private static doubleDateOffset;
        private static oADateMinAsTicks;
        private static oADateMinAsDouble;
        private static oADateMaxAsDouble;
        private static datePartYear;
        private static datePartDayOfYear;
        private static datePartMonth;
        private static DatePartDay;
        private static daysToMonth365;
        private static daysToMonth366;
        static minValue: DateTime;
        static maxValue: DateTime;
        static getStiNetTypeName(): string;
        private innerDate;
        readonly year: number;
        readonly month: number;
        readonly monthName: string;
        readonly monthGenitiveName: string;
        readonly monthShortName: string;
        readonly day: number;
        /** 0 – Sunday, 1 – Monday etc */
        readonly dayOfWeek: DayOfWeek;
        readonly dayName: string;
        readonly dayShortName: string;
        readonly hour: number;
        readonly minute: number;
        readonly second: number;
        readonly millisecond: number;
        readonly ticks: number;
        readonly dayOfYear: number;
        toShortDateString(): string;
        static readonly now: DateTime;
        static readonly today: DateTime;
        static isLeapYear(year: number): boolean;
        /** The month number ranging from 1 to 12. JS calculate month from 0. This will even work for December. */
        static daysInMonth(year: number, month: number): number;
        static compare(t1: DateTime, t2: DateTime): number;
        private static doubleDateToTicks;
        private static ticksToOADate;
        static ticksNetToTicksJs(ticks: number): number;
        negate(): DateTime;
        addYears(value: number): DateTime;
        addMonths(value: number): DateTime;
        addDays(value: number): DateTime;
        addHours(value: number): DateTime;
        addMinutes(value: number): DateTime;
        addSeconds(value: number): DateTime;
        addMilliseconds(value: number): DateTime;
        addTicks(value: number): DateTime;
        compareTo(value: DateTime): number;
        subtract(value: DateTime): TimeSpan;
        readonly date: Date;
        /** By default date and time is converted into American format. */
        toString(format?: string): string;
        toOADate(): number;
        toOADate2(round: boolean): number;
        toNetJsonString(): string;
        static tryParseExact(d: string, format: string): {
            result: DateTime;
            successfully: boolean;
        };
        static fromNetJsonString(jsonDate: string): DateTime;
        static fromOADate(oadate: number): DateTime;
        static fromString(d?: string, logError?: boolean): DateTime;
        static fromString2(format: string, value: string, logError?: boolean): DateTime;
        readonly timeOfDay: TimeSpan;
        constructor(date: Date);
        constructor(ticks: number);
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number);
    }
}
declare module Stimulsoft.System {
    enum DayOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6
    }
}
declare module Stimulsoft.System {
    class Enum {
        static getName(enumType: Object, value: number): string;
        static parse(enumType: Object, value: string | number, ignoreCase?: boolean): number;
        static getNames(enumType: Object): string[];
        static getValues(enumType: Object): number[];
    }
}
declare module Stimulsoft.System {
    class Environment {
        static readonly newLine: string;
    }
}
declare namespace Stimulsoft.System {
    class Event {
        private eventList;
        readonly isNull: boolean;
        readonly isNotNull: boolean;
        add(funct: Function, _this: any): void;
        call(...args: any[]): void;
    }
}
declare module Stimulsoft.System {
    class EventArgs {
        static empty: EventArgs;
    }
}
declare module Stimulsoft.System {
    class EventHandler {
        static _this: any;
        private static handler;
        private args;
        create(script: string, _this: any): Function;
        static create(script: string, _this: any): Function;
        constructor(args: string);
    }
}
declare namespace Stimulsoft.System {
    class Exception extends Error {
        innerException?: Exception;
        constructor(message?: string, innerException?: Exception);
    }
}
declare module Stimulsoft.System {
    class Guid {
        private id;
        static newGuid(): Guid;
        private static s4;
        toString(): string;
        static readonly empty: Guid;
        static compareTo(value: Guid): number;
        constructor(id: string);
    }
}
declare module Stimulsoft.System {
    var ICloneable: string;
    interface ICloneable {
        clone(): any;
    }
}
declare module Stimulsoft.System {
    var IComparable: string;
    interface IComparable {
        compareTo(obj: Object): number;
    }
}
declare module Stimulsoft.System {
    var IFormatProvider: string;
    interface IFormatProvider {
        getFormat(formatType: Type): Object;
    }
}
declare module Stimulsoft.System {
    class JSON2 {
        static decode(text: string): any;
        static encode(value: any): string;
        static stiPopulateObject(json: any, object: any): void;
    }
}
interface Math {
    round2(value: number, digits?: number): number;
    trunc(x: number): number;
    sign(x: number): number;
    log10(value: number): number;
}
declare module Stimulsoft.System {
    enum MidpointRounding {
        ToEven = 0,
        AwayFromZero = 1
    }
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary {
    /**
      * @hidden
     */
    function Moment(inp?: Stimulsoft.ExternalLibrary.Moment.MomentInput, format?: Stimulsoft.ExternalLibrary.Moment.MomentFormatSpecification, strict?: boolean): Stimulsoft.ExternalLibrary.Moment.Moment;
    /**
     * @hidden
     */
    function Moment(inp?: Stimulsoft.ExternalLibrary.Moment.MomentInput, format?: Stimulsoft.ExternalLibrary.Moment.MomentFormatSpecification, language?: string, strict?: boolean): Stimulsoft.ExternalLibrary.Moment.Moment;
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary.Moment {
    type RelativeTimeKey = 's' | 'ss' | 'm' | 'mm' | 'h' | 'hh' | 'd' | 'dd' | 'M' | 'MM' | 'y' | 'yy';
    type CalendarKey = 'sameDay' | 'nextDay' | 'lastDay' | 'nextWeek' | 'lastWeek' | 'sameElse' | string;
    type LongDateFormatKey = 'LTS' | 'LT' | 'L' | 'LL' | 'LLL' | 'LLLL' | 'lts' | 'lt' | 'l' | 'll' | 'lll' | 'llll';
    interface Locale {
        calendar(key?: CalendarKey, m?: Moment, now?: Moment): string;
        longDateFormat(key: LongDateFormatKey): string;
        invalidDate(): string;
        ordinal(n: number): string;
        preparse(inp: string): string;
        postformat(inp: string): string;
        relativeTime(n: number, withoutSuffix: boolean, key: RelativeTimeKey, isFuture: boolean): string;
        pastFuture(diff: number, absRelTime: string): string;
        set(config: Object): void;
        months(): string[];
        months(m: Moment, format?: string): string;
        monthsShort(): string[];
        monthsShort(m: Moment, format?: string): string;
        monthsParse(monthName: string, format: string, strict: boolean): number;
        monthsRegex(strict: boolean): RegExp;
        monthsShortRegex(strict: boolean): RegExp;
        week(m: Moment): number;
        firstDayOfYear(): number;
        firstDayOfWeek(): number;
        weekdays(): string[];
        weekdays(m: Moment, format?: string): string;
        weekdaysMin(): string[];
        weekdaysMin(m: Moment): string;
        weekdaysShort(): string[];
        weekdaysShort(m: Moment): string;
        weekdaysParse(weekdayName: string, format: string, strict: boolean): number;
        weekdaysRegex(strict: boolean): RegExp;
        weekdaysShortRegex(strict: boolean): RegExp;
        weekdaysMinRegex(strict: boolean): RegExp;
        isPM(input: string): boolean;
        meridiem(hour: number, minute: number, isLower: boolean): string;
    }
    interface StandaloneFormatSpec {
        format: string[];
        standalone: string[];
        isFormat?: RegExp;
    }
    interface WeekSpec {
        dow: number;
        doy: number;
    }
    type CalendarSpecVal = string | ((m?: MomentInput, now?: Moment) => string);
    interface CalendarSpec {
        sameDay?: CalendarSpecVal;
        nextDay?: CalendarSpecVal;
        lastDay?: CalendarSpecVal;
        nextWeek?: CalendarSpecVal;
        lastWeek?: CalendarSpecVal;
        sameElse?: CalendarSpecVal;
        [x: string]: CalendarSpecVal | void;
    }
    type RelativeTimeSpecVal = (string | ((n: number, withoutSuffix: boolean, key: RelativeTimeKey, isFuture: boolean) => string));
    type RelativeTimeFuturePastVal = string | ((relTime: string) => string);
    interface RelativeTimeSpec {
        future: RelativeTimeFuturePastVal;
        past: RelativeTimeFuturePastVal;
        s: RelativeTimeSpecVal;
        ss: RelativeTimeSpecVal;
        m: RelativeTimeSpecVal;
        mm: RelativeTimeSpecVal;
        h: RelativeTimeSpecVal;
        hh: RelativeTimeSpecVal;
        d: RelativeTimeSpecVal;
        dd: RelativeTimeSpecVal;
        M: RelativeTimeSpecVal;
        MM: RelativeTimeSpecVal;
        y: RelativeTimeSpecVal;
        yy: RelativeTimeSpecVal;
    }
    interface LongDateFormatSpec {
        LTS: string;
        LT: string;
        L: string;
        LL: string;
        LLL: string;
        LLLL: string;
        lts?: string;
        lt?: string;
        l?: string;
        ll?: string;
        lll?: string;
        llll?: string;
    }
    type MonthWeekdayFn = (momentToFormat: Moment, format?: string) => string;
    type WeekdaySimpleFn = (momentToFormat: Moment) => string;
    interface LocaleSpecification {
        months?: string[] | StandaloneFormatSpec | MonthWeekdayFn;
        monthsShort?: string[] | StandaloneFormatSpec | MonthWeekdayFn;
        weekdays?: string[] | StandaloneFormatSpec | MonthWeekdayFn;
        weekdaysShort?: string[] | StandaloneFormatSpec | WeekdaySimpleFn;
        weekdaysMin?: string[] | StandaloneFormatSpec | WeekdaySimpleFn;
        meridiemParse?: RegExp;
        meridiem?: (hour: number, minute: number, isLower: boolean) => string;
        isPM?: (input: string) => boolean;
        longDateFormat?: LongDateFormatSpec;
        calendar?: CalendarSpec;
        relativeTime?: RelativeTimeSpec;
        invalidDate?: string;
        ordinal?: (n: number) => string;
        ordinalParse?: RegExp;
        week?: WeekSpec;
        [x: string]: any;
    }
    interface MomentObjectOutput {
        years: number;
        months: number;
        date: number;
        hours: number;
        minutes: number;
        seconds: number;
        milliseconds: number;
    }
    interface Duration {
        clone(): Duration;
        humanize(withSuffix?: boolean): string;
        abs(): Duration;
        sti_as(units: unitOfTime.Base): number;
        get(units: unitOfTime.Base): number;
        milliseconds(): number;
        asMilliseconds(): number;
        seconds(): number;
        asSeconds(): number;
        minutes(): number;
        asMinutes(): number;
        hours(): number;
        asHours(): number;
        days(): number;
        asDays(): number;
        weeks(): number;
        asWeeks(): number;
        months(): number;
        asMonths(): number;
        years(): number;
        asYears(): number;
        add(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;
        subtract(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;
        locale(): string;
        locale(locale: LocaleSpecifier): Duration;
        localeData(): Locale;
        toISOString(): string;
        toJSON(): string;
        /**
         * @deprecated since version 2.8.0
         */
        lang(locale: LocaleSpecifier): Moment;
        /**
         * @deprecated since version 2.8.0
         */
        lang(): Locale;
        /**
         * @deprecated
         */
        toIsoString(): string;
    }
    interface MomentRelativeTime {
        future: any;
        past: any;
        s: any;
        ss: any;
        m: any;
        mm: any;
        h: any;
        hh: any;
        d: any;
        dd: any;
        M: any;
        MM: any;
        y: any;
        yy: any;
    }
    interface MomentLongDateFormat {
        L: string;
        LL: string;
        LLL: string;
        LLLL: string;
        LT: string;
        LTS: string;
        l?: string;
        ll?: string;
        lll?: string;
        llll?: string;
        lt?: string;
        lts?: string;
    }
    interface MomentParsingFlags {
        empty: boolean;
        unusedTokens: string[];
        unusedInput: string[];
        overflow: number;
        charsLeftOver: number;
        nullInput: boolean;
        invalidMonth: string | void;
        invalidFormat: boolean;
        userInvalidated: boolean;
        iso: boolean;
        parsedDateParts: any[];
        meridiem: string | void;
    }
    interface MomentParsingFlagsOpt {
        empty?: boolean;
        unusedTokens?: string[];
        unusedInput?: string[];
        overflow?: number;
        charsLeftOver?: number;
        nullInput?: boolean;
        invalidMonth?: string;
        invalidFormat?: boolean;
        userInvalidated?: boolean;
        iso?: boolean;
        parsedDateParts?: any[];
        meridiem?: string;
    }
    interface MomentBuiltinFormat {
        __momentBuiltinFormatBrand: any;
    }
    type MomentFormatSpecification = string | MomentBuiltinFormat | (string | MomentBuiltinFormat)[];
    namespace unitOfTime {
        type Base = ("year" | "years" | "y" | "month" | "months" | "M" | "week" | "weeks" | "w" | "day" | "days" | "d" | "hour" | "hours" | "h" | "minute" | "minutes" | "m" | "second" | "seconds" | "s" | "millisecond" | "milliseconds" | "ms");
        type _quarter = "quarter" | "quarters" | "Q";
        type _isoWeek = "isoWeek" | "isoWeeks" | "W";
        type _date = "date" | "dates" | "D";
        type DurationConstructor = Base | _quarter;
        type DurationAs = Base;
        type StartOf = Base | _quarter | _isoWeek | _date;
        type Diff = Base | _quarter;
        type MomentConstructor = Base | _date;
        type All = Base | _quarter | _isoWeek | _date | "weekYear" | "weekYears" | "gg" | "isoWeekYear" | "isoWeekYears" | "GG" | "dayOfYear" | "dayOfYears" | "DDD" | "weekday" | "weekdays" | "e" | "isoWeekday" | "isoWeekdays" | "E";
    }
    interface MomentInputObject {
        years?: number;
        year?: number;
        y?: number;
        months?: number;
        month?: number;
        M?: number;
        days?: number;
        day?: number;
        d?: number;
        dates?: number;
        date?: number;
        D?: number;
        hours?: number;
        hour?: number;
        h?: number;
        minutes?: number;
        minute?: number;
        m?: number;
        seconds?: number;
        second?: number;
        s?: number;
        milliseconds?: number;
        millisecond?: number;
        ms?: number;
    }
    interface DurationInputObject extends MomentInputObject {
        quarters?: number;
        quarter?: number;
        Q?: number;
        weeks?: number;
        week?: number;
        w?: number;
    }
    interface MomentSetObject extends MomentInputObject {
        weekYears?: number;
        weekYear?: number;
        gg?: number;
        isoWeekYears?: number;
        isoWeekYear?: number;
        GG?: number;
        quarters?: number;
        quarter?: number;
        Q?: number;
        weeks?: number;
        week?: number;
        w?: number;
        isoWeeks?: number;
        isoWeek?: number;
        W?: number;
        dayOfYears?: number;
        dayOfYear?: number;
        DDD?: number;
        weekdays?: number;
        weekday?: number;
        e?: number;
        isoWeekdays?: number;
        isoWeekday?: number;
        E?: number;
    }
    interface FromTo {
        from: MomentInput;
        to: MomentInput;
    }
    type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void;
    type DurationInputArg1 = Duration | number | string | FromTo | DurationInputObject | void;
    type DurationInputArg2 = unitOfTime.DurationConstructor;
    type LocaleSpecifier = string | Moment | Duration | string[] | boolean;
    interface MomentCreationData {
        input: MomentInput;
        format?: MomentFormatSpecification;
        locale: Locale;
        isUTC: boolean;
        strict?: boolean;
    }
    interface Moment extends Object {
        format(format?: string): string;
        startOf(unitOfTime: unitOfTime.StartOf): Moment;
        endOf(unitOfTime: unitOfTime.StartOf): Moment;
        add(amount?: DurationInputArg1, unit?: DurationInputArg2): Moment;
        /**
         * @deprecated reverse syntax
         */
        add(unit: unitOfTime.DurationConstructor, amount: number | string): Moment;
        subtract(amount?: DurationInputArg1, unit?: DurationInputArg2): Moment;
        /**
         * @deprecated reverse syntax
         */
        subtract(unit: unitOfTime.DurationConstructor, amount: number | string): Moment;
        calendar(time?: MomentInput, formats?: CalendarSpec): string;
        clone(): Moment;
        /**
         * @return Unix timestamp in milliseconds
         */
        valueOf(): number;
        local(keepLocalTime?: boolean): Moment;
        isLocal(): boolean;
        utc(keepLocalTime?: boolean): Moment;
        isUTC(): boolean;
        /**
         * @deprecated use isUTC
         */
        isUtc(): boolean;
        parseZone(): Moment;
        isValid(): boolean;
        invalidAt(): number;
        hasAlignedHourOffset(other?: MomentInput): boolean;
        creationData(): MomentCreationData;
        parsingFlags(): MomentParsingFlags;
        year(y: number): Moment;
        year(): number;
        /**
         * @deprecated use year(y)
         */
        years(y: number): Moment;
        /**
         * @deprecated use year()
         */
        years(): number;
        quarter(): number;
        quarter(q: number): Moment;
        quarters(): number;
        quarters(q: number): Moment;
        month(M: number | string): Moment;
        month(): number;
        /**
         * @deprecated use month(M)
         */
        months(M: number | string): Moment;
        /**
         * @deprecated use month()
         */
        months(): number;
        day(d: number | string): Moment;
        day(): number;
        days(d: number | string): Moment;
        days(): number;
        date(d: number): Moment;
        date(): number;
        /**
         * @deprecated use date(d)
         */
        dates(d: number): Moment;
        /**
         * @deprecated use date()
         */
        dates(): number;
        hour(h: number): Moment;
        hour(): number;
        hours(h: number): Moment;
        hours(): number;
        minute(m: number): Moment;
        minute(): number;
        minutes(m: number): Moment;
        minutes(): number;
        second(s: number): Moment;
        second(): number;
        seconds(s: number): Moment;
        seconds(): number;
        millisecond(ms: number): Moment;
        millisecond(): number;
        milliseconds(ms: number): Moment;
        milliseconds(): number;
        weekday(): number;
        weekday(d: number): Moment;
        isoWeekday(): number;
        isoWeekday(d: number | string): Moment;
        weekYear(): number;
        weekYear(d: number): Moment;
        isoWeekYear(): number;
        isoWeekYear(d: number): Moment;
        week(): number;
        week(d: number): Moment;
        weeks(): number;
        weeks(d: number): Moment;
        isoWeek(): number;
        isoWeek(d: number): Moment;
        isoWeeks(): number;
        isoWeeks(d: number): Moment;
        weeksInYear(): number;
        isoWeeksInYear(): number;
        dayOfYear(): number;
        dayOfYear(d: number): Moment;
        from(inp: MomentInput, suffix?: boolean): string;
        to(inp: MomentInput, suffix?: boolean): string;
        fromNow(withoutSuffix?: boolean): string;
        toNow(withoutPrefix?: boolean): string;
        diff(b: MomentInput, unitOfTime?: unitOfTime.Diff, precise?: boolean): number;
        toArray(): number[];
        toDate(): Date;
        toISOString(keepOffset?: boolean): string;
        inspect(): string;
        toJSON(): string;
        unix(): number;
        isLeapYear(): boolean;
        /**
         * @deprecated in favor of utcOffset
         */
        zone(): number;
        zone(b: number | string): Moment;
        utcOffset(): number;
        utcOffset(b: number | string, keepLocalTime?: boolean): Moment;
        isUtcOffset(): boolean;
        daysInMonth(): number;
        isDST(): boolean;
        zoneAbbr(): string;
        zoneName(): string;
        isBefore(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isAfter(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isSame(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isSameOrAfter(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isSameOrBefore(inp?: MomentInput, granularity?: unitOfTime.StartOf): boolean;
        isBetween(a: MomentInput, b: MomentInput, granularity?: unitOfTime.StartOf, inclusivity?: "()" | "[)" | "(]" | "[]"): boolean;
        /**
         * @deprecated as of 2.8.0, use locale
         */
        lang(language: LocaleSpecifier): Moment;
        /**
         * @deprecated as of 2.8.0, use locale
         */
        lang(): Locale;
        locale(): string;
        locale(locale: LocaleSpecifier): Moment;
        localeData(): Locale;
        /**
         * @deprecated no reliable implementation
         */
        isDSTShifted(): boolean;
        /**
         * @deprecated as of 2.7.0, use moment.min/max
         */
        max(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
        /**
         * @deprecated as of 2.7.0, use moment.min/max
         */
        max(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
        /**
         * @deprecated as of 2.7.0, use moment.min/max
         */
        min(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
        /**
         * @deprecated as of 2.7.0, use moment.min/max
         */
        min(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
        get(unit: unitOfTime.All): number;
        set(unit: unitOfTime.All, value: number): Moment;
        set(objectLiteral: MomentSetObject): Moment;
        toObject(): MomentObjectOutput;
    }
    var version: string;
    var fn: Moment;
    function utc(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
    function utc(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
    function unix(timestamp: number): Moment;
    function invalid(flags?: MomentParsingFlagsOpt): Moment;
    function isMoment(m: any): m is Moment;
    function isDate(m: any): m is Date;
    function isDuration(d: any): d is Duration;
    /**
     * @deprecated in 2.8.0
     */
    function lang(language?: string): string;
    /**
     * @deprecated in 2.8.0
     */
    function lang(language?: string, definition?: Locale): string;
    function locale(language?: string): string;
    function locale(language?: string[]): string;
    function locale(language?: string, definition?: LocaleSpecification | void): string;
    function localeData(key?: string | string[]): Locale;
    function duration(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;
    function parseZone(inp?: MomentInput, format?: MomentFormatSpecification, strict?: boolean): Moment;
    function parseZone(inp?: MomentInput, format?: MomentFormatSpecification, language?: string, strict?: boolean): Moment;
    function months(): string[];
    function months(index: number): string;
    function months(format: string): string[];
    function months(format: string, index: number): string;
    function monthsShort(): string[];
    function monthsShort(index: number): string;
    function monthsShort(format: string): string[];
    function monthsShort(format: string, index: number): string;
    function weekdays(): string[];
    function weekdays(index: number): string;
    function weekdays(format: string): string[];
    function weekdays(format: string, index: number): string;
    function weekdays(localeSorted: boolean): string[];
    function weekdays(localeSorted: boolean, index: number): string;
    function weekdays(localeSorted: boolean, format: string): string[];
    function weekdays(localeSorted: boolean, format: string, index: number): string;
    function weekdaysShort(): string[];
    function weekdaysShort(index: number): string;
    function weekdaysShort(format: string): string[];
    function weekdaysShort(format: string, index: number): string;
    function weekdaysShort(localeSorted: boolean): string[];
    function weekdaysShort(localeSorted: boolean, index: number): string;
    function weekdaysShort(localeSorted: boolean, format: string): string[];
    function weekdaysShort(localeSorted: boolean, format: string, index: number): string;
    function weekdaysMin(): string[];
    function weekdaysMin(index: number): string;
    function weekdaysMin(format: string): string[];
    function weekdaysMin(format: string, index: number): string;
    function weekdaysMin(localeSorted: boolean): string[];
    function weekdaysMin(localeSorted: boolean, index: number): string;
    function weekdaysMin(localeSorted: boolean, format: string): string[];
    function weekdaysMin(localeSorted: boolean, format: string, index: number): string;
    function min(moments: Moment[]): Moment;
    function min(...moments: Moment[]): Moment;
    function max(moments: Moment[]): Moment;
    function max(...moments: Moment[]): Moment;
    /**
     * Returns unix time in milliseconds. Overwrite for profit.
     */
    function now(): number;
    function defineLocale(language: string, localeSpec: LocaleSpecification | void | any): Locale;
    function updateLocale(language: string, localeSpec: LocaleSpecification | void): Locale;
    function locales(): string[];
    function normalizeUnits(unit: unitOfTime.All): string;
    function relativeTimeThreshold(threshold: string): number | boolean;
    function relativeTimeThreshold(threshold: string, limit: number): boolean;
    function relativeTimeRounding(fn: (num: number) => number): boolean;
    function relativeTimeRounding(): (num: number) => number;
    function calendarFormat(m: Moment, now: Moment): string;
    function parseTwoDigitYear(input: string): number;
    /**
     * Constant used to enable explicit ISO_8601 format parsing.
     */
    var ISO_8601: MomentBuiltinFormat;
    var RFC_2822: MomentBuiltinFormat;
    var defaultFormat: string;
    var defaultFormatUtc: string;
    var HTML5_FMT: {
        DATETIME_LOCAL: string;
        DATETIME_LOCAL_SECONDS: string;
        DATETIME_LOCAL_MS: string;
        DATE: string;
        TIME: string;
        TIME_SECONDS: string;
        TIME_MS: string;
        WEEK: string;
        MONTH: string;
    };
}
interface Number {
    /** Convert object to the specified interface or class, returns null if not inherited. */
    sti_as(type: any): any;
    compareTo(value: number): number;
    /** Serves as a hash function for a particular type. */
    getHashCode(): number;
    toStringFormat(formatString: string): string;
    toShort(): number;
}
interface NumberConstructor {
    name: string;
    namespace: string;
    fullName: string;
    getStiTypeName(): string;
    getStiNetTypeName(): string;
    tryParse(value: string): {
        result: number;
        successfully: boolean;
    };
}
interface Object {
    /** Returns the type (constructor) of this object. */
    getStiType(): Stimulsoft.System.Type;
    /** Checks inherit from the specified class or interface. */
    sti_is(type: any): boolean;
    /** Convert object to the specified interface or class, returns null if not inherited. */
    sti_as(type: any): any;
    /** Creates a shallow copy of the current Object. */
    memberwiseClone(): any;
    /** Determines whether the specified Object is equal to the current Object. */
    stiEquals(obj: Object): boolean;
    /** Serves as a hash function for a particular type. */
    getHashCode(): number;
    /** Compares the current instance with another object of the same type and returns an integer that indicates whether
     * the current instance precedes, follows, or occurs in the same position in the sort order as the other object. */
    compareTo(object: Object): number;
    sti_toBoolean(): boolean;
    sti_toNumber(): number;
    /** Returns the type name of this object class. */
    getStiTypeName(): string;
    /** Returns the full type name (with .NET namespace) of this object class. */
    getStiNetTypeName(): string;
    stiHashLink: number;
}
interface ObjectConstructor {
    /** Determines whether the specified Object instances are the same instance. */
    referenceEquals(objA: any, objB: any): boolean;
    addEvent(element: any, eventName: string, fn: Function): any;
    stiEquals(objA: any, objB: any): boolean;
    saveAs(data: any, fileName: string, type?: string): any;
    /** Returns the type name of this object class. */
    getStiTypeName(): string;
    /** Returns the full type name (with .NET namespace) of this object class. */
    getStiNetTypeName(): string;
    isNullOrUndefined(obj: any): boolean;
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary.Opentype {
    /**
      * @hidden
     */
    function parse(data: any): any;
}
declare module Stimulsoft.System {
    class ParamsArray {
        arg0: Object;
        arg1: Object;
        arg2: Object;
        private _length;
        constructor(arg0: Object, arg1?: Object, arg2?: Object);
        readonly length: number;
        get(index: Number): Object;
    }
}
declare module Stimulsoft.System {
    class Promise<T> {
        private _this;
        returnValue: T;
        private _tryFunctions;
        private _finallyFunction;
        private _timeout;
        private _startTime;
        private _callTry;
        private _callCatch;
        private _callFinaly;
        private _callTimeout;
        private _catchArgument;
        private _finalyArgument;
        private promise;
        private timeoutHanderId;
        private assignFunction;
        private _catchFunctions;
        try(tryFunction: Function, _this?: any): Promise<T>;
        catch(catchFunction: Function, _this?: any): Promise<T>;
        finally(finallyFunction: Function, _this?: any): Promise<T>;
        this(_this: any): Promise<T>;
        timeout(timeout: number): Promise<T>;
        callTry(returnValue?: T): Promise<T>;
        callCatch(catchArgument?: any): void;
        private callFinally;
        callTimeout(): void;
        private nextPromises;
        abort(previusPromise?: Promise<any>): Promise<T>;
        private abortFunction;
        onAbort(abortFunction: Function): void;
        constructor();
    }
}
declare module Stimulsoft.Report {
    class Range {
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: Object;
        toObject: Object;
        parse(from: string, to: string): void;
        stiEquals(obj: any): boolean;
        readonly fromStrLoc: string;
        readonly toStrLoc: string;
        getHashCode(): number;
        constructor();
    }
    class CharRange extends Range {
        from: string;
        to: string;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: string): boolean;
        constructor(from?: string, to?: string);
    }
    class DateTimeRange extends Range {
        from: Stimulsoft.System.NullableDateTime;
        to: Stimulsoft.System.NullableDateTime;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        readonly fromDate: Stimulsoft.System.DateTime;
        readonly toDate: Stimulsoft.System.DateTime;
        contains(value: Stimulsoft.System.DateTime): boolean;
        toString(): string;
        constructor(from?: Stimulsoft.System.DateTime, to?: Stimulsoft.System.DateTime);
    }
    class TimeSpanRange extends Range {
        from: Stimulsoft.System.NullableTimeSpan;
        to: Stimulsoft.System.NullableTimeSpan;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        readonly fromTime: Stimulsoft.System.TimeSpan;
        readonly toTime: Stimulsoft.System.TimeSpan;
        contains(value: Stimulsoft.System.TimeSpan): boolean;
        constructor(from?: Stimulsoft.System.TimeSpan, to?: Stimulsoft.System.TimeSpan);
    }
    class DecimalRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class FloatRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class DoubleRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ByteRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class ShortRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class IntRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class LongRange extends Range {
        from: number;
        to: number;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: number): boolean;
        constructor(from?: number, to?: number);
    }
    class GuidRange extends Range {
        from: Stimulsoft.System.Guid;
        to: Stimulsoft.System.Guid;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: Stimulsoft.System.Guid): boolean;
        constructor(from?: Stimulsoft.System.Guid, to?: Stimulsoft.System.Guid);
    }
    class StringRange extends Range {
        from: String;
        to: String;
        readonly rangeName: string;
        readonly rangeType: Stimulsoft.System.Type;
        fromObject: any;
        toObject: any;
        contains(value: String): boolean;
        constructor(from?: String, to?: String);
    }
}
declare module Stimulsoft.System {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class ResourceManager {
        private resource;
        getString(name: string, culture: CultureInfo): string;
    }
}
declare module Stimulsoft.System {
    class StiError {
        static errorMessageForm: any;
        static showError(e: any, showForm?: boolean): void;
    }
}
/**
 * @hidden
 */
declare function unescape(s: string): string;
/**
 * @hidden
 */
declare function escape(s: string): string;
interface String {
    /** Convert object to the specified interface or class, returns null if not inherited. */
    sti_as(type: any): any;
    /** Returns a copy of this string converted to lowercase. */
    toLower(): string;
    /** Returns a copy of this string converted to uppercase. */
    toUpper(): string;
    /** Returns a result of checking string is Base64. */
    isBase64String(): boolean;
    /** Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted. */
    remove(startIndex: number): string;
    /** Returns a new string in which a specified number of characters in this instance beginning at a specified position have been deleted. */
    remove(startIndex: number, count: number): string;
    /** Returns a new string in which a specified string is inserted at a specified index position in this instance. */
    insert(startIndex: number, value: string, removeLength: number): string;
    /** Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length. */
    padLeft(totalWidth: number): string;
    /** Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length. */
    padLeft(totalWidth: number, paddingChar: string): string;
    /** Determines whether the beginning of this string instance matches the specified string. */
    startsWith(value: string): boolean;
    /** Determines whether the beginning of this string instance matches the specified string when the case is ignored. */
    startsWith(value: string, ignoreCase: boolean): boolean;
    /** Determines whether the end of this string instance matches the specified string. */
    endsWith(value: string): boolean;
    /** Determines whether the end of this string instance matches the specified string when the case is ignored. */
    endsWith(value: string, ignoreCase: boolean): boolean;
    /** Removes all space characters from the start of the specified string. */
    trimStart(char?: string): string;
    /** Removes all space characters from the end of the specified string. */
    trimEnd(char?: string): string;
    /** Returns the hash code for this string. */
    getHashCode(): number;
    toBytesArray(): number[];
    toUnicodeString(): string;
    fromUnicodeString(): string;
    /** NOT IMPLEMENTS! */
    compareTo(strB: string): number;
    contains(str: string): boolean;
    indexOfAny(values: string[]): number;
    regexIndexOf(regex: RegExp, startpos: number): any;
    regexLastIndexOf(regex: RegExp, startpos: number): any;
    replaceAll(searchValue: string, replaceValue: string, startIndex?: number, count?: number): string;
}
interface StringConstructor {
    /** Represents the empty string. */
    empty: string;
    /** Indicates whether the specified string is null or an empty string. */
    isNullOrEmpty(value: string): boolean;
    /** Indicates whether a specified string is null, empty, or consists only of white-space characters. */
    isNullOrWhiteSpace(value: string): boolean;
    /** Returns a string consisting of a specified string concatenated with itself a specified number of times. */
    repeat(value: string, n: number): string;
    /** Returns a string, which consists of the specified string, linked with itself the indicated number of times. */
    fill(value: string, count: number): string;
    stiFormat(str: string, ...values: any[]): string;
    stiFormat2(provider: Stimulsoft.System.IFormatProvider, format: string, ...values: any[]): string;
    parseFormatString(formatString: String, values: Array<any>): string;
    formatNumber(arg: any, decimalDigits: number, useGroupSeparator: boolean, useSign: boolean): string;
    customFormat(arg: any, format: string): string;
    customFormatNumber(arg: number, format: string): string;
    indexOfAny(str: string, searchChars: string[]): number;
    removeBOM(str: string): string;
    join(separator: string, value: string[]): string;
    fromBytesArray(bytes: number[]): string;
    getStiTypeName(): string;
    getStiNetTypeName(): string;
}
declare module Stimulsoft.System {
    enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5
    }
}
declare module Stimulsoft.System {
    class SwitchSymbolFormatter {
        private numberSymbol;
        private isValid;
        formatValue(format: string, source: any): string;
        constructor(numberSymbol?: string);
    }
}
declare module Stimulsoft.System {
    enum TypeCode {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18
    }
}
declare module Stimulsoft.System {
    import TypeCode = Stimulsoft.System.TypeCode;
    class TypeHelper {
        private static types;
        static getTypes(): Stimulsoft.System.Type[];
        static isValueType(type: Type): boolean;
    }
    class Type {
        apply(thisArg: any, argArray?: any): any;
        call(thisArg: any, ...argArray: any[]): any;
        bind(thisArg: any, ...argArray: any[]): any;
        prototype: any;
        length: number;
        arguments: any;
        caller: Function;
        static getType(value: any): Type;
        static getTypeName(value: any): string;
        static getTypeCode(value: any): TypeCode;
        static isNumericType(type: Type): boolean;
        static isIntegerType(type: Type): boolean;
        static isDateType(type: Type): boolean;
        static getHashCode(type: any): number;
    }
    class Byte {
    }
    class ByteArray {
    }
    class Decimal {
    }
    class Double {
    }
    class Float {
    }
    class Int {
    }
    class Int16 {
    }
    class Int32 {
    }
    class Int64 {
    }
    class Short {
    }
    class Long {
    }
    class SByte {
    }
    class Single extends Number {
    }
    class UInt {
    }
    class UInt16 {
    }
    class UInt32 {
    }
    class UInt64 {
    }
    class UShort {
    }
    class ULong {
    }
    class Nullable {
    }
    class NullableBoolean extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableByte extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableChar extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableDateTime extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableTimeSpan extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableDecimal extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableDouble extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableFloat extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableGuid extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt16 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt32 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableInt64 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableShort extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableLong extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableSByte extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableSingle extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt16 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt32 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUInt64 extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableUShort extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class NullableULong extends Nullable {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftByteRange extends Stimulsoft.Report.ByteRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftCharRange extends Stimulsoft.Report.CharRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDateTimeRange extends Stimulsoft.Report.DateTimeRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDecimalRange extends Stimulsoft.Report.DecimalRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDoubleRange extends Stimulsoft.Report.DoubleRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftFloatRange extends Stimulsoft.Report.FloatRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftGuidRange extends Stimulsoft.Report.GuidRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftIntRange extends Stimulsoft.Report.IntRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftLongRange extends Stimulsoft.Report.LongRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftShortRange extends Stimulsoft.Report.ShortRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftStringRange extends Stimulsoft.Report.StringRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftTimeSpanRange extends Stimulsoft.Report.TimeSpanRange {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftList {
    }
    class StimulsoftBoolList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftByteList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftCharList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDateTimeList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDecimalList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftDoubleList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftFloatList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftGuidList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftIntList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftLongList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftShortList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftStringList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
    class StimulsoftTimeSpanList extends StimulsoftList {
        static getStiTypeName(): string;
        static getStiNetTypeName(): string;
    }
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary.XXH {
    /**
      * @hidden
     */
    function h32(value: string, seed: number): number;
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary.xmldoc {
    /**
      * @hidden
     */
    class XmlDocument {
        constructor(xmlString: string);
    }
}

declare namespace Stimulsoft.Base.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    class Font {
        Name: string;
        Size: number;
        Color: Color;
        SelectedColor: Color;
        IsBold: boolean;
        getGdiFont(zoom?: number, fontSize?: number, baseFont?: Stimulsoft.System.Drawing.Font): Stimulsoft.System.Drawing.Font;
        getCachedGdiFont(): Stimulsoft.System.Drawing.Font;
        private cachedFont;
        constructor(name: string, size: number, color: Color, isBold?: boolean);
    }
    class StiElementConsts {
        static TitleFont: Font;
        static ForegroundColor: Color;
        static BackgroundColor: Color;
        static TreeView: {
            ItemHeight: number;
        };
        static ComboBox: {
            ItemHeight: number;
        };
        static ListBox: {
            ItemHeight: number;
            CheckBoxWidth: number;
        };
        static Table: {
            Font: Font;
            BorderColor: Color;
            Height: number;
            getHeight: (font: Stimulsoft.System.Drawing.Font, scale?: number) => number;
            Header: {
                BackgroundColor: Color;
            };
        };
    }
}
declare module Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiCsvHelper {
        static codePageCodes: number[];
        static codePageNames: string[];
        static getTable(path: string, codePage?: number, separator?: string): DataTable;
        static getDataSet(data: number[], tableName: string, codePage: number, separator: string): DataSet;
        static getTable2(data: number[], codePage?: number, separator?: string, loadData?: boolean): DataTable;
        private static splitToColumns;
    }
}
declare module Stimulsoft.Base {
    class StiDataNameValidator {
        static correct(str: string): string;
    }
}
declare module Stimulsoft.Base {
    class StiFileItemTable {
        static defaultCsvTableName: string;
        static defaultDBaseTableName: string;
    }
}
declare module Stimulsoft.Base {
    class StiObjectSchema {
        name: string;
    }
}
declare module Stimulsoft.Base {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataSchema extends StiObjectSchema {
        tables: StiDataTableSchema[];
        views: StiDataTableSchema[];
        storedProcedures: StiDataTableSchema[];
        queries: StiDataTableSchema[];
        relations: StiDataRelationSchema[];
        connectionIdent: StiConnectionIdent;
        isEmpty(): boolean;
        getDataSet(): DataSet;
        sort(): StiDataSchema;
        constructor(ident?: StiConnectionIdent);
    }
}
declare module Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    class StiODataHelper {
        connectionString: string;
        readonly address: string;
        readonly userName: string;
        readonly password: string;
        readonly addressBearer: string;
        private getConnectionStringKey;
        private getConnectionStringKey1;
        private bearerAccessToken;
        retrieveSchema(): StiDataSchema;
        fillDataTable(table: DataTable, query: string): void;
        testConnection(): StiTestConnectionResult;
        static getNetType(dbType: string): Type;
        static getBearerAccessToken(url: string, userName: string, password: string): string;
        private getDefaultWebClient;
        constructor(connectionString: string);
    }
}
declare module Stimulsoft.Base {
    class StiDataLoaderHelperData {
        name: string;
        array: any;
        toList(): StiDataLoaderHelperData[];
        constructor(name: string, array: any);
    }
    class StiDataLoaderHelper {
        static loadMultiple(path: string, fileExt: string, binary: boolean): StiDataLoaderHelperData[];
        static loadSingle(path: string, binary: boolean): StiDataLoaderHelperData;
    }
}
declare module Stimulsoft.Base {
    class StiFileUrlHelper {
        static get(path: string): number[];
    }
}
declare module Stimulsoft.Base {
    class StiTestConnectionResult {
        success: boolean;
        notice: string;
        static makeWrong(notice: string): StiTestConnectionResult;
        static makeWrong2(exception: string): StiTestConnectionResult;
        static makeWrong3(): StiTestConnectionResult;
        static makeFine(): StiTestConnectionResult;
    }
}
declare module Stimulsoft.Base {
    class StiDataColumnSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Base {
    class StiDataParameterSchema extends StiObjectSchema {
        type: Stimulsoft.System.Type;
        value: Object;
        constructor(name?: string, type?: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Base {
    class StiDataRelationSchema {
        name: string;
        parentSourceName: string;
        childSourceName: string;
        childColumns: string[];
        parentColumns: string[];
    }
}
declare module Stimulsoft.Base {
    class StiDataTableSchema extends StiObjectSchema {
        columns: StiDataColumnSchema[];
        parameters: StiDataParameterSchema[];
        query: string;
        static newTableOrView(name: string, connector?: any, query?: string): StiDataTableSchema;
        static newTable(name: string, connector?: any, query?: string): StiDataTableSchema;
        static newView(name: string, connector?: any, query?: string): StiDataTableSchema;
        static newProcedure(name: string, connector?: any, query?: string): StiDataTableSchema;
        constructor(name?: string, query?: string);
    }
}
declare module Stimulsoft.Base {
    enum StiDataFormatType {
        Xml = 0,
        Json = 1
    }
    enum StiRetrieveColumnsMode {
        KeyInfo = 0,
        SchemaOnly = 1,
        FillSchema = 2
    }
    enum StiConnectionIdent {
        Db2DataSource = 1,
        InformixDataSource = 2,
        MsAccessDataSource = 3,
        MsSqlDataSource = 4,
        MySqlDataSource = 5,
        OdbcDataSource = 6,
        OleDbDataSource = 7,
        FirebirdDataSource = 8,
        PostgreSqlDataSource = 9,
        OracleDataSource = 10,
        SqlCeDataSource = 11,
        SqLiteDataSource = 12,
        SybaseDataSource = 13,
        TeradataDataSource = 14,
        VistaDbDataSource = 15,
        UniversalDevartDataSource = 16,
        ODataDataSource = 17,
        CsvDataSource = 18,
        DBaseDataSource = 19,
        DynamicsNavDataSource = 20,
        ExcelDataSource = 21,
        JsonDataSource = 22,
        XmlDataSource = 23,
        DropboxCloudStorage = 24,
        GoogleDriveCloudStorage = 25,
        OneDriveCloudStorage = 26,
        SharePointCloudStorage = 27,
        Unspecified = 28
    }
    enum StiConnectionOrder {
        MsSqlDataSource = 10,
        MySqlDataSource = 20,
        OdbcDataSource = 30,
        OleDbDataSource = 40,
        OracleDataSource = 50,
        MsAccessDataSource = 60,
        PostgreSqlDataSource = 70,
        FirebirdDataSource = 80,
        SqlCeDataSource = 90,
        SqLiteDataSource = 100,
        Db2DataSource = 110,
        InformixDataSource = 120,
        SybaseDataSource = 130,
        TeradataDataSource = 140,
        VistaDbDataSource = 150,
        UniversalDevartDataSource = 160,
        ODataDataSource = 170,
        ExcelDataSource = 180,
        JsonDataSource = 190,
        XmlDataSource = 200,
        CsvDataSource = 210,
        DBaseDataSource = 220,
        DynamicsNavDataSource = 230,
        DropboxCloudStorage = 240,
        GoogleDriveCloudStorage = 250,
        OneDriveCloudStorage = 260,
        SharePointCloudStorage = 270,
        Unspecified = 0
    }
    enum StiFileType {
        Unknown = 1,
        ReportSnapshot = 2,
        Pdf = 3,
        Xps = 4,
        PowerPoint = 5,
        Html = 6,
        Text = 7,
        RichText = 8,
        Word = 9,
        OpenDocumentWriter = 10,
        Excel = 11,
        OpenDocumentCalc = 12,
        Data = 13,
        Image = 14,
        Xml = 15,
        Xsd = 16,
        Csv = 17,
        Dbf = 18,
        Sylk = 19,
        Dif = 20,
        Json = 21
    }
}
declare namespace Stimulsoft.Base {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import DataTable = Stimulsoft.System.Data.DataTable;
    var IStiBIDataCache: string;
    interface IStiBIDataCache {
        exists(dataSource: IStiAppDataSource): boolean;
        exists2(tableKey: string): boolean;
        remove(tableKey: string): any;
        clean(appKey: string): any;
        cleanAll(): any;
        getTableCount(): number;
        getRowCount(tableKey: string): number;
        getSchema(tableKey: string): DataTable;
        getData(tableKey: string): DataTable;
        runQuery(query: string): DataTable;
        add(appKey: string, tableKey: string, dataTable: DataTable): any;
        getTableName(appKey: string, tableKey: string): string;
    }
}
declare namespace Stimulsoft.Base {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiBIDataCacheHelper {
        private static checkInitialization;
        static exists(tableKey: string): boolean;
        static remove(tableKey: string): void;
        static clean(appKey: string): void;
        static cleanAll(): void;
        static getTableCount(): number;
        static getRowCount(tableKey: string): number;
        static runQuery(query: string): DataTable;
        static get(tableKey: string, loadData?: boolean): DataTable;
        static add(app: IStiApp, tableKey: string, dataTable: DataTable): void;
        static add2(appKey: string, tableKey: string, dataTable: DataTable): void;
        static getTableName(appKey: string, tableKey: string): string;
    }
}
declare namespace Stimulsoft.Base {
    class StiBIDataCacheOptions {
        static enabled: boolean;
        static cache: IStiBIDataCache;
    }
}
declare module Stimulsoft.Base {
    class StiTableQuery {
        private correctName;
        getName(schema: string, table: string): string;
        getSelectQuery1(table: string): string;
        getSelectQuery2(schema: string, table: string): string;
        getExecuteQuery1(table: string): string;
        getExecuteQuery2(schema: string, table: string): string;
        getCallQuery1(table: string): string;
        getCallQuery2(schema: string, table: string): string;
        getProcQuery1(table: string): string;
        getProcQuery2(schema: string, table: string): string;
        static get(adapter: any): StiTableQuery;
        private adapter;
        constructor(adapter: any);
    }
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary.XLSX {
    /**
     * @hidden
     */
    interface IProperties {
        LastAuthor?: string;
        Author?: string;
        CreatedDate?: Date;
        ModifiedDate?: Date;
        Application?: string;
        AppVersion?: string;
        Company?: string;
        DocSecurity?: string;
        Manager?: string;
        HyperlinksChanged?: boolean;
        SharedDoc?: boolean;
        LinksUpToDate?: boolean;
        ScaleCrop?: boolean;
        Worksheets?: number;
        SheetNames?: string[];
    }
    /**
     * @hidden
     */
    interface IParsingOptions {
        cellFormula?: boolean;
        cellHTML?: boolean;
        cellNF?: boolean;
        cellStyles?: boolean;
        cellDates?: boolean;
        sheetStubs?: boolean;
        sheetRows?: number;
        bookDeps?: boolean;
        bookFiles?: boolean;
        bookProps?: boolean;
        bookSheets?: boolean;
        bookVBA?: boolean;
        password?: string;
        /**
         * Possible options: 'binary', 'base64', 'buffer', 'file'
         */
        type?: string;
    }
    /**
     * @hidden
     */
    interface IWorkBook {
        /**
         * A dictionary of the worksheets in the workbook.
         * Use SheetNames to reference these.
         */
        Sheets: {
            [sheet: string]: IWorkSheet;
        };
        /**
         * ordered list of the sheet names in the workbook
         */
        SheetNames: string[];
        /**
         * an object storing the standard properties. wb.Custprops stores custom properties.
         * Since the XLS standard properties deviate from the XLSX standard, XLS parsing stores core properties in both places.
         */
        Props: IProperties;
    }
    /**
     * object representing the worksheet
     * @hidden
     */
    interface IWorkSheet {
        [cell: string]: IWorkSheetCell;
    }
    /**
     * @hidden
     */
    interface IWorkSheetCell {
        /**
         * The Excel Data Type of the cell.
         * b Boolean, n Number, e error, s String, d Date
         */
        t: string;
        /**
         * The raw value of the cell.
         */
        v: string;
        /**
         * rich text encoding (if applicable)
         */
        r?: string;
        /**
         * HTML rendering of the rich text (if applicable)
         */
        h?: string;
        /**
         * formatted text (if applicable)
         */
        w?: string;
        /**
         * cell formula (if applicable)
         */
        f?: string;
        /**
         * comments associated with the cell **
         */
        c?: string;
        /**
         * number format string associated with the cell (if requested)
         */
        z?: string;
        /**
         * cell hyperlink object (.Target holds link, .tooltip is tooltip)
         */
        l?: string;
        /**
         * the style/theme of the cell (if applicable)
         */
        s?: string;
    }
    /**
     * @hidden
     */
    interface IUtils {
        sheet_to_json<T>(worksheet: IWorkSheet): T[];
        sheet_to_csv(worksheet: IWorkSheet): any;
        sheet_to_formulae(worksheet: IWorkSheet): any;
    }
    /**
     * @hidden
     */
    var utils: IUtils;
    /**
     * @hidden
     */
    function readFile(filename: string, opts?: IParsingOptions): IWorkBook;
    /**
     * @hidden
     */
    function read(data: any, opts?: IParsingOptions): IWorkBook;
}
declare namespace Stimulsoft.Base.Design {
    var IStiDefault: string;
    interface IStiDefault {
        isDefault: boolean;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    enum StiCheckState {
        Unchecked = 1,
        Checked = 2,
        Indeterminate = 3
    }
    /**
     *  Actions, which indicate actions in the rectangle.
     */
    enum StiAction {
        /**
         *  No action.
         */
        None = 0,
        /**
         *  Move.
         */
        Move = 1,
        /**
         *  Select.
         */
        Select = 2,
        /**
         *  Left side.
         */
        SizeLeft = 3,
        /**
         *  Right side.
         */
        SizeRight = 4,
        /**
         *  Top side.
         */
        SizeTop = 5,
        /**
         *  Bottom side.
         */
        SizeBottom = 6,
        /**
         *  Left top side.
         */
        SizeLeftTop = 7,
        /**
         *  Left bottom side.
         */
        SizeLeftBottom = 8,
        /**
         *  Right top side.
         */
        SizeRightTop = 9,
        /**
         *  Right bottom side.
         */
        SizeRightBottom = 10,
        /**
         *  Resize columns.
         */
        ResizeColumns = 11,
        /**
         *  Resize rows.
         */
        ResizeRows = 12,
        /**
         *  SelectColumn
         */
        SelectColumn = 13,
        /**
         *  SelectRow
         */
        SelectRow = 14
    }
    /**
     *  Sides of the border.
     */
    enum StiBorderSides {
        /**
         *  No border.
         */
        None = 0,
        /**
         *  Border from all sides.
         */
        All = 15,
        /**
         *  Border on the top.
         */
        Top = 1,
        /**
         *  Border on the left.
         */
        Left = 2,
        /**
         *  Border on the right.
         */
        Right = 4,
        /**
         *  Border on the bottom.
         */
        Bottom = 8
    }
    enum StiPenStyle {
        /**
         *  Solid line.
         */
        Solid = 0,
        /**
         *  Dotted line.
         */
        Dash = 1,
        /**
         *  Dash-dotted line.
         */
        DashDot = 2,
        /**
         *  Dotted-dash-dash line.
         */
        DashDotDot = 3,
        /**
         *  Dotted line.
         */
        Dot = 4,
        /**
         *  Double line.
         */
        Double = 5,
        /**
         *  No.
         */
        None = 6
    }
    enum StiRotationMode {
        LeftTop = 0,
        LeftCenter = 1,
        LeftBottom = 2,
        CenterTop = 3,
        CenterCenter = 4,
        CenterBottom = 5,
        RightTop = 6,
        RightCenter = 7,
        RightBottom = 8
    }
    enum StiShadowSides {
        Top = 1,
        Right = 2,
        Edge = 4,
        Bottom = 8,
        Left = 16,
        All = 31
    }
    /**
     *  Vertical alignment of an object.
     */
    enum StiVertAlignment {
        /**
         *  Align top.
         */
        Top = 0,
        /**
         *  Align center.
         */
        Center = 1,
        /**
         *  Align bottom.
         */
        Bottom = 2
    }
    /**
     *  Horizontal alignment of a text.
     */
    enum StiTextHorAlignment {
        /**
         *  Align left.
         */
        Left = 0,
        /**
         *  Align center.
         */
        Center = 1,
        /**
         *  Align right.
         */
        Right = 2,
        /**
         *  Align width.
         */
        Width = 3
    }
    /**
     *  Horizontal alignment of an object.
     */
    enum StiHorAlignment {
        /**
         *  Align left.
         */
        Left = 1,
        /**
         *  Align center.
         */
        Center = 2,
        /**
         *  Align right.
         */
        Right = 3
    }
    enum StiTextDockMode {
        Top = 0,
        Bottom = 1,
        Left = 2,
        Right = 3
    }
    enum StiBrushIdent {
        Empty = 1,
        Solid = 2,
        Gradient = 3,
        Glare = 4,
        Glass = 5,
        Hatch = 6
    }
    enum StiBorderIdent {
        Border = 1,
        AdvancedBorder = 2
    }
    enum StiCapStyle {
        None = 0,
        Arrow = 1,
        Open = 2,
        Stealth = 3,
        Diamond = 4,
        Square = 5,
        Oval = 6
    }
}
declare module Stimulsoft.Base.Drawing {
    var PointD: typeof System.Drawing.Point;
}
declare module Stimulsoft.Base.Drawing {
    var RectangleD: typeof System.Drawing.Rectangle;
}
declare module Stimulsoft.Base.Drawing {
    var SizeD: typeof System.Drawing.Size;
}
declare module Stimulsoft.Base.Drawing {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiActionUtils {
        static pointInEdge(x: number, y: number, point: Point, size: number): boolean;
        static pointInRect(x: number, y: number, rect: Rectangle): boolean;
    }
}
declare module Stimulsoft.Base.Drawing {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiBrush implements ICloneable {
        implements(): string[];
        clone(): StiBrush;
        stiEquals(obj: Object): boolean;
        static convertToBrush(text: string): StiBrush;
        static loadFromXml(text: string): StiBrush;
        static light(baseBrush: StiBrush, value: number): StiBrush;
        static dark(baseBrush: StiBrush, value: number): StiBrush;
        static getBrush(brush: StiBrush, rect: Rectangle): Brush;
        static toColor(brush: StiBrush): Color;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSolidBrush extends StiBrush {
        private _color;
        color: Color;
        constructor(color?: Color);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiBorder implements ICloneable {
        implements(): string[];
        private bits;
        /** Creates a new object that is a copy of the current instance. */
        clone(): StiBorder;
        stiEquals(other: StiBorder): boolean;
        stiEquals(obj: Object): boolean;
        getSizeOffset(): number;
        getHashCode(): number;
        private defaultHashCode;
        getSizeIncludingSide(): number;
        draw(g: Graphics, rect: Rectangle, zoom: number, emptyColor?: Color, drawBorderFormatting?: boolean, drawBorderSides?: boolean): void;
        drawBorderShadow(g: Graphics, rect: Rectangle, zoom: number): void;
        /** Gets value which indicates that top side of border is present. */
        readonly isTopBorderSidePresent: boolean;
        /** Gets value which indicates that bottom side of border is present. */
        readonly isBottomBorderSidePresent: boolean;
        /** Gets value which indicates that left side of border is present. */
        readonly isLeftBorderSidePresent: boolean;
        /** Gets value which indicates that right side of border is present. */
        readonly isRightBorderSidePresent: boolean;
        /** Gets value which indicates that all sides of border is present. */
        readonly isAllBorderSidesPresent: boolean;
        private readonly isDefaultShadowBrush;
        /** Gets or sets frame borders. */
        side: StiBorderSides;
        /** Gets or sets a border color. */
        color: Color;
        /** Gets or sets a border size. */
        size: number;
        /** Gets or sets a border style. */
        style: StiPenStyle;
        private _shadowBrush;
        /** Gets or sets the border shadow brush. */
        shadowBrush: StiBrush;
        /** Gets or sets Shadow Size. */
        shadowSize: StiPenStyle;
        /** Gets or sets value which indicates drop shadow or not. */
        dropShadow: boolean;
        /** Gets or sets value which indicates that border sides will be drawn on top of all components. */
        topmost: boolean;
        /** Gets value indicates, that this object-frame is by default. */
        readonly isDefault: boolean;
        static loadFromXml(text: string): StiBorder;
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAdvancedBorder extends StiBorder {
        /** Creates a new object that is a copy of the current instance. */
        clone(): StiAdvancedBorder;
        stiEquals(other: StiAdvancedBorder): boolean;
        stiEquals(obj: Object): boolean;
        getHashCode(): number;
        private _leftSide;
        /** Gets or sets frame of left side. */
        readonly leftSide: StiBorderSide;
        private _rightSide;
        /** Gets or sets frame of right side. */
        readonly rightSide: StiBorderSide;
        private _topSide;
        /** Gets or sets frame of top side. */
        readonly topSide: StiBorderSide;
        private _bottomSide;
        /** Gets or sets frame of bottom side. */
        readonly bottomSide: StiBorderSide;
        /** Gets value which indicates that top side of border is present. */
        readonly isTopBorderSidePresent: boolean;
        /** Gets value which indicates that bottom side of border is present. */
        readonly isBottomBorderSidePresent: boolean;
        /** Gets value which indicates that left side of border is present. */
        readonly isLeftBorderSidePresent: boolean;
        /** Gets value which indicates that right side of border is present. */
        readonly isRightBorderSidePresent: boolean;
        /** Gets value which indicates that all sides of border is present. */
        readonly isAllBorderSidesPresent: boolean;
        /** Gets or sets frame borders. Not used in StiAdvancedBorder. */
        side: StiBorderSides;
        /** Gets or sets a border color. Not used in StiAdvancedBorder. */
        color: Color;
        /** Gets or sets a border size. Not used in StiAdvancedBorder. */
        size: number;
        /** Gets or sets a border style. Not used in StiAdvancedBorder. */
        style: StiPenStyle;
        /** Gets value indicates, that this object-frame is by default. */
        readonly isDefault: boolean;
        constructor(topSide?: StiBorderSide, bottomSide?: StiBorderSide, leftSide?: StiBorderSide, rightSide?: StiBorderSide, dropShadow?: boolean, shadowSize?: number, shadowBrush?: StiBrush, topmost?: boolean);
    }
}
declare module Stimulsoft.Base.Drawing {
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBorderSide implements ICloneable {
        implements(): string[];
        /** Creates a new object that is a copy of the current instance. */
        clone(): StiBorderSide;
        stiEquals(other: StiBorderSide): boolean;
        stiEquals(obj: Object): boolean;
        getHashCode(): number;
        getSizeOffset(): number;
        side: StiBorderSides;
        private _color;
        /** Gets or sets a border color. */
        color: Color;
        private _size;
        /** Gets or sets a border size. */
        size: number;
        private _style;
        /** Gets or sets a border style. */
        style: StiPenStyle;
        /** Gets value indicates, that this object-frame is by default. */
        readonly isDefault: boolean;
        /** Creates a new instance of the StiBorderSide class. */
        constructor(color?: Color, size?: number, style?: StiPenStyle);
    }
}
declare module Stimulsoft.Base.Drawing {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCap implements ICloneable {
        implements(): string[];
        clone(): StiCap;
        private _width;
        width: number;
        private _style;
        style: StiCapStyle;
        private _height;
        height: number;
        private _fill;
        fill: boolean;
        private _color;
        color: Color;
        loadFromXml(xmlNode: XmlNode): void;
        constructor(width?: number, style?: StiCapStyle, height?: number, fill?: boolean, color?: Color);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiColorUtils {
        static changeLightness(color: Color, correctionFactor: number): Color;
        static light(baseColor: Color, value: number): Color;
        static mixingColors(color1: Color, color2: Color, alpha: number): Color;
        static dark(baseColor: Color, value: number): Color;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawing {
        static fillRectangle(g: Graphics, brush: Brush, arg: number | Rectangle, y?: number, width?: number, height?: number): void;
    }
}
declare module Stimulsoft.Base.Drawing {
    class StiEmptyBrush extends StiBrush {
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontUtils {
        static correctStyle(fontName: string, style: FontStyle): FontStyle;
        static changeFontName(font: Font, newFontName: string): Font;
        static changeFontSize(font: Font, newFontSize: number): Font;
        static changeFontStyle(font: Font, style: FontStyle): Font;
        static changeFontStyle2(fontName: string, fontSize: number, style: FontStyle): Font;
        static changeFontStyleBold(font: Font, bold: boolean): Font;
        static changeFontStyleItalic(font: Font, italic: boolean): Font;
        static changeFontStyleUnderline(font: Font, underline: boolean): Font;
        static changeFontStyleStrikeout(font: Font, strikeout: boolean): Font;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGlareBrush extends StiBrush {
        private _startColor;
        /** Gets or sets the starting color for the gradient. */
        startColor: Color;
        private _endColor;
        /** Gets or sets the ending color for the gradient. */
        endColor: Color;
        private _angle;
        /** Gets or sets the angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line. */
        angle: number;
        private _focus;
        /** Gets or sets value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color). */
        focus: number;
        private _scale;
        /** Gets or sets value from 0 through 1 that specifies how fast the colors falloff from the focus. */
        scale: number;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number, focus?: number, scale?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiGlassBrush extends StiBrush {
        private _color;
        /** Gets or sets the color of this StiGlassBrush object. */
        color: Color;
        private _drawHatch;
        /** Gets or sets value which indicates draw hatch at background or not. */
        drawHatch: boolean;
        private _blend;
        /** Gets or sets blend factor. */
        blend: number;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        getTopColor(): Color;
        getTopColorLight(): Color;
        getBottomColor(): Color;
        getBottomColorLight(): Color;
        getTopRectangle(rect: Rectangle): Rectangle;
        getBottomRectangle(rect: Rectangle): Rectangle;
        constructor(color?: Color, drawHatch?: boolean, blend?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGradientBrush extends StiBrush {
        private _startColor;
        /** Gets or sets the starting color for the gradient. */
        startColor: Color;
        private _endColor;
        /** Gets or sets the ending color for the gradient. */
        endColor: Color;
        private _angle;
        /** Gets or sets the angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line. */
        angle: number;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(startColor?: Color, endColor?: Color, angle?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    import HatchStyle = Stimulsoft.System.Drawing.Drawing2D.HatchStyle;
    class StiHatchBrush extends StiBrush {
        private _backColor;
        /** Gets the color of spaces between the hatch lines drawn by this StiHatchBrush object. */
        backColor: Color;
        private _foreColor;
        /** Gets the color of hatch lines drawn by this StiHatchBrush object. */
        foreColor: Color;
        private _style;
        /** Gets the hatch style of this StiHatchBrush object. */
        style: HatchStyle;
        stiEquals(obj: Object): boolean;
        private defaultHashCode;
        getHashCode(): number;
        constructor(style?: HatchStyle, foreColor?: Color, backColor?: Color);
    }
}
declare module Stimulsoft.Base.Drawing {
    import ImageCodecInfo = Stimulsoft.System.Drawing.Imaging.ImageCodecInfo;
    class StiImageCodecInfo {
        static getImageCodec(mimeType: string): ImageCodecInfo;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageConverter {
        static imageToString(image: Image): string;
        static bytesToImage(bytes: number[]): Image;
        static stringToImage(str: string): Image;
    }
}
declare module Stimulsoft.Base.Drawing {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageFromURL {
        static loadBitmap(url: string): Image;
        static loadImage(url: string): Image;
    }
}
declare module Stimulsoft.Base.Drawing {
    import DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
    class StiPenUtils {
        static getPenStyle(penStyle: StiPenStyle): DashStyle;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    /**
     *  Class describes a border.
     */
    class StiSimpleBorder implements ICloneable, IStiJsonReportObject {
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        getBorder(): StiBorder;
        getSizeOffset(): number;
        getSize(): number;
        getSizeIncludingSide(): number;
        /**
         *  Gets value which indicates that top side of border is present.
         */
        readonly isTopBorderSidePresent: boolean;
        /**
         *  Gets value which indicates that bottom side of border is present.
         */
        readonly isBottomBorderSidePresent: boolean;
        /**
         *  Gets value which indicates that left side of border is present.
         */
        readonly isLeftBorderSidePresent: boolean;
        /**
         *  Gets value which indicates that right side of border is present.
         */
        readonly isRightBorderSidePresent: boolean;
        /**
         *  Gets value which indicates that all sides of border is present.
         */
        readonly isAllBorderSidesPresent: boolean;
        /**
         *  Gets or sets frame borders.
         */
        side: StiBorderSides;
        /**
         *  Gets or sets a border color.
         */
        color: Color;
        private shouldSerializeColor;
        /**
         *  Gets or sets a border size.
         */
        size: number;
        /**
         *  Gets or sets a border style.
         */
        style: StiPenStyle;
        /**
         *  Gets value indicates, that this object-frame is by default.
         */
        readonly isDefault: boolean;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         *  Creates a new instance of the StiBorder class.
         *  @param side Border sides.
         *  @param color Border color.
         *  @param size Border size.
         *  @param style Border style.
         */
        constructor(side?: StiBorderSides, color?: Color, size?: number, style?: StiPenStyle);
    }
}
declare module Stimulsoft.Base.Drawing {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import List = Stimulsoft.System.Collections.List;
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    class StiTextDrawing {
        static measureString(g: Graphics, text: string, font: Font, width?: number, textOptions?: StiTextOptions, ha?: StiTextHorAlignment, va?: StiVertAlignment, antialiasing?: boolean): Size;
        static splitTextWordwrap(text: string, g: Graphics, font: Font, rect: Rectangle, textOptions: StiTextOptions, ha: StiTextHorAlignment, typographic: boolean): List<LineInfo>;
        static splitTextWordwrap2(text: string, g: Graphics, font: Font, rect: Rectangle, sf: StringFormat, horAlignWidth?: boolean): List<LineInfo>;
        private static makeLineInfo;
        static splitString(inputString: string, removeControl: boolean): List<string>;
        static getStringFormat(textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, zoom: number): StringFormat;
        static getAlignment(alignment: StiTextHorAlignment): StringAlignment;
        static getAlignment2(alignment: StiVertAlignment): StringAlignment;
        static getStringFormat2(textOptions: StiTextOptions, ha: StiTextHorAlignment, va: StiVertAlignment, antialiasing: boolean, zoom: number): StringFormat;
        /**
         *  Gets or sets value which indicates that text drawing engine will be measure text string including trailing spaces.
         */
        static measureTrailingSpaces: boolean;
    }
}
declare module Stimulsoft.Base {
    import DateTime = Stimulsoft.System.DateTime;
    class StiJson {
        static prettyPrint: boolean;
        static dateToJsonDate(date: DateTime): string;
        static jsonDateFormatToDate(jsonDate: string): DateTime;
        name: string;
        value: any;
        private isProperty;
        private isArray;
        properties(): StiJson[];
        removeProperty(propertyName: string): void;
        addPropertyNumber(propertyName: string, value: number, defaultValue?: number): void;
        addPropertyNumberNoDefaultValue(propertyName: string, value: number): void;
        addPropertyJObject(propertyName: string, value: StiJson): void;
        addPropertyJObjectArray(propertyName: string, values: StiJson[]): void;
        addPropertyIdent(propertyName: string, value: string): void;
        addPropertyBool(propertyName: string, value: boolean, defaultValue?: boolean): void;
        addPropertyDateTime(propertyName: string, value: DateTime): void;
        addPropertyEnum(propertyName: string, enumType: Object, value: any, defaultValue?: any): void;
        addPropertyString(propertyName: string, value: string, defaultValue?: string): void;
        addPropertyStringNullOrEmpty(propertyName: string, value: string): void;
        readonly count: number;
        serialize(indent?: number): string;
        deserialize(text: any): void;
        private deserializeFromObject;
        toString(): string;
        constructor(name?: string, value?: any, isProperty?: boolean);
    }
}
declare module Stimulsoft.Base.JsonReportObject {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    var IStiJsonReportObject: string;
    interface IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
declare module Stimulsoft.Base.Drawing {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTextOptions implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(str: string): StiTextOptions;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTextOptions;
        private bits;
        getStringFormat(antialiasing?: boolean, zoom?: number): StringFormat;
        rightToLeft: boolean;
        lineLimit: boolean;
        private _wordWrap;
        wordWrap: boolean;
        angle: number;
        firstTabOffset: number;
        distanceBetweenTabs: number;
        hotkeyPrefix: HotkeyPrefix;
        trimming: StringTrimming;
        readonly isDefault: boolean;
        /** Serves as a hash function for a particular type. */
        getHashCode(): number;
        constructor(rightToLeft?: boolean, lineLimit?: boolean, wordWrap?: boolean, angle?: number, hotkeyPrefix?: HotkeyPrefix, trimming?: StringTrimming, firstTabOffset?: number, distanceBetweenTabs?: number);
    }
}
declare module Stimulsoft.Base.Drawing {
    import List = Stimulsoft.System.Collections.List;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    class StiTextRenderer {
        private static precisionDigits;
        static precisionModeFactor: number;
        static precisionModeEnabled: boolean;
        static correctionEnabled: boolean;
        static maxFontSize: number;
        static compatibility2009: boolean;
        static optimizeBottomMargin: boolean;
        private static hashFonts;
        private static getTabsWidth;
        private static getFontIndex;
        private static getFontIndex2;
        private static htmlNameToColor;
        static interpreteFontSizeInHtmlTagsAsInHtml: boolean;
        private static _htmlEscapeSequence;
        private static readonly htmlEscapeSequence;
        private static convertStringToTag;
        static parseHtmlToStates(inputHtml: string, baseState: StiHtmlState, storeStack?: boolean): Array<StiHtmlState>;
        static prepareStateText(stateText: StringBuilder): StringBuilder;
        private static stateToHtml;
        private static getIndentString;
        private static bulletBlack;
        private static bulletWhite;
        private static insertMarker;
        private static stackToString;
        private static listLevelsToString;
        private static parseHtmlTag;
        private static parseTagIntoPairs;
        private static parseMarkerTypeAttribute;
        private static parseStyleAttribute;
        private static stringToListLevels;
        private static stringToStack;
        private static parseFontSize;
        private static parseColor;
        static measureString(maxWidth: number, font: Font, text: string, angle?: number): Size;
        static getTextLinesAndWidths(g: Graphics, REFtext: any, font: Font, bounds: Rectangle, lineSpacing: number, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, allowHtmlTags: boolean, REFtextLines: any, REFlinesInfo: any): string[];
        static drawTextForOutput(g: Graphics, text: string, font: Font, bounds: Rectangle, foreColor: Color, backColor: Color, lineSpacing: number, horAlign: StiTextHorAlignment, vertAlign: StiVertAlignment, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, lineLimit: boolean, allowHtmlTags: boolean, outRunsList: List<RunInfo>, outFontsList: List<StiFontState>, textOptions: StiTextOptions): void;
        static measureText(g: Graphics, text: string, font: Font, bounds: Rectangle, lineSpacing: number, wordWrap: boolean, rightToLeft: boolean, scale: number, angle: number, trimming: StringTrimming, lineLimit: boolean, allowHtmlTags: boolean, textOptions: StiTextOptions): Size;
        private static drawTextBase;
        private static drawTextBase2;
        static StiForceWidthAlignTag: string;
        private static getFontWidth;
        private static getFontWidth2;
        private static isWordWrapSymbol2;
        private static isNotWordWrapSymbol;
        private static isNotWordWrapSymbol2;
        private static isCJKWordWrap;
        private static isCJKSymbol;
    }
    class StiFontState {
        fontName: string;
        fontBase: Font;
        fontScaled: Font;
        superOrSubscriptIndex: number;
        parentFontIndex: number;
        hFont: number;
        hFontScaled: number;
        hScriptCache: number;
        hScriptCacheScaled: number;
        lineHeight: number;
        ascend: number;
        descend: number;
        elipsisWidth: number;
        emValue: number;
        private _fontNameReal;
        readonly fontNameReal: string;
    }
    class LineInfo {
        begin: number;
        length: number;
        needWidthAlign: boolean;
        end: number;
        width: number;
        widths: number[];
        justifyOffset: number;
        text: string;
        indexOfMaxFont: number;
        lineHeight: number;
        textAlignment: StiTextHorAlignment;
        indent: number;
    }
    class RunInfo {
        text: string;
        xPos: number;
        yPos: number;
        widths: number[];
        glyphWidths: number[];
        textColor: Color;
        backColor: Color;
        fontIndex: number;
        glyphIndexList: number[];
        scaleList: number[];
        href: string;
    }
    enum StiHtmlTag {
        None = 0,
        B = 1,
        I = 2,
        U = 3,
        S = 4,
        Sup = 5,
        Sub = 6,
        Font = 7,
        FontName = 8,
        FontSize = 9,
        FontColor = 10,
        Backcolor = 11,
        LetterSpacing = 12,
        WordSpacing = 13,
        LineHeight = 14,
        TextAlign = 15,
        P = 16,
        Br = 17,
        OrderedList = 18,
        UnorderedList = 19,
        ListItem = 20,
        A = 21,
        Unknown = 22
    }
    enum StiHtmlTag2State {
        Start = 0,
        End = 1,
        Empty = 2
    }
    class StiHtmlTag2 {
        tag: StiHtmlTag;
        tagName: string;
        attributes: List<TagPair>;
        state: StiHtmlTag2State;
        readonly isStart: boolean;
        readonly isEnd: boolean;
        readonly isEmpty: boolean;
        isStartTag(tag: StiHtmlTag): boolean;
        isEndTag(tag: StiHtmlTag): boolean;
        equals(tag2: StiHtmlTag2): boolean;
        toString(): string;
        constructor(tag?: StiHtmlTag, state?: StiHtmlTag2State);
    }
    class StiHtmlTagsState {
        clone(): StiHtmlTagsState;
        bold: boolean;
        italic: boolean;
        underline: boolean;
        strikeout: boolean;
        fontSize: number;
        fontName: string;
        fontColor: Color;
        backColor: Color;
        subsript: boolean;
        superscript: boolean;
        letterSpacing: number;
        wordSpacing: number;
        lineHeight: number;
        textAlign: StiTextHorAlignment;
        isColorChanged: boolean;
        isBackcolorChanged: boolean;
        tag: StiHtmlTag2;
        indent: number;
        htmlStyle: string;
        href: string;
        constructor(bold: any, italic?: boolean, underline?: boolean, strikeout?: boolean, fontSize?: number, fontName?: string, fontColor?: Color, backColor?: Color, superscript?: boolean, subscript?: boolean, letterSpacing?: number, wordSpacing?: number, lineHeight?: number, textAlign?: StiTextHorAlignment);
    }
    class StiHtmlState {
        clone(): StiHtmlState;
        ts: StiHtmlTagsState;
        text: StringBuilder;
        fontIndex: number;
        posBegin: number;
        tagsStack: Array<StiHtmlTagsState>;
        listLevels: Array<number>;
        toString(): string;
        constructor(ts: any, posBegin?: number);
    }
    class TagPair {
        key: string;
        keyBase: string;
        value: string;
    }
}
declare module Stimulsoft.Base {
    enum StiPlanIdent {
        OnlineTrial = 100,
        OnlineStandard = 101,
        ServerTrial = 200,
        ServerTeam5 = 201,
        ServerTeam10 = 202,
        ServerTeam25 = 203,
        ServerTeam50 = 204,
        ServerBusiness = 205,
        ServerEnterprise = 206,
        ServerWorldWide = 207,
        Test = 300
    }
    enum StiPlanFeatureIdent {
        Cycles = 1
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    enum DateTimeFormat {
        USA_DATE = 0,
        UK_DATE = 1
    }
    class ParsedDateTime {
        readonly indexOfDate: number;
        readonly lengthOfDate: number;
        readonly indexOfTime: number;
        readonly lengthOfTime: number;
        readonly dateTime: DateTime;
        readonly isDateFound: boolean;
        readonly isTimeFound: boolean;
        readonly utcOffset: TimeSpan;
        readonly isUtcOffsetFound: boolean;
        utcDateTime: DateTime;
        constructor(indexOfDate: number, lengthOfDate: number, indexOfTime: number, lengthOfTime: number, dateTime: DateTime, utcOffset?: TimeSpan);
    }
    class DateTimeRoutines {
        private static _defaultDate;
        static defaultDate: DateTime;
        static defaultDateIsNow: boolean;
        static tryParseDateTime(str: string, defaultFormat: DateTimeFormat, refDateTime: {
            ref: DateTime;
        }): boolean;
        static tryParseDateTime2(str: string, defaultFormat: DateTimeFormat, refParsedDateTime: {
            ref: ParsedDateTime;
        }): boolean;
        static tryParseDateOrTime2(str: string, defaultFormat: DateTimeFormat, refParsedDateTime: {
            ref: ParsedDateTime;
        }): boolean;
        static tryParseTime2(str: string, defaultFormat: DateTimeFormat, refParsedTime: {
            ref: ParsedDateTime;
        }, parsedDate: ParsedDateTime): boolean;
        static tryParseDate2(str: string, defaultFormat: DateTimeFormat, refParsedDate: {
            ref: ParsedDateTime;
        }): boolean;
        private static tryParseDateInternal;
        private static convertToDate;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiBingMapHelper {
        static BingKey: string;
        private static Script;
        static getImage(size: Size, pushPins?: []): Object;
        static getScript(mapData: Hashtable): string;
        private static getCacheKey;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    class StiComponentProgressHelper {
        progressDelta: number;
        timerInterval: number;
        private static lockCompletedProgressHandler;
        static currentValue: number;
        static add(comp: IStiAppComponent): void;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiOnlineMapRepaintHelper {
        timerInterval: number;
        browserLifetime: number;
        static init(): void;
        static fetchAllComponents(report: IStiReport): List<IStiAppComponent>;
        static clean(reportKey: string): void;
    }
}
declare module Stimulsoft.Base {
    class StiPacker {
        private static encryptedId;
        static allowPacking: boolean;
        static pack(bytes: number[]): number[];
        static unpack(bytes: number[]): number[];
        static packAndEncrypt(bytes: number[], encryptedId: string): number[];
        static unpackAndDecrypt(bytes: number[], encryptedId: string): number[];
        static packAndEncryptToString(bytes: number[]): string;
        static unpackAndDecrypt2(str: string): number[];
        static packToString(bytes: number[]): string;
        static unpackFromString(str: string): number[];
        static packToBytes(str: string, allowPacking?: boolean): number[];
        static unpackToString(bytes: number[]): string;
        private static addZipSignature;
        static isPacked(bytes: number[]): boolean;
        private static isPacked2;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    class StiValueComparer {
        static equalValues(value1: any, value2: any): boolean;
        static compareArrays(a: any[], b: any[]): boolean;
    }
}
declare namespace Stimulsoft.Base.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiValueHelper {
        static isZero(value: any): boolean;
        static equalDecimal(value1: any, value2: any): boolean;
        static tryToString(value: any): string;
        static tryToNumber(value: any): number;
        static tryToBool(value: any): boolean;
        static tryToDateTime(value: any): DateTime;
        static tryToTimeSpan(value: any): TimeSpan;
        static tryToNullableNumber(value: any): number | null;
        static tryToNullableDateTime(value: any): DateTime | null;
        static tryToNullableTimeSpan(value: any): TimeSpan | null;
        static parseNumber(value: string): number;
        private static normalizeFloatingPointValue;
    }
}
declare module Stimulsoft.Base {
    enum StiJsonSaveMode {
        Report = 0,
        Document = 1
    }
}
declare module Stimulsoft.Base.StiJsonReportObjectHelper {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    class Serialize {
        static fontArial8(font: Font): string;
        static font(font: Font, defaultFamily?: string, defaultEmSize?: number, defaultStyle?: FontStyle, defaultUnit?: GraphicsUnit): string;
        static rectangleD(rect: Rectangle): string;
        static sizeD(size: Size | Size): string;
        static jColor(color: Color, defColor?: Color): string;
        static colorArray(array: Color[]): StiJson;
        static stringArray(array: string[]): StiJson;
        static numberArray(array: number[]): StiJson;
        static objectArray(list: IStiJsonReportObject[], mode: StiJsonSaveMode): StiJson;
        static size(size: Size): StiJson;
        static point(pos: Point): StiJson;
        static jCap(cap: StiCap): string;
        static jBrush(brush: StiBrush, defaultBrush?: StiBrush): string;
        static jBorderSide(side: StiBorderSide): string;
        static jBorder(border: StiBorder): string;
        static jBorder2(border: StiSimpleBorder): string;
    }
    class Deserialize {
        static stringArray(jObject: StiJson): string[];
        static numberArray(jObject: StiJson): number[];
        static font(text: string, defaultFont: Font): Font;
        static jBorderSide(text: string): StiBorderSide;
        static jCap(text: string): StiCap;
        static border(text: string): StiBorder;
        static simpleBorder(text: string): StiSimpleBorder;
        static color(value: string): Color;
        static brush(text: string): StiBrush;
        static colorArray(jObject: StiJson): Color[];
        static size(jObject: StiJson): Size;
        static rectangleD(text: string): Rectangle;
        static sizeD(text: string): Size;
        static point(jObject: StiJson): Point;
    }
}
declare module Stimulsoft.Base {
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    class StiJsonToDataSetConverter {
        static getDataSet(str: string, jsonRelationDirection: JsonRelationDirection): any;
        static getDataSet(data: number[], jsonRelationDirection: JsonRelationDirection): any;
        static getDataSet(obj: Object, jsonRelationDirection: JsonRelationDirection): any;
    }
}
declare module Stimulsoft.Base.Licenses {
    enum StiProductIdent {
        Ultimate = 1,
        Net = 2,
        Wpf = 3,
        Web = 4,
        Silverlight = 5,
        Js = 6,
        Java = 7,
        Php = 8,
        NetCore = 9,
        Uwp = 10,
        Flex = 11,
        BI = 12,
        Desktop = 12,
        DbsJs = 13,
        DbsWin = 14,
        DbsWeb = 15
    }
    enum StiActivationType {
        Server = 1,
        Developer = 2
    }
}
/**
 * @hidden
 */
declare module Stimulsoft.Base.Licenses {
    class StiCryptHelper {
        static decrypt(str: string, password: string): string;
        static encrypt(str: string, password?: string): string;
        static recrypt(str: string, oldPassword: string, newPassword: string): string;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiRsaPublicKey {
        static getKey(): any;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiLicenseObject {
        encryptKey: string;
        loadFromString(str: string): void;
        saveToString(): string;
        loadFromBytes(bytes: number[]): void;
        decryptFromBytes(bytes: number[]): void;
        decryptFromString(str: string): void;
    }
}
declare module Stimulsoft.Base.Licenses {
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseKey extends StiLicenseObject {
        activationDate: DateTime;
        signature: string;
        owner: string;
        userName: string;
        startDate: DateTime;
        endDate: DateTime;
        seviceId: string;
        planId: StiPlanIdent;
        products: StiLicenseProduct[];
        productName: string;
        productLogo: number[];
        productFavIcon: number[];
        productDescription: string;
        productUrl: string;
        clone(): StiLicenseKey;
        readonly isServerLicense: boolean;
        readonly isProductLicense: boolean;
        static get1(bytes: number[]): StiLicenseKey;
        static get2(str: string): StiLicenseKey;
        constructor();
    }
}
declare module Stimulsoft.Base {
    import StiLicenseKey = Stimulsoft.Base.Licenses.StiLicenseKey;
    class StiLicense {
        static licenseKey: StiLicenseKey;
        private static _key;
        static key: string;
        static Key: string;
        /**
         * @hidden
         */
        static setNewLicenseKey(value: string, throwException?: boolean): void;
        private static isValidLicenseKey;
        static loadFromFile(file: string): void;
        static loadFromString(licenseKey: string): void;
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiLicenseActivationResponse extends StiLicenseObject {
        encryptKey: string;
        licenseKey: StiLicenseKey;
        exception: string;
        resultSuccess: boolean;
        resultNotice: StiNotice;
    }
}
declare module Stimulsoft.Base {
    class StiKeyObject {
        key: string;
        isStored: string;
        constructor();
    }
}
declare module Stimulsoft.Base.Licenses {
    class StiLicenseKeyContainer extends StiKeyObject {
        checkSum: string;
        license: number[];
    }
}
declare module Stimulsoft.Base.Licenses {
    import StiProductIdent = Stimulsoft.Base.Licenses.StiProductIdent;
    class StiLicenseKeyValidator {
        private static indexValidator;
        static isValid(ident: StiProductIdent): boolean;
        static isValidOnDbsJS(): boolean;
        static isValidOnJS(): boolean;
        static isValidOnAnyPlatform(): boolean;
        static isValidOnBI(): boolean;
        private static isJSPlatform;
        private static isDbsJSPlatform;
        private static isBIPlatform;
        private static getLicenseKey;
    }
}
declare module Stimulsoft.Base.Licenses {
    import DateTime = Stimulsoft.System.DateTime;
    class StiLicenseProduct {
        expirationDate: DateTime;
        ident: StiProductIdent;
    }
}
declare module Stimulsoft.Base.Localization {
    class StiLocalization {
        static languages: any;
        static English: any;
        static setLocalization(localizationXml: string, onlyThis?: boolean): void;
        private static _cultureName;
        static cultureName: string;
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static getJsonStringLocalization(): string;
        static loadLocalization(localizationXml: any, extension?: boolean): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal;
        static get(category: string, key: string): string;
    }
}
declare namespace Stimulsoft.Base.Map {
    var IStiMapKeyHelper: string;
    interface IStiMapKeyHelper {
        getIsoAlpha2FromName(country: string, mapId: string): string;
        getIsoAlpha3FromName(country: string, mapId: string): string;
        getNameFromIsoAlpha2(alpha3: string, mapId: string): string;
        getNameFromIsoAlpha3(alpha3: string, mapId: string): string;
        normalizeName(name: string, mapId: string): string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiArgumentMeter: string;
    interface IStiArgumentMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiColorMapMeter: string;
    interface IStiColorMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiColorScaleColumn: string;
    interface IStiColorScaleColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiDataBarsColumn: string;
    interface IStiDataBarsColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiDimensionColumn: string;
    interface IStiDimensionColumn {
        showHyperlink: boolean;
        hyperlinkPattern: string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiDimensionMeter: string;
    interface IStiDimensionMeter extends IStiMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiGroupMapMeter: string;
    interface IStiGroupMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiIndicatorColumn: string;
    interface IStiIndicatorColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiKeyMapMeter: string;
    interface IStiKeyMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiLocalizedMeter: string;
    interface IStiLocalizedMeter {
        localizedName: string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiMeasureColumn: string;
    interface IStiMeasureColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiMeasureMeter: string;
    interface IStiMeasureMeter extends IStiMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiMeter: string;
    interface IStiMeter {
        getUniqueCode(): number;
        key: string;
        expression: string;
        label: string;
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiNameMapMeter: string;
    interface IStiNameMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiPivotColumn: string;
    interface IStiPivotColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiPivotRow: string;
    interface IStiPivotRow {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiPivotSummary: string;
    interface IStiPivotSummary {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiSeriesMeter: string;
    interface IStiSeriesMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiSparklinesColumn: string;
    interface IStiSparklinesColumn {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiTableColumn: string;
    interface IStiTableColumn {
        visible: boolean;
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiTargetMeter: string;
    interface IStiTargetMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiValueMapMeter: string;
    interface IStiValueMapMeter {
    }
}
declare namespace Stimulsoft.Base.Meters {
    var IStiValueMeter: string;
    interface IStiValueMeter {
    }
}
declare module Stimulsoft.Base {
    enum StiNoticeIdent {
        ActivationMaxActivationsReached = 1,
        ActivationExpiriedBeforeFirstRelease = 2,
        ActivationLicenseIsNotCorrect = 3,
        ActivationLockedAccount = 4,
        ActivationServerVersionNotAllowed = 5,
        ActivationServerIsNotAvailableNow = 6,
        ActivationSomeTroublesOccurred = 7,
        ActivationUserNameOrPasswordIsWrong = 8,
        ActivationWrongAccountType = 9,
        AuthAccountCantBeUsedNow = 10,
        AuthAccountIsNotActivated = 11,
        AuthCantChangeSystemRole = 12,
        AuthCantChangeRoleBecauseLastAdministratorUser = 13,
        AuthCantChangeRoleBecauseLastSupervisorUser = 14,
        AuthCantDeleteHimselfUser = 15,
        AuthCantDeleteLastAdministratorUser = 16,
        AuthCantDeleteLastSupervisorUser = 17,
        AuthCantDeleteSystemRole = 18,
        AuthCantDisableUserBecauseLastAdministratorUser = 19,
        AuthCantDisableUserBecauseLastSupervisorUser = 20,
        AuthOAuthIdNotSpecified = 21,
        AuthPasswordIsTooShort = 22,
        AuthPasswordIsNotSpecified = 23,
        AuthPasswordIsNotCorrect = 24,
        AuthRequestsLimitIsExceeded = 25,
        AuthRoleCantBeDeletedBecauseUsedByUsers = 26,
        AuthRoleNameAlreadyExists = 27,
        AuthRoleNameIsSystemRole = 28,
        AuthUserHasLoggedOut = 29,
        AuthUserNameAlreadyExists = 30,
        AuthUserNameIsNotSpecified = 31,
        AuthUserNameOrPasswordIsNotCorrect = 32,
        AuthUserNameShouldLookLikeAnEmailAddress = 33,
        AuthWorkspaceNameAlreadyInUse = 34,
        CommandTimeOut = 35,
        CustomMessage = 36,
        ExecutionError = 37,
        IsNotAuthorized = 38,
        IsNotDeleted = 39,
        IsNotCorrect = 40,
        IsNotEqual = 41,
        IsNotFound = 42,
        IsNotRecognized = 43,
        IsNotSpecified = 44,
        ItemCantBeDeletedBecauseItemIsAttachedToOtherItems = 45,
        ItemCantBeMovedToSpecifiedPlace = 46,
        ItemDoesNotSupport = 47,
        KeyAndToKeyIsEqual = 48,
        NotificationFailed = 49,
        NotificationFileUploading = 50,
        NotificationFilesUploadingComplete = 51,
        NotificationItemDelete = 52,
        NotificationItemDeleteComplete = 53,
        NotificationItemRestore = 54,
        NotificationItemRestoreComplete = 55,
        NotificationItemTransfer = 56,
        NotificationItemTransferComplete = 57,
        NotificationItemWaitingProcessing = 58,
        NotificationOperationAborted = 59,
        NotificationRecycleBinCleaning = 60,
        NotificationRecycleBinCleaningComplete = 61,
        NotificationRecycleBinWaitingProcessing = 62,
        NotificationReportCompiling = 63,
        NotificationReportDataProcessing = 64,
        NotificationReportExporting = 65,
        NotificationReportExportingComplete = 66,
        NotificationReportRendering = 67,
        NotificationReportRenderingComplete = 68,
        NotificationReportSaving = 69,
        NotificationReportWaitingProcessing = 70,
        NotificationSchedulerRunning = 71,
        NotificationSchedulerRunningComplete = 72,
        NotificationSchedulerWaitingProcessing = 73,
        NotificationTransferring = 74,
        NotificationTransferringComplete = 75,
        NotificationTitleFilesUploading = 76,
        NotificationTitleItemRefreshing = 77,
        NotificationTitleItemTransferring = 78,
        NotificationTitleReportExporting = 79,
        NotificationTitleReportRendering = 80,
        NotificationTitleSchedulerRunning = 81,
        QuotaMaximumComputingCyclesCountExceeded = 82,
        QuotaMaximumFileSizeExceeded = 83,
        QuotaMaximumItemsCountExceeded = 84,
        QuotaMaximumReportPagesCountExceeded = 85,
        QuotaMaximumUsersCountExceeded = 86,
        QuotaMaximumWorkspacesCountExceeded = 87,
        AccessDenied = 88,
        OutOfRange = 89,
        ParsingCommandException = 90,
        SchedulerCantRunItSelf = 91,
        SessionTimeOut = 92,
        SnapshotAlreadyProcessed = 93,
        SpecifiedItemIsNot = 94,
        WithSpecifiedKeyIsNotFound = 95,
        VersionCopyFromItem = 96,
        VersionCreatedFromFile = 97,
        VersionCreatedFromItem = 98,
        VersionNewItemCreation = 99,
        VersionLoadedFromFile = 100
    }
}
declare module Stimulsoft.Base {
    class StiNotice {
        ident: StiNoticeIdent;
        arguments: string[];
        customMessage: string;
    }
}
declare module Stimulsoft.Base {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRepositoryItems implements ICloneable {
        implements(): string[];
        clone(): any;
        private items;
        private valueBoolFalse;
        private valueBoolTrue;
        setNumber(key: Object, value: number, defaultValue: number): void;
        getNumber(key: Object, defaultValue: number): number;
        setBool(key: Object, value: boolean, defaultValue: boolean): void;
        getBool(key: Object, defaultValue: boolean): boolean;
        set(key: Object, value: any, defaultValue: any): void;
        get(key: Object, defaultValue: any): any;
        isPresent(key: Object): boolean;
    }
}
declare module Stimulsoft.Base.Services {
    import StiRepositoryItems = Stimulsoft.Base.StiRepositoryItems;
    import ICloneable = Stimulsoft.System.ICloneable;
    /** Describes an asbtract class that serves for services realization. */
    class StiService implements ICloneable {
        /** Creates a new object that is a copy of the current instance. */
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        implements(): string[];
        isPropertyPresent(key: Object): boolean;
        private _properties;
        properties: StiRepositoryItems;
        /** Internal use only, for LoadDocument optimization. */
        protected isPropertiesInitializedProtected(): boolean;
        /** Gets a service category. */
        readonly serviceCategory: string;
        /** Gets a service name. */
        readonly serviceName: string;
        /** Gets a service description. */
        readonly serviceInfo: string;
        /** Gets a service type. */
        readonly serviceType: Stimulsoft.System.Type;
        /** Gets or sets the value whether a service is enabled or not. */
        serviceEnabled: boolean;
    }
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary.JSZip {
    /**
     * @hidden
     */
    interface JSZip {
        /**
         * Get a file from the archive
         *
         * @param Path relative path to file
         * @return File matching path, null if no file found
         */
        file(path: string): JSZipObject;
        /**
         * Get files matching a RegExp from archive
         *
         * @param path RegExp to match
         * @return Return all matching files or an empty array
         */
        file(path: RegExp): JSZipObject[];
        /**
         * Add a file to the archive
         *
         * @param path Relative path to file
         * @param content Content of the file
         * @param options Optional information about the file
         * @return JSZip object
         */
        file(path: string, data: any, options?: JSZipFileOptions): JSZip;
        /**
         * Return an new JSZip instance with the given folder as root
         *
         * @param name Name of the folder
         * @return New  JSZip object with the given folder as root or null
         */
        folder(name: string): JSZip;
        /**
         * Returns new JSZip instances with the matching folders as root
         *
         * @param name RegExp to match
         * @return New array of JSZipFile objects which match the RegExp
         */
        folder(name: RegExp): JSZipObject[];
        /**
         * Get all files wchich match the given filter function
         *
         * @param predicate Filter function
         * @return Array of matched elements
         */
        filter(predicate: (relativePath: string, file: JSZipObject) => boolean): JSZipObject[];
        /**
         * Removes the file or folder from the archive
         *
         * @param path Relative path of file or folder
         * @return Returns the JSZip instance
         */
        remove(path: string): JSZip;
        /**
         * Generates a new archive
         *
         * @param options Optional options for the generator
         * @return The serialized archive
         */
        generate(options?: JSZipGeneratorOptions): any;
        /**
         * Deserialize zip file
         *
         * @param data Serialized zip file
         * @param options Options for deserializing
         * @return Returns the JSZip instance
         */
        load(data: any, options: JSZipLoadOptions): JSZip;
    }
    /**
     * @hidden
     */
    interface JSZipObject {
        name: string;
        dir: boolean;
        date: Date;
        comment: string;
        options: JSZipObjectOptions;
        asText(): string;
        asBinary(): string;
        asArrayBuffer(): ArrayBuffer;
        asUint8Array(): Uint8Array;
    }
    /**
     * @hidden
     */
    interface JSZipFileOptions {
        base64?: boolean;
        binary?: boolean;
        date?: Date;
        compression?: string;
        comment?: string;
        optimizedBinaryString?: boolean;
        createFolders?: boolean;
    }
    /**
     * @hidden
     */
    interface JSZipObjectOptions {
        /** deprecated */
        base64: boolean;
        /** deprecated */
        binary: boolean;
        /** deprecated */
        dir: boolean;
        /** deprecated */
        date: Date;
        compression: string;
    }
    /**
     * @hidden
     */
    interface JSZipGeneratorOptions {
        /** deprecated */
        base64?: boolean;
        /** DEFLATE or STORE */
        compression?: string;
        /** base64 (default), string, uint8array, blob */
        type?: string;
        comment?: string;
    }
    /**
     * @hidden
     */
    interface JSZipLoadOptions {
        base64?: boolean;
        checkCRC32?: boolean;
        optimizedBinaryString?: boolean;
        createFolders?: boolean;
    }
    /**
     * @hidden
     */
    interface JSZipSupport {
        arraybuffer: boolean;
        uint8array: boolean;
        blob: boolean;
        nodebuffer: boolean;
    }
    /**
     * @hidden
     */
    interface DEFLATE {
        /** pako.deflateRaw, level:0-9 */
        compress(input: string, compressionOptions: {
            level: number;
        }): Uint8Array;
        compress(input: number[], compressionOptions: {
            level: number;
        }): Uint8Array;
        compress(input: Uint8Array, compressionOptions: {
            level: number;
        }): Uint8Array;
        /** pako.inflateRaw */
        uncompress(input: string): Uint8Array;
        uncompress(input: number[]): Uint8Array;
        uncompress(input: Uint8Array): Uint8Array;
    }
    /**
     * @hidden
     */
    var prototype: JSZip;
    /**
     * @hidden
     */
    var support: JSZipSupport;
    /**
     * @hidden
     */
    var compressions: {
        DEFLATE: DEFLATE;
    };
}
/**
 * @hidden
 */
declare namespace Stimulsoft.ExternalLibrary {
    /**
     * Create JSZip instance
     * @hidden
     */
    function JSZip(): Stimulsoft.ExternalLibrary.JSZip.JSZip;
    /**
     * Create JSZip instance
     * If no parameters given an empty zip archive will be created
     *
     * @param data Serialized zip archive
     * @param options Description of the serialized zip archive
     * @hidden
     */
    function JSZip(data: any, options?: Stimulsoft.ExternalLibrary.JSZip.JSZipLoadOptions): Stimulsoft.ExternalLibrary.JSZip.JSZip;
}
declare module Stimulsoft.Base {
    class StiGZipHelper {
        private static DefaultLevel;
        private static DefaultMethod;
        private static ID1;
        private static ID2;
        private static _crcTable;
        static readonly crcTable: number[];
        static crc32(data: number[]): number;
        private static putByte;
        private static putShort;
        private static putLong;
        private static putString;
        private static readByte;
        private static readShort;
        private static readLong;
        private static readString;
        private static readBytes;
        static pack(data2: string | number[], name?: string): string | number[];
        static unpack(data: string | number[]): string | number[];
    }
}
declare module Stimulsoft.Base.Zip {
    import DateTime = Stimulsoft.System.DateTime;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiZipWriter20 {
        static convertToArray(useUnicode: boolean, str: string): number[];
        static getDosTime(dt: DateTime): number;
        private _mainStream;
        private zip;
        begin(stream: MemoryStream, leaveOpen: boolean): void;
        addFile(fileName: string, dataStream: MemoryStream, closeDataStream?: boolean): void;
        end(): void;
        constructor();
    }
}
declare module Stimulsoft.Base {
    enum StiAnimationType {
        Opacity = 0,
        Scale = 1,
        Translation = 2,
        Rotation = 3,
        Column = 4,
        Points = 5,
        PieSegment = 6
    }
    /**
     *  Types of token.
     */
    enum StiTokenType {
        /**
         *  None token.
         */
        None = 0,
        /**
         *  .
         */
        Dot = 1,
        /**
         *  ,
         */
        Comma = 2,
        /**
         *  :
         */
        Colon = 3,
        /**
         *  ;
         */
        SemiColon = 4,
        /**
         *  Shift to the left Token.
         */
        Shl = 5,
        /**
         *  Shift to the right Token.
         */
        Shr = 6,
        /**
         *  Assign Token.
         */
        Assign = 7,
        /**
         *  Equal Token.
         */
        Equal = 8,
        /**
         *  NotEqual Token.
         */
        NotEqual = 9,
        /**
         *  LeftEqual Token.
         */
        LeftEqual = 10,
        /**
         *  Left Token.
         */
        Left = 11,
        /**
         *  RightEqual Token.
         */
        RightEqual = 12,
        /**
         *  Right Token.
         */
        Right = 13,
        /**
         *  Logical OR Token.
         */
        Or = 14,
        /**
         *  Logical AND Token.
         */
        And = 15,
        /**
         *  Logical NOT Token.
         */
        Not = 16,
        /**
         *  Double logical OR Token.
         */
        DoubleOr = 17,
        /**
         *  Double logical AND Token.
         */
        DoubleAnd = 18,
        /**
         *  Copyright
         */
        Copyright = 19,
        /**
         *  ?
         */
        Question = 20,
        /**
         *  +
         */
        Plus = 21,
        /**
         *  -
         */
        Minus = 22,
        /**
         *  *
         */
        Mult = 23,
        /**
         *  /
         */
        Div = 24,
        /**
         *  \
         */
        Splash = 25,
        /**
         *  %
         */
        Percent = 26,
        /**
         *  @
         */
        Ampersand = 27,
        /**
         *  #
         */
        Sharp = 28,
        /**
         *  $
         */
        Dollar = 29,
        /**
         *  ˆ
         */
        Euro = 30,
        /**
         *  ++
         */
        DoublePlus = 31,
        /**
         *  --
         */
        DoubleMinus = 32,
        /**
         *  (
         */
        LPar = 33,
        /**
         *  )
         */
        RPar = 34,
        /**
         *  {
         */
        LBrace = 35,
        /**
         *  }
         */
        RBrace = 36,
        /**
         *  [
         */
        LBracket = 37,
        /**
         *  ]
         */
        RBracket = 38,
        /**
         *  Token contains value.
         */
        Value = 39,
        /**
         *  Token contains identifier.
         */
        Ident = 40,
        /**
         *
         */
        Unknown = 41,
        /**
         *  EOF Token.
         */
        EOF = 42
    }
    enum StiLevel {
        Basic = 0,
        Standard = 1,
        Professional = 2
    }
}
declare namespace Stimulsoft.Base {
    var IStiApp: string;
    /**
     * Describes the base interface for the Stimulsoft Application.
     */
    interface IStiApp extends IStiAppCell {
        /**
         * Returns reference to the data dictionary.
         * @returns The data dictionary.
         */
        getDictionary(): IStiAppDictionary;
    }
}
declare namespace Stimulsoft.Base {
    var IStiAppCalcDataColumn: string;
    /**
     *  Provides access to the calculateed datacolumn.
     */
    interface IStiAppCalcDataColumn extends IStiAppDataColumn {
    }
}
declare namespace Stimulsoft.Base {
    var IStiAppCell: string;
    /**
     * Describes the base interface for all components.
     */
    interface IStiAppCell {
        /**
         * Returns unique key to this cell object.
         */
        getKey(): string;
        /**
         * Sets unique key to this cell object.
         */
        setKey(key: string): any;
    }
}
declare namespace Stimulsoft.Base {
    var IStiIStiAppComponentAppCell: string;
    /**
     * Describes the base interface for all components of the app.
     */
    interface IStiAppComponent extends IStiAppCell {
        /**
         * Returns a name of the component.
         * @returns The name of component.
         */
        getName(): string;
        /**
         * Returns reference to the app which contains this component.
         * @returns Reference to the app.
         */
        getApp(): IStiApp;
    }
}
declare namespace Stimulsoft.Base {
    var IStiAppConnection: string;
    /**
     * Provides access to the data connection.
     */
    interface IStiAppConnection extends IStiAppCell {
        /**
         * Returns a name of the component.
         * @returns The name of component.
         */
        getName(): string;
    }
}
declare namespace Stimulsoft.Base {
    import Type = Stimulsoft.System.Type;
    var IStiAppDataColumn: string;
    /**
     * Provides access to the datacolumn.
     */
    interface IStiAppDataColumn extends IStiAppCell {
        getNameInSource(): string;
        /**
         * Returns a name of the data column.
         * @returns The name of the data column.
         */
        getName(): string;
        /**
         * Returns a type of the data column.
         * @returns The name of the data column.
         */
        getDataType(): Type;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    var IStiAppDataRelation: string;
    /**
     * Provides access to the datarelation.
     */
    interface IStiAppDataRelation extends IStiAppCell {
        /**
         * Returns a name of the component.
         * @returns The name of component.
         */
        getName(): string;
        /**
         * Returns a reference to the dictionary which contains this datasource.
         * @returns A reference to the app.
         */
        getDictionary(): IStiAppDictionary;
        /**
         * Returns parent data source of this relation.
         * @returns A reference to the data source.
         */
        getParentDataSource(): IStiAppDataSource;
        /**
         * Returns child data source of this relation.
         * @returns A reference to the data source.
         */
        getChildDataSource(): IStiAppDataSource;
        /**
         * Returns an enumeration of the parent column keys of the data relation.
         * @returns An reference to the enumeration.
         */
        fetchParentColumns(): List<string>;
        /**
         * Returns an enumeration of the child column keys of the data relation.
         * @returns An reference to the enumeration.
         */
        fetchChildColumns(): List<string>;
        /**
         * Returns the status of the relation.
         * @returns The status of the relation.
         */
        getActiveState(): boolean;
    }
}
declare namespace Stimulsoft.Base {
    import Promise = Stimulsoft.System.Promise;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    var IStiAppDataSource: string;
    /**
     * Provides access to the datasource.
     */
    interface IStiAppDataSource extends IStiAppCell {
        /**
         *  Returns a name of the component in the data source.
         * @return The name of component
         */
        getNameInSource(): string;
        /**
         * Returns a name of the component.
         * @returns The name of component.
         */
        getName(): string;
        /**
         * Returns a DataTable with data from this datasource.
         * @param allowConnectToData Allow to call Connect() method. By default is true.
         * @returns The DataTable with data.
         */
        getDataTable2Async(allowConnectToData: boolean): Promise<DataTable>;
        /**
         * Returns a reference to the dictionary which contains this datasource.
         * @returns Reference to the app.
         */
        getDictionary(): IStiAppDictionary;
        /**
         * Returns an enumeration of the data columns from this dictionary.
         * @returns The enumeration of the data columns.
         */
        fetchColumns(): List<IStiAppDataColumn>;
        /**
         * Returns a connection to data for this data source.
         * @returns Reference to the connection.
         */
        getConnection(): IStiAppConnection;
        /**
         * Returns an enumeration of the parent data relations for this data source.
         * @returns The enumeration of the data relations.
         */
        fetchParentRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        /**
         * Returns an enumeration of the child data relations for this data source.
         * @returns The enumeration of the data relations.
         */
        fetchChildRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        /**
         * Returns an array of values for the specified column in the specified position.
         * @param names An array of names of the data column.
         * @returns The enumeration of the data column values.
         */
        fetchColumnValues(names: string[]): List<any[]>;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    var IStiAppDictionary: string;
    /**
     * Describes the interface to access base data dictionary functionality.
     */
    interface IStiAppDictionary {
        /**
         * Returns an enumeration of the data source from this dictionary.
         * @returns The enumeration of the data source.
         */
        fetchDataSources(): List<IStiAppDataSource>;
        /**
         * Returns an enumeration of the data relations from this dictionary.
         * @returns The enumeration of the data relations.
         */
        fetchDataRelations(): List<IStiAppDataRelation>;
        /**
         * Returns an enumeration of the variables from this dictionary.
         * @returns The enumeration of the variables
         */
        fetchVariables(): List<IStiAppVariable>;
        /**
         * Returns datasource from the data dictionary by its name.
         * @param name A name of the datasource.
         * @returns The datasource from the data dictionary. Returns null, if datasource with specified name is not exists.
         */
        getDataSourceByName(name: string): IStiAppDataSource;
        /**
         * Returns data column from the data dictionary by its name.
         * @param name A name of the data column.
         * @returns The data column from the data dictionary. Returns null, if data column with specified name is not exists.
         */
        getColumnByName(name: string): IStiAppDataColumn;
        /**
         * Returns variable from the data dictionary by its name.
         * @param name A name of the variable.
         * @returns The variable from the data dictionary. Returns null, if variable with specified name is not exists.
         */
        getVariableByName(name: string): IStiAppVariable;
        /**
         * Returns true if a specified name is a name of a system variable.
         * @param name The name of the system variable.
         * @returns True, if the specified name is the name of system variable.
         */
        isSystemVariable(name: string): boolean;
        /**
         * Returns value of a specified system variable.
         * @param name A name of the system variable.
         * @returns The value of the specified system variable.
         */
        getSystemVariableValue(name: string): any;
        /**
         * Returns reference to the app which contains this dictionary.
         * @returns A reference to the app.
         */
        getApp(): IStiApp;
        /**
         * Opens specified connections to the data. Opens all connections if none of them is specified.
         */
        openConnections(connections: List<IStiAppConnection>): List<IStiAppConnection>;
        /**
         * Closes all specified connections. Closes all connections if none of them is specified.
         */
        closeConnections(connections: List<IStiAppConnection>): any;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    var IStiAppFunction: string;
    /**
     * Provides access to the application function.
     */
    interface IStiAppFunction extends IStiAppCell {
        /**
         * Returns a name of the function.
         * @returns The name of the function.
         */
        getName(): string;
        /**
         * Invokes this function with specified arguments.
         * @param arguments The list of arguments.
         * @returns The result of the function calling.
         */
        invoke(arguments: List<any>): any;
    }
}
declare namespace Stimulsoft.Base {
    var IStiAppVariable: string;
    /**
     * Provides access to the application variable.
     */
    interface IStiAppVariable extends IStiAppCell {
        /**
         * Returns a name of the component.
         * @returns The name of component.
         */
        getName(): string;
        /**
         * Returns value of this variable.
         * @returns The variable value.
         */
        getValue(): any;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    var IStiReport: string;
    /**
     * Describes the interface to access main report posibilities.
     */
    interface IStiReport extends IStiApp {
        /**
         * Returns an enumeration of the pages from this report.
         * @returns The enumeration of the pages.
         */
        fetchPages(): List<IStiReportPage>;
    }
}
declare namespace Stimulsoft.Base {
    var IStiReportComponent: string;
    /**
     * Describes the base interface for all report components.
     */
    interface IStiReportComponent extends IStiAppComponent {
        /**
         * Returns reference to the report which contains this component.
         * @returns Reference to the report.
         */
        getReport(): IStiReport;
    }
}
declare namespace Stimulsoft.Base {
    var IStiReportPage: string;
    /**
     * Describes the interface to access report page posibilities.
     */
    interface IStiReportPage extends IStiReportComponent {
        parseExpression(text: string): string;
    }
}
declare module Stimulsoft.Base {
    class StiActivator {
        static createObject(_type: Stimulsoft.System.Type): any;
        static createObject2(typeString: string): any;
    }
}
declare module Stimulsoft.Base {
    class StiAlignValue {
        static alignToMaxGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToMinGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
        static alignToGrid(value: number, gridSize: number, aligningToGrid: boolean): number;
    }
}
declare namespace Stimulsoft.Base {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiAppFunctions {
        static functionsToCompile: Hashtable;
        static functionsToCompileLower: Hashtable;
        static functions: Hashtable;
        static functionsLower: Hashtable;
        static getFunctions(isCompile: boolean, isCaseSensitive: boolean): IStiAppFunction[];
        /**
         *  Returns array of functions with spefified name.
         */
        static getFunctions2(functionName: string, isCompile: boolean, isCaseSensitive: boolean): IStiAppFunction[];
    }
}
declare namespace Stimulsoft.Base {
    class StiAppKey {
        static getOrGeneratedKey(component: IStiReportComponent): string;
        static getOrGeneratedKey2(app: IStiApp): string;
        static getOrGeneratedKey3(dictionary: IStiAppDictionary): string;
        static getOrGeneratedKey4(dataSource: IStiAppDataSource): string;
    }
}
declare namespace Stimulsoft.Base.Drawing {
    import Color = Stimulsoft.System.Drawing.Color;
    /**
     *  This class helps in converting a string to a color.
     */
    class StiColor {
        /**
         *  Translates a HTML color representation to a GDI+ System.Drawing.Color structure.
         */
        static get(color: string): Color;
        /**
         *  Translates an array with HTML colors representation to a GDI+ System.Drawing.Color structure.
         */
        static get2(...colors: string[]): Color[];
    }
}
declare module Stimulsoft.Base {
    class StiConvert {
        static changeType(value: any, conversionType: Stimulsoft.System.Type, convertNulls?: boolean): any;
    }
}
declare namespace Stimulsoft.Base {
    class StiDashboardNotSupportedException {
        readonly message: string;
    }
}
declare module Stimulsoft.Base {
    class StiEncryption {
        private static randomSeed;
        private static rand_m;
        private static rand_a;
        private static rand_c;
        static encrypt(src: number[], key: number[]): number[];
        static encrypt2(src: number[], password: string): number[];
        static encryptS(src: string, password: string): string;
        static decrypt(src: number[], key: number[]): number[];
        static decrypt2(src: number[], password: string): number[];
        static decryptS(src: string, password: string): string;
        static generateRandomKey(): number[];
        private static encryptAdv;
        private static decryptAdv;
        private static cryptXor;
        private static cryptShift;
        private static shiftLeft;
        private static shiftRight;
        private static cryptRandom;
        private static getMixArray;
        private static setRandomSeed;
        private static getRandom;
        private static getKeyFromPassword;
    }
}
declare module Stimulsoft.Base {
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontCollection {
        static addOpentypeFont(font: any, fontName?: string, binFont?: any, filePath?: string, fontStyle?: FontStyle): void;
        static addOpentypeFontFile(filePath: string, fontName?: string, fontStyle?: FontStyle): void;
        static addOpentypeFontFileAsync(callback: Function, filePath: string, fontName?: string, fontStyle?: FontStyle): void;
        static getFontFamilies(): FontFamily[];
        static getBinFont(fontName: string, fontStyle?: FontStyle): any;
        static getBinFonts(): string[];
    }
}
declare module Stimulsoft.Base {
    class StiGuidUtils {
        static newGuid(): string;
    }
}
declare module Stimulsoft.Base {
    class StiJsonChecker {
        static isValidJson(strInput: string): boolean;
    }
}
declare module Stimulsoft.Base {
    class StiKeyHelper {
        static generateKey(): string;
        static isKey(key: string): boolean;
        static isCorrectKey(key: string): boolean;
        static isEmptyKey(key: string): boolean;
        static isEmptyKey2(key1: string, key2: string): boolean;
        static selectKey(key1: string, key2: string): string;
        static isEqualKeys(key1: string, key2: string): boolean;
        static getOrGeneratedKey(key: string): string;
        static getOrGeneratedKey2(key1: string, key2: string): string;
    }
}
declare namespace Stimulsoft.Base {
    import List = Stimulsoft.System.Collections.List;
    /**
     * Performs the lexical analysis.
     */
    class StiLexer {
        private _text;
        /**
         *  Gets or sets text for analys.
         */
        text: string;
        /**
         *  Gets or sets text for analys.
         */
        baseText: string;
        /**
         *  Start positions of token.
         */
        private positions;
        /**
         *  Gets or sets current position in text.
         */
        positionInText: number;
        /**
         *  Saves position of token in text.
         */
        savePosToken(): void;
        /**
         *  Gets position of token in text.
         *  @param this.positionInText Position in text.
         *  @returns Position of token in text.
         */
        getPosition(positionInText: number): StiPosition;
        /**
         *  Skips all not control symbols.
         */
        skip(): void;
        /**
         *  Wait the left paren.
         */
        waitLparen2(): boolean;
        /**
         *  Wait the right bracket.
         */
        waitComma2(): boolean;
        /**
         *  Wait the assign.
         */
        waitAssign2(): boolean;
        /**
         *  Wait the right paren.
         */
        waitRparen2(): boolean;
        /**
         *  Wait the left brace.
         */
        waitLbrace2(): boolean;
        /**
         *  Wait the semicolon.
         */
        waitSemicolon2(): boolean;
        /**
         *  Wait the right brace.
         */
        waitRbrace2(): boolean;
        /**
         *  Scans the number.
         *  @returns Token containing number.
         */
        scanNumber(): StiToken;
        /**
         *  Scans the identifier.
         *  @returns Token containing identifier.
         */
        scanIdent(): StiToken;
        /**
         *  Scans the string.
         *  @returns Token containing string.
         */
        scanString(): StiToken;
        /**
         *  Scans the symbol.
         *  @returns Token containing symbol.
         */
        scanChar(): StiToken;
        /**
         *  Returns to previous token.
         */
        ungetToken(): void;
        /**
         *  Gets next token.
         *  @returns Next token.
         */
        getToken(): StiToken;
        /**
         *  Reset state.
         */
        reset(): void;
        /**
         *  Replaces all occurrences of a specified String, with another specified String.
         *  Before oldValue must follow specified prefix - token.
         *  Replacing is produced with provision for tokens.
         *  @param textValue Text for replace.
         *  @param prefix Prefix - token.
         *  @param oldValue A String to be replaced.
         *  @param newValue A String to replace all occurrences of oldValue.
         *  @returns Replaced string.
         */
        static replaceWithPrefix(textValue: string, prefix: string, oldValue: string, newValue: string): string;
        /**
         *  Replaces all occurrences of a specified String, with another specified string.
         *  Before oldValue must follow specified prefix - string.
         *  Replacing is produced with provision for tokens.
         *  @param prefix Prefix - string.
         *  @param oldValue A String to be replaced.
         *  @param newValue A String to replace all occurrences of oldValue.
         *  @returns Replaced string.
         */
        replaceWithPrefix(prefix: string, oldValue: string, newValue: string): void;
        /**
         *  Replaces all occurrences of a specified String, with another specified string.
         *  Before oldValue must not follow specified prefix - string.
         *  @param prefix Prefix - string.
         *  @param oldValue A String to be replaced.
         *  @param newValue A String to replace all occurrences of oldValue.
         *  @returns Replaced string.
         */
        replaceWithNotEqualPrefix(prefix: StiTokenType, oldValue: string, newValue: string): void;
        static identExists(str: string, name: string, caseSensitive: boolean): boolean;
        static getAllTokens(str: string): List<StiToken>;
        /**
         *  Creates a new instance of the StiLexer class.
         *  @param textValue The Text for lexical analysis.
         */
        constructor(textValue: string);
    }
}
declare module Stimulsoft.Base {
    class StiMD5Helper {
        static MD5(string: any): any[];
    }
}
declare module Stimulsoft.Base {
    class StiObjectConverter {
        static convertToNumber(value: Object): number;
    }
}
declare namespace Stimulsoft.Base {
    /**
     * Saving of the positions in text.
     */
    class StiPosition {
        /**
         *  Gets or sets line in text.
         */
        line: number;
        /**
         *  Gets or sets column in text.
         */
        column: number;
        /**
         *  Creates position in text.
         *  @param line Line in text.
         *  @param column Column in text.
         */
        constructor(line: number, column: number);
    }
}
declare namespace Stimulsoft.Base {
    class StiScale {
        static xx(value: number): number;
        static yy(value: number): number;
        static factor: number;
    }
}
declare module Stimulsoft.Base {
    class StiSettings {
        static get(name: string, def: string): string;
        static set(name: string, value: string): void;
    }
}
declare namespace Stimulsoft.Base {
    /**
     *  Class describes Token.
     */
    class StiToken {
        /**
         *  Gets or sets value indicates the beginning of token in text.
         */
        index: number;
        /**
         *  Gets or sets value indicates the length of token.
         */
        length: number;
        /**
         *  Gets or sets value indicates the type of token.
         */
        type: StiTokenType;
        /**
         *  Gets or sets Value of the identifier.
         */
        data: any;
        toString(): string;
        /**
         *  Creates an object of the type StiToken that contains an object.
         *  @param type Type Token
         *  @param index The Beginning Token in text.
         *  @param length The Length Token.
         *  @param obj Object for initializing.
         */
        constructor(type: StiTokenType, index?: number, length?: number, obj?: any);
    }
}
declare module Stimulsoft.Base {
    class StiTypeFinder {
        private static findTypes;
        private static getCorrectTypeName;
        static getStiType(typeName: string): Stimulsoft.System.Type;
        private static addTypeFF;
        private static getTypeFF;
        static findType(exType: Stimulsoft.System.Type, typeForFinding: Stimulsoft.System.Type): boolean;
    }
}
declare module Stimulsoft.Base {
    class StiTypeWrapper {
        private _type;
        readonly type: Stimulsoft.System.Type;
        toString(): string;
        static toString(type: Stimulsoft.System.Type): string;
        private static _simpleTypes;
        static readonly simpleTypes: Stimulsoft.System.Type[];
        private static _simpleBaseTypes;
        static readonly simpleBaseTypes: Stimulsoft.System.Type[];
        static getTypeWrappers(): StiTypeWrapper[];
        constructor(type: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Base {
    class StiUrl {
        static combine(uriParts: string[]): string;
    }
}
declare module Stimulsoft {
    /**
     * @hidden
     */
    class StiVersion {
        static version: string;
        static creationDate: string;
        static created: System.DateTime;
        static versionInfo: string;
        static copyright: string;
        static platform(): string;
    }
}
declare module Stimulsoft.Base {
    import DateTime = Stimulsoft.System.DateTime;
    class StringExt {
        static tryParseDateTime(value: string, refDateTime: {
            ref: DateTime;
        }): boolean;
        private static tryParseUsingDate;
        private static tryParseJsonDateTime;
        private static tryParseJsonDateTimeInNewDate;
    }
}

declare namespace Stimulsoft.Data.Helpers {
    import DateTime = Stimulsoft.System.DateTime;
    class StiDateTimeCorrector {
        static correct(dateTime: DateTime): DateTime;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    class StiObjectComparer {
        stiEquals(x: any, y: any): boolean;
        getHashCode(x: any): number;
        static readonly default: StiObjectComparer;
        static compare(x: any, y: any): number;
        private static defaultCompare;
        private static dateTimeCompare;
        private static arrayCompare;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiArrayComparer implements IComparer<any[]> {
        compare(x: any[], y: any[]): number;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import IEqualityComparer = Stimulsoft.System.Collections.IEqualityComparer;
    class StiArrayEqualityComparer implements IEqualityComparer<any[]> {
        equals(x: any[], y: any[]): boolean;
        getHashCode(x: any[]): number;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataActionComparer implements IComparer<StiDataActionRule> {
        compare(x: StiDataActionRule, y: StiDataActionRule): number;
    }
}
declare namespace Stimulsoft.Data.Comparers {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRowComparer implements IComparer<DataRow> {
        compare(x: DataRow, y: DataRow): number;
    }
}
declare namespace Stimulsoft.Data.Engine {
    enum StiDataJoinType {
        Inner = 1,
        Left = 2,
        Right = 3,
        Cross = 4,
        Full = 5
    }
    enum StiDataSortDirection {
        Ascending = 1,
        Descending = 2,
        None = 3
    }
    enum StiDataFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13,
        IsBlank = 14,
        IsNotBlank = 15,
        IsFalse = 16
    }
    enum StiDataFilterOperation {
        AND = 0,
        OR = 1
    }
    enum StiDataActionType {
        Limit = 0,
        Replace = 1,
        RunningTotal = 2,
        Percentage = 3
    }
    enum StiDataFilterConditionGroupType {
        Equal = 0,
        NotEqual = 1,
        Custom = 2,
        Empty = 3
    }
    enum StiDataRequestOption {
        None = 0,
        AllowOpenConnections = 1,
        AllowDataSort = 2,
        DisallowTransform = 4,
        All = 3
    }
    enum StiDataTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiDataFilters: string;
    var ImplementsIStiDataFilters: any[];
    interface IStiDataFilters {
        dataFilters: List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    var IStiDataTopN: string;
    var ImplementsIStiDataTopN: any[];
    interface IStiDataTopN {
        topN: StiDataTopN;
    }
}
declare namespace Stimulsoft.Data.Engine {
    var IStiDataTransformationElement: string;
    var ImplementsIStiDataTransformationElement: any[];
    interface IStiDataTransformationElement {
        dataTransformation: any;
        isDefaultDataTransformation(): boolean;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiDrillDownElement: string;
    var ImplementsIStiDrillDownElement: any[];
    interface IStiDrillDownElement {
        drillDownFilters: List<StiDataFilterRule>;
        drillDownFiltersList: List<List<StiDataFilterRule>>;
        drillDownCurrentLevel: number;
        drillDownLevelCount: number;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiRetrieval: string;
    var ImplementsIStiRetrieval: any[];
    interface IStiRetrieval {
        retrieveUsedDataNames(group: string): List<string>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiRetrieval = Stimulsoft.Data.Engine.IStiRetrieval;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    var IStiQueryObject: string;
    var ImplementsIStiQueryObject: any[];
    interface IStiQueryObject extends IStiRetrieval {
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        getKey(): string;
        isDataSource: boolean;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiTransformActions: string;
    var ImplementsIStiTransformActions: any[];
    interface IStiTransformActions {
        transformActions: List<StiDataActionRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiTransformFilters: string;
    var ImplementsIStiTransformFilters: any[];
    interface IStiTransformFilters {
        transformFilters: List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiTransformSorts: string;
    var ImplementsIStiTransformSorts: any[];
    interface IStiTransformSorts {
        transformSorts: List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiUserFilters: string;
    var ImplementsIStiUserFilters: any[];
    interface IStiUserFilters {
        userFilters: List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    var IStiUserSorts: string;
    var ImplementsIStiUserSorts: any[];
    interface IStiUserSorts {
        userSorts: List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    abstract class LogicalExpressionVisitor {
        abstract visit1(expression: LogicalExpression): any;
        abstract visit2(expression: TernaryExpression): any;
        abstract visit3(expression: BinaryExpression): any;
        abstract visit4(expression: UnaryExpression): any;
        abstract visit5(expression: ValueExpression): any;
        abstract visit6(expression: Functionn): any;
        abstract visit7(expression: Identifier): any;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    class StiExpressionHelper {
        private static expressionToArguments;
        static newExpression(expression: string): Stimulsoft.Data.Expressions.NCalc.Expression;
        static prepareExpression(expression: string): string;
        static escapeExpression(expression: string): string;
        static replaceFunction(expression: string, newFunction: string): string;
        static removeFunction(expression: string): string;
        static isAggregationFunctionPresent(expression: string): boolean;
        static isFunctionPresent(expression: string): boolean;
        static getFunction(expression: string): string;
        static getArguments(expression: string): List<string>;
        static getFirstArgumentFromExpression(expression: string): string;
        static parseReportExpression(report: IStiReport, text: string, withBraces: boolean): string;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import DataRelation = Stimulsoft.System.Data.DataRelation;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    class DataTableExt {
        static nullTable: DataTable;
        static getUniqueName(table: DataTable, meter: IStiMeter): string;
        static getUniqueName2(table: DataTable, meter: IStiMeter, baseName: string): string;
        static getUniqueName3(table: DataTable, baseName: string): string;
        static parentRelationList(table: DataTable): List<DataRelation>;
        static childRelationList(table: DataTable): List<DataRelation>;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiDataTableExt {
        static toNetTable(table: StiDataTable, onlyColumns?: boolean): DataTable;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDataActionOperator {
        private static lockObject;
        private static netCache;
        private static meterCache;
        static apply(inTable: DataTable, actions: List<StiDataActionRule>, report: IStiReport, hash: number): DataTable;
        static applyAfterGrouping(inTable: StiDataTable, actions: List<StiDataActionRule>, report: IStiReport, hash: number): StiDataTable;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getCacheKey2;
        private static getFromCache;
        private static getFromCache2;
        private static addToCache;
        private static addToCache2;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import ICloneable = Stimulsoft.System.ICloneable;
    abstract class StiDataRule implements ICloneable {
        /**
         * Creates a new object that is a copy of the current instance.
         * @returns A new object that is a copy of this instance.
         */
        clone(): any;
        abstract getUniqueCode(): any;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataActionRule extends StiDataRule implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        type: StiDataActionType;
        key: string;
        path: string;
        startIndex: number;
        rowsCount: number;
        initialValue: string;
        valueFrom: string;
        valueTo: string;
        matchCase: boolean;
        matchWholeWord: boolean;
        afterGroupingData: boolean;
        static loadFromJson(json: StiJson): StiDataActionRule;
        static loadFromXml(xmlNode: XmlNode): StiDataActionRule;
        getUniqueCode(): number;
        static create1(key: string, path: string): StiDataActionRule;
        static create2(key: string, path: string, startIndex: number, rowsCount: number, afterGroupingData: boolean): StiDataActionRule;
        static create3(key: string, path: string, valueFrom: string, valueTo: string, matchCase: boolean, matchWholeWord: boolean): StiDataActionRule;
        static create4(key: string, path: string, initialValue: string): StiDataActionRule;
        constructor(key?: string, path?: string, type?: StiDataActionType, startIndex?: number, rowsCount?: number, afterGroupingData?: boolean, valueFrom?: string, valueTo?: string, matchCase?: boolean, matchWholeWord?: boolean, initialValue?: string);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataActionRuleHelper {
        /**
         * Used in the CodeDom report compiler.
         */
        static toList(...rules: StiDataActionRule[]): List<StiDataActionRule>;
        static validate(rules: List<StiDataActionRule>, columnKeys: List<string>): List<StiDataActionRule>;
        private static getColumnIndex;
        static applyActions(table: DataTable, actions: List<StiDataActionRule>, columnKeys: List<string>, columnNames: List<string>, report: IStiReport): void;
        private static applyLimitAction;
        private static applyReplaceAction;
        private static applyRunningTotalAction;
        private static applyPercentageAction;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import Promise = Stimulsoft.System.Promise;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataAnalyzer {
        static analyseAsync(query: IStiQueryObject, group: string, meters: List<IStiMeter>, option?: StiDataRequestOption, userSorts?: List<StiDataSortRule>, userFilters?: List<StiDataFilterRule>, dataFilters?: List<StiDataFilterRule>, dataActions?: List<StiDataActionRule>, transformSorts?: List<StiDataSortRule>, transformFilters?: List<StiDataFilterRule>, transformActions?: List<StiDataActionRule>, drillDownFilters?: List<StiDataFilterRule>): Promise<StiDataTable>;
        private static unionNames;
        private static getUniqueCode;
        private static getUniqueCode2;
    }
}
declare namespace Stimulsoft.Data.Engine {
    class StiDataColumnRuleHelper {
        static isGoodColumnName(columnName: string): boolean;
        static getGoodColumnName(columnName: string): string;
        private static keywords;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import List = Stimulsoft.System.Collections.List;
    class StiDataConnections {
        private static connections;
        static isConnectionActive(connection: IStiAppConnection): boolean;
        static registerConnection(connection: IStiAppConnection, items: List<object>): void;
        static unRegisterConnections(connections: List<IStiAppConnection>): List<object>;
        static unRegisterConnection(connection: IStiAppConnection): List<object>;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    class ListExt extends List<any> {
        static compare(a: any, b: any): any;
        private static compareValues;
        static isList(value: any): boolean;
        static isBoolList(value: any): boolean;
        static toList(value: any): List<any>;
        static toStringList(value: any): List<string>;
        static toNumberList(value: any): List<number>;
        static toBoolList(value: any): List<boolean>;
        static toNullableDateTimeList(value: any): List<DateTime | null>;
        static toStringArray(value: any): string[];
        static toNumberArray(value: any): number[];
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    abstract class StiDataException {
        message: string;
        constructor(message?: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiArgumentNotFoundException extends StiDataException {
        private _functionName;
        readonly functionName: string;
        private _argumentName;
        readonly argumentName: string;
        constructor(functionName: string, argumentName: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiArgumentCountException extends StiDataException {
        private _functionName;
        readonly functionName: string;
        constructor(functionName: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiFunctionNotFoundException extends StiDataException {
        private _name;
        readonly name: string;
        constructor(name: string);
    }
}
declare namespace Stimulsoft.Data.Types {
    class SimpleValue {
        private _value;
        readonly value: any;
        constructor(value: any);
    }
}
declare namespace Stimulsoft.Data.Options {
    import MidpointRounding = Stimulsoft.System.MidpointRounding;
    /**
     * This class contains data options.
     */
    class StiDataOptions {
        /**
         * If true then data engine will calculate null values, otherwise null values will be skip
         */
        static allowNulls: boolean;
        /**
         * Specification for how to round d if it is midway between two other numbers.
         */
        static roundType: MidpointRounding;
    }
}
declare namespace Stimulsoft.Data.Types {
    import DateTime = Stimulsoft.System.DateTime;
    class DateTimeValue {
        value: DateTime;
        constructor(value: any);
    }
}
declare namespace Stimulsoft.Data.Functions {
    import Type = Stimulsoft.System.Type;
    import IStiAppFunction = Stimulsoft.Base.IStiAppFunction;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class Funcs {
        static count(value: any): number;
        static countIf(value: any, condition: any): number;
        static distinct(value: any): any;
        static distinctCount(value: any): number;
        static distinctCountIf(value: any, condition: any): number;
        static first(value: any): any;
        static last(value: any): any;
        static all(value: any): any;
        static isAggregationFunction(functionn: string): boolean;
        static avg(value: any): number;
        static avgDate(value: any): DateTime | null;
        static avgTime(value: any): TimeSpan | null;
        static max(value: any): number;
        static maxD(value: any): number;
        static maxI(value: any): number;
        static maxDate(value: any): DateTime | null;
        static maxTime(value: any): TimeSpan | null;
        static maxStr(value: any): string;
        static median(value: any): number;
        static min(value: any): number;
        static minDate(value: any): DateTime | null;
        static minTime(value: any): TimeSpan | null;
        static minMaxDateString(value: any): string;
        static minStr(value: any): string;
        static mode(value: any): number;
        static sum(value: any): number;
        static sumD(value: any): number;
        static sumI(value: any): number;
        static sumTime(value: any): TimeSpan;
        static sumDistinct(value: any): number;
        static sumIf(value: any, condition: any): number;
        static sumDIf(value: any, condition: any): number;
        static sumIIf(value: any, condition: any): number;
        static sumTimeIf(value: any, condition: any): TimeSpan;
        static sumDistinctIf(value: any, condition: any): number;
        private static getCondition;
        private static getConditions;
        static dayOfWeekIdent(dateTime: DateTime | null): DayOfWeek | null;
        static dayOfWeekIdentObject(value: any): any;
        static dayOfWeekIndex(dateTime: DateTime | null): number;
        static dayOfWeekIndexObject(value: any): any;
        static dayOfWeek(date: DateTime | null): string;
        static dayOfWeekObject(value: any): any;
        static dayOfWeek2(date: DateTime | null, localized: boolean): string;
        static dayOfWeekObject2(value: any, localized: boolean): any;
        static dayOfWeek3(date: DateTime | null, culture: string): string;
        static dayOfWeekObject3(value: any, culture: string): any;
        static dayOfWeek4(date: DateTime | null, culture: string, upperCase: boolean): string;
        static dayOfWeekObject4(value: any, culture: string, upperCase: boolean): any;
        static daysInMonth(year: number, month: number): number;
        static daysInMonthObject(value1: any, value2: any): any;
        static daysInMonth2(date: DateTime | null): number;
        static daysInMonthObject2(value: any): any;
        static daysInYear(year: number): number;
        static daysInYear2(date: DateTime | null): number;
        static daysInYearObject(value: any): any;
        static monthIdent(dateTime: DateTime | null): StiMonth | null;
        static monthIdentObject(value: any): any;
        static month(dateTime: DateTime | null): number;
        static monthObject(value: any): any;
        static monthName(date: DateTime | null): string;
        static monthNameObject(value: any): any;
        static monthName2(date: DateTime | null, localized: boolean): string;
        static monthNameObject2(value: any, localized: boolean): any;
        static monthName3(date: DateTime | null, culture: string): string;
        static monthNameObject3(value: any, culture: string): any;
        static monthName4(date: DateTime | null, culture: string, upperCase: boolean): string;
        static monthNameObject4(value: any, culture: string, upperCase: boolean): any;
        static addMonthsObject(date: any, months: number): any;
        static addYears(date: DateTime, years: number): DateTime;
        static addYearsObject(date: any, years: number): any;
        static day(dateTime: DateTime | null): number;
        static dayObject(value: any): any;
        static dateDiff(date1: DateTime | null, date2: DateTime | null): TimeSpan | null;
        static dateDiffObject(value1: any, value2: any): any;
        static dateTime(value: any): any;
        static dayOfYear(dateTime: DateTime | null): any;
        static dayOfYearObject(value: any): any;
        static financialQuarter(dateTime: DateTime | null): StiQuarter | null;
        static financialQuarterObject(value: any): any;
        static financialQuarterIndex(dateTime: DateTime | null): number;
        static financialQuarterIndexObject(value: any): any;
        static hour(dateTime: DateTime | null): number;
        static hourObject(value: any): any;
        static makeDate(year: number, month?: number, day?: number): DateTime;
        static makeDateObject(year: any, month?: any, day?: any): any;
        static makeDateTime(year: number, month?: number, day?: number, hour?: number, minute?: number, second?: number): DateTime;
        static makeDateTimeObject(year: any, month?: any, day?: any, hour?: any, minute?: any, second?: any): any;
        static makeTime(hour: number, minute?: number, second?: number): DateTime;
        static makeTimeObject(hour: any, minute?: any, second?: any): any;
        static minute(dateTime: DateTime | null): number;
        static minuteObject(value: any): any;
        static now(): DateTime;
        static quarterName(dateTime: DateTime | null, localized?: boolean): string;
        static quarterNameObject(value: any, localized?: boolean): any;
        static quarter(dateTime: DateTime | null): StiQuarter | null;
        static quarterObject(value: any): any;
        static quarterIndex(dateTime: DateTime | null): number;
        static quarterIndexObject(value: any): any;
        static second(dateTime: DateTime | null): number;
        static secondObject(value: any): any;
        static time(value: any): any;
        static year(dateTime: DateTime | null): number;
        static yearObject(value: any): any;
        static yearMonth(dateTime: DateTime | null): string;
        static yearMonthObject(value: any): any;
        static getDateDimensionFunctions(): List<string>;
        static localize(func: string): string;
        static abs(value: number): number;
        static absObject(value: any): any;
        static acos(value: number): number;
        static acosObject(value: any): any;
        static asin(value: number): number;
        static asinObject(value: any): any;
        static atan(value: number): any;
        static atanObject(value: any): any;
        static ceiling(value: number): number;
        static ceilingObject(value: any): any;
        static cos(value: number): number;
        static cosObject(value: any): any;
        static div(value1: number, value2: number, zeroResult?: number | null): number | null;
        static divObject(value1: any, value2: any, zeroResult?: any): number;
        static exp(value: number): number;
        static expObject(value: any): any;
        static floor(value: number): number;
        static floorObject(value: any): any;
        static log(value: number): number;
        static logObject(value: any): any;
        static round(value: number): number;
        static roundObject(value: any): any;
        static sign(value: number): number;
        static signObject(value: any): any;
        static sin(value: number): number;
        static sinObject(value: any): any;
        static sqrt(value: number): number;
        static sqrtObject(value: any): any;
        static tan(value: number): number;
        static tanObject(value: any): any;
        static truncate(value: number): number;
        static truncateObject(value: any): any;
        static isMeasureFunction(expression: string): boolean;
        static getMeasureFunctions(): List<string>;
        static getAggregateMeasureFunctions(): List<string>;
        static getCommonMeasureFunctions(): List<string>;
        static calculate(functionn: string, values: List<object>): any;
        private static iso2Cache;
        static getIso2ConvertedValues(name: string): List<string>;
        static iso2(name: string, mapId?: string): string;
        static iso2Object(value: any, mapId?: string): any;
        static iso2ToName(alpha2: string, mapId?: string): string;
        static iso2ToNameObject(value: any, mapId?: string): any;
        static iso3(name: string, mapId?: string): string;
        static iso3Object(value: any, mapId?: string): any;
        static iso3ToName(alpha3: string, mapId?: string): string;
        static iso3ToNameObject(value: any, mapId?: string): any;
        static normalizeName(alpha3: string, mapId?: string): string;
        static normalizeNameObject(value: any, mapId?: string): any;
        private static toProperCaseCache;
        private static toLowerCaseCache;
        private static toUpperCaseCache;
        private static toDataNameCache;
        static insert(str: string, startIndex: number, subStr: string): string;
        static insertObject(value: any, startIndex: number, subStr: string): any;
        static isDataEqual(dataSource: IStiAppDataSource, dataColumnName: string, searchColumnName: string): boolean;
        static left(str: string, length?: number): string;
        static leftObject(value: any, length?: number): any;
        static length2(str: string): number;
        static lengthObject(value: any): any;
        static remove(str: string, startIndex: number, count: number): string;
        static removeObject(value: any, startIndex: number, count: number): any;
        static replace(str: string, oldValue: string, newValue: string): string;
        static replaceObject(value: any, oldValue: string, newValue: string): any;
        static right(str: string, length?: number): string;
        static rightObject(value: any, length?: number): any;
        static toDataName(name: string): string;
        static toExpression(name: string): string;
        static toExpression2(sourceName: string, columnName: string): string;
        static toLowerCase(str: string): string;
        static toLowerCaseObject(value: any): any;
        static toProperCase(str: string): string;
        static toProperCaseObject(value: any): any;
        static toString(value: any): string;
        static toStringObject(value: any): any;
        static toUpperCase(str: string): string;
        static toUpperCaseObject(value: any): any;
        static trim(str: string): string;
        static trimObject(value: any): any;
        static trimStart(str: string): string;
        static trimStartObject(value: any): any;
        static trimEnd(str: string): string;
        static trimEndObject(value: any): any;
        static substring(str: string, startIndex: number, length?: number): string;
        static substringObject(value: any, startIndex: number, length?: number): any;
        static existsCustomFunction(funcName: string): boolean;
        static getCustomFunctions(funcName: string): List<IStiAppFunction>;
        static getCustomFunction(funcName: string, argumentTypes: List<Type>): IStiAppFunction;
        static invokeCustomFunction(funcName: string, argumentss: List<any>): any;
        static skipNulls(values: List<any>): List<any>;
        static optionalSkipNulls(values: List<object>): List<object>;
    }
}
declare namespace Stimulsoft.Data.Parsers {
    import FunctionArgs = Stimulsoft.Data.Expressions.NCalc.FunctionArgs;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    abstract class StiDataParser {
        protected runFunction(funcName: string, args: FunctionArgs): any;
        protected getVariable(name: string): IStiAppVariable;
        protected isVariable(name: string): boolean;
        protected getVariableValue(name: string): any;
        protected isSystemVariable(name: string): any;
        protected getSystemVariableValue(name: string): any;
        private static getObjectFromArg;
        private static evaluateArgs;
        private static getObjectFromArg0;
        private static getObjectFromArg1;
        private static getObjectFromArg2;
        private static getDataColumnFromArg0;
        protected getDataColumnIndex(columnName: string): number;
        private dataEqual;
        protected getDimensionIndex(dimension: IStiDimensionMeter): number;
        dictionary: IStiAppDictionary;
        table: DataTable;
        meters: List<IStiMeter>;
        isGrandTotal: boolean;
        private nameToIndex;
        private nameToVariable;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>);
    }
}
declare namespace Stimulsoft.Data.Parsers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Grouping = Stimulsoft.System.Collections.Grouping;
    class StiMeasureDataParser extends StiDataParser {
        calculate(): List<any[]>;
        calculateMeter(meter: IStiMeter, keys?: any[], rows?: List<object[]>): any;
        private calculateDimension;
        private calculateMeasureFunction;
        private calculateMeasureExpression;
        private getMeasureColumn;
        private getExpression;
        private getDataRowValue;
        private grandRows;
        private currentRows;
        private queryToExpression;
        private expressionToPair;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>, grandRows: List<Grouping<any[], any[]>>);
    }
}
declare namespace Stimulsoft.Data.Parsers {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDimensionDataParser extends StiDataParser {
        calculate(row: any[]): any[];
        private static normalizeDates;
        private calculateDimension;
        private getDimensionGroupColumn;
        private calculateDimensionExpression;
        private calculateDimensionGroup;
        private normalizeEnum;
        private getExpression;
        protected dimensions: List<IStiDimensionMeter>;
        private currentRow;
        private queryToExpression;
        private expressionToColumn;
        constructor(dictionary: IStiAppDictionary, table: DataTable, meters: List<IStiMeter>);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    class StiDataCreator {
        static create(dict: IStiAppDictionary, meters: List<IStiMeter>): StiDataTable;
        private static convert;
        private static getData;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    class StiDataExpressionHelper {
        static getDataColumnFromExpression(query: IStiQueryObject, expression: string): IStiAppDataColumn;
        static isDateDataColumnInExpression(query: IStiQueryObject, expression: string): boolean;
        static isNumericDataColumnInExpression(query: IStiQueryObject, expression: string): boolean;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataFilterComparer implements IComparer<any> {
        convertStrings: boolean;
        compare(x: any, y: any): number;
        constructor(convertStrings?: boolean);
    }
}
declare namespace Stimulsoft.Data.Engine {
    /**
     * Class contains methods to work with filters.
     */
    class StiDataFilterHelper {
        static convertStringToCondition(condition: string): StiDataFilterCondition;
        static convertConditionToString(condition: StiDataFilterCondition): string;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataFilterRule extends StiDataRule implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadFromJson(json: StiJson): StiDataFilterRule;
        static loadFromXml(xmlNode: XmlNode): StiDataFilterRule;
        toString(): string;
        getUniqueCode(): number;
        toList(): List<StiDataFilterRule>;
        getStringRepresentation(): string;
        private getValue;
        key: string;
        elementKey: string;
        path: string;
        condition: StiDataFilterCondition;
        value: string;
        value2: string;
        isEnabled: boolean;
        isExpression: boolean;
        constructor(key?: string, path?: string, condition?: StiDataFilterCondition, value?: string, value2?: string, isEnabled?: boolean, isExpression?: boolean);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    /**
     * An exception occurs if the specified name of type is not recognized.
     */
    class StiTypeNotRecognizedException extends StiDataException {
        constructor(type: any);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import Type = Stimulsoft.System.Type;
    import StiDataFilerRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    class StiDataFilterRuleHelper {
        /**
         * Used in the CodeDom report compiler.
         */
        static toList(...rules: StiDataFilterRule[]): List<StiDataFilterRule>;
        static validate(rules: List<StiDataFilerRule>, columnKeys: List<string>): List<StiDataFilterRule>;
        static getDataTableFilterQuery(rules: List<StiDataFilterRule>, columns: List<IStiAppDataColumn>, report: IStiReport): string;
        static getDataTableFilterQuery2(rules: List<StiDataFilterRule>, columnNames: List<string>, columnTypes: List<Type>, report: IStiReport): string;
        private static getFullPath;
        private static getFilterGroupQuery;
        /**
         *  Tries to resave numbers in en-US culture.
         */
        private static getValue;
        private static getColumnIndex;
        private static getCondition;
        private static getQueryValue;
        private static getFilterOperation;
        static getFilterRulesHash(app: IStiApp, rules: List<StiDataFilterRule>): number;
        private static getFilterRulesHash2;
        private static getFilterRuleHash3;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataFiltrator {
        private static lockObject;
        private static meterCache;
        private static netCache;
        static filter(inTable: DataTable, filters: List<StiDataFilterRule>, report: IStiReport, hash: number): DataTable;
        static filter2(inTable: StiDataTable, filters: List<StiDataFilterRule>, report: IStiReport, hash: number): StiDataTable;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getCacheKey2;
        private static getFromCache;
        private static getFromCache2;
        private static addToCache;
        private static addToCache2;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataGrouper {
        static group(dictionary: IStiAppDictionary, joinedTable: DataTable, meters: List<IStiMeter>): StiDataTable;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDataJoiner {
        private static lockObject;
        private static cache;
        static join(tables: List<DataTable>, links: List<StiDataLink>, app: IStiApp): DataTable;
        private static copyColumns;
        private static mergeInSequence;
        private static findLink;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
        static cleanCache(appKey: string): void;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiDataLink implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        parentTable: string;
        childTable: string;
        parentColumn: string;
        childColumn: string;
        readonly parentKey: string;
        readonly childKey: string;
        /**
         * Gets or sets the key to the data relation in the report dictionary.
         */
        key: string;
        active: boolean;
        static loadFromJson(json: StiJson): StiDataLink;
        static loadFromXml(xmlNode: XmlNode): StiDataLink;
        toString(): string;
        private nullStr;
        constructor(parentTable?: string, childTable?: string, parentColumn?: string, childColumn?: string, active?: boolean, key?: string);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    class StiDataLinkHelper {
        static getLinks(dictionary: IStiAppDictionary): List<StiDataLink>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import Promise = Stimulsoft.System.Promise;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiDataPicker {
        private static lockObject;
        private static cache;
        /**
         * Returns all data tables which is used in all elements of the dashboard
         */
        static fetchAsync(query: IStiQueryObject, group: string, option?: StiDataRequestOption, filterNames?: List<string>): Promise<List<DataTable>>;
        static isAllBICached(query: IStiQueryObject, group: string, option?: StiDataRequestOption): boolean;
        static getDataTableAsync(app: IStiApp, dataSource: IStiAppDataSource, option?: StiDataRequestOption): Promise<DataTable>;
        private static getDataTable2Async;
        static processCalculatedColumns(dataTable: DataTable, dataSource: IStiAppDataSource): DataTable;
        private static addTableNameToColumnNames;
        static getFromCache(dataSource: IStiAppDataSource): DataTable;
        private static existsInCache;
        static addToCache(dataSource: IStiAppDataSource, dataTable: DataTable): void;
        private static getCacheKey;
        static cleanCache(appKey: string): void;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDataRowJoiner {
        join(type: StiDataJoinType, link: StiDataLink): List<DataRow>;
        private innerJoinRows;
        private leftJoinRows;
        private crossJoinRows;
        private fullJoinRows;
        private getHashCode;
        private splitRows;
        private getFieldIndex;
        private resultTable;
        private table1;
        private table2;
        private resultColumnIndexes;
        private column1Indexes;
        private column2Indexes;
        constructor(resultTable: DataTable, table1: DataTable, table2: DataTable);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataSortRule extends StiDataRule implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadFromJson(json: StiJson): StiDataSortRule;
        static loadFromXml(xmlNode: XmlNode): StiDataSortRule;
        toString(): string;
        getUniqueCode(): number;
        key: string;
        direction: StiDataSortDirection;
        constructor(key?: string, direction?: StiDataSortDirection);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    class StiDataSortRuleHelper {
        /**
         * Used in the CodeDom report compiler.
         */
        static toList(...rules: StiDataSortRule[]): List<StiDataSortRule>;
        static validate(rules: List<StiDataSortRule>, columnKeys: List<string>): List<StiDataSortRule>;
        static getDataTableSortQuery(rules: List<StiDataSortRule>, columns: List<IStiAppDataColumn>): string;
        static getDataTableSortQuery2(rules: List<StiDataSortRule>, columnKeys: List<string>, columnNames: List<string>): string;
        static getSortDirection(rules: List<StiDataSortRule>, columnKey: string): StiDataSortDirection;
        static setSortDirection(rules: List<StiDataSortRule>, columnKeys: List<string>, columnKey: string, direction: StiDataSortDirection): List<StiDataSortRule>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiApp = Stimulsoft.Base.IStiApp;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSorter {
        private static lockObject;
        private static hashCache;
        static sort(inTable: StiDataTable, sorts: List<StiDataSortRule>, app: IStiApp, hash: number, option?: StiDataRequestOption): StiDataTable;
        /**
         * Replaces column name which used as key by real column key.
         */
        private static getFixedDataSortRules;
        static cleanCache(appKey: string): void;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourceChainFinder {
        static find(dataSources: List<IStiAppDataSource>): List<IStiAppDataSource>;
        private static find3;
        static findInParent(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource): List<IStiAppDataSource>;
        static findInChild(dataSource1: IStiAppDataSource, dataSource2: IStiAppDataSource): List<IStiAppDataSource>;
        private static getActiveRelations;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    class StiDataSourcePicker {
        static fetch(query: IStiQueryObject, group: string, dataNames: List<string>, dataSources: List<IStiAppDataSource>): List<IStiAppDataSource>;
    }
}
declare namespace Stimulsoft.Data.Engine {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiDataTable {
        static nullTable: StiDataTable;
        meters: List<IStiMeter>;
        rows: List<any[]>;
        isNull: boolean;
        isEmpty: boolean;
        constructor(meters?: List<IStiMeter>, rows?: List<any[]>);
    }
}
declare namespace Stimulsoft.Data.Engine {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataTopN implements IStiJsonReportObject, ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiDataTopN;
        static createFromXml(xmlNode: XmlNode): StiDataTopN;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): StiDataTopN;
        /**
         *  Gets or sets output values mode.
         */
        mode: StiDataTopNMode;
        /**
         *  Gets or sets the number of output values.
         */
        count: number;
        /**
         *  Gets or sets value which indicates whether to display other values.
         */
        showOthers: boolean;
        /**
         *  Gets or sets signature for other values.
         */
        othersText: string;
        /**
         *  Gets or sets meausure field name.
         */
        measureField: string;
        readonly isDefault: boolean;
        toString(): string;
        getUniqueCode(): number;
        constructor(mode?: StiDataTopNMode, count?: number, showOthers?: boolean, othersText?: string, measureField?: string);
    }
}
declare namespace Stimulsoft.Data.Engine {
    class StiErrorStack {
        private static keyToError;
        static setOk(key: string): void;
        static setError(key: string, error: string): void;
        static getError(key: string): string;
        static isFail(key: any): boolean;
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiBingException extends StiDataException {
        constructor(message: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    class StiColumnNotFoundException extends StiDataException {
        private _name;
        readonly name: string;
        constructor(name: string);
    }
}
declare namespace Stimulsoft.Data.Exceptions {
    /**
     * An exception occurs if the specified name of a system variable not recognized.
     */
    class StiSystemVariableNotRecognizedException extends StiDataException {
        constructor(name: string);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
     *  A linked list is fast at dequeue but slow at get(i).  An array is
     *  the reverse.  This is O(1) for both operations.
     *
     *  List grows until you dequeue last element at end of buffer. Then
     *  it resets to start filling at 0 again.  If adds/removes are balanced, the
     *  buffer will not grow too large.
     *
     *  No iterator stuff as that's not how we'll use it.
     */
    class FastQueue<T> {
        /**
         * dynamically-sized buffer of elements
         */
        _data: List<T>;
        /**
         * index of next element to fill
         */
        _p: number;
        readonly count: number;
        /**
         *  How deep have we gone?
         */
        range: number;
        /**
         * Return element {@code i} elements ahead of current element. {@code i==0}
         * gets current element. This is not an absolute index into {@link #data}
         * since {@code p} defines the start of the real list.
         */
        get(i: number): T;
        /**
         * Get and remove first element in queue
         */
        dequeue(): T;
        enqueue(o: T): void;
        peek(): T;
        clear(): void;
        /**
         * Return string of current buffer contents; non-destructive
         */
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class Action {
    }
    class Func<TResult> extends Function {
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    import List = Stimulsoft.System.Collections.List;
    class ListStack<T> extends List<T> {
        peek(depth?: number): T;
        tryPeek(ref: {
            item: T;
        }): boolean;
        tryPeek2(depth: number, ref: {
            item: T;
        }): boolean;
        pop(): T;
        tryPop(ref: {
            item: T;
        }): boolean;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    /**
     * A lookahead queue that knows how to mark/release locations in the buffer for
     * backtracking purposes. Any markers force the {@link FastQueue} superclass to
     * keep all elements until no more markers; then can reset to avoid growing a
     * huge buffer.
     */
    class LookaheadStream<T> extends FastQueue<T> {
        /**
         * Absolute token index. It's the index of the symbol about to be
         *  read via {@code LT(1)}. Goes from 0 to numtokens.
         */
        private _currentElementIndex;
        /**
         * This is the {@code LT(-1)} element for the first element in {@link #data}.
         */
        private _previousElement;
        /** Track object returned by nextElement upon end of stream;
         *  Return it later when they ask for LT passed end of input.
         */
        _eof: T;
        /** <summary>Track the last mark() call result value for use in rewind().</summary> */
        _lastMarker: number;
        /** <summary>tracks how deep mark() calls are nested</summary> */
        _markDepth: number;
        endOfFile: T;
        readonly previousElement: T;
        reset(): void;
        /**
         *  Implement nextElement to supply a stream of elements to this
         *  lookahead buffer.  Return EOF upon end of the stream we're pulling from.
         */
        nextElement(): T;
        isEndOfFile(o: T): boolean;
        /**
         * Get and remove first element in queue; override
         * {@link FastQueue#remove()}; it's the same, just checks for backtracking.
         */
        dequeue(): T;
        /**
         * Make sure we have at least one element to remove, even if EOF
         */
        consume(): void;
        /**
         *  Make sure we have 'need' elements from current position p. Last valid
         *  p index is data.size()-1.  p+need-1 is the data index 'need' elements
         *  ahead.  If we need 1 element, (p+1-1)==p must be &lt; data.size().
         */
        syncAhead(need: number): void;
        /**
         * add n elements to buffer
         */
        fill(n: number): void;
        /**
         * Size of entire stream is unknown; we only know buffer size from FastQueue
         */
        readonly count: number;
        lt(k: number): T;
        readonly index: number;
        mark(): number;
        release(marker: number): void;
        rewind2(marker: number): void;
        rewind(): void;
        /**
         * Seek to a 0-indexed absolute token index. Normally used to seek backwards
         * in the buffer. Does not force loading of nodes.
         * To preserve backward compatibility, this method allows seeking past the
         * end of the currently buffered data. In this case, the input pointer will
         * be moved but the data will only actually be loaded upon the next call to
         * {@link #consume} or {@link #LT} for {@code k>0}.
         */
        seek(index: number): void;
        lb(k: number): T;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Misc {
    class RegexOptionsHelper {
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import ITree = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITree;
    class AntlrRuntime_BaseTreeDebugView {
        private _tree;
        constructor(tree: BaseTree);
        readonly children: ITree[];
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     *  This is identical to the ParserRuleReturnScope except that
     *  the start property is a tree nodes not Token object
     *  when you are parsing trees.
     */
    class TreeRuleReturnScope<TTree> implements IRuleReturnScope<TTree> {
        private static ImplementsTreeRuleReturnScope;
        implements(): string[];
        private _start;
        /**
         * Gets the first node or root node of tree matched for this rule.
         */
        start: TTree;
        stop: TTree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class AstTreeRuleReturnScope<TOutputTree, TInputTree> extends TreeRuleReturnScope<TInputTree> implements IAstRuleReturnScope<TOutputTree>, IAstRuleReturnScope<any> {
        private static ImplementsAstTreeRuleReturnScope;
        implements(): string[];
        tree: TOutputTree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A generic tree implementation with no payload.  You must subclass to
     *  actually have any user data.  ANTLR v3 uses a list of children approach
     *  instead of the child-sibling approach in v2.  A flat tree (a list) is
     *  an empty node whose children represent the list.  An empty, but
     *  non-null node is called "nil".
     */
    class BaseTree implements ITree {
        private static ImplementsBaseTree;
        implements(): string[];
        /**
         *  Create a new node from an existing node does nothing for BaseTree
         *  as there are no fields other than the children list, which cannot
         *  be copied as the children are not considered part of this node.
         */
        constructor(node?: ITree);
        /**
         *  Get the children internal List; note that if you directly mess with
         *  the list, do so at your own risk.
         */
        children: List<ITree>;
        readonly childCount: number;
        /**
         * BaseTree doesn't track parent pointers.
         */
        parent: ITree;
        /**
         * BaseTree doesn't track child indexes.
         */
        childIndex: number;
        isNil: boolean;
        tokenStartIndex: number;
        tokenStopIndex: number;
        type: number;
        text: string;
        line: number;
        charPositionInLine: number;
        getChild(i: number): ITree;
        getFirstChildWithType(type: number): ITree;
        /**>
         * Add t as child of this node.
         *
         *  Warning: if t has no children, but child does
         *  and child isNil then this routine moves children to t via
         *  t.children = child.children; i.e., without copying the array.
         */
        addChild(t: ITree): void;
        /**
         * Add all elements of kids list as children of this node
         */
        addChildren(kids: List<ITree>): void;
        setChild(i: number, t: ITree): void;
        /**
         * Insert child t at child position i (0..n-1) by shifting children
         *  i+1..n-1 to the right one position. Set parent / indexes properly
         *  but does NOT collapse nil-rooted t's that come in here like addChild.
         */
        insertChild(i: number, t: ITree): void;
        deleteChild(i: number): any;
        /**
         *  Delete children from start to stop and replace with t even if t is
         *  a list (nil-root tree).  num of children can increase or decrease.
         *  For huge child lists, inserting children can force walking rest of
         *  children to set their childindex; could be slow.
         */
        replaceChildren(startChildIndex: number, stopChildIndex: number, t: any): void;
        /**
         * Override in a subclass to change the impl of children list
         */
        createChildrenList(): List<ITree>;
        /**
         * Set the parent and child index values for all child of t
         */
        freshenParentAndChildIndexes(offset?: number): void;
        freshenParentAndChildIndexesDeeply(offset?: number): void;
        sanityCheckParentAndChildIndexes(parent?: ITree, i?: number): void;
        /** Walk upwards looking for ancestor with this token type.</summary> */
        hasAncestor(ttype: number): boolean;
        /** Walk upwards and get first ancestor with this token type.</summary> */
        getAncestor(ttype: number): ITree;
        /**
         *  Return a list of all ancestors of this node.  The first node of
         *  list is the root and the last is the parent of this node.
         */
        getAncestors(): List<ITree>;
        /** Print out a whole tree not just a node</summary> */
        toStringTree(): string;
        /**
         * Override to say how a node (not a tree) should look as text
         */
        toString(): string;
        dupNode(): ITree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    /**
     * A TreeAdaptor that works with any Tree implementation.
     */
    class BaseTreeAdaptor implements ITreeAdaptor {
        private static ImplementsBaseTreeAdaptor;
        implements(): string[];
        /**
         *  System.identityHashCode() is not always unique; we have to
         *  track ourselves.  That's ok, it's only for debugging, though it's
         *  expensive: we have to create a hashtable with all tree nodes in it.
         */
        protected treeToUniqueIDMap: Dictionary<any, number>;
        protected uniqueNodeID: number;
        nil(): any;
        /**
         *  Create tree node that holds the start and stop tokens associated
         *  with an error.
         *
         *  If you specify your own kind of tree nodes, you will likely have to
         *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
         *  if no token payload but you might have to set token type for diff
         *  node type.
         *
         *  You don't have to subclass CommonErrorNode; you will likely need to
         *  subclass your own tree node class to avoid class cast exception.
         */
        errorNode(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException): any;
        isNil(tree: any): boolean;
        dupNode(type?: number, treeNode?: any, text?: string): any;
        /**
         *  This is generic in the sense that it will work with any kind of
         *  tree (not just ITree interface).  It invokes the adaptor routines
         *  not the tree node routines to do the construction.
         */
        dupTree(t: any, parent?: any): any;
        /**
         *  Add a child to the tree t.  If child is a flat tree (a list), make all
         *  in list children of t.  Warning: if t has no children, but child does
         *  and child isNil then you can decide it is ok to move children to t via
         *  t.children = child.children; i.e., without copying the array.  Just
         *  make sure that this is consistent with have the user will build
         *  ASTs.
         */
        addChild(t: any, child: any): void;
        /**
         *  If oldRoot is a nil root, just copy or move the children to newRoot.
         *  If not a nil root, make oldRoot a child of newRoot.
         *
         *    old=^(nil a b c), new=r yields ^(r a b c)
         *    old=^(a b c), new=r yields ^(r ^(a b c))
         *
         *  If newRoot is a nil-rooted single child tree, use the single
         *  child as the new root node.
         *
         *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
         *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
         *
         *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
         *
         *    old=null, new=r yields r
         *    old=null, new=^(nil r) yields ^(nil r)
         *
         *  Return newRoot.  Throw an exception if newRoot is not a
         *  simple node or nil root with a single child node--it must be a root
         *  node.  If newRoot is ^(nil x) return x as newRoot.
         *
         *  Be advised that it's ok for newRoot to point at oldRoot's
         *  children; i.e., you don't have to copy the list.  We are
         *  constructing these nodes so we should have this control for
         *  efficiency.
         */
        becomeRoot(newRoot: any, oldRoot: any): any;
        /**
         * Transform ^(nil x) to x and nil to null
         */
        rulePostProcessing(root: any): any;
        becomeRoot2(newRoot: IToken, oldRoot: any): any;
        create5(tokenType: number, fromToken: IToken): any;
        create2(tokenType: number, fromToken: IToken, text: string): any;
        create3(fromToken: IToken, text: string): any;
        create4(tokenType: number, text: string): any;
        getType(t: number): number;
        setType(t: any, type: number): void;
        getText(t: any): string;
        setText(t: any, text: string): void;
        getChild(t: any, i: number): any;
        setChild(t: any, i: number, child: any): void;
        deleteChild(t: any, i: number): any;
        getChildCount(t: any): number;
        getUniqueID(node: any): number;
        /**
         *  Tell me how to create a token for use with imaginary token nodes.
         *  For example, there is probably no input symbol associated with imaginary
         *  token DECL, but you need to create it as a payload or whatever for
         *  the DECL node as in ^(DECL type ID).
         *
         *  If you care what the token payload objects' type is, you should
         *  override this method and any other createToken variant.
         */
        createToken2(tokenType: number, text: string): IToken;
        /**
         *  Tell me how to create a token for use with imaginary token nodes.
         *  For example, there is probably no input symbol associated with imaginary
         *  token DECL, but you need to create it as a payload or whatever for
         *  the DECL node as in ^(DECL type ID).
         *
         *  This is a variant of createToken where the new token is derived from
         *  an actual real input token.  Typically this is for converting '{'
         *  tokens to BLOCK etc...  You'll see
         *
         *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
         *
         *  If you care what the token payload objects' type is, you should
         *  override this method and any other createToken variant.
         */
        createToken(fromToken: IToken): IToken;
        create(payload: IToken): any;
        /**
         *  Duplicate a node.  This is part of the factory;
         *  override if you want another kind of node to be built.
         *
         *  I could use reflection to prevent having to override this
         *  but reflection is slow.
         */
        dupNode2(treeNode: any): any;
        getToken(t: any): IToken;
        /**
         *  Track start/stop token for subtree root created for a rule.
         *  Only works with Tree nodes.  For rules that match nothing,
         *  seems like this will yield start=i and stop=i-1 in a nil node.
         *  Might be useful info so I'll not force to be i..i.
         */
        setTokenBoundaries(t: any, startToken: IToken, stopToken: IToken): void;
        getTokenStartIndex(t: any): number;
        getTokenStopIndex(t: any): number;
        getParent(t: any): any;
        setParent(t: any, parent: any): any;
        getChildIndex(t: any): number;
        setChildIndex(t: any, index: number): void;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        getTree(t: any): ITree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    import Stack = Stimulsoft.System.Collections.Stack;
    /**
     *  A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.
     *
     *  This node stream sucks all nodes out of the tree specified in
     *  the constructor during construction and makes pointers into
     *  the tree using an array of Object pointers. The stream necessarily
     *  includes pointers to DOWN and UP and EOF nodes.
     *
     *  This stream knows how to mark/release for backtracking.
     *
     *  This stream is most suitable for tree interpreters that need to
     *  jump around a lot or for tree parsers requiring speed (at cost of memory).
     *  There is some duplicated functionality here with UnBufferedTreeNodeStream
     *  but just in bookkeeping, not tree walking etc...
     *
     *  TARGET DEVELOPERS:
     *
     *  This is the old CommonTreeNodeStream that buffered up entire node stream.
     *  No need to implement really as new CommonTreeNodeStream is much better
     *  and covers what we need.
     *
     *  @see CommonTreeNodeStream
     */
    class BufferedTreeNodeStream implements ITreeNodeStream, ITokenStreamInformation {
        private static ImplementsBufferedTreeNodeStream;
        implements(): string[];
        DEFAULT_INITIAL_BUFFER_SIZE: number;
        INITIAL_CALL_STACK_SIZE: number;
        down: any;
        up: any;
        eof: any;
        /**
         *  The complete mapping from stream index to tree node.
         *  This buffer includes pointers to DOWN, UP, and EOF nodes.
         *  It is built upon ctor invocation.  The elements are type
         *  Object as we don't what the trees look like.
         *
         *  Load upon first need of the buffer so we can set token types
         *  of interest for reverseIndexing.  Slows us down a wee bit to
         *  do all of the if p==-1 testing everywhere though.
         */
        nodes: List<any>;
        /**
         * Pull nodes from which tree?
         */
        protected root: any;
        /**
         * IF this tree (root) was created from a token stream, track it.
         */
        protected tokens: ITokenStream;
        /**
         * What tree adaptor was used to build these trees
         */
        adaptor: ITreeAdaptor;
        /**
         * Reuse same DOWN, UP navigation nodes unless this is true
         */
        uniqueNavigationNodes: boolean;
        /**
         *  The index into the nodes list of the current node (next node
         *  to consume).  If -1, nodes array not filled yet.
         */
        protected p: number;
        /**
         * Track the last mark() call result value for use in rewind().
         */
        protected lastMarker: number;
        /**
         * Stack of indexes used for push/pop calls
         */
        protected calls: Stack<number>;
        constructor(adaptor?: ITreeAdaptor, tree?: any, initialBufferSize?: number);
        readonly count: number;
        readonly treeSource: any;
        readonly sourceName: string;
        tokenStream: ITokenStream;
        treeAdaptor: ITreeAdaptor;
        readonly lastToken: IToken;
        readonly lastRealToken: IToken;
        maxLookBehind: number;
        /**
         *  Walk tree with depth-first-search and fill nodes buffer.
         *  Don't do DOWN, UP nodes if its a list (t is isNil).
         */
        fillBuffer(): void;
        fillBuffer2(t: any): void;
        /**
         *  What is the stream index for node? 0..n-1
         *  Return -1 if node not found.
         */
        protected getNodeIndex(node: any): number;
        /**
         *  As we flatten the tree, we use UP, DOWN nodes to represent
         *  the tree structure.  When debugging we need unique nodes
         *  so instantiate new ones when uniqueNavigationNodes is true.
         */
        protected addNavigationNode(ttype: number): void;
        get(i: number): any;
        lt(k: number): any;
        getCurrentSymbol(): any;
        /**
         * Look backwards k nodes
         */
        protected lb(k: number): any;
        consume(): void;
        la(i: number): number;
        mark(): number;
        release(marker: number): void;
        readonly index: number;
        rewind2(marker: number): void;
        rewind(): void;
        seek(index: number): void;
        /**
         *  Make stream jump to a new location, saving old location.
         *  Switch back with pop().
         */
        push(index: number): void;
        /**
         *  Seek back to previous index saved during last push() call.
         *  Return top of stack (return index).
         */
        pop(): number;
        reset(): void;
        iterator(): List<any>;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        /**
         * Used for testing, just return the token type stream
         */
        toTokenTypeString(): string;
        toTokenString(start: number, stop: number): string;
        toString(start: any, stop: any): string;
    }
    class StreamIterator extends List<any> {
        _outer: BufferedTreeNodeStream;
        _index: number;
        constructor(outer: BufferedTreeNodeStream);
        readonly current: any;
        dispose(): void;
        moveNext(): boolean;
        reset(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     *  A tree node that is wrapper for a Token object.  After 3.0 release
     *  while building tree rewrite stuff, it became clear that computing
     *  parent and child index is very difficult and cumbersome.  Better to
     *  spend the space in every tree node.  If you don't want these extra
     *  fields, it's easy to cut them out in your own BaseTree subclass.
     */
    class CommonTree extends BaseTree {
        /**
         * A single token is the payload
         */
        private _token;
        /**
         *  What token indexes bracket all tokens associated with this node
         *  and below?
         */
        protected startIndex: number;
        protected stopIndex: number;
        /**
         * Who is the parent node of this node; if null, implies node is root
         */
        parent: CommonTree;
        /**
         * What index is this node in the child list? Range: 0..n-1
         */
        childIndex: number;
        constructor(node?: CommonTree | IToken);
        readonly isNil: boolean;
        readonly text: string;
        token: IToken;
        tokenStartIndex: number;
        tokenStopIndex: number;
        readonly type: number;
        dupNode(): ITree;
        /**
         *  For every node in this subtree, make sure it's start/stop token's
         *  are set.  Walk depth first, visit bottom up.  Only updates nodes
         *  with at least one token index &lt; 0.
         */
        setUnknownTokenBoundaries(): void;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     * A node representing erroneous token range in token stream
     */
    class CommonErrorNode extends CommonTree {
        input: IIntStream;
        start: IToken;
        stop: IToken;
        trappedException: RecognitionException;
        constructor(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException);
        isNil: boolean;
        readonly text: string;
        readonly type: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     *  A TreeAdaptor that works with any Tree implementation.  It provides
     *  really just factory methods; all the work is done by BaseTreeAdaptor.
     *  If you would like to have different tokens created than ClassicToken
     *  objects, you need to override this and then set the parser tree adaptor to
     *  use your subclass.
     *
     *  To get your parser to build nodes of a different type, override
     *  create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
     *  dupNode is called to duplicate nodes during rewrite operations.
     */
    class CommonTreeAdaptor extends BaseTreeAdaptor {
        create(payload: IToken): CommonTree;
        /**
         *  Tell me how to create a token for use with imaginary token nodes.
         *  For example, there is probably no input symbol associated with imaginary
         *  token DECL, but you need to create it as a payload or whatever for
         *  the DECL node as in ^(DECL type ID).
         *
         *  If you care what the token payload objects' type is, you should
         *  override this method and any other createToken variant.
         */
        createToken2(tokenType: number, text: string): IToken;
        /**
         *  Tell me how to create a token for use with imaginary token nodes.
         *  For example, there is probably no input symbol associated with imaginary
         *  token DECL, but you need to create it as a payload or whatever for
         *  the DECL node as in ^(DECL type ID).
         *
         *  This is a variant of createToken where the new token is derived from
         *  an actual real input token.  Typically this is for converting '{'
         *  tokens to BLOCK etc...  You'll see
         *
         *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
         *
         *  If you care what the token payload objects' type is, you should
         *  override this method and any other createToken variant.
         */
        createToken(fromToken: IToken): IToken;
        /**
         *  What is the Token associated with this node?  If
         *  you are not using CommonTree, then you must
         *  override this in your own adaptor.
         */
        getToken(t: any): IToken;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class CommonTreeNodeStream extends Misc.LookaheadStream<any> implements ITreeNodeStream, IPositionTrackingStream {
        private static ImplementsCommonTreeNodeStream;
        implements(): string[];
        DEFAULT_INITIAL_BUFFER_SIZE: number;
        INITIAL_CALL_STACK_SIZE: number;
        /**
         * Pull nodes from which tree?
         */
        private _root;
        /**
         * If this tree (root) was created from a token stream, track it.
         */
        protected tokens: ITokenStream;
        /**
         * What tree adaptor was used to build these trees
         */
        private _adaptor;
        /**
         * The tree iterator we are using
         */
        private _it;
        /**
         * Stack of indexes used for push/pop calls
         */
        private _calls;
        /**
         * Tree (nil A B C) trees like flat A B C streams
         */
        private _hasNilRoot;
        /**
         * Tracks tree depth.  Level=0 means we're at root node level.
         */
        private _level;
        /**
         * Tracks the last node before the start of {@link #data} which contains
         * position information to provide information for error reporting. This is
         * tracked in addition to {@link #prevElement} which may or may not contain
         * position information.
         *
         * @see #hasPositionInformation
         * @see RecognitionException#extractInformationFromTreeNodeStream
         */
        private _previousLocationElement;
        constructor(adaptor: ITreeAdaptor, tree: any);
        readonly sourceName: string;
        tokenStream: ITokenStream;
        treeAdaptor: ITreeAdaptor;
        readonly treeSource: any;
        uniqueNavigationNodes: boolean;
        reset(): void;
        nextElement(): any;
        dequeue(): any;
        isEndOfFile(o: any): boolean;
        la(i: number): number;
        /**
         *  Make stream jump to a new location, saving old location.
         *  Switch back with pop().
         */
        push(index: number): void;
        /**
         *  Seek back to previous index saved during last push() call.
         *  Return top of stack (return index).
         */
        pop(): number;
        /**
         * Returns an element containing position information. If {@code allowApproximateLocation} is {@code false}, then
         * this method will return the {@code LT(1)} element if it contains position information, and otherwise return {@code null}.
         * If {@code allowApproximateLocation} is {@code true}, then this method will return the last known element containing position information.
         *
         * @see #hasPositionInformation
         */
        getKnownPositionElement(allowApproximateLocation: boolean): any;
        hasPositionInformation(node: any): boolean;
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): void;
        toString1(start: any, stop: any): string;
        /**
         * For debugging; destructive: moves tree iterator to end.
         */
        toTokenTypeString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A utility class to generate DOT diagrams (graphviz) from
     *  arbitrary trees.  You can pass in your own templates and
     *  can pass in any kind of tree or use Tree interface method.
     *  I wanted this separator so that you don't have to include
     *  ST just to use the org.antlr.runtime.tree.* package.
     *  This is a set of non-static methods so you can subclass
     *  to override.  For example, here is an invocation:
     *
     *      CharStream input = new ANTLRInputStream(System.in);
     *      TLexer lex = new TLexer(input);
     *      CommonTokenStream tokens = new CommonTokenStream(lex);
     *      TParser parser = new TParser(tokens);
     *      TParser.e_return r = parser.e();
     *      Tree t = (Tree)r.tree;
     *      System.out.println(t.toStringTree());
     *      DOTTreeGenerator gen = new DOTTreeGenerator();
     *      StringTemplate st = gen.toDOT(t);
     *      System.out.println(st);
     */
    class DotTreeGenerator {
        headerLines: string[];
        footer: string;
        nodeFormat: string;
        edgeFormat: string;
        /**
         * Track node to number mapping so we can get proper node name back
         */
        nodeToNumberMap: Dictionary<any, number>;
        /**
         * Track node number so we can get unique node names
         */
        nodeNumber: number;
        /**
         *  Generate DOT (graphviz) for a whole tree not just a node.
         *  For example, 3+4*5 should generate:
         *
         * digraph {
         *   node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
         *         width=.4, height=.2];
         *   edge [arrowsize=.7]
         *   "+"->3
         *   "+"->"*"
         *   "*"->4
         *   "*"->5
         * }
         *
         * Takes a Tree interface object.
         */
        toDot2(tree: any, adaptor: ITreeAdaptor): string;
        toDot(tree: ITree): string;
        protected defineNodes(tree: any, adaptor: ITreeAdaptor): List<string>;
        defineEdges(tree: any, adaptor: ITreeAdaptor): List<string>;
        protected getNodeText(adaptor: ITreeAdaptor, t: any): string;
        protected getNodeNumber(t: any): number;
        protected fixString(text: string): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     * @author Sam Harwell
     */
    var IPositionTrackingStream: string;
    interface IPositionTrackingStream {
        /**
         * Returns an element containing concrete information about the current
         * position in the stream.
         *
         * @param allowApproximateLocation if {@code false}, this method returns
         * {@code null} if an element containing exact information about the current
         * position is not available
         */
        getKnownPositionElement(allowApproximateLocation: boolean): any;
        /**
         * Determines if the specified {@code element} contains concrete position
         * information.
         *
         * @param element the element to check
         * @return {@code true} if {@code element} contains concrete position
         * information, otherwise {@code false}
         */
        hasPositionInformation(element: any): boolean;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  What does a tree look like?  ANTLR has a number of support classes
     *  such as CommonTreeNodeStream that work on these kinds of trees.  You
     *  don't have to make your trees implement this interface, but if you do,
     *  you'll be able to use more support code.
     *
     *  NOTE: When constructing trees, ANTLR can build any kind of tree; it can
     *  even use Token objects as trees if you add a child list to your tokens.
     *
     *  This is a tree node without any payload; just navigation and factory stuff.
     */
    var ITree: string;
    interface ITree {
        getChild(i: number): ITree;
        childCount: number;
        parent: ITree;
        /**
         * Is there is a node above with token type ttype?
         */
        hasAncestor(ttype: number): boolean;
        /**
         * Walk upwards and get first ancestor with this token type.
         */
        getAncestor(ttype: number): ITree;
        /**
         *  Return a list of all ancestors of this node.  The first node of
         *  list is the root and the last is the parent of this node.
         */
        getAncestors(): List<ITree>;
        /**
         * This node is what child index? 0..n-1
         */
        childIndex: number;
        /**
         * Set the parent and child index values for all children
         */
        freshenParentAndChildIndexes(): any;
        /**
         *  Add t as a child to this node.  If t is null, do nothing.  If t
         *  is nil, add all children of t to this' children.
         */
        addChild(t: ITree): any;
        /**
         * Set ith child (0..n-1) to t; t must be non-null and non-nil node
         */
        setChild(i: number, t: ITree): any;
        deleteChild(i: number): any;
        /**
         *  Delete children from start to stop and replace with t even if t is
         *  a list (nil-root tree).  num of children can increase or decrease.
         *  For huge child lists, inserting children can force walking rest of
         *  children to set their childindex; could be slow.
         */
        replaceChildren(startChildIndex: number, stopChildIndex: number, t: any): any;
        /**
         *  Indicates the node is a nil node but may still have children, meaning
         *  the tree is a flat list.
         */
        isNil: boolean;
        /**
         *  What is the smallest token index (indexing from 0) for this node
         *  and its children?
         */
        tokenStartIndex: number;
        /**
         *  What is the largest token index (indexing from 0) for this node
         *  and its children?
         */
        tokenStopIndex: number;
        dupNode(): ITree;
        /**
         * Return a token type; needed for tree parsing
         */
        type: number;
        text: string;
        /**
         * In case we don't have a token payload, what is the line for errors?
         */
        line: number;
        charPositionInLine: number;
        toStringTree(): string;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     *  How to create and navigate trees.  Rather than have a separate factory
     *  and adaptor, I've merged them.  Makes sense to encapsulate.
     *
     *  This takes the place of the tree construction code generated in the
     *  generated code in 2.x and the ASTFactory.
     *
     *  I do not need to know the type of a tree at all so they are all
     *  generic Objects.  This may increase the amount of typecasting needed. :(
     */
    var ITreeAdaptor: string;
    interface ITreeAdaptor {
        /**
         *  Create a tree node from Token object; for CommonTree type trees,
         *  then the token just becomes the payload.  This is the most
         *  common create call.
         *
         *  Override if you want another kind of node to be built.
         */
        create(payload: IToken): any;
        /**
         *  Create a new node derived from a token, with a new token type.
         *  This is invoked from an imaginary node ref on right side of a
         *  rewrite rule as IMAG[$tokenLabel].
         *
         *  This should invoke createToken(Token).
         */
        /**
         *  Same as create(tokenType,fromToken) except set the text too.
         *  This is invoked from an imaginary node ref on right side of a
         *  rewrite rule as IMAG[$tokenLabel, "IMAG"].
         *
         *  This should invoke createToken(Token).
         */
        create2(tokenType: number, fromToken: IToken, text: string): any;
        /**
         *  Same as create(fromToken) except set the text too.
         *  This is invoked when the <c>text</c> terminal option is set, as in
         *  IMAG&lt;text='IMAG'&gt;.
         *
         *  This should invoke createToken(Token).
         */
        create3(fromToken: IToken, text: string): any;
        /**
         *  Create a new node derived from a token, with a new token type.
         *  This is invoked from an imaginary node ref on right side of a
         *  rewrite rule as IMAG["IMAG"].
         *
         *  This should invoke createToken(int,String).
         */
        create4(tokenType: number, text: string): any;
        /**
         * Duplicate a single tree node.
         * Override if you want another kind of node to be built.
         */
        dupNode2(treeNode: any): any;
        dupNode(type?: number, treeNode?: any, text?: string): any;
        /**
         * Duplicate tree recursively, using dupNode() for each node
         */
        dupTree(tree: any): any;
        /**
         *  Return a nil node (an empty but non-null node) that can hold
         *  a list of element as the children.  If you want a flat tree (a list)
         *  use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
         */
        nil(): any;
        /**
         *  Return a tree node representing an error.  This node records the
         *  tokens consumed during error recovery.  The start token indicates the
         *  input symbol at which the error was detected.  The stop token indicates
         *  the last symbol consumed during recovery.
         *
         *  You must specify the input stream so that the erroneous text can
         *  be packaged up in the error node.  The exception could be useful
         *  to some applications; default implementation stores ptr to it in
         *  the CommonErrorNode.
         *
         *  This only makes sense during token parsing, not tree parsing.
         *  Tree parsing should happen only when parsing and tree construction
         *  succeed.
         */
        errorNode(input: ITokenStream, start: IToken, stop: IToken, e: RecognitionException): any;
        /**
         * Is tree considered a nil node used to make lists of child nodes?
         */
        isNil(tree: any): boolean;
        /**
         *  Add a child to the tree t.  If child is a flat tree (a list), make all
         *  in list children of t.  Warning: if t has no children, but child does
         *  and child isNil then you can decide it is ok to move children to t via
         *  t.children = child.children; i.e., without copying the array.  Just
         *  make sure that this is consistent with have the user will build
         *  ASTs.  Do nothing if t or child is null.
         */
        addChild(t: any, child: any): any;
        /**
         *  If oldRoot is a nil root, just copy or move the children to newRoot.
         *  If not a nil root, make oldRoot a child of newRoot.
         *
         *    old=^(nil a b c), new=r yields ^(r a b c)
         *    old=^(a b c), new=r yields ^(r ^(a b c))
         *
         *  If newRoot is a nil-rooted single child tree, use the single
         *  child as the new root node.
         *
         *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
         *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
         *
         *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
         *
         *    old=null, new=r yields r
         *    old=null, new=^(nil r) yields ^(nil r)
         *
         *  Return newRoot.  Throw an exception if newRoot is not a
         *  simple node or nil root with a single child node--it must be a root
         *  node.  If newRoot is ^(nil x) return x as newRoot.
         *
         *  Be advised that it's ok for newRoot to point at oldRoot's
         *  children; i.e., you don't have to copy the list.  We are
         *  constructing these nodes so we should have this control for
         *  efficiency.
         */
        becomeRoot(newRoot: any, oldRoot: any): any;
        /**
         *  Given the root of the subtree created for this rule, post process
         *  it to do any simplifications or whatever you want.  A required
         *  behavior is to convert ^(nil singleSubtree) to singleSubtree
         *  as the setting of start/stop indexes relies on a single non-nil root
         *  for non-flat trees.
         *
         *  Flat trees such as for lists like "idlist : ID+ ;" are left alone
         *  unless there is only one ID.  For a list, the start/stop indexes
         *  are set in the nil node.
         *
         *  This method is executed after all rule tree construction and right
         *  before setTokenBoundaries().
         */
        rulePostProcessing(root: any): any;
        /**
         * For identifying trees.
         *
         *  How to identify nodes so we can say "add node to a prior node"?
         *  Even becomeRoot is an issue.  Use System.identityHashCode(node)
         *  usually.
         */
        getUniqueID(node: any): number;
        /**
         *  Create a node for newRoot make it the root of oldRoot.
         *  If oldRoot is a nil root, just copy or move the children to newRoot.
         *  If not a nil root, make oldRoot a child of newRoot.
         *
         *  @returns Return node created for newRoot.
         *
         *  Be advised: when debugging ASTs, the DebugTreeAdaptor manually
         *  calls create(Token child) and then plain becomeRoot(node, node)
         *  because it needs to trap calls to create, but it can't since it delegates
         *  to not inherits from the TreeAdaptor.
         */
        becomeRoot(newRoot: IToken, oldRoot: any): any;
        /**
         * For tree parsing, I need to know the token type of a node
         */
        getType(t: any): number;
        /**
         * Node constructors can set the type of a node
         */
        setType(t: any, type: number): any;
        getText(t: any): string;
        /**
         * Node constructors can set the text of a node
         */
        setText(t: any, text: string): any;
        /**
         *  Return the token object from which this node was created.
         *  Currently used only for printing an error message.
         *  The error display routine in BaseRecognizer needs to
         *  display where the input the error occurred. If your
         *  tree of limitation does not store information that can
         *  lead you to the token, you can create a token filled with
         *  the appropriate information and pass that back.  See
         *  BaseRecognizer.getErrorMessage().
         */
        getToken(t: any): IToken;
        /**
         *  Where are the bounds in the input token stream for this node and
         *  all children?  Each rule that creates AST nodes will call this
         *  method right before returning.  Flat trees (i.e., lists) will
         *  still usually have a nil root node just to hold the children list.
         *  That node would contain the start/stop indexes then.
         */
        setTokenBoundaries(t: any, startToken: IToken, stopToken: IToken): any;
        /** Get the token start index for this subtree; return -1 if no such index */
        getTokenStartIndex(t: any): number;
        /** Get the token stop index for this subtree; return -1 if no such index */
        getTokenStopIndex(t: any): number;
        /**
         * Get a child 0..n-1 node
         */
        getChild(t: any, i: number): any;
        /**
         * Set ith child (0..n-1) to t; t must be non-null and non-nil node
         */
        setChild(t: any, i: number, child: any): any;
        /**
         * Remove ith child and shift children down from right.
         */
        deleteChild(t: any, i: number): any;
        /** How many children?  If 0, then this is a leaf node */
        getChildCount(t: any): number;
        /**
         *  Who is the parent node of this node; if null, implies node is root.
         *  If your node type doesn't handle this, it's ok but the tree rewrites
         *  in tree parsers need this functionality.
         */
        getParent(t: any): any;
        setParent(t: any, parent: any): any;
        /**
         *  What index is this node in the child list? Range: 0..n-1
         *  If your node type doesn't handle this, it's ok but the tree rewrites
         *  in tree parsers need this functionality.
         */
        getChildIndex(t: any): number;
        setChildIndex(t: any, index: number): any;
        /**
         *  Replace from start to stop child index of parent with t, which might
         *  be a list.  Number of children may be different after this call.
         *
         *  If parent is null, don't do anything; must be at root of overall tree.
         *  Can't replace whatever points to the parent externally.  Do nothing.
         */
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     * A stream of tree nodes, accessing nodes from a tree of some kind
     */
    var ITreeNodeStream: string;
    interface ITreeNodeStream extends IIntStream {
        /**
         *  Get a tree node at an absolute index i; 0..n-1.
         *  If you don't want to buffer up nodes, then this method makes no
         *  sense for you.
         */
        get(i: number): ITreeNodeStream;
        /**
         * Get tree node at current input pointer + <paramref name="k"/> ahead where
         * <paramref name="k"/>==1 is next node. <paramref name="k"/>&lt;0 indicates nodes in the past. So
         * {@code LT(-1)} is previous node, but implementations are not required to
         * provide results for <paramref name="k"/> &lt; -1. {@code LT(0)} is undefined. For
         * <paramref name="k"/>&lt;=n, return <see langword="null"/>. Return <see langword="null"/> for {@code LT(0)}
         * and any index that results in an absolute address that is negative.
         *
         * This is analogous to <see cref="ITokenStream.LT(int)"/>, but this returns a tree node
         * instead of a <see cref="IToken"/>. Makes code generation identical for both
         * parser and tree grammars.
         */
        lt(k: number): any;
        /**
         *  Where is this stream pulling nodes from?  This is not the name, but
         *  the object that provides node objects.
         */
        treeSource: any;
        /**
         * If the tree associated with this stream was created from a
         * {@link TokenStream}, you can specify it here. Used to do rule
         * {@code $text} attribute in tree parser. Optional unless you use tree
         * parser rule {@code $text} attribute or {@code output=template} and
         * {@code rewrite=true} options.
         */
        tokenStream: ITokenStream;
        /**
         *  What adaptor can tell me how to interpret/navigate nodes and
         *  trees.  E.g., get text of a node.
         */
        treeAdaptor: ITreeAdaptor;
        /**
         * As we flatten the tree, we use {@link Token#UP}, {@link Token#DOWN} nodes
         * to represent the tree structure. When debugging we need unique nodes so
         * we have to instantiate new ones. When doing normal tree parsing, it's
         * slow and a waste of memory to create unique navigation nodes. Default
         * should be {@code false}.
         */
        uniqueNavigationNodes: boolean;
        /**
         * Return the text of all nodes from {@code start} to {@code stop},
         * inclusive. If the stream does not buffer all the nodes then it can still
         * walk recursively from start until stop. You can always return
         * {@code null} or {@code ""} too, but users should not access
         * {@code $ruleLabel.text} in an action of course in that case.
         */
        toString(start: any, stop: any): string;
        /**
         * Replace children of {@code parent} from index {@code startChildIndex} to
         * {@code stopChildIndex} with {@code t}, which might be a list. Number of
         * children may be different after this call. The stream is notified because
         * it is walking the tree and might need to know you are monkeying with the
         * underlying tree. Also, it might be able to modify the node stream to
         * avoid restreaming for future phases.
         *
         * If {@code parent} is {@code null}, don't do anything; must be at root of
         * overall tree. Can't replace whatever points to the parent externally. Do
         * nothing.
         */
        replaceChildren(parent: any, startChildIndex: number, stopChildIndex: number, t: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     *  How to execute code for node t when a visitor visits node t.  Execute
     *  pre() before visiting children and execute post() after visiting children.
     */
    var ITreeVisitorAction: string;
    interface ITreeVisitorAction {
        /**
         *  Execute an action before visiting children of t.  Return t or
         *  a rewritten t.  It is up to the visitor to decide what to do
         *  with the return value.  Children of returned value will be
         *  visited if using TreeVisitor.visit().
         */
        pre(t: any): any;
        /**
         *  Execute an action after visiting children of t.  Return t or
         *  a rewritten t.  It is up to the visitor to decide what to do
         *  with the return value.
         */
        post(t: any): any;
    }
    class TreeVisitorAction implements ITreeVisitorAction {
        private static ImplementsTreeVisitorAction;
        implements(): string[];
        pre(t: any): any;
        post(t: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A record of the rules used to match a token sequence.  The tokens
     *  end up as the leaves of this tree and rule nodes are the interior nodes.
     *  This really adds no functionality, it is just an alias for CommonTree
     *  that is more meaningful (specific) and holds a String to display for a node.
     */
    class ParseTree extends BaseTree {
        payload: any;
        hiddenTokens: List<IToken>;
        constructor(label: any);
        readonly text: string;
        tokenStartIndex: number;
        tokenStopIndex: number;
        type: number;
        dupNode(): ITree;
        toString(): string;
        /**
         *  Emit a token and all hidden nodes before.  EOF node holds all
         *  hidden tokens after last real token.
         */
        toStringWithHiddenTokens(): string;
        /**
         *  Print out the leaves of this tree, which means printing original
         *  input back out.
         */
        toInputString(): string;
        protected toStringLeaves(buf: string): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    /**
     *  Base class for all exceptions thrown during AST rewrite construction.
     *  This signifies a case where the cardinality of two or more elements
     *  in a subrule are different: (ID INT)+ where |ID|!=|INT|
     */
    class RewriteCardinalityException extends Exception {
        private _elementDescription;
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    /**
     * No elements within a (...)+ in a rewrite rule
     */
    class RewriteEarlyExitException extends RewriteCardinalityException {
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Exception = Stimulsoft.System.Exception;
    /**
     * Ref to ID or expr but no tokens in ID stream or subtrees in expr stream
     */
    class RewriteEmptyStreamException extends RewriteCardinalityException {
        constructor(message?: string, elementDescription?: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A generic list of elements tracked in an alternative to be used in
     *  a -> rewrite rule.  We need to subclass to fill in the next() method,
     *  which returns either an AST node wrapped around a token payload or
     *  an existing subtree.
     *
     *  Once you start next()ing, do not try to add more elements.  It will
     *  break the cursor tracking I believe.
     *
     *  TODO: add mechanism to detect/puke on modification after reading from stream
     *
     *  <see cref="RewriteRuleSubtreeStream"/>
     *  <see cref="RewriteRuleTokenStream"/>
     */
    class RewriteRuleElementStream {
        /**
         *  Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
         *  which bumps it to 1 meaning no more elements.
         */
        protected cursor: number;
        /**
         * Track single elements w/o creating a list.  Upon 2nd add, alloc list
         */
        protected singleElement: any;
        /**
         * The list of tokens or subtrees we are tracking
         */
        protected elements: List<any>;
        /**
         *  Once a node / subtree has been used in a stream, it must be dup'd
         *  from then on.  Streams are reset after subrules so that the streams
         *  can be reused in future subrules.  So, reset must set a dirty bit.
         *  If dirty, then next() always returns a dup.
         */
        protected dirty: boolean;
        /**
         *  The element or stream description; usually has name of the token or
         *  rule reference that this list tracks.  Can include rulename too, but
         *  the exception would track that info.
         */
        protected elementDescription: string;
        protected adaptor: ITreeAdaptor;
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        /**
         *  Reset the condition of this stream so that it appears we have
         *  not consumed any of its elements.  Elements themselves are untouched.
         *  Once we reset the stream, any future use will need duplicates.  Set
         *  the dirty bit.
         */
        reset(): void;
        add(el: any): void;
        /**
         *  Return the next element in the stream.  If out of elements, throw
         *  an exception unless size()==1.  If size is 1, then return elements[0].
         *  Return a duplicate node/subtree if stream is out of elements and
         *  size==1.  If we've already used the element, dup (dirty bit set).
         */
        nextTree(): any;
        /**
         *  Do the work of getting the next element, making sure that it's
         *  a tree node or subtree.  Deal with the optimization of single-
         *  element list versus list of size > 1.  Throw an exception
         *  if the stream is empty or we're out of elements and size>1.
         *  protected so you can override in a subclass if necessary.
         */
        nextCore(): any;
        /**
         *  When constructing trees, sometimes we need to dup a token or AST
         * 	subtree.  Dup'ing a token means just creating another AST node
         *  around it.  For trees, you must call the adaptor.dupTree() unless
         *  the element is for a tree root; then it must be a node dup.
         */
        protected dup(el: any): any;
        /**
         *  Ensure stream emits trees; tokens must be converted to AST nodes.
         *  AST nodes can be passed through unmolested.
         */
        protected toTree(el: any): any;
        readonly hasNext: boolean;
        readonly count: number;
        readonly description: string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  Queues up nodes matched on left side of -> in a tree parser. This is
     *  the analog of RewriteRuleTokenStream for normal parsers.
     */
    class RewriteRuleNodeStream extends RewriteRuleElementStream {
        /**
         * Create a stream, but feed off an existing list
         */
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        nextNode(): any;
        protected toTree(el: any): any;
        protected dup(el: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class RewriteRuleSubtreeStream extends RewriteRuleElementStream {
        /**
         * Create a stream, but feed off an existing list
         */
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        /**
         *  Treat next element as a single node even if it's a subtree.
         *  This is used instead of next() when the result has to be a
         *  tree root node.  Also prevents us from duplicating recently-added
         *  children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
         *  must dup the type node, but ID has been added.
         *
         *  Referencing a rule result twice is ok; dup entire tree as
         *  we can't be adding trees as root; e.g., expr expr.
         *
         *  Hideous code duplication here with super.next().  Can't think of
         *  a proper way to refactor.  This needs to always call dup node
         *  and super.next() doesn't know which to call: dup node or dup tree.
         */
        nextNode(): any;
        protected dup(el: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    class RewriteRuleTokenStream extends RewriteRuleElementStream {
        /**
         * Create a stream, but feed off an existing list
         */
        constructor(adaptor: ITreeAdaptor, elementDescription: string, oneElement?: any, elements?: List<any>);
        /**
         * Get next token from stream and make a node for it
         */
        nextNode(): any;
        nextToken(): IToken;
        /**
         *  Don't convert to a tree unless they explicitly call nextTree.
         *  This way we can do hetero tree nodes in rewrite.
         */
        toTree(el: any): any;
        protected dup(el: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TemplateTreeRuleReturnScope<TTemplate, TTree> extends TreeRuleReturnScope<TTree> implements ITemplateRuleReturnScope<TTemplate>, ITemplateRuleReturnScope<any> {
        private static ImplementsTemplateTreeRuleReturnScope;
        implements(): string[];
        template: TTemplate;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A generic recognizer that can handle recognizers generated from
     *  lexer, parser, and tree grammars.  This is all the parsing
     *  support code essentially; most of it is error recovery stuff and
     *  backtracking.
     */
    class BaseRecognizer {
        memoRuleFailed: number;
        memoRuleUnknown: number;
        static initialFollowStackSize: number;
        defaultTokenChannel: number;
        hidden: number;
        nextTokenRuleName: string;
        /**
         *  State of a lexer, parser, or tree parser are collected into a this.state
         *  object so the this.state can be shared.  This sharing is needed to
         *  have one grammar import others and share same error variables
         *  and other this.state variables.  It's a kind of explicit multiple
         *  inheritance via delegation of methods and shared this.state.
         */
        state: RecognizerSharedState;
        constructor(state?: RecognizerSharedState);
        setState(value: RecognizerSharedState): void;
        protected initDFAs(): void;
        /**
         * reset the parser's this.state; subclasses must rewinds the input stream
         */
        reset(): void;
        /**
         *  Match current input symbol against ttype.  Attempt
         *  single token insertion or deletion error recovery.  If
         *  that fails, throw MismatchedTokenException.
         *
         *  To turn off single token insertion or deletion error
         *  recovery, override recoverFromMismatchedToken() and have it
         *  throw an exception. See TreeParser.recoverFromMismatchedToken().
         *  This way any error in a rule will cause an exception and
         *  immediate exit from rule.  Rule would recover by resynchronizing
         *  to the set of symbols that can follow rule ref.
         */
        match(input: IIntStream, ttype: number, follow: BitSet): any;
        /** Match the wildcard: in a symbol */
        matchAny(input: IIntStream): void;
        mismatchIsUnwantedToken(input: IIntStream, ttype: number): boolean;
        mismatchIsMissingToken(input: IIntStream, follow: BitSet): boolean;
        /**
         * Report a recognition problem.
         *
         *  This method sets errorRecovery to indicate the parser is recovering
         *  not parsing.  Once in recovery mode, no errors are generated.
         *  To get out of recovery mode, the parser must successfully match
         *  a token (after a resync).  So it will go:
         *
         * 		1. error occurs
         * 		2. enter recovery mode, report error
         * 		3. consume until token found in resynch set
         * 		4. try to resume parsing
         * 		5. next match() will reset errorRecovery mode
         *
         *  If you override, make sure to update syntaxErrors if you care about that.
         */
        reportError(e: RecognitionException): void;
        displayRecognitionError(tokenNames: string[], e: RecognitionException): void;
        /**
         * What error message should be generated for the various exception types?
         *
         *  Not very object-oriented code, but I like having all error message
         *  generation within one method rather than spread among all of the
         *  exception classes. This also makes it much easier for the exception
         *  handling because the exception classes do not have to have pointers back
         *  to this object to access utility routines and so on. Also, changing
         *  the message for an exception type would be difficult because you
         *  would have to subclassing exception, but then somehow get ANTLR
         *  to make those kinds of exception objects instead of the default.
         *  This looks weird, but trust me--it makes the most sense in terms
         *  of flexibility.
         *
         *  For grammar debugging, you will want to override this to add
         *  more information such as the stack frame with
         *  getRuleInvocationStack(e, this.getClass().getName()) and,
         *  for no viable alts, the decision description and this.state etc...
         *
         *  Override this to change the message generated for one or more
         *  exception types.
         */
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
        /**
         *  Get number of recognition errors (lexer, parser, tree parser).  Each
         *  recognizer tracks its own number.  So parser and lexer each have
         *  separate count.  Does not count the spurious errors found between
         *  an error and next valid token match
         *
         *  <seealso cref="ReportError(RecognitionException)"/>
         */
        readonly numberOfSyntaxErrors: number;
        /**
         * What is the error header, normally line/character position information?
         * */
        getErrorHeader(e: RecognitionException): string;
        /**
         *  How should a token be displayed in an error message? The default
         *  is to display just the text, but during development you might
         *  want to have a lot of information spit out.  Override in that case
         *  to use t.ToString() (which, for CommonToken, dumps everything about
         *  the token). This is better than forcing you to override a method in
         *  your token objects because you don't have to go modify your lexer
         *  so that it creates a new Java type.
         */
        getTokenErrorDisplay(t: IToken): string;
        /**
         * Override this method to change where error messages go
         */
        emitErrorMessage(msg: string): void;
        /**
         *  Recover from an error found on the input stream.  This is
         *  for NoViableAlt and mismatched symbol exceptions.  If you enable
         *  single token insertion and deletion, this will usually not
         *  handle mismatched symbol exceptions but there could be a mismatched
         *  token that the match() routine could not recover from.
         */
        recover(input: IIntStream, re: RecognitionException): void;
        /**
         *  A hook to listen in on the token consumption during error recovery.
         *  The DebugParser subclasses this to fire events to the listenter.
         */
        beginResync(): void;
        endResync(): void;
        /**
         *  Compute the error recovery set for the current rule.  During
         *  rule invocation, the parser pushes the set of tokens that can
         *  follow that rule reference on the stack; this amounts to
         *  computing FIRST of what follows the rule reference in the
         *  enclosing rule. This local follow set only includes tokens
         *  from within the rule; i.e., the FIRST computation done by
         *  ANTLR stops at the end of a rule.
         *
         *  EXAMPLE
         *
         *  When you find a "no viable alt exception", the input is not
         *  consistent with any of the alternatives for rule r.  The best
         *  thing to do is to consume tokens until you see something that
         *  can legally follow a call to r *or* any rule that called r.
         *  You don't want the exact set of viable next tokens because the
         *  input might just be missing a token--you might consume the
         *  rest of the input looking for one of the missing tokens.
         *
         *  Consider grammar:
         *
         *  a : '[' b ']'
         *    | '(' b ')'
         *    ;
         *  b : c '^' INT ;
         *  c : ID
         *    | INT
         *    ;
         *
         *  At each rule invocation, the set of tokens that could follow
         *  that rule is pushed on a stack.  Here are the various "local"
         *  follow sets:
         *
         *  FOLLOW(b1_in_a) = FIRST(']') = ']'
         *  FOLLOW(b2_in_a) = FIRST(')') = ')'
         *  FOLLOW(c_in_b) = FIRST('^') = '^'
         *
         *  Upon erroneous input "[]", the call chain is
         *
         *  a -> b -> c
         *
         *  and, hence, the follow context stack is:
         *
         *  depth  local follow set     after call to rule
         *    0         <EOF>                    a (from main())
         *    1          ']'                     b
         *    3          '^'                     c
         *
         *  Notice that ')' is not included, because b would have to have
         *  been called from a different context in rule a for ')' to be
         *  included.
         *
         *  For error recovery, we cannot consider FOLLOW(c)
         *  (context-sensitive or otherwise).  We need the combined set of
         *  all context-sensitive FOLLOW sets--the set of all tokens that
         *  could follow any reference in the call chain.  We need to
         *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
         *  we resync'd to that token, we'd consume until EOF.  We need to
         *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
         *  In this case, for input "[]", LA(1) is in this set so we would
         *  not consume anything and after printing an error rule c would
         *  return normally.  It would not find the required '^' though.
         *  At this point, it gets a mismatched token error and throws an
         *  exception (since LA(1) is not in the viable following token
         *  set).  The rule exception handler tries to recover, but finds
         *  the same recovery set and doesn't consume anything.  Rule b
         *  exits normally returning to rule a.  Now it finds the ']' (and
         *  with the successful match exits errorRecovery mode).
         *
         *  So, you cna see that the parser walks up call chain looking
         *  for the token that was a member of the recovery set.
         *
         *  Errors are not generated in errorRecovery mode.
         *
         *  ANTLR's error recovery mechanism is based upon original ideas:
         *
         *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
         *
         *  and
         *
         *  "A note on error recovery in recursive descent parsers":
         *  http://portal.acm.org/citation.cfm?id=947902.947905
         *
         *  Later, Josef Grosch had some good ideas:
         *
         *  "Efficient and Comfortable Error Recovery in Recursive Descent
         *  Parsers":
         *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
         *
         *  Like Grosch I implemented local FOLLOW sets that are combined
         *  at run-time upon error to avoid overhead during parsing.
         */
        protected computeErrorRecoverySet(): BitSet;
        /**
         *  Compute the context-sensitive FOLLOW set for current rule.
         *  This is set of token types that can follow a specific rule
         *  reference given a specific call chain.  You get the set of
         *  viable tokens that can possibly come next (lookahead depth 1)
         *  given the current call chain.  Contrast this with the
         *  definition of plain FOLLOW for rule r:
         *
         *
         *   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
         *
         *  where x in T* and alpha, beta in V*; T is set of terminals and
         *  V is the set of terminals and nonterminals.  In other words,
         *  FOLLOW(r) is the set of all tokens that can possibly follow
         *  references to r in *any* sentential form (context).  At
         *  runtime, however, we know precisely which context applies as
         *  we have the call chain.  We may compute the exact (rather
         *  than covering superset) set of following tokens.
         *
         *  For example, consider grammar:
         *
         *  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
         *       | "return" expr '.'
         *       ;
         *  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
         *  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
         *       | '(' expr ')'
         *       ;
         *
         *  The FOLLOW sets are all inclusive whereas context-sensitive
         *  FOLLOW sets are precisely what could follow a rule reference.
         *  For input input "i=(3);", here is the derivation:
         *
         *  stat => ID '=' expr ';'
         *       => ID '=' atom ('+' atom)* ';'
         *       => ID '=' '(' expr ')' ('+' atom)* ';'
         *       => ID '=' '(' atom ')' ('+' atom)* ';'
         *       => ID '=' '(' INT ')' ('+' atom)* ';'
         *       => ID '=' '(' INT ')' ';'
         *
         *  At the "3" token, you'd have a call chain of
         *
         *    stat -> expr -> atom -> expr -> atom
         *
         *  What can follow that specific nested ref to atom?  Exactly ')'
         *  as you can see by looking at the derivation of this specific
         *  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
         *
         *  You want the exact viable token set when recovering from a
         *  token mismatch.  Upon token mismatch, if LA(1) is member of
         *  the viable next token set, then you know there is most likely
         *  a missing token in the input stream.  "Insert" one by just not
         *  throwing an exception.
         */
        protected computeContextSensitiveRuleFOLLOW(): BitSet;
        /**
         * what is exact? it seems to only add sets from above on stack
         * if EOR is in set i.  When it sees a set w/o EOR, it stops adding.
         * Why would we ever want them all?  Maybe no viable alt instead of
         * mismatched token?
         */
        protected combineFollows(exact: boolean): BitSet;
        /**
         *  Attempt to recover from a single missing or extra token.
         *
         *  EXTRA TOKEN
         *
         *  LA(1) is not what we are looking for.  If LA(2) has the right token,
         *  however, then assume LA(1) is some extra spurious token.  Delete it
         *  and LA(2) as if we were doing a normal match(), which advances the
         *  input.
         *
         *  MISSING TOKEN
         *
         *  If current token is consistent with what could come after
         *  ttype then it is ok to "insert" the missing token, else throw
         *  exception For example, Input "i=(3;" is clearly missing the
         *  ')'.  When the parser returns from the nested call to expr, it
         *  will have call chain:
         *
         *    stat -> expr -> atom
         *
         *  and it will be trying to match the ')' at this point in the
         *  derivation:
         *
         *       => ID '=' '(' INT ')' ('+' atom)* ';'
         *                          ^
         *  match() will see that ';' doesn't match ')' and report a
         *  mismatched token error.  To recover, it sees that LA(1)==';'
         *  is in the set of tokens that can follow the ')' token
         *  reference in rule atom.  It can assume that you forgot the ')'.
         */
        protected recoverFromMismatchedToken(input: IIntStream, ttype: number, follow: BitSet): any;
        /**
         * Not currently used
         */
        recoverFromMismatchedSet(input: IIntStream, e: RecognitionException, follow: BitSet): any;
        /**
         *  Match needs to return the current input symbol, which gets put
         *  into the label for the associated token ref; e.g., x=ID.  Token
         *  and tree parsers need to return different objects. Rather than test
         *  for input stream type or change the IntStream interface, I use
         *  a simple method to ask the recognizer to tell me what the current
         *  input symbol is.
         *
         *  This is ignored for lexers.
         */
        protected getCurrentInputSymbol(input: IIntStream): any;
        /**
         * Conjure up a missing token during error recovery.
         *
         *  The recognizer attempts to recover from single missing
         *  symbols. But, actions might refer to that missing symbol.
         *  For example, x=ID {f($x);}. The action clearly assumes
         *  that there has been an identifier matched previously and that
         *  $x points at that token. If that token is missing, but
         *  the next token in the stream is what we want we assume that
         *  this token is missing and we keep going. Because we
         *  have to return some token to replace the missing token,
         *  we have to conjure one up. This method gives the user control
         *  over the tokens returned for missing tokens. Mostly,
         *  you will want to create something special for identifier
         *  tokens. For literals such as '{' and ',', the default
         *  action in the parser or tree parser works. It simply creates
         *  a CommonToken of the appropriate type. The text will be the token.
         *  If you change what tokens must be created by the lexer,
         *  override this method to create the appropriate tokens.
         */
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        consumeUntil(input: IIntStream, tokenType: number): void;
        /**
         * Consume tokens until one matches the given token set
         */
        consumeUntil2(input: IIntStream, set: BitSet): void;
        /**
         * Push a rule's follow set using our own hardcoded stack
         */
        protected pushFollow(fset: BitSet): void;
        protected popFollow(): void;
        backtrackingLevel: number;
        /**
         * Return whether or not a backtracking attempt failed.
         */
        readonly failed: boolean;
        /**
         *  Used to print out token names like ID during debugging and
         *  error reporting.  The generated parsers implement a method
         *  that overrides this to point to their String[] tokenNames.
         */
        tokenNames: string[];
        /**
         *  For debugging and other purposes, might want the grammar name.
         *  Have ANTLR generate an implementation for this method.
         */
        grammarFileName: string;
        sourceName: string;
        /**
         *  A convenience method for use most often with template rewrites.
         *  Convert a list of <see cref="IToken"/> to a list of <see cref="string"/>.
         */
        toStrings(tokens: List<IToken>): List<string>;
        /**
         *  Given a rule number and a start token index number, return
         *  MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
         *  start index.  If this rule has parsed input starting from the
         *  start index before, then return where the rule stopped parsing.
         *  It returns the index of the last token matched by the rule.
         *
         *  For now we use a hashtable and just the slow Object-based one.
         *  Later, we can make a special one for ints and also one that
         *  tosses out data after we commit past input position i.
         */
        getRuleMemoization(ruleIndex: number, ruleStartIndex: number): number;
        /**
         *  Has this rule already parsed input at the current index in the
         *  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
         *  If we attempted but failed to parse properly before, return
         *  MEMO_RULE_FAILED.
         *
         *  This method has a side-effect: if we have seen this input for
         *  this rule and successfully parsed before, then seek ahead to
         *  1 past the stop token matched for this rule last time.
         */
        alreadyParsedRule(input: IIntStream, ruleIndex: number): boolean;
        /**
         *  Record whether or not this rule parsed the input at this position
         *  successfully.  Use a standard java hashtable for now.
         */
        memoize(input: IIntStream, ruleIndex: number, ruleStartIndex: number): void;
        /**
         *  return how many rule/input-index pairs there are in total.
         *  TODO: this includes synpreds. :(
         */
        getRuleMemoizationCacheSize(): number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     *  A parser for a stream of tree nodes.  "tree grammars" result in a subclass
     *  of this.  All the error reporting and recovery is shared with Parser via
     *  the BaseRecognizer superclass.
    */
    class TreeParser extends BaseRecognizer {
        DOWN: number;
        UP: number;
        static dotdot: string;
        static doubleEtc: string;
        protected input: ITreeNodeStream;
        constructor(input: ITreeNodeStream, state?: RecognizerSharedState);
        reset(): void;
        /**
         * Set the input stream
         */
        setTreeNodeStream(input: ITreeNodeStream): void;
        getTreeNodeStream(): ITreeNodeStream;
        readonly sourceName: string;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        /**
         *  Match '.' in tree parser has special meaning.  Skip node or
         *  entire tree if node has children.  If children, scan until
         *  corresponding UP node.
         */
        matchAny(ignore: IIntStream): void;
        /**
         *  We have DOWN/UP nodes in the stream that have no line info; override.
         *  plus we want to alter the exception type.  Don't try to recover
         *  from tree parser errors inline...
         */
        protected recoverFromMismatchedToken(input: IIntStream, ttype: number, follow: BitSet): any;
        /**
         *  Prefix error message with the grammar name because message is
         *  always intended for the programmer because the parser built
         *  the input tree not the user.
         */
        getErrorHeader(e: RecognitionException): string;
        /**
         *  Tree parsers parse nodes they usually have a token object as
         *  payload. Set the exception token and do the default behavior.
         */
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Action = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.Action;
    class TreeFilter extends TreeParser {
        protected originalTokenStream: ITokenStream;
        protected originalAdaptor: ITreeAdaptor;
        constructor(input: ITreeNodeStream, state?: RecognizerSharedState);
        applyOnce(t: any, whichRule: Action): void;
        downup(t: any): void;
        /**
         * methods the downup strategy uses to do the up and down rules.
         * to override, just define tree grammar rule topdown and turn on
         * filter=true.
         */
        protected topdown(): void;
        protected bottomup(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import List = Stimulsoft.System.Collections.List;
    import Queue = Stimulsoft.System.Collections.Queue;
    /**
     *  Return a node stream from a doubly-linked tree whose nodes
     *  know what child index they are.  No remove() is supported.
     *
     *  Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
     */
    class TreeIterator extends List<any> {
        protected adaptor: ITreeAdaptor;
        protected root: any;
        protected tree: any;
        protected firstTime: boolean;
        private reachedEof;
        up: any;
        down: any;
        eof: any;
        /**
         *  If we emit UP/DOWN nodes, we need to spit out multiple nodes per
         *  next() call.
         */
        protected nodes: Queue<any>;
        constructor(adaptor: ITreeAdaptor, tree: any);
        current: any;
        dispose(): void;
        moveNext(): boolean;
        reset(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreePatternLexer {
        static begin: number;
        static end: number;
        static id: number;
        static arg: number;
        static percent: number;
        static colon: number;
        static dot: number;
        /**
         * The tree pattern to lex like "(A B C)"
         */
        protected pattern: string;
        /**
         * Index into input string
         */
        protected p: number;
        /**
         * Current char
         */
        protected c: number;
        /**
         * How long is the pattern in char?
         */
        protected n: number;
        /**
         * Set when token type is ID or ARG (name mimics Java's StreamTokenizer)
         */
        sval: string;
        error: boolean;
        constructor(pattern: string);
        nextToken(): number;
        consume(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreePatternParser {
        protected tokenizer: TreePatternLexer;
        protected ttype: number;
        protected wizard: TreeWizard;
        protected adaptor: ITreeAdaptor;
        constructor(tokenizer: TreePatternLexer, wizard: TreeWizard, adaptor: ITreeAdaptor);
        pattern(): any;
        parseTree(): any;
        parseNode(): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    class TreeRewriter extends TreeParser {
        protected showTransformations: boolean;
        protected originalTokenStream: ITokenStream;
        protected originalAdaptor: ITreeAdaptor;
        topdown_func: Misc.Func<IAstRuleReturnScope<any>>;
        bottomup_func: Misc.Func<IAstRuleReturnScope<any>>;
        constructor(input: ITreeNodeStream, state: RecognizerSharedState);
        applyOnce(t: any, whichRule: Misc.Func<IAstRuleReturnScope<any>>): any;
        applyRepeatedly(t: any, whichRule: Misc.Func<IAstRuleReturnScope<any>>): any;
        downup(t: any, showTransformations?: boolean): any;
        /**
         *  methods the downup strategy uses to do the up and down rules.
         *  to override, just define tree grammar rule topdown and turn on
         *  filter=true.
         */
        protected topdown(): IAstRuleReturnScope<any>;
        protected bottomup(): IAstRuleReturnScope<any>;
        /**
         *  Override this if you need transformation tracing to go somewhere
         *  other than stdout or if you're not using ITree-derived trees.
         */
        protected reportTransformation(oldTree: any, newTree: any): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    /**
     * Do a depth first walk of a tree, applying pre() and post() actions as we go.
     */
    class TreeVisitor {
        protected adaptor: ITreeAdaptor;
        constructor(adaptor?: ITreeAdaptor);
        /**
         *  Visit every node in tree t and trigger an action for each node
         *  before/after having visited all of its children.  Bottom up walk.
         *  Execute both actions even if t has no children.  Ignore return
         *  results from transforming children since they will have altered
         *  the child list of this node (their parent).  Return result of
         *  applying post action to this node.
         */
        visit(t: any, action: ITreeVisitorAction): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime.Tree {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    import Action = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.Action;
    /**
     *  Build and navigate trees with this object.  Must know about the names
     *  of tokens so you have to pass in a map or array of token names (from which
     *  this class can build the map).  I.e., Token DECL means nothing unless the
     *  class can translate it to a token type.
     *
     *  In order to create nodes and navigate, this class needs a TreeAdaptor.
     *
     *  This class can build a token type -> node index for repeated use or for
     *  iterating over the various nodes with a particular type.
     *
     *  This class works in conjunction with the TreeAdaptor rather than moving
     *  all this functionality into the adaptor.  An adaptor helps build and
     *  navigate trees using methods.  This class helps you do it with string
     *  patterns like "(A B C)".  You can create a tree from that pattern or
     *  match subtrees against it.
     */
    class TreeWizard {
        protected adaptor: ITreeAdaptor;
        protected tokenNameToTypeMap: Dictionary<string, number>;
        /**
         *  Compute a Map&lt;String, Integer&gt; that is an inverted index of
         *  tokenNames (which maps int token types to names).
         */
        computeTokenTypes(tokenNames: string[]): Dictionary<string, number>;
        /**
         * Using the map of token names to token types, return the type.
         */
        getTokenType(tokenName: string): number;
        /**
         *  Walk the entire tree and make a node name to nodes mapping.
         *  For now, use recursion but later nonrecursive version may be
         *  more efficient.  Returns Map&lt;Integer, List&gt; where the List is
         *  of your AST node type.  The Integer is the token type of the node.
         *
         *  TODO: save this index so that find and visit are faster
         */
        index(t: any): Dictionary<number, List<any>>;
        /**
         * Do the work for index
         */
        protected indexCore(t: any, m: Dictionary<number, List<any>>): void;
        /**
         * Return a List of tree nodes with token type ttype
         */
        find(t: any, ttype: number): List<any>;
        /**
         * Return a List of subtrees matching pattern.
         */
        find2(t: any, pattern: string): List<any>;
        findFirst(t: any, ttype: number): any;
        findFirst2(t: any, pattern: string): any;
        /**
         *  Visit every ttype node in t, invoking the visitor.  This is a quicker
         *  version of the general visit(t, pattern) method.  The labels arg
         *  of the visitor action method is never set (it's null) since using
         *  a token type rather than a pattern doesn't let us set a label.
         */
        visit(t: any, ttype: number, visitor: IContextVisitor): void;
        visit2(t: any, ttype: number, action: Action): void;
        /**
         * Do the recursive work for visit
         */
        protected visitCore(t: any, parent: any, childIndex: number, ttype: number, visitor: IContextVisitor): void;
        /**
         *  For all subtrees that match the pattern, execute the visit action.
         *  The implementation uses the root node of the pattern in combination
         *  with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
         *  Patterns with wildcard roots are also not allowed.
         */
        visit3(t: any, pattern: string, visitor: IContextVisitor): void;
        /**
         *  Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
         *  on the various nodes and '.' (dot) as the node/subtree wildcard,
         *  return true if the pattern matches and fill the labels Map with
         *  the labels pointing at the appropriate nodes.  Return false if
         *  the pattern is malformed or the tree does not match.
         *
         *  If a node specifies a text arg in pattern, then that must match
         *  for that node in t.
         *
         *  TODO: what's a better way to indicate bad pattern? Exceptions are a hassle
         */
        parse(t: any, pattern: string, labels: Dictionary<string, any>): boolean;
        parse2(t: any, pattern: string): boolean;
        /**
         *  Do the work for parse. Check to see if the t2 pattern fits the
         *  structure and token types in t1.  Check text if the pattern has
         *  text arguments on nodes.  Fill labels map with pointers to nodes
         *  in tree matched against nodes in pattern with labels.
         */
        parseCore(t1: any, tpattern: TreePattern, labels: Dictionary<string, any>): boolean;
        /**
         *  Create a tree or node from the indicated tree pattern that closely
         *  follows ANTLR tree grammar tree element syntax:
         *
         *      (root child1 ... child2).
         *
         *
         *  You can also just pass in a node: ID
         *
         *  Any node can have a text argument: ID[foo]
         *  (notice there are no quotes around foo--it's clear it's a string).
         *
         *  nil is a special name meaning "give me a nil node".  Useful for
         *  making lists: (nil A B C) is a list of A B C.
         */
        create(pattern: string): any;
        /**
         *  Compare t1 and t2; return true if token types/text, structure match exactly.
         *  The trees are examined in their entirety so that (A B) does not match
         *  (A B C) nor (A (B C)).
         *
         *  TODO: allow them to pass in a comparator
         *  TODO: have a version that is nonstatic so it can use instance adaptor
         *
         *  I cannot rely on the tree node's equals() implementation as I make
         *  no constraints at all on the node types nor interface etc...
         */
        static equals(t1: any, t2: any, adaptor: ITreeAdaptor): boolean;
        /**
         *  Compare type, structure, and text of two trees, assuming adaptor in
         *  this instance of a TreeWizard.
         */
        protected static equalsCore(t1: any, t2: any, adaptor: ITreeAdaptor): boolean;
    }
    var IContextVisitor: string;
    interface IContextVisitor {
        visit(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): any;
    }
    class Visitor implements IContextVisitor {
        private static ImplementsVisitor;
        implements(): string[];
        visit2(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): void;
        visit(t: any): void;
    }
    class ActionVisitor extends Visitor {
        _action: Action;
        constructor(action: Action);
        visit(t: any): void;
    }
    /**
    *  When using %label:TOKENNAME in a tree for parse(), we must
    *  track the label.
    */
    class TreePattern extends CommonTree {
        label: string;
        hasTextArg: boolean;
        constructor(payload: IToken);
        toString(): string;
    }
    class WildcardTreePattern extends TreePattern {
        constructor(payload: IToken);
    }
    /**
     * This adaptor creates TreePattern objects for use during scan()
     */
    class TreePatternTreeAdaptor extends CommonTreeAdaptor {
        create(payload: IToken): any;
    }
    class FindTreeWizardVisitor extends Visitor {
        _nodes: List<any>;
        constructor(nodes: List<any>);
        visit(t: any): void;
    }
    class FindTreeWizardContextVisitor implements IContextVisitor {
        private static ImplementsFindTreeWizardContextVisitor;
        implements(): string[];
        _outer: TreeWizard;
        _tpattern: TreePattern;
        _subtrees: List<any>;
        constructor(outer: TreeWizard, tpattern: TreePattern, subtrees: List<any>);
        visit(t: any, parent: any, childIndex: number, labels: Dictionary<string, any>): void;
    }
    class VisitTreeWizardContextVisitor implements IContextVisitor {
        private static ImplementsVisitTreeWizardContextVisitor;
        implements(): string[];
        _outer: TreeWizard;
        _visitor: IContextVisitor;
        _labels: Dictionary<string, any>;
        _tpattern: TreePattern;
        constructor(outer: TreeWizard, visitor: IContextVisitor, labels: Dictionary<string, any>, tpattern: TreePattern);
        visit(t: any, parent: any, childIndex: number, unusedlabels: Dictionary<string, any>): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    /**
     *  A pretty quick CharStream that pulls all data from an array
     *  directly.  Every method call counts in the lexer.  Java's
     *  strings aren't very good so I'm avoiding.
     */
    class ANTLRStringStream implements ICharStream {
        private static ImplementsANTLRStringStream;
        implements(): string[];
        /**
         * The data being scanned
         */
        protected data: string[];
        /**
         * How many characters are actually in the buffer
         */
        protected n: number;
        /**
         * 0..n-1 index into string of next char
         */
        protected p: number;
        /**
         * tracks how deep mark() calls are nested
         */
        protected markDepth: number;
        /**
         *  A list of CharStreamState objects that tracks the stream state
         *  values this.line, this.charPositionInLine, and this.p that can change as you
         *  move through the input stream.  Indexed from 1..markDepth.
         *  A null is kept @ index 0.  Create upon first call to mark().
         */
        protected markers: List<CharStreamState>;
        /**
         * Track the last mark() call result value for use in rewind().
         */
        protected lastMarker: number;
        /**
         * What is name or source of this char stream?
         */
        name: string;
        /**
         * Copy data in string to a local char array
         */
        constructor(input?: string, data?: string[], numberOfActualCharsInArray?: number, sourceName?: string);
        /**
         *  Return the current input symbol index 0..n where n indicates the
         *  last symbol has been read.  The index is the index of char to
         *  be returned from LA(1).
         */
        readonly index: number;
        /**
         * this.line number 1..n within the input
         */
        line: number;
        /**
         * The index of the character relative to the beginning of the this.line 0..n-1
         */
        charPositionInLine: number;
        /**
         *  Reset the stream so that it's in the same state it was
         *  when the object was created *except* the data array is not
         *  touched.
         */
        reset(): void;
        consume(): void;
        la(i: number): number;
        lt(i: number): number;
        readonly count: number;
        mark(): number;
        rewind(m?: number): void;
        release(marker: number): void;
        /**
         *  consume() ahead until this.p==index; can't just set this.p=index as we must
         *  update this.line and this.charPositionInLine.
         */
        seek(index: number): void;
        substring(start: number, length: number): string;
        readonly sourceName: string;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  Vacuum all input from a Reader and then treat it like a StringStream.
     *  Manage the buffer manually to avoid unnecessary data copying.
     *
     *  If you need encoding, use ANTLRInputStream.
     */
    class ANTLRReaderStream extends ANTLRStringStream {
        readBufferSize: number;
        initialBufferSize: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A kind of ReaderStream that pulls from an InputStream.
     *  Useful for reading from stdin and specifying file encodings etc...
     */
    class ANTLRInputStream extends ANTLRReaderStream {
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  Rules that return more than a single value must return an object
     *  containing all the values.  Besides the properties defined in
     *  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
     *  return values.  This class simply defines the minimum properties that
     *  are always defined and methods to access the others that might be
     *  available depending on output option such as template and tree.
     *
     *  Note text is not an actual property of the return value, it is computed
     *  from start and stop using the input stream's toString() method.  I
     *  could add a ctor to this so that we can pass in and store the input
     *  stream, but I'm not sure we want to do that.  It would seem to be undefined
     *  to get the .text property anyway if the rule matches tokens from multiple
     *  input streams.
     *
     *  I do not use getters for fields of objects that are used simply to
     *  group values such as this aggregate.  The getters/setters are there to
     *  satisfy the superclass interface.
     */
    class ParserRuleReturnScope<TToken> implements IRuleReturnScope<TToken> {
        private static ImplementsParserRuleReturnScope;
        implements(): string[];
        start: TToken;
        stop: TToken;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class AstParserRuleReturnScope<TTree, TToken> extends ParserRuleReturnScope<TToken> implements IAstRuleReturnScope<TTree>, IAstRuleReturnScope<any> {
        private static ImplementsAstParserRuleReturnScope;
        implements(): string[];
        tree: TTree;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A stripped-down version of org.antlr.misc.BitSet that is just
     *  good enough to handle runtime requirements such as FOLLOW sets
     *  for automatic error recovery.
     */
    class BitSet {
        private static BITS;
        private static LOG_BITS;
        /**
         *  We will often need to do a mod operator (i mod nbits).  Its
         *  turns out that, for powers of two, this mod operation is
         *  same as (i &amp; (nbits-1)).  Since mod is slow, we use a
         *  precomputed mod mask to do the mod instead.
         */
        private static MOD_MASK;
        /**
         * The actual data bits
         */
        _bits: number[];
        /** Construction from a static array of longs */
        static create(bits: number[]): BitSet;
        /** Construct a bitset given the size
         *  @param nbits The size of the bitset in bits
         */
        constructor(nbits?: number);
        static of(el: number): BitSet;
        static of2(a: number, b: number): BitSet;
        static of3(a: number, b: number, c: number): BitSet;
        static of4(a: number, b?: number, c?: number, d?: number): BitSet;
        /**
         * return this | a in a new set
         */
        or(a: BitSet): BitSet;
        /**
         * or this element into this set (grow as necessary to accommodate)
         */
        add(el: number): void;
        /**
         * Grows the set to a larger number of bits.
         * @param bit element that must fit in set
         */
        growToInclude(bit: number): void;
        orInPlace(a: BitSet): void;
        /**
         * Sets the size of a set.
         * @param nwords how many words the new set should be
         */
        private setSize;
        private static bitMask;
        clone(): any;
        size(): number;
        getHashCode(): number;
        equals(other: any): boolean;
        member(el: number): boolean;
        remove(el: number): void;
        isNil(): boolean;
        private static numWordsToHold;
        numBits(): number;
        /**
         * return how much space is being used by the bits array not how many actually have member bits on.
         */
        lengthInLongWords(): number;
        /**
         * Is this contained within a?
         */
        toArray(): number[];
        private static wordNumber;
        toString(tokenNames?: string[]): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    /**
     * Buffer all input tokens but do on-demand fetching of new tokens from
     *  lexer. Useful when the parser or lexer has to set context/mode info before
     *  proper lexing of future tokens. The ST template parser needs this,
     *  for example, because it has to constantly flip back and forth between
     *  inside/output templates. E.g., <c>&lt;names:{hi, &lt;it&gt;}&gt;</c> has to parse names
     *  as part of an expression but "hi, &lt;it&gt;" as a nested template.
     *
     *  You can't use this stream if you pass whitespace or other off-channel
     *  tokens to the parser. The stream can't ignore off-channel tokens.
     *  (UnbufferedTokenStream is the same way.)
     *
     *  This is not a subclass of UnbufferedTokenStream because I don't want
     *  to confuse small moving window of tokens it uses for the full buffer.
     */
    class BufferedTokenStream implements ITokenStream, ITokenStreamInformation {
        private static ImplementsBufferedTokenStream;
        implements(): string[];
        private _tokenSource;
        /**
         * Record every single token pulled from the source so we can reproduce
         *  chunks of it later.  The buffer in LookaheadStream overlaps sometimes
         *  as its moving window moves through the input.  This list captures
         *  everything so we can access complete input text.
         */
        _tokens: List<IToken>;
        /**
         * Track the last mark() call result value for use in rewind().
         */
        private _lastMarker;
        /**
         * The index into the tokens list of the current token (next token
         *  to consume).  tokens[p] should be LT(1).  p=-1 indicates need
         *  to initialize with first token.  The ctor doesn't get a token.
         *  First call to LT(1) or whatever gets the first token and sets p=0;
         */
        protected _p: number;
        constructor(tokenSource?: ITokenSource);
        tokenSource: ITokenSource;
        readonly index: number;
        /**
         *  How deep have we gone?
         */
        range: number;
        readonly count: number;
        readonly sourceName: string;
        readonly lastToken: IToken;
        readonly lastRealToken: IToken;
        maxLookBehind: number;
        mark(): number;
        release(marker: number): void;
        rewind(marker?: number): void;
        reset(): void;
        seek(index: number): void;
        /**
         *  Move the input pointer to the next incoming token.  The stream
         *  must become active with LT(1) available.  consume() simply
         *  moves the input pointer so that LT(1) points at the next
         *  input symbol. Consume at least one token.
         *
         *  Walk past any token not on the channel the parser is listening to.
         */
        consume(): void;
        /**
         * Make sure index i in tokens has a token.
         */
        protected sync(i: number): void;
        /**
         * add n elements to buffer
         */
        protected fetch(n: number): void;
        get(i: number): IToken;
        la(i: number): number;
        protected lb(k: number): IToken;
        lt(k: number): IToken;
        protected setup(): void;
        /**
         * Given a start and stop index, return a List of all tokens in
         *  the token type BitSet.  Return null if no tokens were found.  This
         *  method looks at both on and off channel tokens.
         */
        getTokens(start: number, stop: number, types: BitSet): List<IToken>;
        toString(): string;
        toString2(start: number, stop: number): string;
        fill(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CharStreamConstants {
        static endOfFile: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  When walking ahead with cyclic DFA or for syntactic predicates,
     *  we need to record the state of the input stream (char index,
     *  line, etc...) so that we can rewind the state after scanning ahead.
     *
     *  This is the complete state of a stream.
     */
    class CharStreamState {
        /**
         * Index into the char stream of next lookahead char
         */
        p: number;
        /**
         * What line number is the scanner at before processing buffer[p]?
         */
        line: number;
        /**
         * What char position 0..n-1 in line is scanner before processing buffer[p]?
         */
        charPositionInLine: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A Token object like we'd use in ANTLR 2.x; has an actual string created
     *  and associated with this object.  These objects are needed for imaginary
     *  tree nodes that have payload objects.  We need to create a Token object
     *  that has a string; the tree node will point at this token.  CommonToken
     *  has indexes into a char stream and hence cannot be used to introduce
     *  new strings.
     */
    class ClassicToken implements IToken {
        private static ImplementsClassicToken;
        implements(): string[];
        /**
         * What token number is this from 0..n-1 tokens
         */
        index: number;
        constructor(type: number, text: string, channel: number);
        text: string;
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        tokenIndex: number;
        inputStream: ICharStream;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class CommonToken implements IToken {
        private static ImplementsCommonToken;
        implements(): string[];
        input: ICharStream;
        /**
         *  We need to be able to change the text once in a while.  If
         *  this is non-null, then getText should return this.  Note that
         *  start/stop are not affected by changing this.
          */
        _text: string;
        /**
         * What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index
         */
        index: number;
        /**
         * The char position into the input buffer where this token starts
         */
        start: number;
        /**
         * The char position into the input buffer where this token stops
         */
        stop: number;
        constructor();
        static create1(type: number): CommonToken;
        static create2(input: ICharStream, type: number, channel: number, start: number, stop: number): CommonToken;
        static create3(type: number, text: string): CommonToken;
        static create4(oldToken: IToken): CommonToken;
        text: string;
        type: number;
        line: number;
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        tokenIndex: number;
        inputStream: ICharStream;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  The most common stream of tokens is one where every token is buffered up
     *  and tokens are prefiltered for a certain channel (the parser will only
     *  see these tokens and cannot change the filter channel number during the
     *  parse).
     *
     *  TODO: how to access the full token stream?  How to track all tokens matched per rule?
     */
    class CommonTokenStream extends BufferedTokenStream {
        /**
         * Skip tokens on any channel but this one; this is how we skip whitespace...
         */
        channel: number;
        constructor(tokenSource?: ITokenSource, channel?: number);
        /**
         * Reset this token stream by setting its token source.
         */
        /** Always leave p on an on-channel token. */
        consume(): void;
        lb(k: number): IToken;
        lt(k: number): IToken;
        /** Given a starting index, return the index of the first on-channel
         *  token.
         */
        skipOffTokenChannels(i: number): number;
        protected skipOffTokenChannelsReverse(i: number): number;
        reset(): void;
        setup(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A DFA implemented as a set of transition tables.
     *
     *  Any state that has a semantic predicate edge is special; those states
     *  are generated with if-then-else structures in a specialStateTransition()
     *  which is generated by cyclicDFA template.
     *
     *  There are at most 32767 states (16-bit signed short).
     *  Could get away with byte sometimes but would have to generate different
     *  types and the simulation code too.  For a point of reference, the Java
     *  lexer's Tokens rule DFA has 326 states roughly.
     */
    class DFA {
        protected eot: number[];
        protected eof: number[];
        protected min: string[];
        protected max: string[];
        protected accept: number[];
        protected special: number[];
        protected transition: number[][];
        protected decisionNumber: number;
        /**
         * Which recognizer encloses this DFA?  Needed to check backtracking
         */
        protected recognizer: BaseRecognizer;
        debug: boolean;
        constructor();
        description: string;
        /**
         *  From the input stream, predict what alternative will succeed
         *  using this DFA (representing the covering regular approximation
         *  to the underlying CFL).  Return an alternative number 1..n.  Throw
         *  an exception upon error.
         */
        predict(input: IIntStream): number;
        private dfaDebugMessage;
        private dfaDebugInvalidSymbol;
        protected noViableAlt(s: number, input: IIntStream): void;
        /** A hook for debugging interface */
        error(nvae: NoViableAltException): void;
        static specialStateTransitionDefault(dfa: DFA, s: number, input: IIntStream): number;
        /**
         *  Given a String that has a run-length-encoding of some unsigned shorts
         *  like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
         *  static short[] which generates so much init code that the class won't
         *  compile. :(
         */
        static unpackEncodedString(encodedString: string): number[];
        /**
         * Hideous duplication of code, but I need different typed arrays out :(
         */
        static unpackEncodedStringToUnsignedChars(encodedString: string): string[];
        protected debugRecognitionException(ex: RecognitionException): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    import ITreeNodeStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeNodeStream;
    /**
     *  The root of the ANTLR exception hierarchy.
     *
     *  To avoid English-only error messages and to generally make things
     *  as flexible as possible, these exceptions are not created with strings,
     *  but rather the information necessary to generate an error.  Then
     *  the various reporting methods in Parser and Lexer can be overridden
     *  to generate a localized error message.  For example, MismatchedToken
     *  exceptions are built with the expected token type.
     *  So, don't expect getMessage() to return anything.
     *
     *  Note that as of Java 1.4, you can access the stack trace, which means
     *  that you can compute the complete trace of rules from the start symbol.
     *  This gives you considerable context information with which to generate
     *  useful error messages.
     *
     *  ANTLR generates code that throws exceptions upon recognition error and
     *  also generates code to catch these exceptions in each rule.  If you
     *  want to quit upon first error, you can turn off the automatic error
     *  handling mechanism using rulecatch action, but you still need to
     *  override methods mismatch and recoverFromMismatchSet.
     *
     *  In general, the recognition exceptions can track where in a grammar a
     *  problem occurred and/or what was the expected input.  While the parser
     *  knows its state (such as current input symbol and line info) that
     *  state can change before the exception is reported so current token index
     *  is computed and stored at exception time.  From this info, you can
     *  perhaps print an entire line of input not just a single token, for example.
     *  Better to just say the recognizer had a problem and then let the parser
     *  figure out a fancy report.
     */
    class RecognitionException extends Exception {
        /**
         * What was the lookahead index when this exception was thrown?
         */
        private _k;
        /**
         * The current char when an error occurred. For lexers.
         */
        private _c;
        /**
         * Used for remote debugger deserialization
         */
        constructor(message?: string, input?: IIntStream, k?: number, innerException?: Exception);
        /**
         *  Return the token type or char of the unexpected input element
         */
        readonly unexpectedType: number;
        /**
         *  If you are parsing a tree node stream, you will encounter som
         *  imaginary nodes w/o line/col info.  We now search backwards looking
         *  for most recent token with line/col info, but notify getErrorHeader()
         *  that info is approximate.
         */
        approximateLineInfo: boolean;
        /**
         * What input stream did the error occur in?
         */
        input: IIntStream;
        readonly lookahead: number;
        /**
         *  The current Token when an error occurred.  Since not all streams
         *  can retrieve the ith Token, we have to track the Token object.
         *  For parsers.  Even when it's a tree parser, token might be set.
         */
        token: IToken;
        /**
         *  If this is a tree parser exception, node is set to the node with
         *  the problem.
         */
        node: any;
        character: string;
        /**
         * What is index of token/char were we looking at when the error occurred?
         */
        index: number;
        /**
         *  Track the line (1-based) at which the error occurred in case this is
         *  generated from a lexer.  We need to track this since the
         *  unexpected char doesn't carry the line info.
         */
        line: number;
        /**
         * The 0-based index into the line where the error occurred.
         */
        charPositionInLine: number;
        protected extractInformationFromTreeNodeStream(input: ITreeNodeStream): void;
        protected extractInformationFromTreeNodeStream2(input: ITreeNodeStream, k: number): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    /**
     * The recognizer did not match anything for a (..)+ loop.
     */
    class EarlyExitException extends RecognitionException {
        constructor(message?: string, decisionNumber?: number, input?: IIntStream, innerException?: Exception);
        decisionNumber: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    /**
     *  A semantic predicate failed during validation.  Validation of predicates
     *  occurs when normally parsing the alternative just like matching a token.
     *  Disambiguating predicate evaluation occurs when we hoist a predicate into
     *  a prediction decision.
     */
    class FailedPredicateException extends RecognitionException {
        constructor(message?: string, input?: IIntStream, ruleName?: string, predicateText?: string, innerException?: Exception);
        ruleName: string;
        predicateText: string;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Attribute = Stimulsoft.System.Attribute;
    class GrammarRuleAttribute extends Attribute {
        constructor(name: string);
        name: string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     * AST rules have trees
     */
    var IAstRuleReturnScope: string;
    interface IAstRuleReturnScope<TAstLabel> {
        /**
         * Has a value potentially if output=AST;
         */
        tree: TAstLabel;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     * A source of characters for an ANTLR lexer
     */
    var ICharStream: string;
    interface ICharStream extends IIntStream {
        /**
         *  For infinite streams, you don't need this; primarily I'm providing
         *  a useful interface for action code.  Just make sure actions don't
         *  use this on streams that don't support it.
         */
        substring(start: number, length: number): string;
        /**
         *  Get the ith character of lookahead.  This is the same usually as
         *  LA(i).  This will be used for labels in the generated
         *  lexer code.  I'd prefer to return a char here type-wise, but it's
         *  probably better to be 32-bit clean and be consistent with LA.
         */
        lt(i: number): number;
        /**
         * ANTLR tracks the line information automatically
         * Because this stream can rewind, we need to be able to reset the line
         */
        line: number;
        /**
         * The index of the character relative to the beginning of the line 0..n-1
         */
        charPositionInLine: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A simple stream of integers used when all I care about is the char
     *  or token type sequence (such as interpretation).
     */
    var IIntStream: string;
    interface IIntStream {
        consume(): any;
        /**
         *  Get int at current input pointer + i ahead where i=1 is next int.
         *  Negative indexes are allowed.  LA(-1) is previous token (token
         *  just matched).  LA(-i) where i is before first token should
         *  yield -1, invalid char / EOF.
         */
        la(i: number): number;
        /**
         *  Tell the stream to start buffering if it hasn't already.  Return
         *  current input position, Index, or some other marker so that
         *  when passed to rewind() you get back to the same spot.
         *  rewind(mark()) should not affect the input cursor.  The Lexer
         *  track line/col info as well as input index so its markers are
         *  not pure input indexes.  Same for tree node streams.
         */
        mark(): number;
        /**
         *  Return the current input symbol index 0..n where n indicates the
         *  last symbol has been read.  The index is the symbol about to be
         *  read not the most recently read symbol.
         */
        index: number;
        /**
         *  Reset the stream so that next call to index would return marker.
         *  The marker will usually be Index but it doesn't have to be.  It's
         *  just a marker to indicate what state the stream was in.  This is
         *  essentially calling release() and seek().  If there are markers
         *  created after this marker argument, this routine must unroll them
         *  like a stack.  Assume the state the stream was in when this marker
         *  was created.
         */
        rewind(marker: number): any;
        /**
         *  Rewind to the input position of the last marker.
         *  Used currently only after a cyclic DFA and just
         *  before starting a sem/syn predicate to get the
         *  input position back to the start of the decision.
         *  Do not "pop" the marker off the state.  mark(i)
         *  and rewind(i) should balance still. It is
         *  like invoking rewind(last marker) but it should not "pop"
         *  the marker off.  It's like seek(last marker's input position).
         */
        rewind(): any;
        /**
         *  You may want to commit to a backtrack but don't want to force the
         *  stream to keep bookkeeping objects around for a marker that is
         *  no longer necessary.  This will have the same behavior as
         *  rewind() except it releases resources without the backward seek.
         *  This must throw away resources for all markers back to the marker
         *  argument.  So if you're nested 5 levels of mark(), and then release(2)
         *  you have to release resources for depths 2..5.
         */
        release(marker: number): any;
        /**
         *  Set the input cursor to the position indicated by index.  This is
         *  normally used to seek ahead in the input stream.  No buffering is
         *  required to do this unless you know your stream will use seek to
         *  move backwards such as when backtracking.
         *
         *  This is different from rewind in its multi-directional
         *  requirement and in that its argument is strictly an input cursor (index).
         *
         *  For char streams, seeking forward must update the stream state such
         *  as line number.  For seeking backwards, you will be presumably
         *  backtracking using the mark/rewind mechanism that restores state and
         *  so this method does not need to update state when seeking backwards.
         *
         *  Currently, this method is only used for efficient backtracking using
         *  memoization, but in the future it may be used for incremental parsing.
         *
         *  The index is 0..n-1.  A seek to position i means that LA(1) will
         *  return the ith symbol.  So, seeking to 0 means LA(1) will return the
         *  first element in the stream.
         */
        seek(index: number): any;
        /**
         *  Only makes sense for streams that buffer everything up probably, but
         *  might be useful to display the entire stream or for testing.  This
         *  value includes a single EOF.
         */
        count: number;
        /**
         *  Where are you getting symbols from?  Normally, implementations will
         *  pass the buck all the way to the lexer who can ask its input stream
         *  for the file name or whatever.
         */
        sourceName: string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     * Rules can have start/stop info.
     * <typeparam name="TLabel">The element type of the input stream.</typeparam>
     */
    var IRuleReturnScope: string;
    interface IRuleReturnScope<TLabel> {
        /**
         * Gets the start element from the input stream
         */
        start: TLabel;
        /**
         * Gets the stop element from the input stream
         */
        stop: TLabel;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    var ITemplateRuleReturnScope: string;
    interface ITemplateRuleReturnScope<TTemplate> {
        template: TTemplate;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    var IToken: string;
    interface IToken {
        /**
         * Get the text of the token
         */
        text: string;
        type: number;
        /**
         * The line number on which this token was matched; line=1..n
         */
        line: number;
        /**
         * The index of the first character relative to the beginning of the line 0..n-1
         */
        charPositionInLine: number;
        channel: number;
        startIndex: number;
        stopIndex: number;
        /**
         *  An index from 0..n-1 of the token object in the input stream.
         *  This must be valid in order to use the ANTLRWorks debugger.
         */
        tokenIndex: number;
        /**
         *  From what character stream was this token created?  You don't have to
         *  implement but it's nice to know where a Token comes from if you have
         *  include files etc... on the input.
         */
        inputStream: ICharStream;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A source of tokens must provide a sequence of tokens via nextToken()
     *  and also must reveal it's source of characters; CommonToken's text is
     *  computed from a CharStream; it only store indices into the char stream.
     *
     *  Errors from the lexer are never passed to the parser.  Either you want
     *  to keep going or you do not upon token recognition error.  If you do not
     *  want to continue lexing then you do not want to continue parsing.  Just
     *  throw an exception not under RecognitionException and Java will naturally
     *  toss you all the way out of the recognizers.  If you want to continue
     *  lexing then you should not throw an exception to the parser--it has already
     *  requested a token.  Keep lexing until you get a valid one.  Just report
     *  errors and keep going, looking for a valid token.
     */
    var ITokenSource: string;
    interface ITokenSource {
        /**
         *  Return a Token object from your input stream (usually a CharStream).
         *  Do not fail/return upon lexing error; keep chewing on the characters
         *  until you get a good one; errors are not passed through to the parser.
         */
        nextToken(): IToken;
        /**
         *  Where are you getting tokens from? normally the implication will simply
         *  ask lexers input stream.
         */
        sourceName: string;
        tokenNames: string[];
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     * A stream of tokens accessing tokens from a TokenSource
     */
    var ITokenStream: string;
    interface ITokenStream extends IIntStream {
        /**
         *  Get Token at current input pointer + i ahead where i=1 is next Token.
         *  i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is
         *  two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken.
         *  Return null for LT(0) and any index that results in an absolute address
         *  that is negative.
         */
        lt(k: number): IToken;
        /**
         * How far ahead has the stream been asked to look?  The return
         * value is a valid index from 0..n-1.
        */
        range: number;
        /**
         *  Get a token at an absolute index i; 0..n-1.  This is really only
         *  needed for profiling and debugging and token stream rewriting.
         *  If you don't want to buffer up tokens, then this method makes no
         *  sense for you.  Naturally you can't use the rewrite stream feature.
         *  I believe DebugTokenStream can easily be altered to not use
         *  this method, removing the dependency.
         */
        get(i: number): IToken;
        /**
         *  Where is this stream pulling tokens from?  This is not the name, but
         *  the object that provides Token objects.
         */
        tokenSource: ITokenSource;
        /**
         *  Return the text of all tokens from start to stop, inclusive.
         *  If the stream does not buffer all the tokens then it can just
         *  return "" or null;  Users should not access $ruleLabel.text in
         *  an action of course in that case.
         */
        toString(start: number, stop: number): string;
        /**
         *  Because the user is not required to use a token with an index stored
         *  in it, we must provide a means for two token objects themselves to
         *  indicate the start/end location.  Most often this will just delegate
         *  to the other toString(int,int).  This is also parallel with
         *  the TreeNodeStream.toString(Object,Object).
         */
        toString(start: IToken, stop: IToken): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    var ITokenStreamInformation: string;
    interface ITokenStreamInformation {
        lastToken: IToken;
        lastRealToken: IToken;
        maxLookBehind: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    /**
     *  The most common stream of this.tokens is one where every token is buffered up
     *  and this.tokens are prefiltered for a certain channel (the parser will only
     *  see these this.tokens and cannot change the filter channel number during the
     *  parse).
     *
     *  TODO: how to access the full token stream?  How to track all this.tokens matched per rule?
     */
    class LegacyCommonTokenStream implements ITokenStream {
        private static ImplementsLegacyCommonTokenStream;
        implements(): string[];
        _tokenSource: ITokenSource;
        /**
         *  Record every single token pulled from the source so we can reproduce
         *  chunks of it later.
         */
        protected tokens: List<IToken>;
        /**
         * Map from token type to channel to override some Tokens' channel numbers
         */
        protected channelOverrideMap: Dictionary<number, number>;
        /**
         * Set of token types; discard any this.tokens with this type
         */
        protected discardSet: List<number>;
        /**
         * Skip tokens on any channel but this one; this is how we skip whitespace...
         */
        protected channel: number;
        /**
         * By default, track all incoming this.tokens
         */
        protected discardOffChannelTokens: boolean;
        /**
         * Track the last mark() call result value for use in rewind().
         */
        protected lastMarker: number;
        /**
         *  The index into the this.tokens list of the current token (next token
         *  to consume).  p==-1 indicates that the this.tokens list is empty
         */
        protected p: number;
        constructor(tokenSource?: ITokenSource, channel?: number);
        readonly index: number;
        /**
         * How deep have we gone?
         */
        range: number;
        /**
         * Reset this token stream by setting its token source.
         */
        setTokenSource(tokenSource: ITokenSource): void;
        /**
         *  Load all this.tokens from the token source and put in this.tokens.
         *  This is done upon first LT request because you might want to
         *  set some token type / channel overrides before filling buffer.
         */
        fillBuffer(): void;
        /**
         *  Move the input pointer to the next incoming token.  The stream
         *  must become active with LT(1) available.  consume() simply
         *  moves the input pointer so that LT(1) points at the next
         *  input symbol. Consume at least one token.
         *
         *  Walk past any token not on the channel the parser is listening to.
         */
        consume(): void;
        /**
         * Given a starting index, return the index of the first on-channel token.
         */
        protected skipOffTokenChannels(i: number): number;
        protected skipOffTokenChannelsReverse(i: number): number;
        /**
         *  A simple filter mechanism whereby you can tell this token stream
         *  to force all this.tokens of type ttype to be on channel.  For example,
         *  when interpreting, we cannot exec actions so we need to tell
         *  the stream to force all WS and NEWLINE to be a different, ignored
         *  channel.
         */
        setTokenTypeChannel(ttype: number, channel: number): void;
        discardTokenType(ttype: number): void;
        setDiscardOffChannelTokens(discardOffChannelTokens: boolean): void;
        getTokens(): List<IToken>;
        /**
         *  Given a start and stop index, return a List of all this.tokens in
         *  the token type BitSet.  Return null if no this.tokens were found.  This
         *  method looks at both on and off channel this.tokens.
         */
        getTokens2(start: number, stop: number, types?: BitSet): List<IToken>;
        /**
         *  Get the ith token from the current position 1..n where k=1 is the
         *  first symbol of lookahead.
         */
        lt(k: number): IToken;
        /**
         * Look backwards k this.tokens on-channel this.tokens
         */
        protected lb(k: number): IToken;
        /**
         *  Return absolute token i; ignore which channel the this.tokens are on;
         *  that is, count all this.tokens not just on-channel this.tokens.
         */
        get(i: number): IToken;
        la(i: number): number;
        mark(): number;
        release(marker: number): void;
        readonly count: number;
        rewind(marker?: number): void;
        reset(): void;
        seek(index: number): void;
        tokenSource: ITokenSource;
        readonly sourceName: string;
        toString(): string;
        toString2(start: number, stop: number): string;
        toString3(start: IToken, stop: IToken): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A lexer is recognizer that draws input symbols from a character stream.
     *  lexer grammars result in a subclass of this object. A Lexer object
     *  uses simplified match() and error recovery mechanisms in the interest
     *  of speed.
     */
    class Lexer extends BaseRecognizer implements ITokenSource {
        private static ImplementsLexer;
        implements(): string[];
        /**
         * Where is the lexer drawing characters from?
         */
        protected input: ICharStream;
        constructor(input?: ICharStream, state?: RecognizerSharedState);
        /**
         *  Gets or sets the text matched so far for the current token or any text override.
         *  <para>Setting this value replaces any previously set value, and overrides the original text.</para>
         */
        text: string;
        line: number;
        charPositionInLine: number;
        reset(): void;
        /** Return a token from this source; i.e., match a token on the char stream. */
        nextToken(): IToken;
        /**
         *  Returns the EOF token (default), if you need
         *  to return a custom token instead override this method.
         */
        getEndOfFileToken(): IToken;
        /**
         *  Instruct the lexer to skip creating a token for current lexer rule
         *  and look for another token.  nextToken() knows to keep looking when
         *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
         *  if token==null at end of any token rule, it creates one for you
         *  and emits it.
         */
        skip(): void;
        /**
         * This is the lexer entry point that sets instance let 'token'
         */
        mTokens(): void;
        /* Set the char stream and reset the lexer */
        charStream: ICharStream;
        readonly sourceName: string;
        /**
         *  Currently does not support multiple emits per nextToken invocation
         *  for efficiency reasons.  Subclass and override this method and
         *  nextToken (to push tokens into a list and pull from that list rather
         *  than a single variable as this implementation does).
         */
        emit2(token: IToken): void;
        /**
         *  The standard method called to automatically emit a token at the
         *  outermost lexical rule.  The token object should point into the
         *  char buffer start..stop.  If there is a text override in 'text',
         *  use that to set the token's text.  Override this method to emit
         *  custom Token objects.
         *
         *  If you are building trees, then you should also override
         *  Parser or TreeParser.getMissingSymbol().
         */
        emit(): IToken;
        match3(s: string): void;
        matchAny(): void;
        match2(c: number): void;
        matchRange(a: number, b: number): void;
        /**
         * What is the index of the current character of lookahead?
         */
        readonly charIndex: number;
        reportError(e: RecognitionException): void;
        getErrorMessage(e: RecognitionException, tokenNames: string[]): string;
        getCharErrorDisplay(c: number): string;
        /**
         *  Lexers can normally match any char in it's vocabulary after matching
         *  a token, so do the easy thing and just kill a character and hope
         *  it all works out.  You can instead use the rule invocation stack
         *  to do sophisticated error recovery if you are in a fragment rule.
         */
        recover2(re: RecognitionException): void;
        protected parseNextToken(): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedSetException extends RecognitionException {
        constructor(message?: string, expecting?: BitSet, input?: IIntStream, innerException?: Exception);
        expecting: BitSet;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedNotSetException extends MismatchedSetException {
        constructor(message?: string, expecting?: BitSet, input?: IIntStream, innerException?: Exception);
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class MismatchedRangeException extends RecognitionException {
        constructor(message?: string, a?: number, b?: number, input?: IIntStream, innerException?: Exception);
        a: number;
        b: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Exception = Stimulsoft.System.Exception;
    /**
     * A mismatched char or Token or tree node
     */
    class MismatchedTokenException extends RecognitionException {
        constructor(message?: string, expecting?: number, input?: IIntStream, tokenNames?: List<string>, innerException?: Exception);
        expecting: number;
        tokenNames: List<string>;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    import ITreeNodeStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeNodeStream;
    class MismatchedTreeNodeException extends RecognitionException {
        constructor(message?: string, expecting?: number, input?: ITreeNodeStream, innerException?: Exception);
        expecting: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Exception = Stimulsoft.System.Exception;
    /**
     *  We were expecting a token but it's not found.  The current token
     *  is actually what we wanted next.  Used for tree node errors too.
     */
    class MissingTokenException extends MismatchedTokenException {
        private _inserted;
        constructor(message?: string, expecting?: number, input?: IIntStream, inserted?: any, tokenNames?: List<string>, innerException?: Exception);
        readonly missingType: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Exception = Stimulsoft.System.Exception;
    class NoViableAltException extends RecognitionException {
        constructor(message: string, grammarDecisionDescription: string, decisionNumber: number, stateNumber: number, input: IIntStream, k?: number, innerException?: Exception);
        decisionNumber: number;
        grammarDecisionDescription: string;
        stateNumber: number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    /**
     *  A parser for TokenStreams.  "parser grammars" result in a subclass
     *  of this.
     */
    class Parser extends BaseRecognizer {
        input: ITokenStream;
        constructor(input: ITokenStream, state?: RecognizerSharedState);
        reset(): void;
        protected getCurrentInputSymbol(input: IIntStream): any;
        protected getMissingSymbol(input: IIntStream, e: RecognitionException, expectedTokenType: number, follow: BitSet): any;
        /**
         * Gets or sets the token stream; resets the parser upon a set.
         */
        tokenStream: ITokenStream;
        readonly sourceName: string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    /**
     *  The set of fields needed by an abstract recognizer to recognize input
     *  and recover from errors etc...  As a separate state object, it can be
     *  shared among multiple grammars; e.g., when one grammar imports another.
     *
     *  These fields are publically visible but the actual state pointer per
     *  parser is protected.
     */
    class RecognizerSharedState {
        /**
         *  Track the set of token types that can follow any rule invocation.
         *  Stack grows upwards.  When it hits the max, it grows 2x in size
         *  and keeps going.
         */
        following: BitSet[];
        _fsp: number;
        /**
         *  This is true when we see an error and before having successfully
         *  matched a token.  Prevents generation of more than one error message
         *  per error.
         */
        errorRecovery: boolean;
        /**
         *  The index into the input stream where the last error occurred.
         * 	This is used to prevent infinite loops where an error is found
         *  but no token is consumed during recovery...another error is found,
         *  ad naseum.  This is a failsafe mechanism to guarantee that at least
         *  one token/tree node is consumed for two errors.
         */
        lastErrorIndex: number;
        /**
         *  In lieu of a return value, this indicates that a rule or token
         *  has failed to match.  Reset to false upon valid token match.
         */
        failed: boolean;
        /**
         * Did the recognizer encounter a syntax error?  Track how many.
         */
        syntaxErrors: number;
        /**
         *  If 0, no backtracking is going on.  Safe to exec actions etc...
         *  If >0 then it's the level of backtracking.
         */
        backtracking: number;
        /**
         *  An array[size num rules] of dictionaries that tracks
         *  the stop token index for each rule.  ruleMemo[ruleIndex] is
         *  the memoization table for ruleIndex.  For key ruleStartIndex, you
         *  get back the stop token for associated rule or MEMO_RULE_FAILED.
         *
         *  This is only used if rule memoization is on (which it is by default).
         */
        ruleMemo: Dictionary<number, number>[];
        /**
         *  The goal of all lexer rules/methods is to create a token object.
         *  This is an instance variable as multiple rules may collaborate to
         *  create a single token.  nextToken will return this object after
         *  matching lexer rule(s).  If you subclass to allow multiple token
         *  emissions, then set this to the last token to be matched or
         *  something nonnull so that the auto token emit mechanism will not
         *  emit another token.
         */
        token: IToken;
        /**
         *  What character index in the stream did the current token start at?
         *  Needed, for example, to get the text for current token.  Set at
         *  the start of nextToken.
         */
        tokenStartCharIndex: number;
        /**
         * The line on which the first character of the token resides
         */
        tokenStartLine: number;
        /**
         * The character position of first character within the line
         */
        tokenStartCharPositionInLine: number;
        /**
         * The channel number for the current token
         */
        channel: number;
        /**
         * The token type for the current token
         */
        type: number;
        /**
         *  You can set the text for the current token to override what is in
         *  the input char buffer.  Use setText() or can set this instance var.
         */
        text: string;
        constructor();
        static recognizerSharedState(state: RecognizerSharedState): RecognizerSharedState;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TemplateParserRuleReturnScope<TTemplate, TToken> extends ParserRuleReturnScope<TToken> implements ITemplateRuleReturnScope<TTemplate>, ITemplateRuleReturnScope<any> {
        private static ImplementsTemplateParserRuleReturnScope;
        implements(): string[];
        template: TTemplate;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TokenChannels {
        /**
         *  All tokens go to the parser (unless skip() is called in that rule)
         *  on a particular "channel".  The parser tunes to a particular channel
         *  so that whitespace etc... can go to the parser on a "hidden" channel.
         */
        static default: number;
        /**
         *  Anything on different channel than DEFAULT_CHANNEL is not parsed
         *  by parser.
         */
        static hidden: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import Type = Stimulsoft.System.Type;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    /**
     *  Useful for dumping out the input stream after doing some
     *  augmentation or other manipulations.
     *
     *  You can insert stuff, replace, and delete chunks.  Note that the
     *  operations are done lazily--only if you convert the buffer to a
     *  String.  This is very efficient because you are not moving data around
     *  all the time.  As the buffer of tokens is converted to strings, the
     *  toString() method(s) check to see if there is an operation at the
     *  current index.  If so, the operation is done and then normal String
     *  rendering continues on the buffer.  This is like having multiple Turing
     *  machine instruction streams (programs) operating on a single input tape. :)
     *
     *  Since the operations are done lazily at toString-time, operations do not
     *  screw up the token index values.  That is, an insert operation at token
     *  index i does not change the index values for tokens i+1..n-1.
     *
     *  Because operations never actually alter the buffer, you may always get
     *  the original token stream back without undoing anything.  Since
     *  the instructions are queued up, you can easily simulate transactions and
     *  roll back any changes if there is an error just by removing instructions.
     *  For example,
     *
     *   CharStream input = new ANTLRFileStream("input");
     *   TLexer lex = new TLexer(input);
     *   TokenRewriteStream tokens = new TokenRewriteStream(lex);
     *   T parser = new T(tokens);
     *   parser.startRule();
     *
     * 	 Then in the rules, you can execute
     *      Token t,u;
     *      ...
     *      input.insertAfter(t, "text to put after t");}
     * 		input.insertAfter(u, "text after u");}
     * 		System.out.println(tokens.toString());
     *
     *  Actually, you have to cast the 'input' to a TokenRewriteStream. :(
     *
     *  You can also have multiple "instruction streams" and get multiple
     *  rewrites from a single pass over the input.  Just name the instruction
     *  streams and use that name again when printing the buffer.  This could be
     *  useful for generating a C file and also its header file--all from the
     *  same buffer:
     *
     *      tokens.insertAfter("pass1", t, "text to put after t");}
     * 		tokens.insertAfter("pass2", u, "text after u");}
     * 		System.out.println(tokens.toString("pass1"));
     * 		System.out.println(tokens.toString("pass2"));
     *
     *  If you don't use named rewrite streams, a "default" stream is used as
     *  the first example shows.
     */
    class TokenRewriteStream extends CommonTokenStream {
        DEFAULT_PROGRAM_NAME: string;
        PROGRAM_INIT_SIZE: number;
        MIN_TOKEN_INDEX: number;
        /**
         *  You may have multiple, named streams of rewrite operations.
         *  I'm calling these things "programs."
         *  Maps String (name) -> rewrite (List)
         */
        protected programs: Dictionary<string, List<RewriteOperation>>;
        /** Map String (program name) -> Integer index */
        protected lastRewriteTokenIndexes: Dictionary<string, number>;
        protected init(): void;
        constructor(tokenSource?: ITokenSource, channel?: number);
        /**
         *  Rollback the instruction stream for a program so that
         *  the indicated instruction (via instructionIndex) is no
         *  longer in the stream.  UNTESTED!
         */
        rollback(programName: string, instructionIndex: number): void;
        /** Reset the program so that no instructions exist */
        deleteProgram(programName?: string): void;
        unsertAfter(programName: string, index: number, text: any): void;
        insertBefore(programName: string, index: number, text: any): void;
        replace(programName: string, from: number, to: number, text: any): void;
        replace2(programName: string, from: IToken, to: IToken, text: any): void;
        delete(programName: string, from: IToken, to: IToken): void;
        protected getLastRewriteTokenIndex(programName: string): number;
        protected setLastRewriteTokenIndex(programName: string, i: number): void;
        protected getProgram(name: string): List<RewriteOperation>;
        private initializeProgram;
        toOriginalString(): string;
        toOriginalString2(start: number, end: number): string;
        toString(): string;
        toString3(programName: string, start: number, end: number): string;
        /**
         *  We need to combine operations and report invalid operations (like
         *  overlapping replaces that are not completed nested).  Inserts to
         *  same index need to be combined etc...   Here are the cases:
         *
         *  I.i.u I.j.v								leave alone, nonoverlapping
         *  I.i.u I.i.v								combine: Iivu
         *
         *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
         *  R.i-j.u R.i-j.v							delete first R
         *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
         *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
         *
         *  Delete special case of replace (text==null):
         *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
         *
         *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
         *											we're not deleting i)
         *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
         *  R.x-y.v I.i.u | i in x-y				ERROR
         *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
         *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
         *
         *  I.i.u = insert u before op @ index i
         *  R.x-y.u = replace x-y indexed tokens with u
         *
         *  First we need to examine replaces.  For any replace op:
         *
         * 		1. wipe out any insertions before op within that range.
         *		2. Drop any replace op before that is contained completely within
         *         that range.
         *		3. Throw exception upon boundary overlap with any previous replace.
         *
         *  Then we can deal with inserts:
         *
         * 		1. for any inserts to same index, combine even if not adjacent.
         * 		2. for any prior replace with same left boundary, combine this
         *         insert with replace and delete this replace.
         * 		3. throw exception if index in same range as previous replace
         *
         *  Don't actually delete; make op null in list. Easier to walk list.
         *  Later we can throw as we add to index -> op map.
         *
         *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
         *  inserted stuff would be before the replace range.  But, if you
         *  add tokens in front of a method body '{' and then delete the method
         *  body, I think the stuff before the '{' you added should disappear too.
         *
         *  Return a map from token index to operation.
         */
        protected reduceToSingleOperationPerIndex(rewrites: List<RewriteOperation>): Dictionary<number, RewriteOperation>;
        protected catOpText(a: any, b: any): string;
        /**
         * Get all operations before an index of a particular kind
         */
        protected getKindOfOps(rewrites: List<RewriteOperation>, kind: Type, before?: number): List<RewriteOperation>;
        toDebugString(start?: number, end?: number): string;
    }
    class RewriteOperation {
        /**
         * What index into rewrites List are we?
         */
        instructionIndex: number;
        /**
         * Token buffer index.
         */
        index: number;
        text: any;
        protected stream: TokenRewriteStream;
        constructor(stream: TokenRewriteStream, index: number, text?: any);
        /**
         *  Execute the rewrite operation by possibly adding to the buffer.
         *  Return the index of the next token to operate on.
         */
        execute(buf: string): number;
        toString(): string;
    }
    class InsertBeforeOp extends RewriteOperation {
        constructor(stream: TokenRewriteStream, index: number, text: any);
        execute(buf: string): number;
    }
    /**
     *  I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
     *  instructions.
     */
    class ReplaceOp extends RewriteOperation {
        lastIndex: number;
        constructor(stream: TokenRewriteStream, from: number, to: number, text: any);
        execute(buf: string): number;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class TokenTypes {
        static endOfFile: number;
        static invalid: number;
        static endOfRule: number;
        /**
         * imaginary tree navigation type; traverse "get child" link
         */
        static down: number;
        /**
         * imaginary tree navigation type; finish with a child list
         */
        static up: number;
        static min: number;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    class Tokens {
        /**
         *  In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
         *  will avoid creating a token for this symbol and try to fetch another.
         */
        static skip: IToken;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import LookaheadStream = Stimulsoft.Data.Expressions.Antlr.Runtime.Misc.LookaheadStream;
    /**
     * A token stream that pulls tokens from the code source on-demand and
     *  without tracking a complete buffer of the tokens. This stream buffers
     *  the minimum number of tokens possible.  It's the same as
     *  OnDemandTokenStream except that OnDemandTokenStream buffers all tokens.
     *
     *  You can't use this stream if you pass whitespace or other off-channel
     *  tokens to the parser. The stream can't ignore off-channel tokens.
     *
     *  You can only look backwards 1 token: LT(-1).
     *
     *  Use this when you need to read from a socket or other infinite stream.
     *
     *  @see BufferedTokenStream
     *  @see CommonTokenStream
     */
    class UnbufferedTokenStream extends LookaheadStream<IToken> implements ITokenStream, ITokenStreamInformation {
        private static ImplementsUnbufferedTokenStream;
        implements(): string[];
        tokenSource: ITokenSource;
        protected tokenIndex: number;
        /** Skip tokens on any channel but this one; this is how we skip whitespace... */
        protected channel: number;
        private _realTokens;
        constructor(tokenSource: ITokenSource);
        readonly sourceName: string;
        readonly lastToken: IToken;
        readonly lastRealToken: IToken;
        maxLookBehind: number;
        mark(): number;
        release(marker: number): void;
        clear(): void;
        consume(): void;
        extElement(): IToken;
        isEndOfFile(o: IToken): boolean;
        get(i: number): IToken;
        la(i: number): number;
        toString2(start: IToken | number, stop: IToken | number): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.Antlr.Runtime {
    import List = Stimulsoft.System.Collections.List;
    import Exception = Stimulsoft.System.Exception;
    /**
     * An extra token while parsing a TokenStream
     */
    class UnwantedTokenException extends MismatchedTokenException {
        constructor(message?: string, expecting?: number, input?: IIntStream, tokenNames?: List<string>, innerException?: Exception);
        readonly unexpectedToken: IToken;
        toString(): string;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class LogicalExpression {
        static bs: string;
        private static extractString;
        and(operand: LogicalExpression | any): BinaryExpression;
        dividedBy(operand: LogicalExpression | any): BinaryExpression;
        equalsTo(operand: LogicalExpression | any): BinaryExpression;
        greaterThan(operand: LogicalExpression | any): BinaryExpression;
        greaterOrEqualThan(operand: LogicalExpression | any): BinaryExpression;
        lesserThan(operand: LogicalExpression | any): BinaryExpression;
        lesserOrEqualThan(operand: LogicalExpression | any): BinaryExpression;
        minus(operand: LogicalExpression | any): BinaryExpression;
        modulo(operand: LogicalExpression | any): BinaryExpression;
        notEqual(operand: LogicalExpression | any): BinaryExpression;
        or(operand: LogicalExpression | any): BinaryExpression;
        plus(operand: LogicalExpression | any): BinaryExpression;
        mult(operand: LogicalExpression | any): BinaryExpression;
        bitwiseOr(operand: LogicalExpression | any): BinaryExpression;
        bitwiseAnd(operand: LogicalExpression | any): BinaryExpression;
        bitwiseXOr(operand: LogicalExpression | any): BinaryExpression;
        leftShift(operand: LogicalExpression | any): BinaryExpression;
        rightShift(operand: LogicalExpression | any): BinaryExpression;
        toString(): string;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class BinaryExpression extends LogicalExpression {
        constructor(type: BinaryExpressionType, leftExpression: LogicalExpression, rightExpression: LogicalExpression);
        leftExpression: LogicalExpression;
        rightExpression: LogicalExpression;
        type: BinaryExpressionType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum BinaryExpressionType {
        And = 0,
        Or = 1,
        NotEqual = 2,
        LesserOrEqual = 3,
        GreaterOrEqual = 4,
        Lesser = 5,
        Greater = 6,
        Equal = 7,
        Minus = 8,
        Plus = 9,
        Modulo = 10,
        Div = 11,
        Times = 12,
        BitwiseOr = 13,
        BitwiseAnd = 14,
        BitwiseXOr = 15,
        LeftShift = 16,
        RightShift = 17,
        Unknown = 18
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    import LogicalExpressionVisitor = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpressionVisitor;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class EvaluationVisitor extends LogicalExpressionVisitor {
        private _options;
        private readonly ignoreCase;
        constructor(options: EvaluateOptions);
        result: any;
        evaluate(expression: LogicalExpression): any;
        visit1(expression: LogicalExpression): void;
        private static commonTypes;
        /**
         *  Gets the the most precise type.
         * @param a Type a.
         * @param b Type b
         */
        private static getMostPreciseType;
        compareUsingMostPreciseType(a: any, b: any): any;
        visit2(expression: TernaryExpression): void;
        private static isReal;
        visit3(expression: BinaryExpression): void;
        visit4(expression: UnaryExpression): void;
        visit5(expression: ValueExpression): void;
        visit6(functionn: Functionn): void;
        private checkCase;
        evaluateFunction: (name: string, args: FunctionArgs) => void;
        private onEvaluateFunction;
        visit7(parameter: Identifier): void;
        evaluateParameter: (...args: any[]) => void;
        private onEvaluateParameter;
        parameters: Dictionary<string, any>;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class Functionn extends LogicalExpression {
        constructor(identifier: Identifier, expressions: LogicalExpression[]);
        identifier: Identifier;
        expressions: LogicalExpression[];
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class Identifier extends LogicalExpression {
        constructor(name: string);
        name: string;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class SerializationVisitor extends LogicalExpressionVisitor {
        private _numberFormatInfo;
        constructor();
        result: string;
        visit1(expression: LogicalExpression): void;
        visit2(expression: TernaryExpression): void;
        visit3(expression: BinaryExpression): void;
        visit4(expression: UnaryExpression): void;
        visit5(expression: ValueExpression): void;
        visit6(functionn: Functionn): void;
        visit7(parameter: Identifier): void;
        encapsulateNoValue(expression: LogicalExpression): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class TernaryExpression extends LogicalExpression {
        constructor(leftExpression: LogicalExpression, middleExpression: LogicalExpression, rightExpression: LogicalExpression);
        leftExpression: LogicalExpression;
        middleExpression: LogicalExpression;
        rightExpression: LogicalExpression;
        accept(visitor: LogicalExpressionVisitor): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class UnaryExpression extends LogicalExpression {
        constructor(type: UnaryExpressionType, expression: LogicalExpression);
        expression: LogicalExpression;
        type: UnaryExpressionType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum UnaryExpressionType {
        Not = 0,
        Negate = 1,
        BitwiseNot = 2
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc.Domain {
    class ValueExpression extends LogicalExpression {
        constructor(value: any, type?: ValueType);
        value: any;
        type: ValueType;
        accept(visitor: LogicalExpressionVisitor): void;
    }
    enum ValueType {
        Integer = 0,
        String = 1,
        DateTime = 2,
        Float = 3,
        Boolean = 4
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import Exception = Stimulsoft.System.Exception;
    class EvaluationException extends Exception {
        constructor(message: string, innerException?: Exception);
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    /**
     *  Provides enumerated values to use to set evaluation options.
     */
    enum EvaluateOptions {
        /**
         *  Specifies that no options are set.
         */
        None = 1,
        /**
         *  Specifies case-insensitive matching.
         */
        IgnoreCase = 2,
        /**
         *  No-cache mode. Ingores any pre-compiled expression in the cache.
         */
        NoCache = 4,
        /**
         *  Treats parameters as arrays and result a set of results.
         */
        IterateParameters = 8,
        /**
         * When using Round(), if a number is halfway between two others, it is rounded toward the nearest number that is away from zero.
         */
        RoundAwayFromZero = 16
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import BaseRecognizer = Stimulsoft.Data.Expressions.Antlr.Runtime.BaseRecognizer;
    import DFA = Stimulsoft.Data.Expressions.Antlr.Runtime.DFA;
    import NoViableAltException = Stimulsoft.Data.Expressions.Antlr.Runtime.NoViableAltException;
    import RecognizerSharedState = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognizerSharedState;
    import Lexer = Stimulsoft.Data.Expressions.Antlr.Runtime.Lexer;
    import ICharStream = Stimulsoft.Data.Expressions.Antlr.Runtime.ICharStream;
    class NCalcLexer extends Lexer {
        EOF: number;
        DATETIME: number;
        DIGIT: number;
        E: number;
        EscapeSequence: number;
        FALSE: number;
        FLOAT: number;
        HexDigit: number;
        ID: number;
        INTEGER: number;
        LETTER: number;
        NAME: number;
        STRING: number;
        TRUE: number;
        UnicodeEscape: number;
        WS: number;
        T__19: number;
        T__20: number;
        T__21: number;
        T__22: number;
        T__23: number;
        T__24: number;
        T__25: number;
        T__26: number;
        T__27: number;
        T__28: number;
        T__29: number;
        T__30: number;
        T__31: number;
        T__32: number;
        T__33: number;
        T__34: number;
        T__35: number;
        T__36: number;
        T__37: number;
        T__38: number;
        T__39: number;
        T__40: number;
        T__41: number;
        T__42: number;
        T__43: number;
        T__44: number;
        T__45: number;
        T__46: number;
        T__47: number;
        T__48: number;
        constructor(input?: ICharStream, state?: RecognizerSharedState);
        mT__19(): void;
        mT__20(): void;
        mT__21(): void;
        mT__22(): void;
        mT__23(): void;
        mT__24(): void;
        mT__25(): void;
        mT__26(): void;
        mT__27(): void;
        mT__28(): void;
        mT__29(): void;
        mT__30(): void;
        mT__31(): void;
        mT__32(): void;
        mT__33(): void;
        enterRule_T__34(): void;
        leaveRule_T__34(): void;
        mT__34(): void;
        mT__35(): void;
        mT__36(): void;
        mT__37(): void;
        mT__38(): void;
        mT__39(): void;
        mT__40(): void;
        mT__41(): void;
        mT__42(): void;
        mT__43(): void;
        mT__44(): void;
        enterRule_T__45(): void;
        leaveRule_T__45(): void;
        mT__45(): void;
        mT__46(): void;
        mT__47(): void;
        mT__48(): void;
        mTRUE(): void;
        mFALSE(): void;
        mID(): void;
        mINTEGER(): void;
        mFLOAT(): void;
        mSTRING(): void;
        mDATETIME(): void;
        mNAME(): void;
        mE(): void;
        mLETTER(): void;
        mDIGIT(): void;
        mEscapeSequence(): void;
        mHexDigit(): void;
        mUnicodeEscape(): void;
        mWS(): void;
        mTokens(): void;
        dfa7: DFA7;
        dfa14: DFA14;
        initDFAs(): void;
    }
    class DFA7 extends DFA {
        static DFA7_eotS: string;
        static DFA7_eofS: string;
        static DFA7_minS: string;
        static DFA7_maxS: string;
        static DFA7_acceptS: string;
        static DFA7_specialS: string;
        private static DFA7_transitionS;
        private static DFA7_eot;
        private static DFA7_eof;
        private static DFA7_min;
        private static DFA7_max;
        private static DFA7_accept;
        private static DFA7_special;
        private static DFA7_transition;
        static initialize(): void;
        constructor(recognizer: BaseRecognizer);
        description: string;
        error(nvae: NoViableAltException): void;
    }
    class DFA14 extends DFA {
        static DFA14_eotS: string;
        static DFA14_eofS: string;
        static DFA14_minS: string;
        static DFA14_maxS: string;
        static DFA14_acceptS: string;
        static DFA14_specialS: string;
        private static DFA14_transitionS;
        private static DFA14_eot;
        private static DFA14_eof;
        private static DFA14_min;
        private static DFA14_max;
        private static DFA14_accept;
        private static DFA14_special;
        private static DFA14_transition;
        static initialize(): void;
        constructor(recognizer: BaseRecognizer);
        description: string;
        error(nvae: NoViableAltException): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import List = Stimulsoft.System.Collections.List;
    class ReaderWriterLock {
        releaseReaderLock(): void;
        releaseWriterLock(): void;
        acquireReaderLock(t: number): void;
        acquireWriterLock(t: number): void;
    }
    class WeakReference {
        constructor(t: LogicalExpression);
        isAlive: boolean;
    }
    class Expression {
        static Timeout: {
            Infinite: number;
        };
        options: EvaluateOptions;
        protected originalExpression: string;
        /**
         * Textual representation of the expression to evaluate.
         */
        constructor();
        static create1(expression: string, options?: EvaluateOptions): Expression;
        static create2(expression: LogicalExpression, options?: EvaluateOptions): Expression;
        private static _cacheEnabled;
        private static _compiledExpressions;
        private static rwl;
        static cacheEnabled: boolean;
        /**
         * Removed unused entries from cached compiled expression
         */
        private static cleanCache;
        static compile(expression: string, nocache: boolean): LogicalExpression;
        /**
         * Pre-compiles the expression in order to check syntax errors.
         * If errors are detected, the Error property contains the message.
         * @returns True if the expression syntax is correct, otherwiser False
         */
        hasErrors(): boolean;
        error: string;
        parsedExpression: LogicalExpression;
        protected parameterEnumerators: Dictionary<string, List<any>>;
        protected parametersBackup: Dictionary<string, any>;
        evaluate(): any;
        evaluateFunction: any;
        evaluateParameter: any;
        parameters: Dictionary<string, any>;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import EventArgs = Stimulsoft.System.EventArgs;
    class FunctionArgs extends EventArgs {
        private _result;
        result: any;
        hasResult: boolean;
        parameters: Expression[];
        evaluateParameters(): any[];
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import ValueExpression = Stimulsoft.Data.Expressions.NCalc.Domain.ValueExpression;
    import Identifier = Stimulsoft.Data.Expressions.NCalc.Domain.Identifier;
    import RecognitionException = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognitionException;
    import RecognizerSharedState = Stimulsoft.Data.Expressions.Antlr.Runtime.RecognizerSharedState;
    import Parser = Stimulsoft.Data.Expressions.Antlr.Runtime.Parser;
    import ITokenStream = Stimulsoft.Data.Expressions.Antlr.Runtime.ITokenStream;
    import List = Stimulsoft.System.Collections.List;
    import AstParserRuleReturnScope = Stimulsoft.Data.Expressions.Antlr.Runtime.AstParserRuleReturnScope;
    import IToken = Stimulsoft.Data.Expressions.Antlr.Runtime.IToken;
    import LogicalExpression = Stimulsoft.Data.Expressions.NCalc.Domain.LogicalExpression;
    import ITreeAdaptor = Stimulsoft.Data.Expressions.Antlr.Runtime.Tree.ITreeAdaptor;
    class NCalcParser extends Parser {
        tokenNames: string[];
        EOF: number;
        DATETIME: number;
        DIGIT: number;
        E: number;
        EscapeSequence: number;
        FALSE: number;
        FLOAT: number;
        HexDigit: number;
        ID: number;
        INTEGER: number;
        LETTER: number;
        NAME: number;
        STRING: number;
        TRUE: number;
        UnicodeEscape: number;
        WS: number;
        T__19: number;
        T__20: number;
        T__21: number;
        T__22: number;
        T__23: number;
        T__24: number;
        T__25: number;
        T__26: number;
        T__27: number;
        T__28: number;
        T__29: number;
        T__30: number;
        T__31: number;
        T__32: number;
        T__33: number;
        T__34: number;
        T__35: number;
        T__36: number;
        T__37: number;
        T__38: number;
        T__39: number;
        T__40: number;
        T__41: number;
        T__42: number;
        T__43: number;
        T__44: number;
        T__45: number;
        T__46: number;
        T__47: number;
        T__48: number;
        constructor(input: ITokenStream, state?: RecognizerSharedState);
        createTreeAdaptor(adaptor: {
            ref: ITreeAdaptor;
        }): void;
        adaptor: ITreeAdaptor;
        grammarFileName: string;
        private bs;
        private extractString;
        errors: List<string>;
        displayRecognitionError(tokenNames: string[], e: RecognitionException): void;
        onCreated(): void;
        enterRule(ruleName: string, ruleIndex: number): void;
        leaveRule(ruleName: string, ruleIndex: number): void;
        traceIn(ruleName: string, ruleIndex: number): void;
        enterRule_ncalcExpression(): void;
        leaveRule_ncalcExpression(): void;
        ncalcExpression(): ncalcExpression_return;
        enterRule_logicalExpression(): void;
        leaveRule_logicalExpression(): void;
        private logicalExpression;
        enterRule_conditionalExpression(): void;
        leaveRule_conditionalExpression(): void;
        private conditionalExpression;
        enterRule_booleanAndExpression(): void;
        leaveRule_booleanAndExpression(): void;
        booleanAndExpression(): booleanAndExpression_return;
        enterRule_bitwiseOrExpression(): void;
        leaveRule_bitwiseOrExpression(): void;
        bitwiseOrExpression(): bitwiseOrExpression_return;
        enterRule_bitwiseXOrExpression(): void;
        leaveRule_bitwiseXOrExpression(): void;
        bitwiseXOrExpression(): bitwiseXOrExpression_return;
        enterRule_bitwiseAndExpression(): void;
        leaveRule_bitwiseAndExpression(): void;
        bitwiseAndExpression(): bitwiseAndExpression_return;
        enterRule_equalityExpression(): void;
        leaveRule_equalityExpression(): void;
        equalityExpression(): equalityExpression_return;
        enterRule_relationalExpression(): void;
        leaveRule_relationalExpression(): void;
        relationalExpression(): relationalExpression_return;
        enterRule_shiftExpression(): void;
        leaveRule_shiftExpression(): void;
        shiftExpression(): shiftExpression_return;
        enterRule_additiveExpression(): void;
        leaveRule_additiveExpression(): void;
        additiveExpression(): additiveExpression_return;
        enterRule_multiplicativeExpression(): void;
        leaveRule_multiplicativeExpression(): void;
        multiplicativeExpression(): multiplicativeExpression_return;
        enterRule_unaryExpression(): void;
        leaveRule_unaryExpression(): void;
        unaryExpression(): unaryExpression_return;
        enterRule_primaryExpression(): void;
        leaveRule_primaryExpression(): void;
        primaryExpression(): primaryExpression_return;
        enterRule_value(): void;
        leaveRule_value(): void;
        value(): value_return;
        enterRule_identifier(): void;
        leaveRule_identifier(): void;
        identifier(): identifier_return;
        enterRule_expressionList(): void;
        leaveRule_expressionList(): void;
        expressionList(): expressionList_return;
        enterRule_arguments(): void;
        leaveRule_arguments(): void;
        arguments(): arguments_return;
    }
    class ncalcExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class booleanAndExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: any): void;
    }
    class bitwiseOrExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class bitwiseXOrExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class bitwiseAndExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class equalityExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class relationalExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class shiftExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class additiveExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class multiplicativeExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class unaryExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class primaryExpression_return extends AstParserRuleReturnScope<any, IToken> {
        value: LogicalExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class value_return extends AstParserRuleReturnScope<any, IToken> {
        value: ValueExpression;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class identifier_return extends AstParserRuleReturnScope<any, IToken> {
        value: Identifier;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class expressionList_return extends AstParserRuleReturnScope<any, IToken> {
        value: List<LogicalExpression>;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
    class arguments_return extends AstParserRuleReturnScope<any, IToken> {
        value: List<LogicalExpression>;
        constructor(grammar: NCalcParser);
        onCreated(grammar: NCalcParser): void;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    class Numbers {
        private static convertIfString;
        static add(a: any, b: any): any;
        static soustract(a: any, b: any): any;
        static multiply(a: any, b: any): any;
        static divide(a: any, b: any): any;
        static modulo(a: any, b: any): any;
        static max(a: any, b: any): any;
        static min(a: any, b: any): any;
    }
}
declare namespace Stimulsoft.Data.Expressions.NCalc {
    import EventArgs = Stimulsoft.System.EventArgs;
    class ParameterArgs extends EventArgs {
        private _result;
        result: any;
        hasResult: boolean;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    class StiHumanReadableHelper {
        static getSize(size: number): string;
        static getHumanReadableName(name: string): string;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    class StiMoneyNameHelper {
        static isMoneyName(name: string): boolean;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    class DataColumnExt {
        static isNumericType(column: DataColumn): boolean;
        static isDateType(column: DataColumn): boolean;
        static isIntegerType(column: DataColumn): boolean;
        static isMoneyName(column: DataColumn): boolean;
        static getHumanReadableName(column: DataColumn): string;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    class DataTimeExt {
    }
}
declare namespace Stimulsoft.Data.Extensions {
    class EnumerableRowCollectionExt {
    }
}
declare namespace Stimulsoft.Data.Extensions {
}
declare namespace Stimulsoft.Data.Helpers {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiLabelHelper {
        private static cache;
        static getLabel(meter: IStiMeter): string;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class ListTableExt {
        static toNetTable(source: List<any[]>, meters: List<IStiMeter>, onlyColumns?: boolean): DataTable;
        private static loadDataRow;
        private static findType;
        private static findTypeInRows;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiMeterExt {
        static indexOf(meters: List<IStiMeter>, meter: IStiMeter): number;
        static getDimensions(meters: List<IStiMeter>): List<IStiDimensionMeter>;
    }
}
declare namespace Stimulsoft.Data.Extensions {
    class TOuterExt {
    }
}
declare namespace Stimulsoft.Data.Functions {
    enum StiQuarter {
        Q1 = 1,
        Q2 = 2,
        Q3 = 3,
        Q4 = 4
    }
    enum StiMonth {
        January = 1,
        February = 2,
        March = 3,
        April = 4,
        May = 5,
        June = 6,
        July = 7,
        August = 8,
        September = 9,
        October = 10,
        November = 11,
        December = 12
    }
}
declare namespace Stimulsoft.Data.Functions {
    import DateTime = Stimulsoft.System.DateTime;
    class StiDayOfWeekToStrHelper {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        /**
         * Returns the day of the week.
         */
        static dayOfWeek(date: DateTime): string;
        /**
         * Returns the day of the week.
         */
        static dayOfWeek2(date: DateTime, localized: boolean): string;
        static dayOfWeek3(dateTime: DateTime, culture: string): string;
        static dayOfWeek4(dateTime: DateTime, culture: string, upperCase: boolean): string;
        static addCulture(monthNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static initialize(): void;
    }
}
declare namespace Stimulsoft.Data.Functions {
    import DateTime = Stimulsoft.System.DateTime;
    /**
     * MonthToStr helper.
     */
    class StiMonthToStrHelper {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime): string;
        static monthName2(dateTime: DateTime, localized: boolean): string;
        static monthName3(dateTime: DateTime, culture: string): string;
        static monthName4(dateTime: DateTime, culture: string, upperCase: boolean): string;
        static addCulture(monthNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static initialize(): void;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiDataTableConverter {
        static toNetTable(dataTable: StiDataTable, types?: Type[]): DataTable;
        private static getDataType;
    }
}
declare namespace Stimulsoft.Data.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiUsedDataHelper {
        static getMany(...meters: IStiMeter[]): List<string>;
        static getMany2(meters: List<IStiMeter>): List<string>;
        static getSingle(meter: IStiMeter): List<string>;
        static getSingle2(expression: string): List<string>;
    }
}
declare namespace Stimulsoft.Data.Parsers {
    class StiFunctionColumnPair {
        private _function;
        function: string;
        private _columnName;
        columnName: string;
    }
}

declare module Stimulsoft.Report.BarCodes {
    class ArrayHelper {
        static copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class BitVector {
        private sizeInBits;
        private array;
        constructor();
        at(index: number): number;
        size(): number;
        sizeInBytes(): number;
        appendBit(bit: number): void;
        appendBits(value: number, numBits: number): void;
        appendBitVector(bits: BitVector): void;
        xor(other: BitVector): void;
        toString(): string;
        getArray(): number[];
        private appendByte;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class BlockPair {
        private dataBytes;
        private errorCorrectionBytes;
        constructor(data: ByteArray, errorCorrection: ByteArray);
        getDataBytes(): ByteArray;
        getErrorCorrectionBytes(): ByteArray;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ByteArray {
        private static INITIAL_SIZE;
        private _bytes;
        private _size;
        constructor(size?: number, byteArray?: number[]);
        at(index: number): number;
        set(index: number, value: number): void;
        size(): number;
        isEmpty(): boolean;
        appendByte(value: number): void;
        reserve(capacity: number): void;
        set1(source: number[], offset: number, count: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ByteMatrix {
        private _bytes;
        private _width;
        private _height;
        getValueString(): string;
        constructor(width: number, height: number);
        getHeight(): number;
        getWidth(): number;
        get(x: number, y: number): Stimulsoft.System.SByte;
        getArray(): Stimulsoft.System.SByte[][];
        set(x: number, y: number, value: Stimulsoft.System.SByte): void;
        set2(x: number, y: number, value: number): void;
        clear(value: Stimulsoft.System.SByte): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CharacterSetECI {
        private static lockNAME_TO_ECI;
        private static _name_to_eci;
        static NAME_TO_ECI: Hashtable;
        private static Initialize;
        private _encodingName;
        private _value;
        constructor(value: number, encodingName: string);
        getEncodingName(): string;
        getValue(): number;
        private static addCharacterSet;
        static getCharacterSetECIByName(name: String): CharacterSetECI;
        static GetEncodingByNumber(number: number, defaultEncoding: string): string;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ErrorCorrectionLevel {
        static L: ErrorCorrectionLevel;
        static M: ErrorCorrectionLevel;
        static Q: ErrorCorrectionLevel;
        static H: ErrorCorrectionLevel;
        private _ordinal;
        private _bits;
        private _name;
        constructor(ordinal: number, bits: number, name: string);
        ordinal(): number;
        getBits(): number;
        getName(): string;
        toString(): string;
        static forBits(bits: number): ErrorCorrectionLevel;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class FormatInformation {
        private FORMAT_INFO_MASK_QR;
        private static FORMAT_INFO_DECODE_LOOKUP;
        private static BITS_SET_IN_HALF_BYTE;
        private errorCorrectionLevel;
        private dataMask;
        constructor(formatInfo: number);
        static numBitsDiffering(a: number, b: number): number;
        static decodeFormatInformation(maskedFormatInfo1: number, maskedFormatInfo2: number): FormatInformation;
        private static doDecodeFormatInformation;
        getErrorCorrectionLevel(): ErrorCorrectionLevel;
        getDataMask(): number;
        stiEquals(o: Object): boolean;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class GF256 {
        static QR_CODE_FIELD: GF256;
        static DATA_MATRIX_FIELD: GF256;
        private _expTable;
        private _logTable;
        private _zero;
        private _one;
        constructor(primitive: number);
        getZero(): GF256Poly;
        getOne(): GF256Poly;
        buildMonomial(degree: number, coefficient: number): GF256Poly;
        static addOrSubtract(a: number, b: number): number;
        exp(a: number): number;
        log(a: number): number;
        inverse(a: number): number;
        multiply(a: number, b: number): number;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class GF256Poly {
        _field: GF256;
        _coefficients: number[];
        constructor(field: GF256, coefficients: number[]);
        getCoefficients(): number[];
        getDegree(): number;
        isZero(): boolean;
        getCoefficient(degree: number): number;
        evaluateAt(a: number): number;
        addOrSubtract(other: GF256Poly): GF256Poly;
        multiply(other: GF256Poly): GF256Poly;
        multiply1(scalar: number): GF256Poly;
        multiplyByMonomial(degree: number, coefficient: number): GF256Poly;
        divide(other: GF256Poly): GF256Poly[];
    }
}
declare module Stimulsoft.Report.BarCodes {
    class MaskUtil {
        static applyMaskPenaltyRule1(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule2(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule3(matrix: ByteMatrix): number;
        static applyMaskPenaltyRule4(matrix: ByteMatrix): number;
        static getDataMaskBit(maskPattern: number, x: number, y: number): boolean;
        private static ApplyMaskPenaltyRule1Internal;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class MatrixUtil {
        private static POSITION_DETECTION_PATTERN;
        private static HORIZONTAL_SEPARATION_PATTERN;
        private static VERTICAL_SEPARATION_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN;
        private static POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
        private static TYPE_INFO_COORDINATES;
        private static VERSION_INFO_POLY;
        private static TYPE_INFO_POLY;
        private static TYPE_INFO_MASK_PATTERN;
        static ClearMatrix(matrix: ByteMatrix): void;
        static BuildMatrix(dataBits: BitVector, ecLevel: ErrorCorrectionLevel, version: number, maskPattern: number, matrix: ByteMatrix): void;
        static EmbedBasicPatterns(version: number, matrix: ByteMatrix): void;
        static EmbedTypeInfo(ecLevel: ErrorCorrectionLevel, maskPattern: number, matrix: ByteMatrix): void;
        static MaybeEmbedVersionInfo(version: number, matrix: ByteMatrix): void;
        static EmbedDataBits(dataBits: BitVector, maskPattern: number, matrix: ByteMatrix): void;
        static FindMSBSet(value: number): number;
        static CalculateBCHCode(value: number, poly: number): number;
        static MakeTypeInfoBits(ecLevel: ErrorCorrectionLevel, maskPattern: number, bits: BitVector): void;
        static MakeVersionInfoBits(version: number, bits: BitVector): void;
        private static IsEmpty;
        private static IsValidValue;
        private static EmbedTimingPatterns;
        private static EmbedDarkDotAtLeftBottomCorner;
        private static EmbedHorizontalSeparationPattern;
        private static EmbedVerticalSeparationPattern;
        private static EmbedPositionAdjustmentPattern;
        private static EmbedPositionDetectionPattern;
        private static EmbedPositionDetectionPatternsAndSeparators;
        private static MaybeEmbedPositionAdjustmentPatterns;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class Mode {
        static TERMINATOR: Mode;
        static NUMERIC: Mode;
        static ALPHANUMERIC: Mode;
        static STRUCTURED_APPEND: Mode;
        static BYTE: Mode;
        static ECI: Mode;
        static KANJI: Mode;
        static FNC1_FIRST_POSITION: Mode;
        static FNC1_SECOND_POSITION: Mode;
        private characterCountBitsForVersions;
        private bits;
        private name;
        constructor(characterCountBitsForVersions: number[], bits: number, name: string);
        static ForBits(bits: number): Mode;
        GetCharacterCountBits(version: Version): number;
        GetBits(): number;
        GetName(): string;
        ToString(): string;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class QREncoder {
        private static ALPHANUMERIC_TABLE;
        private static defaultECIByteModeEncoding;
        private static BYTE_MODE_UTF8;
        private static QUESTION_MARK_CHAR;
        private static CalculateMaskPenalty;
        static Encode(content: string, ecLevel: ErrorCorrectionLevel, qrCode: StiQRCode): void;
        private static GetEncodingName;
        private static GetAlphanumericCode;
        static ChooseMode(content: string): Mode;
        static ChooseMode1(content: string, encoding: string): Mode;
        private static ChooseMaskPattern;
        private static InitQRCode;
        private static TerminateBits;
        private static GetNumDataBytesAndNumECBytesForBlockID;
        private static InterleaveWithECBytes;
        private static GenerateECBytes;
        private static AppendModeInfo;
        private static AppendLengthInfo;
        private static AppendBytes;
        private static AppendNumericBytes;
        private static AppendAlphanumericBytes;
        private static Append8BitBytes;
        private static AppendKanjiBytes;
        private static AppendECI;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ReedSolomonEncoder {
        private field;
        private cachedGenerators;
        constructor(field: GF256);
        private BuildGenerator;
        Encode(toEncode: number[], ecBytes: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    class StiQRCode {
        static NUM_MASK_PATTERNS: number;
        private _mode;
        private _ecLevel;
        private _version;
        private _matrixWidth;
        private _maskPattern;
        private _numTotalBytes;
        private _numDataBytes;
        private _numECBytes;
        private _numRSBlocks;
        private _matrix;
        GetMode(): Mode;
        GetECLevel(): ErrorCorrectionLevel;
        GetVersion(): number;
        GetMatrixWidth(): number;
        GetMaskPattern(): number;
        GetNumTotalBytes(): number;
        GetNumDataBytes(): number;
        GetNumECBytes(): number;
        GetNumRSBlocks(): number;
        GetMatrix(): ByteMatrix;
        At(x: number, y: number): number;
        IsValid(): boolean;
        SetMode(value: Mode): void;
        SetECLevel(value: ErrorCorrectionLevel): void;
        SetVersion(value: number): void;
        SetMatrixWidth(value: number): void;
        SetMaskPattern(value: number): void;
        SetNumTotalBytes(value: number): void;
        SetNumDataBytes(value: number): void;
        SetNumECBytes(value: number): void;
        SetNumRSBlocks(value: number): void;
        SetMatrix(value: ByteMatrix): void;
        static IsValidMaskPattern(maskPattern: number): boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.BarCodes {
    class ECB {
        private _count;
        private _dataCodewords;
        constructor(count: number, dataCodewords: number);
        getCount(): number;
        getDataCodewords(): number;
    }
    class ECBlocks {
        private ecCodewordsPerBlock;
        private ecBlocks;
        constructor(ecCodewordsPerBlock: number, ecBlocks1: ECB, ecBlocks2?: ECB);
        getECCodewordsPerBlock(): number;
        getNumBlocks(): number;
        getTotalECCodewords(): number;
        getECBlocks(): ECB[];
    }
    class Version {
        private static VERSION_DECODE_INFO;
        private static BuildVersions;
        private static VERSIONS;
        private _versionNumber;
        private _alignmentPatternCenters;
        private _ecBlocks;
        private _totalCodewords;
        constructor(versionNumber: number, alignmentPatternCenters: number[], ecBlocks1: ECBlocks, ecBlocks2: ECBlocks, ecBlocks3: ECBlocks, ecBlocks4: ECBlocks);
        getVersionNumber(): number;
        getAlignmentPatternCenters(): number[];
        getTotalCodewords(): number;
        getDimensionForVersion(): number;
        getECBlocksForLevel(ecLevel: ErrorCorrectionLevel): ECBlocks;
        static getProvisionalVersionForDimension(dimension: number): Version;
        static getVersionForNumber(versionNumber: number): Version;
        static decodeVersionInformation(versionBits: number): Version;
        toString(): string;
    }
}
declare module Stimulsoft.Report.BarCodes {
    enum CodeSet {
        None = 0,
        A = 1,
        B = 2,
        C = 3
    }
    enum ControlCodes {
        FNC1 = 129,
        FNC2 = 130,
        FNC3 = 131,
        FNC4 = 132,
        CodeA = 133,
        CodeB = 134,
        CodeC = 135,
        Shift = 136
    }
    enum BarcodeCommands {
        FNC1 = 102,
        FNC2 = 97,
        FNC3 = 96,
        FNC4A = 101,
        FNC4B = 100,
        CodeA = 101,
        CodeB = 100,
        CodeC = 99,
        Shift = 98,
        StartA = 103,
        StartB = 104,
        StartC = 105,
        Stop = 106
    }
    enum StiCheckSum {
        Yes = 0,
        No = 1
    }
    enum StiPlesseyCheckSum {
        None = 0,
        Modulo10 = 1,
        Modulo11 = 2
    }
    enum StiDataMatrixSize {
        Automatic = -1,
        s10x10 = 0,
        s12x12 = 1,
        s8x18 = 2,
        s14x14 = 3,
        s8x32 = 4,
        s16x16 = 5,
        s12x26 = 6,
        s18x18 = 7,
        s20x20 = 8,
        s12x36 = 9,
        s22x22 = 10,
        s16x36 = 11,
        s24x24 = 12,
        s26x26 = 13,
        s16x48 = 14,
        s32x32 = 15,
        s36x36 = 16,
        s40x40 = 17,
        s44x44 = 18,
        s48x48 = 19,
        s52x52 = 20,
        s64x64 = 21,
        s72x72 = 22,
        s80x80 = 23,
        s88x88 = 24,
        s96x96 = 25,
        s104x104 = 26,
        s120x120 = 27,
        s132x132 = 28,
        s144x144 = 29
    }
    enum StiDataMatrixEncodingType {
        Ascii = 0,
        C40 = 1,
        Text = 2,
        X12 = 3,
        Edifact = 4,
        Binary = 5
    }
    enum StiPdf417EncodingMode {
        Text = 0,
        Numeric = 1,
        Byte = 2
    }
    enum StiPdf417ErrorsCorrectionLevel {
        Automatic = -1,
        Level0 = 0,
        Level1 = 1,
        Level2 = 2,
        Level3 = 3,
        Level4 = 4,
        Level5 = 5,
        Level6 = 6,
        Level7 = 7,
        Level8 = 8
    }
    enum StiEanSupplementType {
        None = 0,
        TwoDigit = 1,
        FiveDigit = 2
    }
    enum StiCode11CheckSum {
        None = 0,
        OneDigit = 1,
        TwoDigits = 2,
        Auto = 3
    }
    enum StiQRCodeSize {
        Automatic = 0,
        v1 = 1,
        v2 = 2,
        v3 = 3,
        v4 = 4,
        v5 = 5,
        v6 = 6,
        v7 = 7,
        v8 = 8,
        v9 = 9,
        v10 = 10,
        v11 = 11,
        v12 = 12,
        v13 = 13,
        v14 = 14,
        v15 = 15,
        v16 = 16,
        v17 = 17,
        v18 = 18,
        v19 = 19,
        v20 = 20,
        v21 = 21,
        v22 = 22,
        v23 = 23,
        v24 = 24,
        v25 = 25,
        v26 = 26,
        v27 = 27,
        v28 = 28,
        v29 = 29,
        v30 = 30,
        v31 = 31,
        v32 = 32,
        v33 = 33,
        v34 = 34,
        v35 = 35,
        v36 = 36,
        v37 = 37,
        v38 = 38,
        v39 = 39,
        v40 = 40
    }
    enum StiQRCodeErrorCorrectionLevel {
        Level1 = 0,
        Level2 = 1,
        Level3 = 2,
        Level4 = 3
    }
    enum StiQRCodeECIMode {
        Cp437 = 2,
        ISO_8859_1 = 3,
        ISO_8859_2 = 4,
        ISO_8859_3 = 5,
        ISO_8859_4 = 6,
        ISO_8859_5 = 7,
        ISO_8859_6 = 8,
        ISO_8859_7 = 9,
        ISO_8859_8 = 10,
        ISO_8859_9 = 11,
        ISO_8859_11 = 13,
        ISO_8859_13 = 15,
        ISO_8859_15 = 17,
        Shift_JIS = 20,
        Windows_1250 = 21,
        Windows_1251 = 22,
        Windows_1252 = 23,
        Windows_1256 = 24,
        UTF_8 = 26
    }
    enum StiMaxicodeMode {
        Mode2 = 2,
        Mode3 = 3,
        Mode4 = 4,
        Mode5 = 5,
        Mode6 = 6
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    var IStiBarCode: string;
    interface IStiBarCode extends IStiBackColor, IStiForeColor {
        getBarCodeString(): string;
        autoScale: boolean;
        showLabelText: boolean;
        barCodeType: StiBarCodeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128,
        Abbreviation = 256,
        NegativeInRed = 512
    }
    enum StiIconSet {
        None = 0,
        Full = 1,
        ArrowsColored3 = 2,
        ArrowsColored4 = 3,
        ArrowsColored5 = 4,
        ArrowsGray3 = 5,
        ArrowsGray4 = 6,
        ArrowsGray5 = 7,
        Flags3 = 8,
        Latin4 = 9,
        Quarters5 = 10,
        QuartersGreen5 = 11,
        QuartersRed5 = 12,
        Ratings3 = 13,
        Ratings4 = 14,
        Ratings5 = 15,
        RedToBlack4 = 16,
        Signs3 = 17,
        Squares5 = 18,
        Stars3 = 19,
        Stars5 = 20,
        SymbolsCircled3 = 21,
        SymbolsUncircled3 = 22,
        TrafficLights4 = 23,
        TrafficLightsRimmed3 = 24,
        TrafficLightsUnrimmed3 = 25,
        Triangles3 = 26
    }
    enum StiIcon {
        None = 0,
        ArrowRightDownGray = 1,
        ArrowRightUpGray = 2,
        ArrowDownGray = 3,
        ArrowRightGray = 4,
        ArrowUpGray = 5,
        ArrowUpGreen = 6,
        ArrowDownRed = 7,
        ArrowRightYellow = 8,
        ArrowRightDownYellow = 9,
        ArrowRightUpYellow = 10,
        CheckGreen = 11,
        CircleBlack = 12,
        CircleGreen = 13,
        CircleCheckGreen = 14,
        CircleRed = 15,
        CircleCrossRed = 16,
        CircleYellow = 17,
        CircleExclamationYellow = 18,
        CrossRed = 19,
        ExclamationYellow = 20,
        FlagGreen = 21,
        FlagRed = 22,
        FlagYellow = 23,
        FromRedToBlackGray = 24,
        FromRedToBlackPink = 25,
        FromRedToBlackRed = 26,
        Latin1 = 27,
        Latin2 = 28,
        Latin3 = 29,
        Latin4 = 30,
        LightsGreen = 31,
        LightsRed = 32,
        LightsYellow = 33,
        MinusYellow = 34,
        QuarterFull = 35,
        QuarterFullGreen = 36,
        QuarterFullRed = 37,
        QuarterHalf = 38,
        QuarterHalfGreen = 39,
        QuarterHalfRed = 40,
        QuarterNone = 41,
        QuarterNoneGreen = 42,
        QuarterNoneRed = 43,
        QuarterQuarter = 44,
        QuarterQuarterGreen = 45,
        QuarterQuarterRed = 46,
        QuarterThreeFourth = 47,
        QuarterThreeFourthGreen = 48,
        QuarterThreeFourthRed = 49,
        Rating0 = 50,
        Rating1 = 51,
        Rating2 = 52,
        Rating3 = 53,
        Rating4 = 54,
        RhombRed = 55,
        Square0 = 56,
        Square1 = 57,
        Square2 = 58,
        Square3 = 59,
        Square4 = 60,
        StarFull = 61,
        StarHalf = 62,
        StarNone = 63,
        StarQuarter = 64,
        StarThreeFourth = 65,
        TriangleGreen = 66,
        TriangleRed = 67,
        TriangleYellow = 68
    }
    enum StiIconSetOperation {
        MoreThan = 0,
        MoreThanOrEqual = 1
    }
    enum StiIconSetValueType {
        Value = 0,
        Percent = 1
    }
    enum StiProcessAt {
        None = 0,
        EndOfReport = 1,
        EndOfPage = 2
    }
    enum StiMinimumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Minimum = 3
    }
    enum StiMidType {
        Auto = 0,
        Value = 1,
        Percent = 2
    }
    enum StiMaximumType {
        Auto = 0,
        Value = 1,
        Percent = 2,
        Maximum = 3
    }
    enum StiDrillDownMode {
        SinglePage = 0,
        MultiPage = 1
    }
    enum StiConditionBorderSides {
        None = 0,
        All = 15,
        Top = 1,
        Left = 2,
        Right = 4,
        Bottom = 8,
        NotAssigned = 16
    }
    enum StiConditionPermissions {
        None = 0,
        Font = 1,
        FontSize = 2,
        FontStyleBold = 4,
        FontStyleItalic = 8,
        FontStyleUnderline = 16,
        FontStyleStrikeout = 32,
        TextColor = 64,
        BackColor = 128,
        Borders = 256,
        All = 511
    }
    enum StiQuickInfoType {
        None = 0,
        ShowComponentsNames = 1,
        ShowAliases = 2,
        ShowFieldsOnly = 3,
        ShowFields = 4,
        ShowEvents = 5,
        ShowContent = 6
    }
    enum StiAngle {
        Angle0 = 0,
        Angle90 = 90,
        Angle180 = 180,
        Angle270 = 270
    }
    enum StiDockStyle {
        Left = 0,
        Right = 1,
        Top = 2,
        Bottom = 3,
        None = 4,
        Fill = 5
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4
    }
    enum StiFilterMode {
        And = 0,
        Or = 1
    }
    enum StiFilterEngine {
        ReportEngine = 0,
        SQLQuery = 1
    }
    enum StiKeepDetails {
        None = 0,
        KeepFirstRowTogether = 1,
        KeepFirstDetailTogether = 2,
        KeepDetailsTogether = 3
    }
    enum StiPrintOnType {
        AllPages = 0,
        ExceptFirstPage = 1,
        ExceptLastPage = 2,
        ExceptFirstAndLastPage = 3,
        OnlyFirstPage = 4,
        OnlyLastPage = 8,
        OnlyFirstAndLastPage = 12
    }
    enum StiPrintOnEvenOddPagesType {
        Ignore = 0,
        PrintOnEvenPages = 1,
        PrintOnOddPages = 2
    }
    enum StiShiftMode {
        None = 0,
        IncreasingSize = 1,
        DecreasingSize = 2,
        OnlyInWidthOfComponent = 4
    }
    enum StiAnchorMode {
        Top = 1,
        Bottom = 2,
        Left = 4,
        Right = 8
    }
    enum StiProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveText = 3,
        BasedOnTagMerge = 4,
        BasedOnTagHide = 5,
        BasedOnTagRemoveText = 6,
        GlobalMerge = 7,
        GlobalHide = 8,
        GlobalRemoveText = 9,
        BasedOnValueRemoveText = 10,
        BasedOnValueAndTagMerge = 11,
        BasedOnValueAndTagHide = 12,
        GlobalBasedOnValueRemoveText = 13,
        GlobalBasedOnValueAndTagMerge = 14,
        GlobalBasedOnValueAndTagHide = 15
    }
    enum StiImageProcessingDuplicatesType {
        None = 0,
        Merge = 1,
        Hide = 2,
        RemoveImage = 3,
        GlobalMerge = 4,
        GlobalHide = 5,
        GlobalRemoveImage = 6
    }
    enum StiCheckStyle {
        Cross = 0,
        Check = 1,
        CrossRectangle = 2,
        CheckRectangle = 3,
        CrossCircle = 4,
        DotCircle = 5,
        DotRectangle = 6,
        NoneCircle = 7,
        NoneRectangle = 8,
        None = 9
    }
    enum StiToolboxCategory {
        Bands = 0,
        Cross = 1,
        Components = 2,
        Shapes = 3,
        Controls = 4,
        Dashboards = 5
    }
    /**
     *  Enumeration which sets positions of the report components on the toolbox of the report designer.
     */
    enum StiComponentToolboxPosition {
        Component = 0,
        /**
         *  Sets a position of the ReportTitle band on the toolbox of the designer.
         */
        ReportTitleBand = 1,
        /**
         *  Sets a position of the ReportSummary band on the toolbox of the designer.
         */
        ReportSummaryBand = 2,
        /**
         *  Sets a position of the PageHeader band on the toolbox of the designer.
         */
        PageHeaderBand = 3,
        /**
         *  Sets a position of the PageFooter band on the toolbox of the designer.
         */
        PageFooterBand = 4,
        /**
         *  Sets a position of the GroupHeader band on the toolbox of the designer.
         */
        GroupHeaderBand = 5,
        /**
         *  Sets a position of the GroupFooter band on the toolbox of the designer.
         */
        GroupFooterBand = 6,
        /**
         *  Sets a position of the Header band on the toolbox of the designer.
         */
        HeaderBand = 7,
        /**
         *  Sets a position of the Footer band on the toolbox of the designer.
         */
        FooterBand = 8,
        /**
         *  Sets a position of the ColumnHeader band on the toolbox of the designer.
         */
        ColumnHeaderBand = 9,
        /**
         *  Sets a position of the ColumnFooter band on the toolbox of the designer.
         */
        ColumnFooterBand = 10,
        /**
         *  Sets a position of the Data band on the toolbox of the designer.
         */
        DataBand = 11,
        /**
         *  Sets a position of the Hierarchical band on the toolbox of the designer.
         */
        HierarchicalBand = 13,
        /**
         *  Sets a position of the Child band on the toolbox of the designer.
         */
        ChildBand = 14,
        /**
         *  Sets a position of the Empty band on the toolbox of the designer.
         */
        EmptyBand = 15,
        /**
         *  Sets a position of the Overlay band on the toolbox of the designer.
         */
        OverlayBand = 16,
        /**
         *  Sets a position of the CrossGroupHeader band on the toolbox of the designer.
         */
        CrossGroupHeaderBand = 21,
        /**
         *  Sets a position of the CrossGroupFooter band on the toolbox of the designer.
         */
        CrossGroupFooterBand = 22,
        /**
         *  Sets a position of the CrossHeader band on the toolbox of the designer.
         */
        CrossHeaderBand = 23,
        /**
         *  Sets a position of the CrossFooter band on the toolbox of the designer.
         */
        CrossFooterBand = 24,
        /**
         *  Sets a position of the CrossData band on the toolbox of the designer.
         */
        CrossDataBand = 25,
        /**
         *  Sets a position of the Text component on the toolbox of the designer.
         */
        Text = 101,
        /**
         *  Sets a position of the TextInCells component on the toolbox of the designer.
         */
        TextInCells = 102,
        /**
         *  Sets a position of the SystemText component on the toolbox of the designer.
         */
        SystemText = 103,
        /**
         *  Sets a position of the ContourText component on the toolbox of the designer.
         */
        ContourText = 104,
        /**
         *  Sets a position of the RichText component on the toolbox of the designer.
         */
        RichText = 105,
        /**
         *  Sets a position of the Image component on the toolbox of the designer.
         */
        Image = 106,
        /**
         *  Sets a position of the BarCode component on the toolbox of the designer.
         */
        BarCode = 107,
        /**
         *  Sets a position of the Shape component on the toolbox of the designer.
         */
        Shape = 108,
        /**
         *  Sets a position of the Line component on the toolbox of the designer.
         */
        Line = 109,
        /**
         *  Sets a position of the Container component on the toolbox of the designer.
         */
        Container = 110,
        /**
         *  Sets a position of the Panel component on the toolbox of the designer.
         */
        Panel = 110,
        /**
         *  Sets a position of the Clone component on the toolbox of the designer.
         */
        Clone = 112,
        /**
         *  Sets a position of the CheckBox component on the toolbox of the designer.
         */
        CheckBox = 113,
        /**
         *  Sets a position of the SubReport component on the toolbox of the designer.
         */
        SubReport = 114,
        /**
         *  Sets a position of the WinControl component on the toolbox of the designer.
         */
        WinControl = 115,
        /**
         *  Sets a position of the ZipCode component on the toolbox of the designer.
         */
        ZipCode = 116,
        /**
         *  Sets a position of the HorizontalLinePrimitive component on the toolbox of the designer.
         */
        HorizontalLinePrimitive = 150,
        /**
         *  Sets a position of the VerticalLinePrimitive component on the toolbox of the designer.
         */
        VerticalLinePrimitive = 151,
        /**
         *  Sets a position of the RectanglePrimitive component on the toolbox of the designer.
         */
        RectanglePrimitive = 152,
        /**
         *  Sets a position of the RoundedRectanglePrimitive component on the toolbox of the designer.
         */
        RoundedRectanglePrimitive = 153,
        /**
         *  Sets a position of the Chart component on the toolbox of the designer.
         */
        Chart = 200,
        /**
         *  Sets a position of the Table on the toolbox of the designer.
         */
        Table = 201,
        /**
         *  Sets a position of the CrossTab band on the toolbox of the designer.
         */
        CrossTab = 202,
        /**
         *  Sets a position of the Gauge component on the toolbox of the designer.
         */
        Map = 210,
        /**
         *  Sets a position of the Gauge component on the toolbox of the designer.
         */
        Gauge = 220,
        /**
         *  Sets a position of the Dashboard Table component on the toolbox of the designer.
         */
        TableElement = 301,
        /**
         *  Sets a position of the Dashboard Chart component on the toolbox of the designer.
         */
        ChartElement = 302,
        /**
         *  Sets a position of the Dashboard ComboBox component on the toolbox of the designer.
         */
        ComboBoxElement = 400,
        /**
         *  Sets a position of the Dashboard Gauge component on the toolbox of the designer.
         */
        GaugeElement = 303,
        /**
         *  Sets a position of the Dashboard Pivot component on the toolbox of the designer.
         */
        PivotTableElement = 304,
        /**
         *  Sets a position of the Dashboard Indicator component on the toolbox of the designer.
         */
        IndicatorElement = 305,
        /**
         *  Sets a position of the Dashboard Progress component on the toolbox of the designer.
         */
        ProgressElement = 306,
        /**
         *  Sets a position of the Dashboard Map component on the toolbox of the designer.
         */
        RegionMapElement = 307,
        /**
         *  Sets a position of the Dashboard ListBox component on the toolbox of the designer.
         */
        ListBoxElement = 308,
        /**
         *  Sets a position of the Dashboard Online Map component on the toolbox of the designer.
         */
        OnlineMapElement = 309,
        /**
         *  Sets a position of the Dashboard Image component on the toolbox of the designer.
         */
        ImageElement = 310,
        /**
         *  Sets a position of the Dashboard Text component on the toolbox of the designer.
         */
        TextElement = 311,
        /**
         *  Sets a position of the Dashboard Panel component on the toolbox of the designer.
         */
        PanelElement = 312,
        /**
         *  Sets a position of the Dashboard Shape component on the toolbox of the designer.
         */
        ShapeElement = 313,
        /**
         *  Sets a position of the Dashboard TreeView component on the toolbox of the designer.
         */
        TreeViewElement = 314,
        /**
         *  Sets a position of the Dashboard TreeViewBox component on the toolbox of the designer.
         */
        TreeViewBoxElement = 315,
        /**
         *  Sets a position of the Dashboard DatePicker component on the toolbox of the designer.
         */
        DatePickerElement = 316,
        /**
         *  Sets a position of the UserCode component on the toolbox of the designer.
         */
        UserCode = 1000
    }
    enum StiComponentPriority {
        Component = 0,
        CrossTab = 1500,
        SubReportsV1 = 1500,
        SubReportsV2 = 0,
        Container = 0,
        Panel = 0,
        ReportTitleBandBefore = -400,
        ReportTitleBandAfterV1 = -200,
        ReportTitleBandAfterV2 = 200,
        ReportSummaryBand = 500,
        PageHeaderBandBefore = -200,
        PageHeaderBandAfter = -400,
        PageFooterBandBottom = -300,
        PageFooterBandTop = 1000,
        GroupHeaderBand = 300,
        GroupFooterBand = 300,
        HeaderBand = 300,
        FooterBand = 300,
        ColumnHeaderBand = 300,
        ColumnFooterBand = 300,
        DataBand = 300,
        Table = 300,
        ChildBand = 300,
        EmptyBand = 300,
        OverlayBand = 700,
        Primitive = 1500,
        CrossGroupHeaderBand = 300,
        CrossGroupFooterBand = 300,
        CrossHeaderBand = 300,
        CrossFooterBand = 300,
        CrossDataBand = 300
    }
    enum StiComponentType {
        /** Simple components - only one copy in one print cycle is output.*/
        Simple = 0,
        /** Master components – more than one copy in one print cycle are output.*/
        Master = 1,
        /** Detailed components – these components are output with Master components.*/
        Detail = 2,
        /** Static components – these components are the same as simple components but are output on pages only.*/
        Static = 3
    }
    enum StiRestrictions {
        None = 0,
        AllowMove = 1,
        AllowResize = 2,
        AllowSelect = 4,
        AllowChange = 8,
        AllowDelete = 16,
        All = 31
    }
    enum StiHighlightState {
        Hide = 0,
        Show = 1,
        Active = 2
    }
    enum StiAligning {
        Left = 0,
        Center = 1,
        Right = 2,
        Top = 3,
        Middle = 4,
        Bottom = 5
    }
    enum StiColumnDirection {
        DownThenAcross = 0,
        AcrossThenDown = 1
    }
    enum StiEmptySizeMode {
        IncreaseLastRow = 0,
        DecreaseLastRow = 1,
        AlignFooterToBottom = 2,
        AlignFooterToTop = 3
    }
    enum StiGroupSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2
    }
    enum StiGroupSummaryType {
        Avg = 0,
        AvgDate = 1,
        AvgTime = 2,
        Count = 3,
        CountDistinct = 4,
        MaxDate = 5,
        MaxTime = 6,
        Max = 7,
        MinDate = 8,
        MinTime = 9,
        Min = 10,
        Median = 11,
        Mode = 12,
        Sum = 13,
        SumTime = 14
    }
    enum StiPageOrientation {
        Portrait = 0,
        Landscape = 1
    }
    enum StiTextQuality {
        Standard = 0,
        Typographic = 1,
        Wysiwyg = 2
    }
    enum StiSystemTextType {
        Totals = 0,
        SystemVariables = 1,
        Expression = 2,
        DataColumn = 3,
        None = 4
    }
    enum StiBrushType {
        Solid = 0,
        Gradient = 1
    }
    enum StiColorScaleType {
        Color2 = 0,
        Color3 = 1
    }
    enum StiDataBarDirection {
        Default = 0,
        LeftToRight = 1,
        RighToLeft = 2
    }
    enum StiInteractionSortDirection {
        Ascending = 0,
        Descending = 1,
        None = 2
    }
    enum StiImageRotation {
        None = 0,
        Rotate90CW = 1,
        Rotate90CCW = 2,
        Rotate180 = 3,
        FlipHorizontal = 4,
        FlipVertical = 5
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiBarCodePainter = Stimulsoft.Report.Painters.IStiBarCodePainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    interface DrawBaseLinesDelegate {
        (cobtext: any, brush: StiBrush, barCode: StiBarCodeTypeService): any;
    }
    enum BarcodeCommandCode {
        Fnc1 = 256,
        Fnc2 = 512,
        Fnc3 = 768,
        Fnc4 = 1024
    }
    class StiBarCodeTypeService extends StiService {
        static loadFromJsonObjectInternal(jObject: StiJson): StiBarCodeTypeService;
        static loadFromXmlInternal(xmlNode: XmlNode): StiBarCodeTypeService;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        loadFromXmlObject(xmlNode: XmlNode): void;
        visiblePropertiesCount: number;
        private _visibleProperties;
        visibleProperties: boolean[];
        readonly defaultCodeValue: string;
        private _customPainter;
        customPainter: IStiBarCodePainter;
        private _mainWidth;
        readonly mainWidth: number;
        private _mainHeight;
        readonly mainHeight: number;
        private _barCodeData;
        readonly barCodeData: StiBarCodeData;
        module: number;
        height: number;
        protected readonly textAlignment: StringAlignment;
        protected readonly textSpacing: boolean;
        protected rectWindow: RectangleD;
        readonly labelFontHeight: number;
        protected defaultLabelFontHeight: number;
        protected checkCodeSymbols(inputCode: string, tolerantSymbols: string): string;
        getCode(barCode: IStiBarCode): string;
        getCombinedCode(): string;
        static unpackTilde(input: number[], processTilde: boolean): number[];
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolLong(symbol: string): boolean;
        protected isSymbolSpace(symbol: string): boolean;
        protected isSymbolPostDescend(symbol: string): boolean;
        protected getSymbolsStringWidth(symbolsString: string): number;
        protected drawBars(context: any, sym: string, foreBrush: StiBrush): void;
        protected drawBarCode(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCode1(context: any, rect: RectangleD, barCode: StiBarCode, drawMethod: DrawBaseLinesDelegate): void;
        protected calculateSizeFull(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, TextPosition: number, TextHeight: number, mainHeight: number, lineHeightForCut: number, wideToNarrowRatio: number, zoom: number, code: string, textString: string, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected calculateSize2(spaceLeft: number, spaceRight: number, spaceTop: number, spaceBottom: number, lineHeightShort: number, lineHeightLong: number, textPosition: number, textHeight: number, mainHeight: number, wideToNarrowRatio: number, zoom: number, barsArray: string, rect: RectangleD, barCode: StiBarCode): void;
        protected draw2DBarCode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawMaxicode(context: any, rect: RectangleD, barCode: StiBarCode, zoom: number): void;
        protected drawBarCodeError(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected drawBarCodeError2(context: any, rect: RectangleD, barCode: StiBarCode, message: string): void;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        protected translateRect(context: any, rect: RectangleD, barCode: StiBarCode): void;
        protected rollbackTransform(context: any): void;
        protected baseDrawString(context: any, st: string, font: Font, brush: StiBrush, x: number, y: number): void;
        protected baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        protected baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        protected baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        protected baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        protected baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        protected baseDrawString2(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        protected baseMeasureString3(context: any, st: string, font: Font): SizeD;
        createNew(): StiBarCodeTypeService;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiAustraliaPost4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly serviceName: string;
        protected australiaPost4StateSymbolsC: string;
        protected australiaPost4StateSymbolsN: string;
        private australiaPost4StateStartCode;
        private australiaPost4StateStopCode;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected australiaPost4StateSpaceLeft: number;
        protected australiaPost4StateSpaceRight: number;
        protected australiaPost4StateSpaceTop: number;
        protected australiaPost4StateSpaceBottom: number;
        protected australiaPost4StateLineHeightLong: number;
        protected australiaPost4StateLineHeightShort: number;
        protected australiaPost4StateTextPosition: number;
        protected australiaPost4StateTextHeight: number;
        protected australiaPost4StateMainHeight: number;
        protected australiaPost4StateLineHeightForCut: number;
        protected readonly textAlignment: StringAlignment;
        private mult;
        private gen;
        private rSInitialise;
        private rSEncode;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    var IStiBorder: string;
    interface IStiBorder {
        border: StiBorder;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiEnumAngle: string;
    interface IStiEnumAngle {
        angle: StiAngle;
    }
}
declare module Stimulsoft.Report.Components {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    var IStiHorAlignment: string;
    var ImplementsIStiHorAlignment: any[];
    interface IStiHorAlignment {
        horAlignment: StiHorAlignment;
    }
}
declare module Stimulsoft.Report.Components {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    var IStiVertAlignment: string;
    var ImplementsIStiVertAlignment: any[];
    interface IStiVertAlignment {
        vertAlignment: StiVertAlignment;
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiForeColor: string;
    var ImplementsIStiForeColor: any[];
    interface IStiForeColor {
        foreColor: Color;
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiBackColor: string;
    var ImplementsIStiBackColor: any[];
    interface IStiBackColor {
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    var IStiExportImage: string;
    interface IStiExportImage {
        getImage(REFzoom: any, format?: StiExportFormat): Image;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiExportImageExtended: string;
    interface IStiExportImageExtended extends IStiExportImage {
        isExportAsImage(format: StiExportFormat): boolean;
    }
}
declare module Stimulsoft.Report.Expressions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiExpression implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private val;
        value: string;
        protected getValueProp(): string;
        protected setValueProp(value: string): void;
        parentComponent: Object;
        fullConvert: boolean;
        applyFormat: boolean;
        genAddEvent: boolean;
        toString(): string;
        clone(): Object;
        constructor(value?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiConditionsCollection extends CollectionBase<StiBaseCondition> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private isBorderSides;
        private convertIconSetItemFromString;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiConditionsCollection;
        add(condition: StiBaseCondition): void;
        addRange(conditions: StiConditionsCollection, addOnlyNotEqual?: boolean): void;
        contains(condition: StiBaseCondition): boolean;
        indexOf(condition: StiBaseCondition): number;
        insert(index: number, condition: StiBaseCondition): void;
        remove(condition: StiBaseCondition): void;
        getByIndex(index: number): StiBaseCondition;
        setByIndex(index: number, value: StiBaseCondition): void;
    }
}
declare module Stimulsoft.Report {
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBase extends StiService implements IStiName {
        memberwiseClone(): StiBase;
        private _name;
        /** Gets or sets a component name. */
        name: string;
        getName(): string;
        setName(value: string): void;
        implements(): string[];
        readonly localizedName: string;
        readonly localizedCategory: string;
    }
}
declare module Stimulsoft.Report.Events {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiEvent implements ICloneable, IStiJsonReportObject {
        private static ImplementsStiEvent;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): Object;
        protected readonly propertyName: string;
        private _script;
        script: string;
        private parent;
        set(parent: Stimulsoft.Report.Components.StiComponent, value: string): void;
        constructor(script?: string | Stimulsoft.Report.Components.StiComponent);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetToolTipEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetHyperlinkEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetTagEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetBookmarkEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiBeforePrintEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiAfterPrintEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetDrillDownReportEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiClickEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiDoubleClickEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseEnterEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseLeaveEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiValueEventHandler: EventHandler;
    class StiValueEventArgs extends EventArgs {
        value: Object;
        displayValue: string;
        constructor(value?: Object);
    }
}
declare module Stimulsoft.Report.Components {
    import StiPaintEventArgs = Stimulsoft.Report.Events.StiPaintEventArgs;
    import StiGetDrillDownReportEventArgs = Stimulsoft.Report.Events.StiGetDrillDownReportEventArgs;
    import StiGetToolTipEvent = Stimulsoft.Report.Events.StiGetToolTipEvent;
    import StiGetHyperlinkEvent = Stimulsoft.Report.Events.StiGetHyperlinkEvent;
    import StiGetTagEvent = Stimulsoft.Report.Events.StiGetTagEvent;
    import StiGetBookmarkEvent = Stimulsoft.Report.Events.StiGetBookmarkEvent;
    import StiBeforePrintEvent = Stimulsoft.Report.Events.StiBeforePrintEvent;
    import StiAfterPrintEvent = Stimulsoft.Report.Events.StiAfterPrintEvent;
    import StiGetDrillDownReportEvent = Stimulsoft.Report.Events.StiGetDrillDownReportEvent;
    import StiClickEvent = Stimulsoft.Report.Events.StiClickEvent;
    import StiDoubleClickEvent = Stimulsoft.Report.Events.StiDoubleClickEvent;
    import StiMouseEnterEvent = Stimulsoft.Report.Events.StiMouseEnterEvent;
    import StiMouseLeaveEvent = Stimulsoft.Report.Events.StiMouseLeaveEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBase = Stimulsoft.Report.StiBase;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiReport = Stimulsoft.Base.IStiReport;
    class StiComponent extends StiBase implements IStiComponentGuid, IStiCanGrow, IStiCanShrink, IStiUnitConvert, IStiShift, IStiGrowToHeight, IStiAnchor, IStiConditions, IStiPrintOn, IStiInherited, IStiStateSaveRestore, IStiJsonReportObject, IStiReportComponent, IStiComponent {
        private static ImplementsStiComponent;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        protected loadRectangleDFromXml(text: string): RectangleD;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private _infographicsDisplayRectangle;
        infographicsDisplayRectangle: RectangleD;
        private _isSelected;
        isSelected: boolean;
        select(): void;
        invert(): void;
        reset(): void;
        getApp(): IStiApp;
        getKey(): string;
        setKey(key: string): void;
        getReport(): IStiReport;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _states;
        readonly states: StiStatesManager;
        getStates(): StiStatesManager;
        clearAllStates(): void;
        shift: boolean;
        getShift(): boolean;
        private _shiftMode;
        shiftMode: StiShiftMode;
        private _guid;
        guid: string;
        newGuid(): void;
        private _printOn;
        printOn: StiPrintOnType;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        memberwiseClone(): StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _canShrink;
        canShrink: boolean;
        getCanShrink(): boolean;
        private _canGrow;
        canGrow: boolean;
        getCanGrow(): boolean;
        setCanGrow(value: boolean): void;
        private _growToHeight;
        growToHeight: boolean;
        getGrowToHeight(): boolean;
        private _anchor;
        anchor: StiAnchorMode;
        private _conditions;
        conditions: StiConditionsCollection;
        getConditions(): StiConditionsCollection;
        setConditions(value: StiConditionsCollection): void;
        private static propertyInherited;
        inherited: boolean;
        getActualSize(): SizeD;
        report: StiReport;
        private _interaction;
        interaction: StiInteraction;
        doBookmark(): void;
        private doGetBookmark;
        printable: boolean;
        private _isRendered;
        isRendered: boolean;
        private static propertyRenderedCount;
        renderedCount: number;
        allowPrintOn(): boolean;
        readonly isEnabled: boolean;
        prepare(): void;
        unPrepare(): void;
        setReportVariables(): void;
        internalRender(): StiComponent;
        render(): StiComponent;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        dockStyle: StiDockStyle;
        getDockStyle(): StiDockStyle;
        readonly isAutomaticDock: boolean;
        getDockRegion(parent: StiComponent, useColumns?: boolean): RectangleD;
        dockToContainer(): void;
        dockToContainer2(rect: RectangleD): RectangleD;
        private checkWidth;
        private checkHeight;
        private disableCheckWidthHeight;
        private static propertyMinSize;
        minSize: SizeD;
        getMinSize(): SizeD;
        setMinSize(value: SizeD): void;
        private static propertyMaxSize;
        maxSize: SizeD;
        getMaxSize(): SizeD;
        setMaxSize(value: SizeD): void;
        private _left;
        left: number;
        getLeft(): number;
        setLeft(value: number): void;
        private _top;
        top: number;
        getTop(): number;
        setTop(value: number): void;
        private _width;
        width: number;
        getWidth(): number;
        setWidth(value: number): void;
        private _height;
        height: number;
        getHeight(): number;
        setHeight(value: number): void;
        readonly right: number;
        readonly bottom: number;
        getBottom(): number;
        clientRectangle: RectangleD;
        protected setClientRectangle(value: RectangleD): void;
        displayRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        selectRectangle: RectangleD;
        defaultClientRectangle: RectangleD;
        private _parentBookmark;
        parentBookmark: StiBookmark;
        private _currentBookmark;
        currentBookmark: StiBookmark;
        invokeEvents(): void;
        readonly isGetToolTipHandlerEmpty: boolean;
        private static eventGetToolTip;
        protected onGetToolTip(): void;
        invokeGetToolTip(sender: any, e: StiValueEventArgs): void;
        getToolTipEvent: StiGetToolTipEvent;
        readonly isGetHyperlinkHandlerEmpty: boolean;
        private static eventGetHyperlink;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: Object, e: StiValueEventArgs): void;
        getHyperlinkEvent: StiGetHyperlinkEvent;
        readonly isGetTagHandlerEmpty: boolean;
        private static eventGetTag;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: Object, e: StiValueEventArgs): void;
        getTagEvent: StiGetTagEvent;
        readonly isGetBookmarkHandlerEmpty: boolean;
        private static eventGetBookmark;
        protected onGetBookmark(): void;
        invokeGetBookmark(sender: any, e: EventArgs): void;
        getBookmarkEvent: StiGetBookmarkEvent;
        private static eventBeforePrint;
        protected onBeforePrint(e: EventArgs): void;
        invokeBeforePrint(sender: any, e: EventArgs): void;
        applyConditions(sender: Object, conditions: any[]): void;
        beforePrintEvent: StiBeforePrintEvent;
        private static eventAfterPrint;
        protected onAfterPrint(e: EventArgs): void;
        invokeAfterPrint(sender: any, e: EventArgs): void;
        afterPrintEvent: StiAfterPrintEvent;
        private static eventGetDrillDownReport;
        protected onGetDrillDownReport(e: StiGetDrillDownReportEventArgs): void;
        invokeGetDrillDownReport(sender: Object, e: StiGetDrillDownReportEventArgs): void;
        getDrillDownReportEvent: StiGetDrillDownReportEvent;
        readonly isClickHandlerEmpty: boolean;
        private static eventClick;
        protected onClick(e: EventArgs): void;
        invokeClick(sender: Object, e: EventArgs): void;
        clickEvent: StiClickEvent;
        readonly isDoubleClickHandlerEmpty: boolean;
        private static eventDoubleClick;
        protected onDoubleClick(e: EventArgs): void;
        invokeDoubleClick(sender: Object, e: EventArgs): void;
        doubleClickEvent: StiDoubleClickEvent;
        readonly isMouseEnterHandlerEmpty: boolean;
        private static eventMouseEnter;
        protected onMouseEnter(e: EventArgs): void;
        invokeMouseEnter(sender: Object, e: EventArgs): void;
        mouseEnterEvent: StiMouseEnterEvent;
        readonly isMouseLeaveHandlerEmpty: boolean;
        private static eventMouseLeave;
        protected onMouseLeave(e: EventArgs): void;
        invokeMouseLeave(sender: Object, e: EventArgs): void;
        mouseLeaveEvent: StiMouseLeaveEvent;
        private static eventPainting;
        protected onPainting(e: StiPaintEventArgs): void;
        invokePainting(sender: StiComponent, e: StiPaintEventArgs): void;
        private static eventPainted;
        protected onPainted(e: StiPaintEventArgs): void;
        invokePainted(sender: StiComponent, e: StiPaintEventArgs): void;
        bookmarkValue: Object;
        bookmark: string;
        toolTipValue: Object;
        toolTip: string;
        hyperlinkValue: Object;
        hyperlink: string;
        tagValue: Object;
        tag: string;
        private _alias;
        alias: string;
        private _events;
        protected readonly events: Hashtable;
        protected static propertyRestrictions: string;
        restrictions: StiRestrictions;
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        ignoreNamingRule: boolean;
        setName(value: string): void;
        protected static propertyPlaceOnToolbox: string;
        placeOnToolbox: boolean;
        /**
         *  Gets a value to sort a position in the toolbox.
         */
        toolboxPosition: number;
        readonly isPrinting: boolean;
        readonly isExporting: boolean;
        readonly isDesigning: boolean;
        allowDelete(): boolean;
        readonly priority: number;
        readonly componentType: StiComponentType;
        protected static propertyDockable: string;
        dockable: boolean;
        highlightState: StiHighlightState;
        private _componentPlacement;
        componentPlacement: string;
        private _drillDownParameters;
        drillDownParameters: any[];
        protected static propertyComponentStyle: string;
        componentStyle: string;
        getComponentStyle(): string;
        setComponentStyle(value: string): void;
        protected static propertyLocked: string;
        locked: boolean;
        protected static propertyLinked: string;
        linked: boolean;
        getLinked(): boolean;
        setLinked(value: boolean): void;
        enabled: boolean;
        getEnabled(): boolean;
        setEnabled(value: boolean): void;
        private static propertyUseParentStyles;
        useParentStyles: boolean;
        getUseParentStyles(): boolean;
        setUseParentStyles(value: boolean): void;
        private _page;
        page: StiPage;
        protected getPage(): StiPage;
        protected setPage(value: StiPage): void;
        private _parent;
        parent: StiContainer;
        isExportAsImage(format: StiExportFormat): boolean;
        private lockOnResize;
        private invokeOnResizeComponent;
        onResizeComponent(oldSize: SizeD, newSize: SizeD): void;
        clearContents(): void;
        toString(): string;
        readonly isCross: boolean;
        canContainIn(component: StiComponent): boolean;
        componentToPage(value: PointD | RectangleD): any;
        pageToComponent(value: PointD | RectangleD): any;
        static isParentSelect(component: StiComponent): boolean;
        static doOffsetRect(component: StiComponent, rect: RectangleD, offsetRect: RectangleD): RectangleD;
        getPaintRectangle(convertToHInches?: boolean, convertByZoom?: boolean, docking?: boolean): RectangleD;
        setPaintRectangle(rect: RectangleD): void;
        getDisplayRectangle2(): RectangleD;
        getDataBand(): StiDataBand;
        getGroupHeaderBand(): StiGroupHeaderBand;
        getContainer(): StiContainer;
        checkForParentComponent(comp: StiComponent): boolean;
        getComponentStyle2(): StiBaseStyle;
        private bits;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiAngle = Stimulsoft.Report.Components.StiAngle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiEnumAngle = Stimulsoft.Report.Components.IStiEnumAngle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiBarCode extends StiComponent implements IStiBarCode, IStiBackColor, IStiForeColor, IStiExportImage, IStiExportImageExtended, IStiVertAlignment, IStiHorAlignment, IStiEnumAngle, IStiBorder, IStiJsonReportObject {
        private static implementsStiBarCode;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        readonly localizedCategory: string;
        readonly localizedName: string;
        isExportAsImage(format: StiExportFormat): boolean;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        private _angle;
        angle: StiAngle;
        private _border;
        border: StiBorder;
        private _foreColor;
        foreColor: Color;
        private _backColor;
        backColor: Color;
        private _autoScale;
        autoScale: boolean;
        private _showLabelText;
        showLabelText: boolean;
        private _showQuietZones;
        showQuietZones: boolean;
        private _barCodeType;
        barCodeType: StiBarCodeTypeService;
        getBarCodeString(): string;
        private _font;
        font: Font;
        private _horAlignment;
        horAlignment: StiHorAlignment;
        private _vertAlignment;
        vertAlignment: StiVertAlignment;
        private _codeValue;
        codeValue: string;
        private _code;
        code: string;
        invokeEvents(): void;
        private static eventGetBarCode;
        onGetBarCode(e: StiValueEventArgs): void;
        invokeGetBarCode(sender: StiComponent, e: StiValueEventArgs): void;
        getBarCodeEvent: Stimulsoft.Report.Events.StiGetBarCodeEvent;
        createNew(): StiComponent;
        defaultClientRectangle: Rectangle;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.BarCodes {
    class StiBarCodeData {
        spaceLeft: number;
        spaceRight: number;
        spaceTop: number;
        spaceBottom: number;
        lineHeightShort: number;
        lineHeightLong: number;
        lineWidth: number;
        textPosition: number;
        textHeight: number;
        mainHeight: number;
        mainWidth: number;
        wideToNarrowRatio: number;
        code: string;
        textString: string;
        barsArray: string;
        fullZoomY: number;
        spaceBeforeAdd: number;
        spaceTextTop: number;
        textPositionTop: number;
        textPositionBottom: number;
        eanBarsArray: EanBarInfo[];
        offsetY: number;
        matrixGrid: number[];
        matrixWidth: number;
        matrixHeight: number;
        matrixRatioY: number;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCodabarBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        private codabarSymbols;
        private codabarTable;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        codabarSpaceLeft: number;
        codabarSpaceRight: number;
        codabarSpaceTop: number;
        codabarSpaceBottom: number;
        codabarLineHeightShort: number;
        codabarLineHeightLong: number;
        codabarTextPosition: number;
        codabarTextHeight: number;
        codabarMainHeight: number;
        codabarLineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode11BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        code11Symbols: string;
        code11StartStopSymbolIndex: number;
        code11Table: string[];
        code11SpaceLeft: number;
        code11SpaceRight: number;
        code11SpaceTop: number;
        code11SpaceBottom: number;
        code11LineHeightShort: number;
        code11LineHeightLong: number;
        code11TextPosition: number;
        code11TextHeight: number;
        code11MainHeight: number;
        code11LineHeightForCut: number;
        defaultCode11Module: number;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _checksum;
        checksum: StiCode11CheckSum;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checksum?: StiCode11CheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode128BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        protected code128Table: string[];
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected code128SpaceLeft: number;
        protected code128SpaceRight: number;
        protected code128SpaceTop: number;
        protected code128SpaceBottom: number;
        protected code128LineHeightShort: number;
        protected code128LineHeightLong: number;
        protected code128TextPosition: number;
        protected code128TextHeight: number;
        protected code128MainHeight: number;
        protected code128LineHeightForCut: number;
        protected defaultCodeSetAB: CodeSet;
        protected codeToBar(inputCode: string): string;
        protected encodeAuto(inputText: string, encodeAsEan: boolean): string;
        private isDigit;
        private getSet;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128AutoBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128aBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128bBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode128cBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode39BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        code39Symbols: string;
        code39StartStopSymbolIndex: number;
        code39Table: string[];
        readonly defaultCodeValue: string;
        private _checkSum;
        checkSum: StiCheckSum;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        code39SpaceLeft: number;
        code39SpaceRight: number;
        code39SpaceTop: number;
        code39SpaceBottom: number;
        code39LineHeightShort: number;
        code39LineHeightLong: number;
        code39TextPosition: number;
        code39TextHeight: number;
        code39MainHeight: number;
        code39LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode39ExtBarCodeType extends StiCode39BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        protected code39ExtTable: string[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, checkSum?: StiCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiCode93BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        private code93Symbols;
        code93Table: string[];
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        code93SpaceLeft: number;
        code93SpaceRight: number;
        code93SpaceTop: number;
        code93SpaceBottom: number;
        code93LineHeightShort: number;
        code93LineHeightLong: number;
        code93TextPosition: number;
        code93TextHeight: number;
        code93MainHeight: number;
        code93LineHeightForCut: number;
        codeToBar(inputCode: string): string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCode93ExtBarCodeType extends StiCode93BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private code93ExtSymbols;
        private code93ExtTable;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDataMatrix {
        readonly matrix: number[];
        readonly width: number;
        readonly height: number;
        readonly errorMessage: string;
        private gridWidth;
        private gridHeight;
        private grid;
        private _errorMessage;
        private ecc200List;
        private _processTilde;
        private dataMatrixPlacementbit;
        private dataMatrixPlacementBlock;
        private dataMatrixPlacementCornerA;
        private dataMatrixPlacementCornerB;
        private dataMatrixPlacementCornerC;
        private dataMatrixPlacementCornerD;
        private dataMatrixPlacement;
        private makeEcc200Blocks;
        private dataMatrixEncode;
        private encodeB;
        private encodeA;
        private encodeE;
        private encodeCTX;
        private static isDigit;
        private static convertStringToBytes;
        private makeGrid;
        constructor(message: string, globalEncoding: StiDataMatrixEncodingType, useRectangularSymbols: boolean, matrixSize: StiDataMatrixSize, processTilde: boolean);
    }
    class StiDataMatrixBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _encodingType;
        encodingType: StiDataMatrixEncodingType;
        private _matrixSize;
        matrixSize: StiDataMatrixSize;
        private _useRectangularSymbols;
        useRectangularSymbols: boolean;
        private _processTilde;
        processTilde: boolean;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, encodingType?: StiDataMatrixEncodingType, useRectangularSymbols?: boolean, matrixSize?: StiDataMatrixSize, processTilde?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDutchKIXBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        dutchKIXSymbols: string;
        private dutchKIXCodes;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        dutchKIXSpaceLeft: number;
        dutchKIXSpaceRight: number;
        dutchKIXSpaceTop: number;
        dutchKIXSpaceBottom: number;
        dutchKIXLineHeightLong: number;
        dutchKIXLineHeightShort: number;
        dutchKIXTextPosition: number;
        dutchKIXTextHeight: number;
        dutchKIXMainHeight: number;
        dutchKIXLineHeightForCut: number;
        readonly textAlignment: StringAlignment;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128AutoBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128aBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128bBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN128cBarCodeType extends StiCode128BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class EanBarInfo {
        symbolType: Ean13Symbol;
        symbolText: string;
        textAtTop: boolean;
        makeLonger: boolean;
        constructor(symbolType: Ean13Symbol, symbolText: string, textAtTop: boolean, makeLonger?: boolean);
    }
    enum Ean13Symbol {
        ComboA0 = 0,
        ComboA1 = 1,
        ComboA2 = 2,
        ComboA3 = 3,
        ComboA4 = 4,
        ComboA5 = 5,
        ComboA6 = 6,
        ComboA7 = 7,
        ComboA8 = 8,
        ComboA9 = 9,
        ComboB0 = 10,
        ComboB1 = 11,
        ComboB2 = 12,
        ComboB3 = 13,
        ComboB4 = 14,
        ComboB5 = 15,
        ComboB6 = 16,
        ComboB7 = 17,
        ComboB8 = 18,
        ComboB9 = 19,
        ComboC0 = 20,
        ComboC1 = 21,
        ComboC2 = 22,
        ComboC3 = 23,
        ComboC4 = 24,
        ComboC5 = 25,
        ComboC6 = 26,
        ComboC7 = 27,
        ComboC8 = 28,
        ComboC9 = 29,
        GuardLeft = 30,
        GuardCenter = 31,
        GuardRight = 32,
        GuardSpecial = 33,
        GuardAddLeft = 34,
        GuardAddDelineator = 35,
        SpaceLeft = 36,
        SpaceRight = 37,
        SpaceBeforeAdd = 38
    }
    class StiEAN13BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        private _module;
        module: number;
        private _height;
        height: number;
        private _supplementType;
        supplementType: StiEanSupplementType;
        private _supplementCode;
        supplementCode: string;
        private _showQuietZoneIndicator;
        showQuietZoneIndicator: boolean;
        readonly labelFontHeight: number;
        protected readonly eanSpaceLeft: number;
        protected readonly eanSpaceRight: number;
        protected readonly eanSpaceTop: number;
        protected readonly eanSpaceBottom: number;
        protected readonly eanSpaceBeforeAdd: number;
        protected readonly eanSpaceTextTop: number;
        protected readonly eanLineHeightShort: number;
        protected readonly eanLineHeightLong: number;
        protected readonly eanTextPositionTop: number;
        protected readonly eanTextPositionBottom: number;
        protected readonly eanTextHeight: number;
        protected readonly eanMainHeight: number;
        protected readonly eanLineHeightForCut: number;
        protected readonly eanWideToNarrowRatio: number;
        protected symComboSet: string[];
        protected symParitySetAdd2: string[];
        protected symParitySetAdd5: string[];
        protected ean13SymData: string[];
        protected calculateSizeEan(offsetY: number, zoom: number, barsArray: EanBarInfo[], rect: RectangleD, barCode: StiBarCode): void;
        protected drawEanBars(context: any, barsArray: EanBarInfo[], barCode: StiBarCode): void;
        protected makeEan13Bars(REFcode: any, isLast: boolean): EanBarInfo[];
        protected makeEanAdd2Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeEanAdd5Bars(code: string, baseArray: EanBarInfo[], isLast: boolean): EanBarInfo[];
        protected makeLonger(symString: string): string;
        protected getSymbolWidth(symbol: string): number;
        protected isSymbolSpace(symbol: string): boolean;
        draw(context: number, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEAN8BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly eanSpaceLeft: number;
        readonly eanSpaceRight: number;
        readonly eanLineHeightShort: number;
        readonly eanMainHeight: number;
        makeEan8Bars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiFIMBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        fIMSymbols: string;
        fIMTable: string[];
        defaultFIMModule: number;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        private _module;
        module: number;
        private _height;
        height: number;
        private _addClearZone;
        addClearZone: boolean;
        readonly labelFontHeight: number;
        readonly fIMSpaceLeft: number;
        readonly fIMSpaceRight: number;
        fIMSpaceTop: number;
        fIMSpaceBottom: number;
        fIMLineHeightShort: number;
        fIMLineHeightLong: number;
        fIMTextPosition: number;
        fIMTextHeight: number;
        fIMMainHeight: number;
        fIMLineHeightForCut: number;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, addClearZone?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiITF14BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        private _printVerticalBars;
        printVerticalBars: boolean;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected symTableSet: string[];
        private itf14BearerBarWidth;
        private itf14SpaceLeft;
        private itf14SpaceRight;
        private itf14SpaceTop;
        private itf14SpaceBottom;
        private itf14LineHeightShort;
        private itf14LineHeightLong;
        private itf14TextHeight;
        private itf14MainHeight;
        private itf14TextPosition;
        private itf14LineHeightForCut;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number, printVerticalBars?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiInterleaved2of5BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected symTableSet: string[];
        private interleaved2of5SpaceLeft;
        private interleaved2of5SpaceRight;
        private interleaved2of5SpaceTop;
        private interleaved2of5SpaceBottom;
        private interleaved2of5LineHeightShort;
        private interleaved2of5LineHeightLong;
        private interleaved2of5TextHeight;
        private interleaved2of5MainHeight;
        private interleaved2of5TextPosition;
        private interleaved2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        StiInterleaved2of5BarCodeType(module?: number, height?: number, ratio?: number): void;
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn13BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        isbnOffsetY: number;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiIsbn10BarCodeType extends StiIsbn13BarCodeType {
        readonly componentId: StiComponentId;
        readonly visibleProperties: boolean[];
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan13BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiJan8BarCodeType extends StiEAN8BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiMaxicodeMode = Stimulsoft.Report.BarCodes.StiMaxicodeMode;
    class StiMaxicodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        module: number;
        readonly height: number;
        innerHeight: number;
        private _mode;
        mode: StiMaxicodeMode;
        private _processTilde;
        processTilde: boolean;
        private _structuredAppendPosition;
        structuredAppendPosition: number;
        private _structuredAppendTotal;
        structuredAppendTotal: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(mode?: StiMaxicodeMode, structuredAppendPosition?: number, structuredAppendTotal?: number, processTilde?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPlesseyBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        plesseySymbols: string;
        private plesseyTable;
        private plesseyStartCode;
        private plesseyStopCode;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _checkSum1;
        checkSum1: StiPlesseyCheckSum;
        private _checkSum2;
        checkSum2: StiPlesseyCheckSum;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        plesseySpaceLeft: number;
        plesseySpaceRight: number;
        plesseySpaceTop: number;
        plesseySpaceBottom: number;
        plesseyLineHeightShort: number;
        plesseyLineHeightLong: number;
        plesseyTextPosition: number;
        plesseyTextHeight: number;
        plesseyMainHeight: number;
        plesseyLineHeightForCut: number;
        private codeToBar;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiMsiBarCodeType extends StiPlesseyBarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        private msiTable;
        private msiStartCode;
        private msiStopCode;
        protected codeToBarMsi(inputCode: string): string;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum1?: StiPlesseyCheckSum, checkSum2?: StiPlesseyCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPdf417BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _encodingMode;
        encodingMode: StiPdf417EncodingMode;
        private _errorsCorrectionLevel;
        errorsCorrectionLevel: StiPdf417ErrorsCorrectionLevel;
        private _dataColumns;
        dataColumns: number;
        private _dataRows;
        dataRows: number;
        private _autoDataColumns;
        autoDataColumns: boolean;
        private _autoDataRows;
        autoDataRows: boolean;
        private _aspectRatio;
        aspectRatio: number;
        private _ratioY;
        ratioY: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, encodingMode?: StiPdf417EncodingMode, errorsCorrectionLevel?: StiPdf417ErrorsCorrectionLevel, dataColumns?: number, dataRows?: number, autoDataColumns?: boolean, autoDataRows?: boolean, aspectRatio?: number, ratioY?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPharmacodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        pharmacodeSymbols: string;
        defaultPharmacodeModule: number;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        pharmacodeSpaceLeft: number;
        pharmacodeSpaceRight: number;
        pharmacodeSpaceTop: number;
        pharmacodeSpaceBottom: number;
        pharmacodeLineHeightShort: number;
        pharmacodeLineHeightLong: number;
        pharmacodeTextPosition: number;
        pharmacodeTextHeight: number;
        pharmacodeMainHeight: number;
        pharmacodeLineHeightForCut: number;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiPostnetBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        postnetSymbols: string;
        private postnetTable;
        private postnetStartCode;
        private postnetStopCode;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _space;
        space: number;
        private _height;
        height: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        postnetSpaceLeft: number;
        postnetSpaceRight: number;
        postnetSpaceTop: number;
        postnetSpaceBottom: number;
        postnetLineHeightLong: number;
        postnetLineHeightShort: number;
        postnetTextPosition: number;
        postnetTextHeight: number;
        postnetMainHeight: number;
        postnetLineHeightForCut: number;
        private codeToBar;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, space?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiQRCodeBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _errorCorrectionLevel;
        errorCorrectionLevel: StiQRCodeErrorCorrectionLevel;
        private _matrixSize;
        matrixSize: StiQRCodeSize;
        private _image;
        image: Image;
        private _imageMultipleFactor;
        imageMultipleFactor: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, errorCorrectionLevel?: StiQRCodeErrorCorrectionLevel, matrixSize?: StiQRCodeSize, image?: Image, imageMultipleFactor?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiRoyalMail4StateBarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        royalMail4StateSymbols: string;
        private royalMail4StateStartCode;
        private royalMail4StateStopCode;
        private royalMail4StateCodes;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _checkSum;
        checkSum: StiCheckSum;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        royalMail4StateSpaceLeft: number;
        royalMail4StateSpaceRight: number;
        royalMail4StateSpaceTop: number;
        royalMail4StateSpaceBottom: number;
        royalMail4StateLineHeightLong: number;
        royalMail4StateLineHeightShort: number;
        royalMail4StateTextPosition: number;
        royalMail4StateTextHeight: number;
        royalMail4StateMainHeight: number;
        royalMail4StateLineHeightForCut: number;
        readonly textAlignment: StringAlignment;
        private charTo4State;
        private stateToBar;
        private makeBarsArray;
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, checkSum?: StiCheckSum);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiSSCC18BarCodeType extends StiCode128cBarCodeType implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _companyPrefix;
        companyPrefix: string;
        private _serialNumber;
        serialNumber: string;
        private _extensionDigit;
        extensionDigit: string;
        readonly textSpacing: boolean;
        readonly visibleProperties: boolean[];
        getCombinedCode(): string;
        private getCheckDigit;
        private checkContens;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStandard2of5BarCodeType extends StiBarCodeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXmlObject(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        private _module;
        module: number;
        private _height;
        height: number;
        private _ratio;
        ratio: number;
        readonly labelFontHeight: number;
        readonly visibleProperties: boolean[];
        protected symTableSet: string[];
        private standard2of5SpaceLeft;
        private standard2of5SpaceRight;
        private standard2of5SpaceTop;
        private standard2of5SpaceBottom;
        private standard2of5LineHeightShort;
        private standard2of5LineHeightLong;
        private standard2of5TextHeight;
        private standard2of5MainHeight;
        private standard2of5TextPosition;
        private standard2of5LineHeightForCut;
        draw(context: any, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, ratio?: number);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcABarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly eanSpaceLeft: number;
        readonly eanSpaceRight: number;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        showQuietZoneIndicator: boolean;
        makeUpcABars(code: string, isLast: boolean): EanBarInfo[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare namespace Stimulsoft.Report.BarCodes {
    class StiUpcEBarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        protected symParitySet: string[];
        protected readonly eanSpaceLeft: number;
        protected readonly eanSpaceRight: number;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        showQuietZoneIndicator: boolean;
        protected makeUpcEBars(code: string, isLast: boolean): EanBarInfo[];
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup2BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.BarCodes {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpcSup5BarCodeType extends StiEAN13BarCodeType {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        readonly defaultCodeValue: string;
        readonly visibleProperties: boolean[];
        draw(context: Object, barCode: StiBarCode, rect: RectangleD, zoom: number): void;
        createNew(): StiBarCodeTypeService;
        constructor(module?: number, height?: number, supplementType?: StiEanSupplementType, supplementCodeValue?: string, showQuietZoneIndicator?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiBubbleArea: string;
    interface IStiBubbleArea extends IStiScatterArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCandlestickArea: string;
    interface IStiCandlestickArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiClusteredBarArea: string;
    interface IStiClusteredBarArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAreaArea: string;
    interface IStiAreaArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiClusteredColumnArea: string;
    interface IStiClusteredColumnArea extends IStiAxisArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLineArea: string;
    interface IStiLineArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiParetoArea: string;
    interface IStiParetoArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineArea: string;
    interface IStiSplineArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineAreaArea: string;
    interface IStiSplineAreaArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedAreaArea: string;
    interface IStiSteppedAreaArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedLineArea: string;
    interface IStiSteppedLineArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiDoughnutArea: string;
    interface IStiDoughnutArea extends IStiPieArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedBarArea: string;
    interface IStiFullStackedBarArea extends IStiStackedBarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedAreaArea: string;
    interface IStiFullStackedAreaArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedColumnArea: string;
    interface IStiFullStackedColumnArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedLineArea: string;
    interface IStiFullStackedLineArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineArea: string;
    interface IStiFullStackedSplineArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineAreaArea: string;
    interface IStiFullStackedSplineAreaArea extends IStiFullStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFunnelArea: string;
    interface IStiFunnelArea extends IStiArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGanttArea: string;
    interface IStiGanttArea extends IStiClusteredBarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiPictorialArea: string;
    interface IStiPictorialArea extends IStiArea {
        roundValues: boolean;
        actual: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiPieArea: string;
    interface IStiPieArea extends IStiArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarArea: string;
    interface IStiRadarArea extends IStiArea {
        radarStyle: StiRadarStyle;
        xAxis: IStiXRadarAxis;
        yAxis: IStiYRadarAxis;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiRadarGridLinesHor;
        gridLinesVert: IStiRadarGridLinesVert;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarAreaArea: string;
    interface IStiRadarAreaArea extends IStiRadarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarLineArea: string;
    interface IStiRadarLineArea extends IStiRadarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarPointArea: string;
    interface IStiRadarPointArea extends IStiRadarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeArea: string;
    interface IStiRangeArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeBarArea: string;
    interface IStiRangeBarArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineRangeArea: string;
    interface IStiSplineRangeArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedRangeArea: string;
    interface IStiSteppedRangeArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterArea: string;
    interface IStiScatterArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedBarArea: string;
    interface IStiStackedBarArea extends IStiClusteredBarArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedAreaArea: string;
    interface IStiStackedAreaArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedColumnArea: string;
    interface IStiStackedColumnArea extends IStiAxisArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedLineArea: string;
    interface IStiStackedLineArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedSplineArea: string;
    interface IStiStackedSplineArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedSplineAreaArea: string;
    interface IStiStackedSplineAreaArea extends IStiStackedColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStockArea: string;
    interface IStiStockArea extends IStiClusteredColumnArea {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTreemapArea: string;
    interface IStiTreemapArea extends IStiArea {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiArea: string;
    interface IStiArea extends ICloneable, IStiJsonReportObject {
        core: IStiAreaCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        colorEach: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        isDefaultSeriesTypeFullStackedColumnSeries: boolean;
        isDefaultSeriesTypeFullStackedBarSeries: boolean;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiAreaCoreXF: string;
    interface IStiAreaCoreXF extends IStiApplyStyle {
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        seriesOrientation: StiChartSeriesOrientation;
        getSeries(): IStiSeries[];
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisArea: string;
    interface IStiAxisArea extends IStiArea {
        axisCore: IStiAxisAreaCoreXF;
        interlacingHor: IStiInterlacingHor;
        interlacingVert: IStiInterlacingVert;
        gridLinesHor: IStiGridLinesHor;
        gridLinesHorRight: IStiGridLinesHor;
        gridLinesVert: IStiGridLinesVert;
        yAxis: IStiYAxis;
        yRightAxis: IStiYAxis;
        xAxis: IStiXAxis;
        xTopAxis: IStiXAxis;
        reverseHor: boolean;
        reverseVert: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisAreaCoreXF: string;
    interface IStiAxisAreaCoreXF extends IStiAreaCoreXF {
        switchOff(): any;
        getDividerX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        scrollRangeX: number;
        scrollRangeY: number;
        scrollDpiX: number;
        scrollDpiY: number;
        getArgumentLabel(line: IStiStripLineXF, series: IStiSeries): string;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStripLineXF: string;
    interface IStiStripLineXF {
        valueObject: Object;
        value: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiStripLinesXF: string;
    interface IStiStripLinesXF extends ICollection<IStiStripLineXF> {
        add(valueObject: Object, value: number): any;
        getByindex(index: number): IStiStripLineXF;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStripPositionXF: string;
    interface IStiStripPositionXF {
        stripLine: IStiStripLineXF;
        position: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxis: string;
    interface IStiAxis extends ICloneable, IStiJsonReportObject {
        logarithmicScale: boolean;
        core: IStiAxisCoreXF;
        allowApplyStyle: boolean;
        startFromZero: boolean;
        step: number;
        interaction: IStiAxisInteraction;
        labels: IStiAxisLabels;
        range: IStiAxisRange;
        title: IStiAxisTitle;
        ticks: IStiAxisTicks;
        arrowStyle: StiArrowStyle;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        visible: boolean;
        area: IStiAxisArea;
        info: IStiAxisInfoXF;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    var IStiAxisCoreXF: string;
    interface IStiAxisCoreXF extends IStiApplyStyle {
        arrowHeight: number;
        arrowWidth: number;
        ticksMaxLength: number;
        renderView(context: StiContext, rect: RectangleD): IStiCellGeom;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        applyStyle(style: IStiChartStyle): any;
        getStartFromZero(): boolean;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        isMouseOverDecreaseButton: boolean;
        isMouseOverIncreaseButton: boolean;
        isMouseOverTrackBar: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisDateTimeStep: string;
    interface IStiAxisDateTimeStep extends ICloneable, IStiJsonReportObject {
        step: StiTimeDateStep;
        numberOfValues: number;
        interpolation: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    var IStiAxisInfoXF: string;
    interface IStiAxisInfoXF extends ICloneable {
        minimum: number;
        maximum: number;
        stripLines: IStiStripLinesXF;
        stripPositions: number[];
        dpi: number;
        ticksCollection: IStiStripPositionXF[];
        labelsCollection: IStiStripPositionXF[];
        step: number;
        range: number;
        clone(): IStiAxisInfoXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisInteraction: string;
    interface IStiAxisInteraction extends ICloneable, IStiJsonReportObject {
        showScrollBar: boolean;
        rangeScrollEnabled: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisLabels: string;
    interface IStiAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiAxisLabelsCoreXF;
        allowApplyStyle: boolean;
        format: string;
        angle: number;
        width: number;
        textBefore: string;
        textAfter: string;
        font: Font;
        antialiasing: boolean;
        placement: StiLabelsPlacement;
        color: Color;
        textAlignment: StiHorAlignment;
        step: number;
        wordWrap: boolean;
        formatService: StiFormatService;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisLabelsCoreXF: string;
    interface IStiAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisRange: string;
    interface IStiAxisRange extends ICloneable, IStiJsonReportObject {
        minimum: number;
        maximum: number;
        auto: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisTicks: string;
    interface IStiAxisTicks extends ICloneable, IStiJsonReportObject {
        lengthUnderLabels: number;
        length: number;
        minorLength: number;
        minorCount: number;
        step: number;
        minorVisible: boolean;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiAxisTitle: string;
    interface IStiAxisTitle extends ICloneable, IStiJsonReportObject {
        core: IStiAxisTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        color: Color;
        antialiasing: boolean;
        alignment: StringAlignment;
        direction: StiDirection;
        position: StiTitlePosition;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisTitleCoreXF: string;
    interface IStiAxisTitleCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    var IStiXAxis: string;
    interface IStiXAxis extends IStiAxis {
        showEdgeValues: boolean;
        showXAxis: StiShowXAxis;
        dateTimeStep: IStiAxisDateTimeStep;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiXBottomAxis: string;
    interface IStiXBottomAxis extends IStiXAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiXTopAxis: string;
    interface IStiXTopAxis extends IStiXAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    var IStiYAxis: string;
    interface IStiYAxis extends IStiAxis {
        showYAxis: StiShowYAxis;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiYLeftAxis: string;
    interface IStiYLeftAxis extends IStiYAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiYRightAxis: string;
    interface IStiYRightAxis extends IStiYAxis {
    }
}
declare module Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTitle: string;
    interface IStiChartTitle extends ICloneable, IStiJsonReportObject {
        core: IStiChartTitleCoreXF;
        allowApplyStyle: boolean;
        font: Font;
        text: string;
        brush: StiBrush;
        antialiasing: boolean;
        alignment: StringAlignment;
        dock: StiChartTitleDock;
        spacing: number;
        visible: boolean;
        chart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiChartTitleCoreXF: string;
    interface IStiChartTitleCoreXF extends IStiApplyStyle {
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiChartCondition: string;
    interface IStiChartCondition extends IStiChartFilter {
        color: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiChartConditionsCollection: string;
    interface IStiChartConditionsCollection extends ICollection<IStiChartCondition> {
        add(condition: IStiChartCondition): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiConstantLines: string;
    interface IStiConstantLines extends ICloneable, IStiJsonReportObject {
        core: IStiConstantLinesCoreXF;
        allowApplyStyle: boolean;
        antialiasing: boolean;
        position: StiConstantLines_StiTextPosition;
        font: Font;
        text: string;
        titleVisible: boolean;
        orientation: StiConstantLines_StiOrientation;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        showInLegend: boolean;
        showBehind: boolean;
        axisValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiConstantLinesCollection: string;
    interface IStiConstantLinesCollection extends ICollection<IStiConstantLines>, IStiApplyStyle {
        add(value: IStiConstantLines): any;
        insert(index: number, value: IStiConstantLines): any;
        getByIndex(index: number): IStiConstantLines;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiConstantLinesCoreXF: string;
    interface IStiConstantLinesCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    var IStiChartFilter: string;
    interface IStiChartFilter extends IStiJsonReportObject, ICloneable {
        clone(): any;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        item: StiFilterItem;
        value: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiChartFiltersCollection: string;
    interface IStiChartFiltersCollection extends ICollection<IStiChartFilter> {
        add(value: IStiChartFilter): any;
        getByIndex(index: number): IStiChartFilter;
        insert(index: number, value: IStiChartFilter): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiGridLines: string;
    interface IStiGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        minorColor: Color;
        style: StiPenStyle;
        minorStyle: StiPenStyle;
        visible: boolean;
        minorVisible: boolean;
        minorCount: number;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGridLinesCoreXF: string;
    interface IStiGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGridLinesHor: string;
    interface IStiGridLinesHor extends IStiGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGridLinesVert: string;
    interface IStiGridLinesVert extends IStiGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiRadarGridLines: string;
    interface IStiRadarGridLines extends ICloneable, IStiJsonReportObject {
        core: IStiRadarGridLinesCoreXF;
        allowApplyStyle: boolean;
        color: Color;
        style: StiPenStyle;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarGridLinesCoreXF: string;
    interface IStiRadarGridLinesCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarGridLinesHor: string;
    interface IStiRadarGridLinesHor extends IStiRadarGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarGridLinesVert: string;
    interface IStiRadarGridLinesVert extends IStiRadarGridLines {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiInterlacing: string;
    interface IStiInterlacing extends ICloneable, IStiJsonReportObject {
        core: IStiInterlacingCoreXF;
        allowApplyStyle: boolean;
        interlacedBrush: StiBrush;
        visible: boolean;
        area: IStiArea;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInterlacingCoreXF: string;
    interface IStiInterlacingCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInterlacingHor: string;
    interface IStiInterlacingHor extends IStiInterlacing {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInterlacingVert: string;
    interface IStiInterlacingVert extends IStiInterlacing {
    }
}
declare module Stimulsoft.Report.Chart {
    import SizeD = Stimulsoft.System.Drawing.Size;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiLegend: string;
    interface IStiLegend extends ICloneable, IStiJsonReportObject {
        core: IStiLegendCoreXF;
        allowApplyStyle: boolean;
        chart: IStiChart;
        hideSeriesWithEmptyTitle: boolean;
        showShadow: boolean;
        borderColor: Color;
        brush: StiBrush;
        titleColor: Color;
        labelsColor: Color;
        direction: StiLegendDirection;
        horAlignment: StiLegendHorAlignment;
        vertAlignment: StiLegendVertAlignment;
        titleFont: Font;
        font: Font;
        visible: boolean;
        markerVisible: boolean;
        markerBorder: boolean;
        markerSize: SizeD;
        markerAlignment: StiMarkerAlignment;
        columns: number;
        horSpacing: number;
        vertSpacing: number;
        size: SizeD;
        title: string;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiLegendCoreXF: string;
    interface IStiLegendCoreXF extends IStiApplyStyle {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiLegendMarker: string;
    interface IStiLegendMarker {
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLineMarker: string;
    interface IStiLineMarker extends IStiMarker {
        step: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiMarker: string;
    interface IStiMarker extends ICloneable, IStiJsonReportObject {
        core: IStiMarkerCoreXF;
        showInLegend: boolean;
        visible: boolean;
        brush: StiBrush;
        borderColor: Color;
        size: number;
        angle: number;
        type: StiMarkerType;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    var IStiMarkerCoreXF: string;
    interface IStiMarkerCoreXF {
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: String, tag: Object, interaction: StiInteractionDataGeom): any;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: Object, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiRadarAxis: string;
    interface IStiRadarAxis extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisCoreXF;
        allowApplyStyle: boolean;
        area: IStiRadarArea;
        visible: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarAxisCoreXF: string;
    interface IStiRadarAxisCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiRadarAxisLabels: string;
    interface IStiRadarAxisLabels extends ICloneable, IStiJsonReportObject {
        core: IStiRadarAxisLabelsCoreXF;
        rotationLabels: boolean;
        allowApplyStyle: boolean;
        drawBorder: boolean;
        textBefore: string;
        textAfter: string;
        format: string;
        font: Font;
        antialiasing: boolean;
        color: Color;
        borderColor: Color;
        brush: StiBrush;
        width: number;
        wordWrap: boolean;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarAxisLabelsCoreXF: string;
    interface IStiRadarAxisLabelsCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiXRadarAxis: string;
    interface IStiXRadarAxis extends IStiRadarAxis {
        xCore: IStiXRadarAxisCoreXF;
        labels: IStiRadarAxisLabels;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    var IStiXRadarAxisCoreXF: string;
    interface IStiXRadarAxisCoreXF {
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: Object, angle: number, colorIndex: number, colorCount: number): IStiCellGeom;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiYRadarAxis: string;
    interface IStiYRadarAxis extends IStiRadarAxis {
        yCore: IStiYRadarAxisCoreXF;
        labels: IStiAxisLabels;
        ticks: IStiAxisTicks;
        lineStyle: StiPenStyle;
        lineColor: Color;
        lineWidth: number;
        info: IStiAxisInfoXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    var IStiYRadarAxisCoreXF: string;
    interface IStiYRadarAxisCoreXF {
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
        ticksMaxLength: number;
        getFontGeom(context: StiContext): StiFontGeom;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAxisSeriesLabels: string;
    interface IStiAxisSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCenterAxisLabels: string;
    interface IStiCenterAxisLabels extends IStiAxisSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInsideBaseAxisLabels: string;
    interface IStiInsideBaseAxisLabels extends IStiAxisSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInsideEndAxisLabels: string;
    interface IStiInsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLeftAxisLabels: string;
    interface IStiLeftAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideAxisLabels: string;
    interface IStiOutsideAxisLabels extends IStiAxisSeriesLabels {
        lineLength: number;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideBaseAxisLabels: string;
    interface IStiOutsideBaseAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideEndAxisLabels: string;
    interface IStiOutsideEndAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRightAxisLabels: string;
    interface IStiRightAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiValueAxisLabels: string;
    interface IStiValueAxisLabels extends IStiCenterAxisLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCenterFunnelLabels: string;
    interface IStiCenterFunnelLabels extends IStiFunnelSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFunnelSeriesLabels: string;
    interface IStiFunnelSeriesLabels extends IStiSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideLeftFunnelLabels: string;
    interface IStiOutsideLeftFunnelLabels extends IStiCenterFunnelLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiOutsideRightFunnelLabels: string;
    interface IStiOutsideRightFunnelLabels extends IStiCenterFunnelLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCenterPieLabels: string;
    interface IStiCenterPieLabels extends IStiPieSeriesLabels {
        autoRotate: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiInsideEndPieLabels: string;
    interface IStiInsideEndPieLabels extends IStiCenterPieLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiOutsidePieLabels: string;
    interface IStiOutsidePieLabels extends IStiCenterPieLabels {
        showValue: boolean;
        lineLength: number;
        lineColor: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiPieSeriesLabels: string;
    interface IStiPieSeriesLabels extends IStiSeriesLabels {
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTwoColumnsPieLabels: string;
    interface IStiTwoColumnsPieLabels extends IStiOutsidePieLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarSeriesLabels: string;
    interface IStiRadarSeriesLabels extends IStiSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTangentRadarLabels: string;
    interface IStiTangentRadarLabels extends IStiRadarSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiNoneLabels: string;
    interface IStiNoneLabels extends IStiSeriesLabels {
    }
}
declare module Stimulsoft.Report.Chart {
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiSeriesLabels: string;
    interface IStiSeriesLabels extends ICloneable, IStiJsonReportObject {
        allowApplyStyle: boolean;
        showZeros: boolean;
        showNulls: boolean;
        markerVisible: boolean;
        step: number;
        valueTypeSeparator: string;
        textBefore: string;
        textAfter: string;
        angle: number;
        format: string;
        antialiasing: boolean;
        visible: boolean;
        drawBorder: boolean;
        useSeriesColor: boolean;
        markerAlignment: StiMarkerAlignment;
        valueType: StiSeriesLabelsValueType;
        legendValueType: StiSeriesLabelsValueType;
        markerSize: SizeD;
        labelColor: Color;
        borderColor: Color;
        brush: StiBrush;
        font: Font;
        chart: IStiChart;
        core: IStiSeriesLabelsCoreXF;
        preventIntersection: boolean;
        wordWrap: boolean;
        width: number;
        createNew(): IStiSeriesLabels;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    var IStiSeriesLabelsCoreXF: string;
    interface IStiSeriesLabelsCoreXF extends IStiApplyStyle {
        recalcValue(value: number, signs: number): number;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType: boolean): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiBubbleSeries: string;
    interface IStiBubbleSeries extends IStiScatterSeries {
        weights: number[];
        borderColor: Color;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiClusteredBarSeries: string;
    interface IStiClusteredBarSeries extends IStiClusteredColumnSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiAreaSeries: string;
    interface IStiAreaSeries extends IStiLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiBaseLineSeries: string;
    interface IStiBaseLineSeries extends IStiSeries, IStiAllowApplyColorNegative {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
        labelsOffset: number;
        showNulls: boolean;
        showZeros: boolean;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiClusteredColumnSeries: string;
    interface IStiClusteredColumnSeries extends IStiSeries, IStiAllowApplyBrushNegative {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        brushNegative: StiBrush;
        showZeros: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiLineSeries: string;
    interface IStiLineSeries extends IStiBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiParetoSeries: string;
    interface IStiParetoSeries extends IStiClusteredColumnSeries, IStiBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSplineAreaSeries: string;
    interface IStiSplineAreaSeries extends IStiSplineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSplineSeries: string;
    interface IStiSplineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSteppedAreaSeries: string;
    interface IStiSteppedAreaSeries extends IStiSteppedLineSeries, IStiAllowApplyBrushNegative {
        topmostLine: boolean;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSteppedLineSeries: string;
    interface IStiSteppedLineSeries extends IStiBaseLineSeries, IStiAllowApplyColorNegative {
        pointAtCenter: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiDoughnutSeries: string;
    interface IStiDoughnutSeries extends IStiPieSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiCandlestickSeries: string;
    interface IStiCandlestickSeries extends IStiSeries, IStiFinancialSeries {
        borderColor: Color;
        borderColorNegative: Color;
        borderWidth: number;
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFinancialSeries: string;
    interface IStiFinancialSeries {
        valuesOpen: number[];
        valuesClose: number[];
        valuesHigh: number[];
        valuesLow: number[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiStockSeries: string;
    interface IStiStockSeries extends IStiSeries, IStiFinancialSeries, IStiAllowApplyColorNegative {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lineWidth: number;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedBarSeries: string;
    interface IStiFullStackedBarSeries extends IStiStackedBarSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedAreaSeries: string;
    interface IStiFullStackedAreaSeries extends IStiStackedAreaSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedColumnSeries: string;
    interface IStiFullStackedColumnSeries extends IStiStackedColumnSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedLineSeries: string;
    interface IStiFullStackedLineSeries extends IStiStackedLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineAreaSeries: string;
    interface IStiFullStackedSplineAreaSeries extends IStiStackedSplineAreaSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFullStackedSplineSeries: string;
    interface IStiFullStackedSplineSeries extends IStiStackedSplineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiFunnelSeries: string;
    interface IStiFunnelSeries extends IStiSeries {
        showZeros: boolean;
        allowApplyBrush: boolean;
        allowApplyBorderColor: boolean;
        borderColor: Color;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiFunnelWeightedSlicesSeries: string;
    interface IStiFunnelWeightedSlicesSeries extends IStiFunnelSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGanttSeries: string;
    interface IStiGanttSeries extends IStiClusteredBarSeries, IStiRangeSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiPictorialSeries: string;
    interface IStiPictorialSeries extends IStiSeries {
        brush: StiBrush;
        icon: StiFontIcons;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiPieSeries: string;
    interface IStiPieSeries extends IStiSeries, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        startAngle: number;
        borderColor: Color;
        brush: StiBrush;
        lighting: boolean;
        diameter: number;
        distance: number;
        cutPieListValues: number[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiRadarAreaSeries: string;
    interface IStiRadarAreaSeries extends IStiRadarLineSeries {
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiRadarLineSeries: string;
    interface IStiRadarLineSeries extends IStiRadarSeries {
        lineColor: Color;
        lineStyle: StiPenStyle;
        lighting: boolean;
        lineWidth: number;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarPointSeries: string;
    interface IStiRadarPointSeries extends IStiRadarSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRadarSeries: string;
    interface IStiRadarSeries extends IStiSeries {
        marker: IStiMarker;
        showNulls: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiLineRangeSeries: string;
    interface IStiLineRangeSeries extends IStiLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeBarSeries: string;
    interface IStiRangeBarSeries extends IStiClusteredColumnSeries, IStiRangeSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiRangeSeries: string;
    interface IStiRangeSeries {
        valuesEnd: number[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSplineRangeSeries: string;
    interface IStiSplineRangeSeries extends IStiSplineSeries, IStiRangeSeries {
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiSteppedRangeSeries: string;
    interface IStiSteppedRangeSeries extends IStiSteppedLineSeries, IStiRangeSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterLineSeries: string;
    interface IStiScatterLineSeries extends IStiScatterSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterSeries: string;
    interface IStiScatterSeries extends IStiBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiScatterSplineSeries: string;
    interface IStiScatterSplineSeries extends IStiScatterLineSeries {
        tension: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedBarSeries: string;
    interface IStiStackedBarSeries extends IStiSeries, IStiAllowApplyBrushNegative {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
        allowApplyBrushNegative: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedAreaSeries: string;
    interface IStiStackedAreaSeries extends IStiStackedLineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiStackedBaseLineSeries: string;
    interface IStiStackedBaseLineSeries extends IStiSeries {
        marker: IStiMarker;
        lineMarker: IStiLineMarker;
        lighting: boolean;
        lineColor: Color;
        lineWidth: number;
        lineStyle: StiPenStyle;
        showNulls: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedColumnSeries: string;
    interface IStiStackedColumnSeries extends IStiSeries, IStiAllowApplyBrushNegative {
        width: number;
        borderColor: Color;
        brush: StiBrush;
        showZeros: boolean;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiStackedLineSeries: string;
    interface IStiStackedLineSeries extends IStiStackedBaseLineSeries {
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiStackedSplineAreaSeries: string;
    interface IStiStackedSplineAreaSeries extends IStiStackedSplineSeries, IStiAllowApplyBrushNegative {
        brush: StiBrush;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiStackedSplineSeries: string;
    interface IStiStackedSplineSeries extends IStiStackedBaseLineSeries, IStiAllowApplyColorNegative {
        tension: number;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiTreemapSeries: string;
    interface IStiTreemapSeries extends IStiSeries {
        borderColor: Color;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAllowApplyBorderColor: string;
    interface IStiAllowApplyBorderColor {
        allowApplyBorderColor: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiAllowApplyBrush: string;
    interface IStiAllowApplyBrush {
        allowApplyBrush: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiAllowApplyBrushNegative: string;
    interface IStiAllowApplyBrushNegative {
        allowApplyBrushNegative: boolean;
        brushNegative: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiAllowApplyColorNegative: string;
    interface IStiAllowApplyColorNegative {
        allowApplyColorNegative: boolean;
        lineColorNegative: Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    var IStiSeries: string;
    interface IStiSeries extends ICloneable, IStiJsonReportObject {
        core: IStiSeriesCoreXF;
        allowApplyStyle: boolean;
        format: string;
        coreTitle: string;
        titleValue: string;
        sortBy: StiSeriesSortType;
        sortDirection: StiSeriesSortDirection;
        showInLegend: boolean;
        showSeriesLabels: StiShowSeriesLabels;
        showShadow: boolean;
        filters: IStiChartFiltersCollection;
        topN: IStiSeriesTopN;
        conditions: IStiChartConditionsCollection;
        yAxis: StiSeriesYAxis;
        seriesLabels: IStiSeriesLabels;
        chart: IStiChart;
        valuesStart: number[];
        values: number[];
        arguments: Object[];
        toolTips: string[];
        tags: Object[];
        hyperlinks: string[];
        interaction: IStiSeriesInteraction;
        argumentDataColumn: string;
        argument: string;
        title: string;
        filterMode: StiFilterMode;
        trendLine: IStiTrendLine;
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiSeriesCollection: string;
    interface IStiSeriesCollection extends ICollection<IStiSeries>, IStiApplyStyle {
        add(value: IStiSeries): any;
        getByIndex(index: number): IStiSeries;
        insert(index: number, value: IStiSeries): any;
        indexOf(value: IStiSeries): number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiSeriesCoreXF: string;
    interface IStiSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: IStiCellGeom, seriesArray: IStiSeries[]): any;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        getSeriesLabels(): IStiAxisSeriesLabels;
        setIsMouseOverSeriesElement(seriesIndex: number, value: boolean): any;
        isDateTimeValues: boolean;
        applyStyle(style: IStiChartStyle, color: Color): any;
        getTag(tagIndex: number): string;
        getIsMouseOverSeriesElement(seriesIndex: number): boolean;
        interaction: IStiSeriesInteraction;
        seriesColors: Color[];
        isDateTimeArguments: boolean;
        isMouseOver: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import Point = Stimulsoft.System.Drawing.Point;
    var IStiSeriesInteractionData: string;
    interface IStiSeriesInteractionData {
        isElements: boolean;
        tag: Object;
        tooltip: string;
        hyperlink: string;
        argument: Object;
        value: number;
        series: IStiSeries;
        pointIndex: number;
        point: Point;
        fill(area: IStiArea, series: IStiSeries, pointIndex: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiStrips: string;
    interface IStiStrips extends ICloneable, IStiJsonReportObject {
        core: IStiStripsCoreXF;
        allowApplyStyle: boolean;
        showBehind: boolean;
        stripBrush: StiBrush;
        antialiasing: boolean;
        font: Font;
        text: string;
        titleVisible: boolean;
        titleColor: Color;
        orientation: StiStrips_StiOrientation;
        showInLegend: boolean;
        maxValue: string;
        minValue: string;
        visible: boolean;
        chart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICollection = Stimulsoft.System.Collections.ICollection;
    var IStiStripsCollection: string;
    interface IStiStripsCollection extends ICollection<IStiStrips>, IStiApplyStyle {
        add(value: IStiStrips): any;
        insert(index: number, value: IStiStrips): any;
        getByIndex(index: number): IStiStrips;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiStripsCoreXF: string;
    interface IStiStripsCoreXF extends IStiApplyStyle {
        render(context: StiContext, geom: IStiCellGeom, rect: RectangleD): any;
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiBaseStyle = Stimulsoft.Report.Styles.IStiBaseStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartStyle: string;
    interface IStiChartStyle extends IStiBaseStyle, ICloneable, IStiJsonReportObject {
        styleIdent: StiElementStyleIdent;
        core: IStiStyleCoreXF;
        serviceEnabled: boolean;
        allowDashboard: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiCustomStyle: string;
    interface IStiCustomStyle extends IStiChartStyle {
        customCore: IStiCustomStyleCoreXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    var IStiCustomStyleCoreXF: string;
    interface IStiCustomStyleCoreXF extends IStiStyleCoreXF {
        reportStyle: StiChartStyle;
        reportStyleName: string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    var IStiStyleCoreXF: string;
    interface IStiStyleCoreXF {
        chart: IStiChart;
        chartBrush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        seriesShowShadow: boolean;
        seriesLighting: boolean;
        seriesLabelsFont: Font;
        seriesLabelsColor: Color;
        seriesLabelsBrush: StiBrush;
        seriesLabelsBorderColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        axisTitleColor: Color;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        legendShowShadow: boolean;
        legendFont: Font;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number, seriesColors: Color[]): Color[];
        getColorByIndex(index: number, count: number, seriesColor: Color[]): Color;
        getColorBySeries(series: IStiSeries, seriesColor: Color[]): Color;
        basicStyleColor: Color;
        markerVisible: boolean;
        styleColors: Color[];
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTable: string;
    interface IStiChartTable extends ICloneable, IStiJsonReportObject {
        core: IStiChartTableCoreXF;
        chart: IStiChart;
        allowApplyStyle: boolean;
        font: Font;
        markerVisible: boolean;
        gridLineColor: Color;
        textColor: Color;
        gridLinesHor: boolean;
        gridLinesVert: boolean;
        gridOutline: boolean;
        visible: boolean;
        format: string;
        header: IStiChartTableHeader;
        dataCells: IStiChartTableDataCells;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiChartTableCoreXF: string;
    interface IStiChartTableCoreXF extends IStiApplyStyle {
        showTable(): boolean;
        getWidthCellLegend(context: StiContext): number;
        getHeightTable(context: StiContext, widthTable: number): number;
        render(context: StiContext, rect: RectangleD): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTableDataCells: string;
    interface IStiChartTableDataCells extends ICloneable, IStiJsonReportObject {
        font: Font;
        textColor: Color;
        shrinkFontToFit: boolean;
        shrinkFontToFitMinimumSize: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiChartTableHeader: string;
    interface IStiChartTableHeader extends ICloneable, IStiJsonReportObject {
        brush: StiBrush;
        font: Font;
        textColor: Color;
        wordWrap: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiSeriesTopN: string;
    interface IStiSeriesTopN extends ICloneable, IStiJsonReportObject {
        mode: StiTopNMode;
        count: number;
        showOthers: boolean;
        othersText: string;
        loadFromXml(xmlNode: XmlNode): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    var IStiTrendLine: string;
    interface IStiTrendLine extends ICloneable, IStiJsonReportObject {
        core: IStiTrendLineCoreXF;
        lineWidth: number;
        lineStyle: StiPenStyle;
        lineColor: Color;
        font: Font;
        showShadow: boolean;
        titleVisible: boolean;
        text: string;
        position: StiTrendLine_StiTextPosition;
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    var IStiTrendLineCoreXF: string;
    interface IStiTrendLineCoreXF {
        renderTrendLine(geom: IStiCellGeom, points: PointD[], posY: number): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineExponential: string;
    interface IStiTrendLineExponential extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineLinear: string;
    interface IStiTrendLineLinear extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineLogarithmic: string;
    interface IStiTrendLineLogarithmic extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiTrendLineNone: string;
    interface IStiTrendLineNone extends IStiTrendLine {
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiApplyStyle: string;
    interface IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiApplyStyleSeries: string;
    interface IStiApplyStyleSeries {
        applyStyle(style: IStiChartStyle, color: Color): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    var IStiCellGeom: string;
    interface IStiCellGeom {
        drawGeom(context: StiContext): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import IStiCanGrow = Stimulsoft.Report.Components.IStiCanGrow;
    import IStiCanShrink = Stimulsoft.Report.Components.IStiCanShrink;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    var IStiChart: string;
    interface IStiChart extends IStiComponent, IStiName, IStiCanGrow, IStiCanShrink {
        seriesLabelsConditions: IStiChartConditionsCollection;
        series: IStiSeriesCollection;
        area: IStiArea;
        style: IStiChartStyle;
        seriesLabels: IStiSeriesLabels;
        legend: IStiLegend;
        title: IStiChartTitle;
        table: IStiChartTable;
        strips: IStiStripsCollection;
        constantLines: IStiConstantLinesCollection;
        horSpacing: number;
        vertSpacing: number;
        isDesigning: boolean;
        isAnimation: boolean;
        brush: StiBrush;
        core: IStiChartCoreXF;
        allowApplyStyle: boolean;
        masterComponent: IStiComponent;
        jsonMasterComponentTemp: string;
        dataSourceName: string;
        chartInfo: IStiChartInfo;
        processAtEnd: boolean;
        convertToHInches(value: number): number;
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        customStyleName: string;
        name: string;
        border: StiBorder;
        filters: StiFiltersCollection;
        filterMode: StiFilterMode;
        filterOn: boolean;
        dataSource: StiDataSource;
        dataRelation: StiDataRelation;
        countData: number;
        businessObject: StiBusinessObject;
        canGrow: boolean;
        canShrink: boolean;
        rotation: StiImageRotation;
        page: StiPage;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): any;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    var IStiChartCoreXF: string;
    interface IStiChartCoreXF extends IStiApplyStyle {
        applyStyle(style: IStiChartStyle): any;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): IStiCellGeom;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiText = Stimulsoft.Report.Components.StiText;
    var IStiChartInfo: string;
    interface IStiChartInfo {
        interactiveComps: StiText[];
        storedForProcessAtEndChart: IStiChart;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiGeomInteraction: string;
    interface IStiGeomInteraction {
        invokeClick(options: any): any;
        invokeMouseEnter(options: any): any;
        invokeMouseLeave(options: any): any;
        invokeMouseDown(options: any): any;
        invokeMouseUp(options: any): any;
        invokeDrag(options: any): any;
    }
}
declare module Stimulsoft.Report.Chart {
    var IStiSeriesElement: string;
    interface IStiSeriesElement {
        elementIndex: String;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    var IStiSeriesInteraction: string;
    interface IStiSeriesInteraction extends ICloneable, IStiJsonReportObject {
        drillDownEnabled: boolean;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        loadFromXml(xmlNode: XmlNode): any;
        drillDownPageGuid: string;
        drillDownPage: StiPage;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiTrendLinePropertyOrder {
        lineColor: number;
        lineStyle: number;
        lineWidth: number;
        showShadow: number;
    }
    class StiSeriesLabelsPropertyOrder {
        allowApplyStyle: number;
        angle: number;
        antialiasing: number;
        autoRotate: number;
        conditions: number;
        drawBorder: number;
        borderColor: number;
        brush: number;
        font: number;
        format: number;
        labelColor: number;
        legendValueType: number;
        lineColor: number;
        lineColorNegative: number;
        lineLength: number;
        markerAlignment: number;
        markerSize: number;
        markerVisible: number;
        preventIntersection: number;
        showInPercent: number;
        showNulls: number;
        showValue: number;
        showZeros: number;
        step: number;
        textAfter: number;
        textBefore: number;
        useSeriesColor: number;
        valueType: number;
        valueTypeSeparator: number;
        visible: number;
        width: number;
        wordWrap: number;
    }
    class StiSeriesPropertyOrder {
        allowSeries: number;
        allowSeriesElements: number;
        drillDownEnabled: number;
        drillDownPage: number;
        drillDownReport: number;
        hyperlinkDataColumn: number;
        tagDataColumn: number;
        toolTipDataColumn: number;
        weightDataColumn: number;
        hyperlink: number;
        tag: number;
        toolTip: number;
        weight: number;
        listOfHyperlinks: number;
        listOfTags: number;
        listOfToolTips: number;
        listOfWeights: number;
        valueValueDataColumn: number;
        valueValue: number;
        valueListOfValues: number;
        valueValueDataColumnEnd: number;
        valueValueEnd: number;
        valueListOfValuesEnd: number;
        valueValueDataColumnOpen: number;
        valueValueOpen: number;
        valueListOfValuesOpen: number;
        valueValueDataColumnClose: number;
        valueValueClose: number;
        valueListOfValuesClose: number;
        valueValueDataColumnHigh: number;
        valueValueHigh: number;
        valueListOfValuesHigh: number;
        valueValueDataColumnLow: number;
        valueValueLow: number;
        valueListOfValuesLow: number;
        argumentArgumentDataColumn: number;
        argumentArgument: number;
        argumentListOfArguments: number;
        weightWeightDataColumn: number;
        weightWeight: number;
        weightListOfWeights: number;
        appearanceAllowApplyBorderColor: number;
        appearanceAllowApplyBrush: number;
        appearanceAllowApplyBrushNegative: number;
        appearanceAllowApplyColorNegative: number;
        appearanceDiameter: number;
        appearanceBorderColor: number;
        appearanceBrush: number;
        appearanceBrushNegative: number;
        appearanceLighting: number;
        appearanceShowShadow: number;
        appearanceTopmostLine: number;
        appearanceFunnelSliceMode: number;
        dataConditions: number;
        dataFilters: number;
        dataFilterMode: number;
        dataTopN: number;
        dataFormat: number;
        dataSortBy: number;
        dataSortDirection: number;
        dataAutoSeriesKeyDataColumn: number;
        dataAutoSeriesColorDataColumn: number;
        dataAutoSeriesTitleDataColumn: number;
    }
    enum StiChartTitleDock {
        Top = 0,
        Right = 90,
        Bottom = 180,
        Left = 270
    }
    enum StiLegendDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3
    }
    enum StiDirection {
        LeftToRight = 0,
        RightToLeft = 1,
        TopToBottom = 2,
        BottomToTop = 3
    }
    enum StiLegendHorAlignment {
        LeftOutside = 0,
        Left = 1,
        Center = 2,
        Right = 3,
        RightOutside = 4
    }
    enum StiLegendVertAlignment {
        TopOutside = 0,
        Top = 1,
        Center = 2,
        Bottom = 3,
        BottomOutside = 4
    }
    enum StiMarkerAlignment {
        Left = 0,
        Center = 1,
        Right = 2
    }
    enum StiChartAreaPosition {
        ClusteredColumn = 0,
        StackedColumn = 1,
        FullStackedColumn = 2,
        Pareto = 3,
        ClusteredBar = 10,
        StackedBar = 11,
        FullStackedBar = 12,
        Pie = 20,
        Doughnut = 21,
        Line = 30,
        SteppedLine = 31,
        StackedLine = 32,
        FullStackedLine = 33,
        Spline = 40,
        StackedSpline = 41,
        FullStackedSpline = 42,
        Area = 50,
        SteppedArea = 51,
        StackedArea = 52,
        FullStackedArea = 53,
        SplineArea = 60,
        StackedSplineArea = 61,
        FullStackedSplineArea = 62,
        Gantt = 70,
        Scatter = 80,
        Bubble = 81,
        RadarPoint = 82,
        RadarLine = 83,
        RadarArea = 84,
        Range = 90,
        SteppedRange = 91,
        RangeBar = 92,
        SplineRange = 93,
        Funnel = 100,
        Candlestick = 110,
        Stock = 120,
        Treemap = 130,
        Pictorial = 131
    }
    enum StiChartSeriesOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum StiArrowStyle {
        None = 0,
        Triangle = 1,
        Lines = 2,
        Circle = 3,
        Arc = 4,
        ArcAndCircle = 5
    }
    enum StiLabelsPlacement {
        None = 0,
        OneLine = 1,
        TwoLines = 2,
        AutoRotation = 3
    }
    enum StiXAxisDock {
        Top = 0,
        Bottom = 1
    }
    enum StiYAxisDock {
        Left = 0,
        Right = 1
    }
    enum StiTitlePosition {
        Inside = 0,
        Outside = 1
    }
    enum StiSeriesLabelsPosition {
        None = 0,
        InsideEndAxis = 1,
        InsideBaseAxis = 2,
        CenterAxis = 3,
        OutsideEndAxis = 4,
        OutsideBaseAxis = 5,
        OutsideAxis = 6,
        Left = 7,
        Value = 8,
        Right = 9,
        InsideEndPie = 10,
        CenterPie = 11,
        OutsidePie = 12,
        TwoColumnsPie = 13,
        CenterFunnel = 14,
        OutsideRightFunnel = 15,
        OutsideLeftFunnel = 16,
        CenterTreemap = 17
    }
    enum StiSeriesLabelsType {
        Axis = 1,
        Pie = 2,
        Doughnut = 4,
        Radar = 8,
        Funnel = 10,
        Treemap = 12,
        All = 15
    }
    enum StiSeriesLabelsValueType {
        Value = 0,
        SeriesTitle = 1,
        Argument = 2,
        Tag = 3,
        Weight = 4,
        ValueArgument = 5,
        ArgumentValue = 6,
        SeriesTitleValue = 7,
        SeriesTitleArgument = 8
    }
    enum StiMarkerType {
        Rectangle = 0,
        Triangle = 1,
        Circle = 2,
        Star5 = 3,
        Star6 = 4,
        Star7 = 5,
        Star8 = 6,
        Hexagon = 7
    }
    enum StiSeriesSortType {
        Value = 0,
        Argument = 1,
        None = 2
    }
    enum StiSeriesSortDirection {
        Ascending = 0,
        Descending = 1
    }
    enum StiSeriesYAxis {
        LeftYAxis = 0,
        RightYAxis = 1
    }
    enum StiShowSeriesLabels {
        None = 0,
        FromChart = 1,
        FromSeries = 2
    }
    enum StiShowYAxis {
        Left = 0,
        Center = 1,
        Both = 2
    }
    enum StiShowXAxis {
        Bottom = 0,
        Center = 1,
        Both = 2
    }
    enum StiRadarStyle {
        Polygon = 0,
        Circle = 1
    }
    enum StiTimeDateStep {
        None = 0,
        Second = 1,
        Minute = 2,
        Hour = 3,
        Day = 4,
        Month = 5,
        Year = 6
    }
    enum StiTopNMode {
        None = 0,
        Top = 1,
        Bottom = 2
    }
    enum StiChartStyleId {
        StiStyle01 = 0,
        StiStyle02 = 1,
        StiStyle03 = 2,
        StiStyle04 = 3,
        StiStyle05 = 4,
        StiStyle06 = 5,
        StiStyle07 = 6,
        StiStyle08 = 7,
        StiStyle09 = 8,
        StiStyle10 = 9,
        StiStyle11 = 10,
        StiStyle12 = 11,
        StiStyle13 = 12,
        StiStyle14 = 13,
        StiStyle15 = 14,
        StiStyle16 = 15,
        StiStyle17 = 16,
        StiStyle18 = 17,
        StiStyle19 = 18,
        StiStyle20 = 19,
        StiStyle21 = 20,
        StiStyle22 = 21,
        StiStyle23 = 22,
        StiStyle24 = 23,
        StiStyle25 = 24,
        StiStyle26 = 25,
        StiStyle27 = 26,
        StiStyle28 = 27,
        StiStyle29 = 28,
        StiStyle30 = 29,
        StiStyle31 = 30,
        StiStyle32 = 31,
        StiStyle33 = 32
    }
    enum StiStrips_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2
    }
    enum StiConstantLines_StiOrientation {
        Horizontal = 0,
        Vertical = 1,
        HorizontalRight = 2
    }
    enum StiConstantLines_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        CenterTop = 2,
        CenterBottom = 3,
        RightTop = 4,
        RightBottom = 5
    }
    enum StiTrendLine_StiTextPosition {
        LeftTop = 0,
        LeftBottom = 1,
        RightTop = 2,
        RightBottom = 3
    }
}
declare module Stimulsoft.Report.CodeDom {
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    class StiCodeDomExpressionHelper {
        private static parseRtf;
        static readString(codeGenerator: StiCodeGenerator, REFpos: any, REFlexem: any, script: string, REFal: any, isRichText: boolean, fullRtf: boolean): void;
        private static readChar;
        static getLexemSimple(codeGenerator: StiCodeGenerator, script: string, richText: StiRichText): string[];
        static getLexem(script: string): string[];
        private static replaceBackslash;
    }
}
declare module Stimulsoft.Report.CodeDom {
    class StiCodeGenerator {
        private static keywordsHashtable;
        private static keywords;
        static isKeywordExist(value: string): boolean;
        quoteSnippetString(value: string): string;
        static init(): void;
    }
}
declare module Stimulsoft.Report {
    /** Enum provide variants of nested factor. */
    enum StiNestedFactor {
        High = 0,
        Normal = 1,
        Low = 2
    }
    enum StiFontIcons {
        Latin5 = 0,
        Latin4 = 1,
        Latin3 = 2,
        Latin2 = 3,
        Latin1 = 4,
        QuarterFull = 5,
        QuarterThreeFourth = 6,
        QuarterHalf = 7,
        QuarterQuarter = 8,
        QuarterNone = 9,
        Rating4 = 10,
        Rating3 = 11,
        Rating2 = 12,
        Rating1 = 13,
        Rating0 = 14,
        Square0 = 15,
        Square1 = 16,
        Square2 = 17,
        Square3 = 18,
        Square4 = 19,
        StarFull = 20,
        StarThreeFourth = 21,
        StarHalf = 22,
        StarQuarter = 23,
        StarNone = 24,
        ArrowDown = 25,
        ArrowRight = 26,
        ArrowRightDown = 27,
        ArrowRightUp = 28,
        ArrowUp = 29,
        Check = 30,
        Circle = 31,
        CircleCheck = 32,
        CircleCross = 33,
        CircleExclamation = 34,
        Cross = 35,
        Rhomb = 36,
        Exclamation = 37,
        Flag = 38,
        Minus = 39,
        Triangle = 40,
        TriangleDown = 41,
        TriangleUp = 42,
        Home = 43,
        Cart = 44,
        Phone = 45,
        Mobile = 46,
        Mug = 47,
        Airplane = 48,
        Man = 49,
        Woman = 50,
        UserTie = 51,
        Truck = 52,
        Earth = 53,
        ManWoman = 54,
        Appleinc = 55,
        Android = 56,
        Windows8 = 57
    }
    enum StiResizeReportOptions {
        ProcessAllPages = 1,
        RebuildReport = 2,
        RescaleContent = 4,
        PageOrientationChanged = 8,
        ShowProgressOnRebuildReport = 16,
        AllowPageMarginsRescaling = 32
    }
    enum StiCalculationMode {
        Compilation = 0,
        Interpretation = 1
    }
    enum StiReportLanguageType {
        CSharp = 0,
        VB = 1,
        JS = 2
    }
    enum StiReportUnitType {
        Centimeters = 0,
        HundredthsOfInch = 1,
        Inches = 2,
        Millimeters = 3
    }
    enum StiGridMode {
        Lines = 0,
        Dots = 1
    }
    enum StiReportPass {
        None = 0,
        First = 1,
        Second = 2
    }
    enum StiNumberOfPass {
        SinglePass = 0,
        DoublePass = 1
    }
    enum StiExportFormat {
        None = 0,
        Pdf = 1,
        Xps = 2,
        HtmlTable = 3,
        HtmlSpan = 4,
        HtmlDiv = 5,
        Rtf = 6,
        RtfTable = 7,
        RtfFrame = 8,
        RtfWinWord = 9,
        RtfTabbedText = 10,
        Text = 11,
        Excel = 12,
        ExcelXml = 13,
        Excel2007 = 14,
        Word2007 = 15,
        Xml = 16,
        Csv = 17,
        Dif = 18,
        Sylk = 19,
        Image = 20,
        ImageGif = 21,
        ImageBmp = 22,
        ImagePng = 23,
        ImageTiff = 24,
        ImageJpeg = 25,
        ImagePcx = 26,
        ImageEmf = 27,
        ImageSvg = 28,
        ImageSvgz = 29,
        Mht = 30,
        Dbf = 31,
        Html = 32,
        Ods = 33,
        Odt = 34,
        Ppt2007 = 35,
        Html5 = 36,
        Data = 37,
        Json = 38,
        Document = 1000
    }
    enum StiReportCacheMode {
        Off = 0,
        On = 1,
        Auto = 2
    }
    enum StiReportResourceType {
        Bitmap = 0,
        Metafile = 1,
        Report = 2
    }
    enum StiRangeType {
        All = 1,
        CurrentPage = 2,
        Pages = 3
    }
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3
    }
    enum ImageFormat {
        Bmp = 0,
        Emf = 1,
        Exif = 2,
        Gif = 3,
        Guid = 4,
        Icon = 5,
        Jpeg = 6,
        MemoryBmp = 7,
        Png = 8,
        Tiff = 9,
        Wmf = 10
    }
    enum StiArabicDigitsType {
        /** A value for the standard arabic digits. */
        Standard = 0,
        /** A value for the Eastern arabic digits. */
        Eastern = 1
    }
    enum StiBrushType {
        Solid = 0,
        Glare = 1,
        Gradient0 = 2,
        Gradient90 = 3,
        Gradient180 = 4,
        Gradient270 = 5,
        Gradient45 = 6
    }
    enum StiComponentId {
        StiComponent = 0,
        StiBarCode = 1,
        StiButtonControl = 2,
        StiChart = 3,
        StiChartCommon = 4,
        StiCheckBox = 5,
        StiCheckBoxControl = 6,
        StiCheckedListBoxControl = 7,
        StiChildBand = 8,
        StiClone = 9,
        StiColumnFooterBand = 10,
        StiColumnHeaderBand = 11,
        StiComboBoxControl = 12,
        StiContainer = 13,
        StiContourText = 14,
        StiCrossColumn = 15,
        StiCrossColumnTotal = 16,
        StiCrossDataBand = 17,
        StiCrossFooterBand = 18,
        StiCrossGroupFooterBand = 19,
        StiCrossGroupHeaderBand = 20,
        StiCrossHeaderBand = 21,
        StiCrossRow = 22,
        StiCrossRowTotal = 23,
        StiCrossSummary = 24,
        StiCrossTab = 25,
        StiCrossTitle = 26,
        StiDashboardPage = 27,
        StiDataBand = 28,
        StiDateTimePickerControl = 29,
        StiEmptyBand = 30,
        StiFooterBand = 31,
        StiForm = 32,
        StiGridControl = 33,
        StiGroupBoxControl = 34,
        StiGroupFooterBand = 35,
        StiGroupHeaderBand = 36,
        StiHeaderBand = 37,
        StiHierarchicalBand = 38,
        StiHorizontalLinePrimitive = 39,
        StiImage = 40,
        StiLabelControl = 41,
        StiListBoxControl = 42,
        StiListViewControl = 43,
        StiLookUpBoxControl = 44,
        StiNumericUpDownControl = 45,
        StiOverlayBand = 46,
        StiPage = 47,
        StiPageFooterBand = 48,
        StiPageHeaderBand = 49,
        StiPanel = 50,
        StiPanelControl = 51,
        StiPictureBoxControl = 52,
        StiRadioButtonControl = 53,
        StiRectanglePrimitive = 54,
        StiReportControl = 55,
        StiReportSummaryBand = 56,
        StiReportTitleBand = 57,
        StiRichText = 58,
        StiRichTextBoxControl = 59,
        StiRoundedRectanglePrimitive = 60,
        StiShape = 61,
        StiSubReport = 62,
        StiSystemText = 63,
        StiTable = 64,
        StiTableCell = 65,
        StiText = 66,
        StiTextBoxControl = 67,
        StiTextInCells = 68,
        StiTreeViewControl = 69,
        StiVerticalLinePrimitive = 70,
        StiWinControl = 71,
        StiUndefinedComponent = 72,
        StiZipCode = 73,
        StiTableCellCheckBox = 74,
        StiTableCellImage = 75,
        StiTableCellRichText = 76,
        StiDataColumn = 77,
        StiCalcDataColumn = 78,
        StiBusinessObject = 79,
        StiDataSource = 80,
        StiDataStoreSource = 81,
        StiFileDataSource = 82,
        StiDataRelation = 83,
        StiVariable = 84,
        StiResource = 85,
        StiReport = 86,
        StiStyle = 87,
        StiCrossTabStyle = 88,
        StiChartStyle = 89,
        StiMapStyle = 90,
        StiTableStyle = 91,
        StiGaugeStyle = 92,
        StiIndicatorStyle = 93,
        StiDialogStyle = 94,
        StiDataParameter = 95,
        StiCrossField = 96,
        StiCrossTotal = 97,
        StiCrossCell = 98,
        StiCrossHeader = 99,
        StiCrossSummaryHeader = 100,
        StiStartPointPrimitive = 101,
        StiEndPointPrimitive = 102,
        StiEvent = 103,
        StiChartElement = 104,
        StiGaugeElement = 105,
        StiImageElement = 106,
        StiIndicatorElement = 107,
        StiRegionMapElement = 108,
        StiOnlineMapElement = 109,
        StiTableElement = 110,
        StiPivotTableElement = 111,
        StiProgressElement = 112,
        StiTextElement = 113,
        StiPanelElement = 114,
        StiShapeElement = 115,
        StiTreeViewElement = 116,
        StiTreeViewBoxElement = 117,
        StiListBoxElement = 118,
        StiComboBoxElement = 119,
        StiDatePickerElement = 120,
        StiDateRangeElement = 121,
        StiDashboard = 122,
        StiSeries = 123,
        StiBubbleSeries = 124,
        StiClusteredColumnSeries = 125,
        StiParetoSeries = 126,
        StiLineSeries = 127,
        StiSteppedLineSeries = 128,
        StiSplineSeries = 129,
        StiAreaSeries = 130,
        StiSteppedAreaSeries = 131,
        StiSplineAreaSeries = 132,
        StiStackedColumnSeries = 133,
        StiStackedLineSeries = 134,
        StiStackedSplineSeries = 135,
        StiStackedAreaSeries = 136,
        StiStackedSplineAreaSeries = 137,
        StiFullStackedColumnSeries = 138,
        StiFullStackedLineSeries = 139,
        StiFullStackedAreaSeries = 140,
        StiFullStackedSplineSeries = 141,
        StiFullStackedSplineAreaSeries = 142,
        StiClusteredBarSeries = 143,
        StiStackedBarSeries = 144,
        StiTreemapSeries = 145,
        StiPictorialSeries = 146,
        StiFullStackedBarSeries = 147,
        StiPieSeries = 148,
        StiDoughnutSeries = 149,
        StiGanttSeries = 150,
        StiScatterSeries = 151,
        StiScatterLineSeries = 152,
        StiScatterSplineSeries = 153,
        StiRadarAreaSeries = 154,
        StiRadarLineSeries = 155,
        StiRadarPointSeries = 156,
        StiRangeSeries = 157,
        StiSteppedRangeSeries = 158,
        StiFunnelSeries = 159,
        StiFunnelWeightedSlicesSeries = 160,
        StiRangeBarSeries = 161,
        StiSplineRangeSeries = 162,
        StiCandlestickSeries = 163,
        StiStockSeries = 164,
        StiChartTitle = 165,
        StiLineMarker = 166,
        StiMarker = 167,
        StiChartTable = 168,
        StiSeriesTopN = 169,
        StiSeriesInteraction = 170,
        StiTrendLine = 171,
        StiSeriesLabels = 172,
        StiNoneLabels = 173,
        StiInsideEndAxisLabels = 174,
        StiInsideBaseAxisLabels = 175,
        StiCenterTreemapLabels = 176,
        StiCenterAxisLabels = 177,
        StiOutsideEndAxisLabels = 178,
        StiOutsideBaseAxisLabels = 179,
        StiOutsideAxisLabels = 180,
        StiLeftAxisLabels = 181,
        StiValueAxisLabels = 182,
        StiRightAxisLabels = 183,
        StiCenterFunnelLabels = 184,
        StiCenterPieLabels = 185,
        StiOutsidePieLabels = 186,
        StiTwoColumnsPieLabels = 187,
        StiOutsideLeftFunnelLabels = 188,
        StiOutsideRightFunnelLabels = 189,
        StiLegend = 190,
        StiClusteredColumnArea = 191,
        StiPieArea = 192,
        StiTreemapArea = 193,
        StiFunnelArea = 194,
        StiFunnelWeightedSlicesArea = 195,
        StiPictorialArea = 196,
        StiRadarAreaArea = 197,
        StiRadarLineArea = 198,
        StiRadarPointArea = 199,
        StiStackedColumnArea = 200,
        StiGridLines = 201,
        StiInterlacing = 202,
        StiXAxis = 203,
        StiXTopAxis = 204,
        StiYAxis = 205,
        StiYRightAxis = 206,
        StiRadarGridLines = 207,
        StiXRadarAxis = 208,
        StiYRadarAxis = 209,
        StiDialogInfoItem = 210,
        StiStringDialogInfoItem = 211,
        StiGuidDialogInfoItem = 212,
        StiCharDialogInfoItem = 213,
        StiBoolDialogInfoItem = 214,
        StiImageDialogInfoItem = 215,
        StiDateTimeDialogInfoItem = 216,
        StiTimeSpanDialogInfoItem = 217,
        StiDoubleDialogInfoItem = 218,
        StiDecimalDialogInfoItem = 219,
        StiLongDialogInfoItem = 220,
        StiExpressionDialogInfoItem = 221,
        StiStringRangeDialogInfoItem = 222,
        StiGuidRangeDialogInfoItem = 223,
        StiByteArrayRangeDialogInfoItem = 224,
        StiCharRangeDialogInfoItem = 225,
        StiDateTimeRangeDialogInfoItem = 226,
        StiTimeSpanRangeDialogInfoItem = 227,
        StiDoubleRangeDialogInfoItem = 228,
        StiDecimalRangeDialogInfoItem = 229,
        StiLongRangeDialogInfoItem = 230,
        StiExpressionRangeDialogInfoItem = 231,
        OracleConnectionStringBuilder = 232,
        StiStrips = 233,
        StiConstantLines = 234,
        StiShapeTypeService = 235,
        StiDiagonalDownLineShapeType = 236,
        StiRoundedRectangleShapeType = 237,
        StiTriangleShapeType = 238,
        StiComplexArrowShapeType = 239,
        StiBentArrowShapeType = 240,
        StiChevronShapeType = 241,
        StiEqualShapeType = 242,
        StiFlowchartCollateShapeType = 243,
        StiFlowchartOffPageConnectorShapeType = 244,
        StiArrowShapeType = 245,
        StiOctagonShapeType = 246,
        StiAustraliaPost4StateBarCodeType = 247,
        StiCode11BarCodeType = 248,
        StiCode128aBarCodeType = 249,
        StiCode128bBarCodeType = 250,
        StiCode128cBarCodeType = 251,
        StiCode128AutoBarCodeType = 252,
        StiCode39BarCodeType = 253,
        StiCode39ExtBarCodeType = 254,
        StiCode93BarCodeType = 255,
        StiCode93ExtBarCodeType = 256,
        StiCodabarBarCodeType = 257,
        StiEAN128aBarCodeType = 258,
        StiEAN128bBarCodeType = 259,
        StiEAN128cBarCodeType = 260,
        StiEAN128AutoBarCodeType = 261,
        StiGS1_128BarCodeType = 262,
        StiEAN13BarCodeType = 263,
        StiEAN8BarCodeType = 264,
        StiFIMBarCodeType = 265,
        StiIsbn10BarCodeType = 266,
        StiIsbn13BarCodeType = 267,
        StiITF14BarCodeType = 268,
        StiJan13BarCodeType = 269,
        StiJan8BarCodeType = 270,
        StiMsiBarCodeType = 271,
        StiPdf417BarCodeType = 272,
        StiPharmacodeBarCodeType = 273,
        StiPlesseyBarCodeType = 274,
        StiPostnetBarCodeType = 275,
        StiQRCodeBarCodeType = 276,
        StiRoyalMail4StateBarCodeType = 277,
        StiDutchKIXBarCodeType = 278,
        StiSSCC18BarCodeType = 279,
        StiUpcABarCodeType = 280,
        StiUpcEBarCodeType = 281,
        StiUpcSup2BarCodeType = 282,
        StiUpcSup5BarCodeType = 283,
        StiInterleaved2of5BarCodeType = 284,
        StiStandard2of5BarCodeType = 285,
        StiDataMatrixBarCodeType = 286,
        StiMaxicodeBarCodeType = 287,
        StiDatabase = 288,
        StiFileDatabase = 289,
        StiCsvDatabase = 290,
        StiDBaseDatabase = 291,
        StiExcelDatabase = 292,
        StiJsonDatabase = 293,
        StiXmlDatabase = 294,
        StiSqlDatabase = 295,
        StiGauge = 296,
        StiMap = 297,
        StiFullStackedColumnArea = 298,
        StiClusteredBarArea = 299,
        StiStackedBarArea = 300,
        StiFullStackedBarArea = 301,
        StiDoughnutArea = 302,
        StiLineArea = 303,
        StiParetoArea = 304,
        StiSteppedLineArea = 305,
        StiStackedLineArea = 306,
        StiFullStackedLineArea = 307,
        StiSplineArea = 308,
        StiStackedSplineArea = 309,
        StiFullStackedSplineArea = 310,
        StiAreaArea = 311,
        StiSteppedAreaArea = 312,
        StiStackedAreaArea = 313,
        StiFullStackedAreaArea = 314,
        StiSplineAreaArea = 315,
        StiStackedSplineAreaArea = 316,
        StiFullStackedSplineAreaArea = 317,
        StiGanttArea = 318,
        StiScatterArea = 319,
        StiBubbleArea = 320,
        StiRangeArea = 321,
        StiSteppedRangeArea = 322,
        StiRangeBarArea = 323,
        StiSplineRangeArea = 324,
        StiCandlestickArea = 325,
        StiStockArea = 326,
        StiInsideEndPieLabels = 327,
        StiTrendLineNone = 328,
        StiTrendLineLinear = 329,
        StiTrendLineExponential = 330,
        StiTrendLineLogarithmic = 331,
        StiDB2Database = 332,
        StiDotConnectUniversalDatabase = 333,
        StiFirebirdDatabase = 334,
        StiInformixDatabase = 335,
        StiMongoDbDatabase = 336,
        StiAzureTableStorageDatabase = 337,
        StiMySqlDatabase = 338,
        StiMSAccessDatabase = 339,
        StiOdbcDatabase = 340,
        StiOleDbDatabase = 341,
        StiOracleDatabase = 342,
        StiPostgreSQLDatabase = 343,
        StiSQLiteDatabase = 344,
        StiSqlCeDatabase = 345,
        StiSybaseDatabase = 346,
        StiTeradataDatabase = 347,
        StiVistaDBDatabase = 348,
        StiODataDatabase = 349,
        StiDataTableSource = 350,
        StiDataViewSource = 351,
        StiUndefinedDataSource = 352,
        StiCsvSource = 353,
        StiDBaseSource = 354,
        StiBusinessObjectSource = 355,
        StiCrossTabDataSource = 356,
        StiEnumerableSource = 357,
        StiUserSource = 358,
        StiVirtualSource = 359,
        StiDataTransformation = 360,
        StiOracleODPSource = 361,
        StiFirebirdSource = 362,
        StiInformixSource = 363,
        StiMongoDbSource = 364,
        StiAzureTableStorageSource = 365,
        StiMSAccessSource = 366,
        StiMySqlSource = 367,
        StiOdbcSource = 368,
        StiOleDbSource = 369,
        StiOracleSource = 370,
        StiPostgreSQLSource = 371,
        StiSqlCeSource = 372,
        StiSQLiteSource = 373,
        StiSqlSource = 374,
        StiNoSqlSource = 375,
        StiSybaseSource = 376,
        StiTeradataSource = 377,
        StiVistaDBSource = 378,
        StiDB2Source = 379,
        StiDiagonalUpLineShapeType = 380,
        StiHorizontalLineShapeType = 381,
        StiLeftAndRightLineShapeType = 382,
        StiOvalShapeType = 383,
        StiRectangleShapeType = 384,
        StiTopAndBottomLineShapeType = 385,
        StiVerticalLineShapeType = 386,
        StiDivisionShapeType = 387,
        StiFlowchartCardShapeType = 388,
        StiFlowchartDecisionShapeType = 389,
        StiFlowchartManualInputShapeType = 390,
        StiFlowchartSortShapeType = 391,
        StiFrameShapeType = 392,
        StiMinusShapeType = 393,
        StiMultiplyShapeType = 394,
        StiParallelogramShapeType = 395,
        StiPlusShapeType = 396,
        StiRegularPentagonShapeType = 397,
        StiTrapezoidShapeType = 398,
        StiSnipSameSideCornerRectangleShapeType = 399,
        StiSnipDiagonalSideCornerRectangleShapeType = 400,
        StiFlowchartPreparationShapeType = 401,
        StiRadialScale = 402,
        StiLinearScale = 403,
        StiLinearBar = 404,
        StiRadialBar = 405,
        StiNeedle = 406,
        StiRadialMarker = 407,
        StiScaleRangeList = 408,
        StiRadialRange = 409,
        StiStateIndicator = 410,
        StiStateIndicatorFilter = 411,
        StiRadialRangeList = 412,
        StiLinearRangeList = 413,
        StiLinearRange = 414,
        StiLinearTickMarkMajor = 415,
        StiLinearTickMarkMinor = 416,
        StiLinearTickMarkCustomValue = 417,
        StiLinearTickLabelMajor = 418,
        StiLinearTickLabelMinor = 419,
        StiLinearTickLabelCustom = 420,
        StiLinearTickLabelCustomValue = 421,
        StiRadialTickMarkMajor = 422,
        StiRadialTickMarkMinor = 423,
        StiRadialTickMarkCustom = 424,
        StiRadialTickMarkCustomValue = 425,
        StiRadialTickLabelMajor = 426,
        StiRadialTickLabelMinor = 427,
        StiRadialTickLabelCustom = 428,
        StiRadialTickLabelCustomValue = 429,
        StiLinearMarker = 430,
        StiLinearTickMarkCustom = 431,
        StiLinearIndicatorRangeInfo = 432,
        StiRadialIndicatorRangeInfo = 433,
        StiBlueDashboardControlStyle = 434,
        StiBlueDashboardIndicatorStyle = 435,
        StiBlueDashboardPageStyle = 436,
        StiBlueDashboardPivotStyle = 437,
        StiBlueDashboardProgressStyle = 438,
        StiBlueDashboardTableStyle = 439,
        StiOrangeDashboardControlStyle = 440,
        StiOrangeDashboardIndicatorStyle = 441,
        StiOrangeDashboardPageStyle = 442,
        StiOrangeDashboardPivotStyle = 443,
        StiOrangeDashboardProgressStyle = 444,
        StiOrangeDashboardTableStyle = 445,
        StiGreenDashboardControlStyle = 446,
        StiGreenDashboardIndicatorStyle = 447,
        StiGreenDashboardPageStyle = 448,
        StiGreenDashboardProgressStyle = 449,
        StiGreenDashboardPivotStyle = 450,
        StiGreenDashboardTableStyle = 451,
        StiTurquoiseDashboardControlStyle = 452,
        StiTurquoiseDashboardIndicatorStyle = 453,
        StiTurquoiseDashboardPageStyle = 454,
        StiTurquoiseDashboardProgressStyle = 455,
        StiTurquoiseDashboardPivotStyle = 456,
        StiTurquoiseDashboardTableStyle = 457,
        StiSlateGrayDashboardControlStyle = 458,
        StiSlateGrayDashboardIndicatorStyle = 459,
        StiSlateGrayDashboardPageStyle = 460,
        StiSlateGrayDashboardProgressStyle = 461,
        StiSlateGrayDashboardPivotStyle = 462,
        StiSlateGrayDashboardTableStyle = 463,
        StiDarkBlueDashboardControlStyle = 464,
        StiDarkBlueDashboardIndicatorStyle = 465,
        StiDarkBlueDashboardPageStyle = 466,
        StiDarkBlueDashboardProgressStyle = 467,
        StiDarkBlueDashboardPivotStyle = 468,
        StiDarkBlueDashboardTableStyle = 469,
        StiYellowDashboardPageStyle = 470,
        StiDarkGrayDashboardControlStyle = 471,
        StiDarkGrayDashboardIndicatorStyle = 472,
        StiDarkGrayDashboardPageStyle = 473,
        StiDarkGrayDashboardProgressStyle = 474,
        StiDarkGrayDashboardPivotStyle = 475,
        StiDarkGrayDashboardTableStyle = 476,
        StiDarkTurquoiseDashboardControlStyle = 477,
        StiDarkTurquoiseDashboardIndicatorStyle = 478,
        StiDarkTurquoiseDashboardPageStyle = 479,
        StiDarkTurquoiseDashboardProgressStyle = 480,
        StiDarkTurquoiseDashboardPivotStyle = 481,
        StiDarkTurquoiseDashboardTableStyle = 482,
        StiSilverDashboardControlStyle = 483,
        StiSilverDashboardIndicatorStyle = 484,
        StiSilverDashboardPageStyle = 485,
        StiSilverDashboardPivotStyle = 486,
        StiSilverDashboardProgressStyle = 487,
        StiSilverDashboardTableStyle = 488,
        StiAliceBlueDashboardControlStyle = 489,
        StiAliceBlueDashboardIndicatorStyle = 490,
        StiAliceBlueDashboardPageStyle = 491,
        StiAliceBlueDashboardPivotStyle = 492,
        StiAliceBlueDashboardProgressStyle = 493,
        StiAliceBlueDashboardTableStyle = 494,
        StiCustomDashboardControlStyle = 495,
        StiCustomDashboardPivotStyle = 496,
        StiCustomDashboardIndicatorStyle = 497,
        StiCustomDashboardProgressStyle = 498,
        StiCustomDashboardTableStyle = 499
    }
    enum StiRankOrder {
        Asc = 0,
        Desc = 1
    }
    enum StiXmlType {
        AdoNetXml = 0,
        Xml = 1
    }
    enum StiStyleElements {
        Font = 1,
        Border = 2,
        Brush = 4,
        TextBrush = 8,
        TextOptions = 16,
        HorAlignment = 32,
        VertAlignment = 64,
        All = 127
    }
    enum StiDateRangeKind {
        CurrentMonth = 0,
        CurrentQuarter = 1,
        CurrentWeek = 2,
        CurrentYear = 3,
        NextMonth = 4,
        NextQuarter = 5,
        NextWeek = 6,
        NextYear = 7,
        PreviousMonth = 8,
        PreviousQuarter = 9,
        PreviousWeek = 10,
        PreviousYear = 11,
        FirstQuarter = 12,
        SecondQuarter = 13,
        ThirdQuarter = 14,
        FourthQuarter = 15,
        MonthToDate = 16,
        QuarterToDate = 17,
        WeekToDate = 18,
        YearToDate = 19,
        Today = 20,
        Tomorrow = 21,
        Yesterday = 22,
        Last7Days = 23,
        Last14Days = 24,
        Last30Days = 25
    }
    enum StiDashboardViewerSettings {
        None = 0,
        ShowToolBar = 1,
        ShowRefreshButton = 2,
        ShowOpenButton = 4,
        ShowFullScreenButton = 8,
        ShowMenuButton = 16,
        ShowEditButton = 32,
        All = 63
    }
    enum StiElementMeterAction {
        None = 0,
        Rename = 1,
        Delete = 2,
        ClearAll = 3
    }
}
declare module Stimulsoft.Report.Components {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    class StiComponentDivider {
        static breakText(g: Graphics, rect: RectangleD, REFtext: any, font: Font, textOptions: StiTextOptions, textQuality: StiTextQuality, allowHtmlTags: boolean, textComp: StiText): string;
        static breakContainer(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        static breakContainerV2(maxAllowedHeight: number, renderedContainer: StiContainer): StiContainer;
        private static getDivideLine;
        private static searchDivideLine;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiContainer extends StiComponent implements IStiBorder, IStiBrush, IStiBreakable, IStiIgnoryStyle, IStiJsonReportObject {
        private static ImplementsStiContainer;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        parseContainerFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        protected static propertyCanBreak: string;
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean, convertComponents?: boolean): void;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        getActualSize(isFirstPass?: boolean, REFneedSecondPass?: any): SizeD;
        private _containerInfo;
        readonly containerInfo: StiContainerInfo;
        readonly priority: number;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly componentType: StiComponentType;
        parentComponentIsBand: boolean;
        parentComponentIsCrossBand: boolean;
        private _collapsedValue;
        collapsedValue: Object;
        private _collapsingIndex;
        collapsingIndex: number;
        private _collapsingTreePath;
        collapsingTreePath: string;
        readonly hasSelected: boolean;
        defaultClientRectangle: RectangleD;
        private _components;
        components: StiComponentsCollection;
        protected static propertyBlocked: string;
        blocked: boolean;
        setParentStylesToChilds(style?: Stimulsoft.Report.Styles.StiBaseStyle): void;
        offsetLocation(offsetX: number, offsetY: number): void;
        changePosition(delta: RectangleD): void;
        normalize(): void;
        sortByPriority(): void;
        bringToFront(): void;
        sendToBack(): void;
        moveForward(): void;
        moveBackward(): void;
        alignTo(aligning: StiAligning): void;
        private getContainerInRectPrivate;
        getContainerInRect(rect: RectangleD, component: StiComponent): StiContainer;
        private getSizesTable;
        private getNodeSize;
        private getContainerInRect2Private;
        getContainerInRect2(rect: RectangleD, component: StiComponent, hash: Hashtable): StiContainer;
        private getIncorrect2;
        correct2(onlySelect: boolean): void;
        getIncorrect(onlySelect?: boolean): StiComponentsCollection;
        correct(onlySelect?: boolean): void;
        checkLargeHeight(needFullCalculation?: boolean): void;
        resetSelection(): void;
        getSelectedComponents(): StiComponentsCollection;
        getSelectedComponents2(REFcomps: any): void;
        getSelectedRectangle(): RectangleD;
        makeHorizontalSpacingEqual(): void;
        makeVerticalSpacingEqual(): void;
        makeSameSize(size: SizeD): void;
        makeSameWidth(width: number): void;
        makeSameHeight(height: number): void;
        setCenterHorizontally(): void;
        setCenterVertically(): void;
        selectAll(): void;
        containerToPage(value: PointD | RectangleD): any;
        private containerToPageRectangle;
        private containerToPagePoint;
        pageToContainer(value: PointD | RectangleD): any;
        getComponents(): StiComponentsCollection;
        getComponents2(REFcomps: any): void;
        getComponentsList(): Array<StiComponent>;
        moveComponentsToPage(): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBand extends StiContainer implements IStiResetPageNumber, IStiJsonReportObject, IStiCanGrow, IStiConditions {
        private static ImplementsStiBand;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        canContainIn(component: StiComponent): boolean;
        readonly componentType: StiComponentType;
        protected getComponentType(): StiComponentType;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _resetPageNumber;
        resetPageNumber: boolean;
        private _bandInfo;
        readonly bandInfo: StiBandInfo;
        printable: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        readonly isAutomaticDock: boolean;
        minHeight: number;
        getMinHeight(): number;
        setMinHeight(value: number): void;
        maxHeight: number;
        getMaxHeight(): number;
        setMaxHeight(value: number): void;
        defaultClientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        selectRectangle: RectangleD;
        readonly nestedLevel: number;
        private _rectangleMoveComponent;
        rectangleMoveComponent: RectangleD;
        headerStartColor: Color;
        headerEndColor: Color;
        getHeaderText(): string;
        readonly headerSize: number;
        readonly footerSize: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDynamicBand extends StiBand implements IStiPageBreak, IStiBreakable, IStiPrintAtBottom, IStiJsonReportObject {
        private _implementsStiDynamicBand;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printAtBottom;
        printAtBottom: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, divLine: number): boolean;
        private _newPageBefore;
        newPageBefore: boolean;
        private _newPageAfter;
        newPageAfter: boolean;
        private _newColumnBefore;
        newColumnBefore: boolean;
        private _newColumnAfter;
        newColumnAfter: boolean;
        private _skipFirst;
        skipFirst: boolean;
        private _breakIfLessThan;
        breakIfLessThan: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChildBand extends StiDynamicBand implements IStiKeepChildTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepChildTogether;
        keepChildTogether: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        protected getComponentType(): StiComponentType;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        private _printIfParentDisabled;
        printIfParentDisabled: boolean;
        createNew(): StiComponent;
        getMaster(): StiBand;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFooterBand extends StiDynamicBand implements IStiPrintOnAllPages, IStiPrintIfEmpty, IStiKeepFooterTogether, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepFooterTogether;
        keepFooterTogether: boolean;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiFooterBand;
        private _startNewPage;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        private _printIfEmpty;
        printIfEmpty: boolean;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _footerBandInfo;
        readonly footerBandInfo: StiFooterBandInfo;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        private static eventMoveFooterToBottom;
        protected onMoveFooterToBottom(e: EventArgs): void;
        invokeMoveFooterToBottom(): void;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnFooterBand extends StiFooterBand implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHeaderBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiPrintOnAllPages, IStiPrintOnEvenOddPages, IStiKeepHeaderTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiHeaderBand;
        private _keepHeaderTogether;
        keepHeaderTogether: boolean;
        private _startNewPage;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        private _printIfEmpty;
        printIfEmpty: boolean;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _headerBandInfo;
        readonly headerBandInfo: StiHeaderBandInfo;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnHeaderBand extends StiHeaderBand {
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBusinessObjectsCollection extends CollectionBase<StiBusinessObject> implements IStiJsonReportObject, ICloneable, IComparer<Object> {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: Object, y: Object): number;
        readonly toList: Array<StiBusinessObject>;
        protected onSet(index: number, oldValue: Object, newValue: Object): void;
        protected onInsert(index: number, value: Object): void;
        add(source: StiBusinessObject): void;
        addRange(sources: StiBusinessObject[] | StiBusinessObjectsCollection): void;
        contains(source: StiBusinessObject): boolean;
        indexOf(source: StiBusinessObject): number;
        insert(index: number, source: StiBusinessObject): void;
        protected onClear(): void;
        remove(source: StiBusinessObject): void;
        getByIndex(index: number): StiBusinessObject;
        setByIndex(index: number, data: StiBusinessObject): void;
        _cachedBusinessObjects: Hashtable;
        readonly cachedBusinessObjects: Hashtable;
        getByName(name: string): StiBusinessObject;
        setByName(name: string, value: StiBusinessObject): void;
        clone(): Object;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        connect(): void;
        disconnect(): void;
        dictionary: StiDictionary;
        parentBusinessObject: StiBusinessObject;
        constructor(dictionary: StiDictionary, parentBusinessObject: StiBusinessObject);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    class StiBusinessObjectHelper {
        static getElementType(arrayType: Type): Type;
        private static getElement;
        static getAlias(valueProp: string): string;
        static isAllowUseProperty(valueProp: string): boolean;
        private static getType;
        private static getDataColumn;
        private static getDataColumn2;
        private static getColumnsFromObject;
        private static getColumnsFromClass;
        static getColumnsFromData(data: Object, includeChildDataSources?: boolean): StiDataColumnsCollection;
        static isDataColumn(type: Type): boolean;
        static getBusinessObjectFromGuid(report: StiReport, guid: string): StiBusinessObject;
        static getBusinessObjectsFromReport(data: StiBusinessObjectsCollection | StiReport): Array<StiBusinessObject>;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetCollapsedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiEndRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiRenderingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiBeginRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetCollapsedEvent = Stimulsoft.Report.Events.StiGetCollapsedEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDataBand extends StiDynamicBand implements IStiDataSource, Stimulsoft.Report.Dictionary.IStiEnumerator, IStiMasterComponent, IStiDataRelation, IStiOddEvenStyles, IStiSort, IStiFilter, IStiPrintOnAllPages, IStiPrintIfDetailEmpty, IStiKeepDetailsTogether, IStiResetPageNumber, IStiRenderMaster, IStiBusinessObject, IStiJsonReportObject {
        private static ImplementsStiDataBand;
        implements(): string[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadXmlSort(xmlNode: XmlNode): string[];
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        private _masterComponent;
        masterComponent: StiComponent;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        keepDetailsTogether: boolean;
        private _keepDetails;
        keepDetails: StiKeepDetails;
        private _sort;
        sort: string[];
        clone(cloneProperties: boolean, cloneComponents: boolean): StiBand;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _printIfDetailEmpty;
        printIfDetailEmpty: boolean;
        readonly isDataSourceEmpty: boolean;
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        isEof: boolean;
        isBofValue: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        positionValue: number;
        position: number;
        readonly count: number;
        readonly dataRelation: StiDataRelation;
        private _dataRelationName;
        dataRelationName: string;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filterEngine;
        filterEngine: StiFilterEngine;
        private _filterMethodHandler;
        filterMethodHandler: Function;
        private _filters;
        filters: StiFiltersCollection;
        filter: string;
        private _filterOn;
        filterOn: boolean;
        static propertyEvenStyle: string;
        evenStyle: string;
        static propertyOddStyle: string;
        oddStyle: string;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        getHeaderText(): string;
        doBookmark(): void;
        invokeGroupRendering(): void;
        private _dataBandInfo;
        readonly dataBandInfo: StiDataBandInfo;
        render(): StiComponent;
        renderMaster(): void;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        private static eventGetCollapsed;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        getCollapsedEvent: StiGetCollapsedEvent;
        private _collapsed;
        collapsed: string;
        private _rightToLeft;
        rightToLeft: boolean;
        getRightToLeft(): boolean;
        setRightToLeft(value: boolean): void;
        getColumnWidth(): number;
        private _columnGaps;
        columnGaps: number;
        private _columnWidth;
        columnWidth: number;
        private _columns;
        columns: number;
        private _minRowsInColumn;
        minRowsInColumn: number;
        private _columnDirection;
        columnDirection: StiColumnDirection;
        private _lineThrough;
        lineThrough: number;
        private _line;
        line: number;
        private _selectedLine;
        selectedLine: number;
        private _resetDataSource;
        resetDataSource: boolean;
        private _calcInvisible;
        calcInvisible: boolean;
        private _countData;
        countData: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEmptyBand extends StiBand implements IStiOddEvenStyles, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getHeaderText(): string;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        evenStyle: string;
        oddStyle: string;
        private static eventBeginRender;
        protected onBeginRender(e: EventArgs): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(e: EventArgs): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(e: EventArgs): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        createNew(): StiComponent;
        private _sizeMode;
        sizeMode: StiEmptySizeMode;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGroupFooterBand extends StiDynamicBand implements IStiKeepGroupFooterTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupFooterBand;
        private _keepGroupFooterTogether;
        keepGroupFooterTogether: boolean;
        private _groupFooterBandInfo;
        readonly groupFooterBandInfo: StiGroupFooterBandInfo;
        readonly line: number;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        readonly priority: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetSummaryExpressionEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetGroupConditionEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGetSummaryExpressionEvent = Stimulsoft.Report.Events.StiGetSummaryExpressionEvent;
    import StiGetGroupConditionEvent = Stimulsoft.Report.Events.StiGetGroupConditionEvent;
    import StiGetCollapsedEvent = Stimulsoft.Report.Events.StiGetCollapsedEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    class StiGroupHeaderBand extends StiDynamicBand implements IStiGroup, IStiPrintOnAllPages, IStiKeepGroupTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiGroupHeaderBand;
        private _keepGroupHeaderTogether;
        keepGroupHeaderTogether: boolean;
        private _keepGroupTogether;
        keepGroupTogether: boolean;
        private _startNewPage;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        private _sortDirection;
        sortDirection: StiGroupSortDirection;
        private _summarySortDirection;
        summarySortDirection: StiGroupSortDirection;
        private _summaryType;
        summaryType: StiGroupSummaryType;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _groupHeaderBandInfo;
        readonly groupHeaderBandInfo: StiGroupHeaderBandInfo;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        protected getComponentType(): StiComponentType;
        readonly priority: number;
        getDataBand(): StiDataBand;
        private _line;
        line: number;
        private static eventGetSummaryExpression;
        protected onGetSummaryExpression(e: StiValueEventArgs): void;
        invokeGetSummaryExpression(e: StiValueEventArgs): void;
        getSummaryExpressionEvent: StiGetSummaryExpressionEvent;
        private static eventGetValue;
        protected onGetValue(e: StiValueEventArgs): void;
        invokeGetValue(e: StiValueEventArgs): void;
        getValueEvent: StiGetGroupConditionEvent;
        private static eventGetCollapsed;
        protected onGetCollapsed(e: StiValueEventArgs): void;
        invokeGetCollapsed(e: StiValueEventArgs): void;
        getCollapsedEvent: StiGetCollapsedEvent;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        private _condition;
        condition: string;
        private _summaryExpression;
        summaryExpression: string;
        private _collapsed;
        collapsed: string;
        getHeaderText(): string;
        createNew(): StiComponent;
        getCurrentConditionValue(): Object;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHierarchicalBand extends StiDataBand implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        private _keyDataColumn;
        keyDataColumn: string;
        private _masterKeyDataColumn;
        masterKeyDataColumn: string;
        private _parentValue;
        parentValue: string;
        private _indent;
        indent: number;
        private _headers;
        headers: string;
        private _footers;
        footers: string;
        private _hierarchicalBandInfo;
        readonly hierarchicalBandInfo: StiHierarchicalBandInfo;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStaticBand extends StiBand implements IStiBreakable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        protected getComponentType(): StiComponentType;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOverlayBand extends StiStaticBand implements IStiVertAlignment, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _vertAlignment;
        vertAlignment: StiVertAlignment;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        protected getComponentType(): StiComponentType;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPageFooterBand extends StiStaticBand implements IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPageHeaderBand extends StiStaticBand implements IStiBreakable, IStiPrintOnEvenOddPages, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        canContainIn(component: StiComponent): boolean;
        protected getComponentType(): StiComponentType;
        private _printOnEvenOddPages;
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
        printOnFirstPage: boolean;
        getMaster(): StiComponent;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportSummaryBand extends StiDynamicBand implements IStiPrintIfEmpty, IStiKeepReportSummaryTogether, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _keepReportSummaryTogether;
        keepReportSummaryTogether: boolean;
        private _printIfEmpty;
        printIfEmpty: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        canContainIn(component: StiComponent): boolean;
        readonly priority: number;
        protected getComponentType(): StiComponentType;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiReportTitleBand extends StiStaticBand implements IStiBreakable, IStiPrintIfEmpty, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _printIfEmpty;
        printIfEmpty: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        protected getComponentType(): StiComponentType;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly priority: number;
        canContainIn(component: StiComponent): boolean;
        createNew(): StiComponent;
        getMaster(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiClone extends StiContainer implements IStiClone {
        private static ImplementsStiClone;
        implements(): string[];
        jsonContainerValueTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        canShrink: boolean;
        canGrow: boolean;
        private _container;
        container: StiContainer;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        readonly toolboxPosition: number;
        readonly toolboxCategory: StiToolboxCategory;
        readonly componentType: StiComponentType;
        canContainIn(component: StiComponent): boolean;
        private _components2;
        components: StiComponentsCollection;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.Components {
    class StiContainerHelper {
        static checkSize(component: StiComponent): void;
        private static componentPlacedOnBand;
        static checkContainerGrowToHeight(component: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiBreakable: string;
    interface IStiBreakable {
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPanel extends StiContainer implements IStiBreakable, IStiJsonReportObject {
        private static ImplementsStiPanel;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _rightToLeft;
        rightToLeft: boolean;
        private _columnGaps;
        columnGaps: number;
        private _columnWidth;
        columnWidth: number;
        private _columns;
        columns: number;
        getColumnWidth(): number;
    }
}
declare module Stimulsoft.Report.Events {
    class StiFillParametersEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetSubReportEventHandler: EventHandler;
    class StiGetSubReportEventArgs extends EventArgs {
        report: StiReport;
        subReportName: string;
        constructor(subReportName: string);
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHyperlinkProcessor {
        static getBytes(report: StiReport, hyperlink: string): number[];
        static getImage(report: StiReport, hyperlink: string): Image;
        static getString(report: StiReport, hyperlink: string): string;
        static getResource(report: StiReport, resourceName: string): StiResource;
        private static getVariable;
        static getServerNameFromHyperlink(hyperlink: string): string;
        static getResourceNameFromHyperlink(hyperlink: string): string;
        static getVariableNameFromHyperlink(hyperlink: string): string;
        static getFileNameFromHyperlink(hyperlink: string): string;
        static isServerHyperlink(hyperlink: string): boolean;
        static isResourceHyperlink(hyperlink: string): boolean;
        static isVariableHyperlink(hyperlink: string): boolean;
        static isFileHyperlink(hyperlink: string): boolean;
        static createResourceName(name: string): string;
        static createVariableName(name: string): string;
        static createFileName(path: string): string;
        static hyperlinkToString(hyperlink: string): string;
        static serverIdent: string;
        static resourceIdent: string;
        static variableIdent: string;
        static fileIdent: string;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFillParametersEventArgs = Stimulsoft.Report.Events.StiFillParametersEventArgs;
    import StiFillParametersEvent = Stimulsoft.Report.Events.StiFillParametersEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSubReport extends StiContainer implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentType: StiComponentType;
        clone(): StiSubReport;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        width: number;
        setClientRectangle(value: RectangleD): void;
        private updateSubReportPageWidth;
        getExternalSubReport(): StiReport;
        protected getSubReportFromUrl(url: string): StiReport;
        protected getSubReportFromFile(url: string): StiReport;
        private static eventFillParameters;
        protected onFillParameters(e: StiFillParametersEventArgs): void;
        invokeFillParameters(sender: StiComponent, e: StiFillParametersEventArgs): void;
        fillParametersEvent: StiFillParametersEvent;
        readonly useExternalReport: boolean;
        private _keepSubReportTogether;
        keepSubReportTogether: boolean;
        subReportPage: StiPage;
        private _subReportPageGuid;
        subReportPageGuid: string;
        private _subReportUrl;
        subReportUrl: string;
        private _parameters;
        parameters: StiParametersCollection;
        static getSubReportForPage(page: StiPage): StiSubReport;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFilter implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiFilter;
        memberwiseClone(): StiFilter;
        private _condition;
        condition: StiFilterCondition;
        private _dataType;
        dataType: StiFilterDataType;
        private _column;
        column: string;
        private _item;
        item: StiFilterItem;
        private valueObj1;
        value1: string;
        private valueObj2;
        value2: string;
        private _expression;
        expression: string;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
declare module Stimulsoft.Report.Components {
    class StiBaseCondition extends StiFilter {
        implements(): string[];
        private _tag;
        tag: Object;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiColorScaleCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        private _scaleType;
        scaleType: StiColorScaleType;
        private _minimumColor;
        minimumColor: Color;
        private _midColor;
        midColor: Color;
        private _maximumColor;
        maximumColor: Color;
        private _minimumType;
        minimumType: StiMinimumType;
        private _minimumValue;
        minimumValue: number;
        private _midType;
        midType: StiMidType;
        private _midValue;
        midValue: number;
        private _maximumType;
        maximumType: StiMaximumType;
        private _maximumValue;
        maximumValue: number;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, scaleType?: StiColorScaleType, minimumColor?: Color, midColor?: Color, maximumColor?: Color, minimumType?: StiMinimumType, minimumValue?: number, midType?: StiMidType, midValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiCondition extends StiBaseCondition implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiCondition;
        memberwiseClone(): StiCondition;
        private _enabled;
        enabled: boolean;
        private _textColor;
        textColor: Color;
        private _backColor;
        backColor: Color;
        private _font;
        font: Font;
        private _canAssignExpression;
        canAssignExpression: boolean;
        private _breakIfTrue;
        breakIfTrue: boolean;
        private _assignExpression;
        assignExpression: string;
        private _style;
        style: string;
        private _borderSides;
        borderSides: StiConditionBorderSides;
        private _permissions;
        permissions: StiConditionPermissions;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        constructor(item?: StiFilterItem, column?: string, condition?: StiFilterCondition, value1?: string, value2?: string, dataType?: StiFilterDataType, expression?: string, textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides, permissions?: StiConditionPermissions);
    }
}
declare module Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConditionHelper extends StiFilter {
        implements(): string[];
        static apply(comp: Object, styleName: string): void;
        private static applyParentStyle;
        static applyFont(component: Object, font: Font, perms: StiConditionPermissions): void;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarCondition extends StiBaseCondition implements IStiDataBarIndicator, IStiIndicatorCondition, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        createIndicator(component: StiText): StiIndicator;
        reset(): void;
        private _brushType;
        brushType: StiBrushType;
        private _positiveColor;
        positiveColor: Color;
        private _negativeColor;
        negativeColor: Color;
        private _positiveBorderColor;
        positiveBorderColor: Color;
        private _negativeBorderColor;
        negativeBorderColor: Color;
        private _showBorder;
        showBorder: boolean;
        private _direction;
        direction: StiDataBarDirection;
        private _minimumType;
        minimumType: StiMinimumType;
        private _minimumValue;
        minimumValue: number;
        private _maximumType;
        maximumType: StiMaximumType;
        private _maximumValue;
        maximumValue: number;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, minimumType?: StiMinimumType, minimumValue?: number, maximumType?: StiMaximumType, maximumValue?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetCondition extends StiBaseCondition implements IStiIndicatorCondition, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        createIndicator(component: StiText): StiIndicator;
        private inRange;
        reset(): void;
        private _iconSet;
        iconSet: StiIconSet;
        private _contentAlignment;
        contentAlignment: ContentAlignment;
        private _iconSetItem1;
        iconSetItem1: StiIconSetItem;
        private _iconSetItem2;
        iconSetItem2: StiIconSetItem;
        private _iconSetItem3;
        iconSetItem3: StiIconSetItem;
        private _iconSetItem4;
        iconSetItem4: StiIconSetItem;
        private _iconSetItem5;
        iconSetItem5: StiIconSetItem;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        private minimum;
        private maximum;
        constructor(column?: string, iconSet?: StiIconSet, contentAlignment?: ContentAlignment, item1?: StiIconSetItem, item2?: StiIconSetItem, item3?: StiIconSetItem, item4?: StiIconSetItem, item5?: StiIconSetItem);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetItem implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _icon;
        icon: StiIcon;
        private _operation;
        operation: StiIconSetOperation;
        private _valueType;
        valueType: StiIconSetValueType;
        private _value;
        value: number;
        constructor(icon?: StiIcon, operation?: StiIconSetOperation, valueType?: StiIconSetValueType, value?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiMultiCondition extends StiCondition implements IStiFilter, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadfromXmlDoc(xmlDoc: XmlNode): void;
        clone(): StiMultiCondition;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: StiFiltersCollection;
        filterMethodHandler: Function;
        readonly filterOn: boolean;
        condition: StiFilterCondition;
        dataType: StiFilterDataType;
        column: string;
        item: StiFilterItem;
        value1: string;
        value2: string;
        expression: string;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        constructor(textColor?: Color, backColor?: Color, font?: Font, enabled?: boolean, filterMode?: StiFilterMode, filters?: StiFilter[], canAssignExpression?: boolean, assignExpression?: string, style?: string, borderSides?: StiConditionBorderSides);
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiMultiConditionContainer {
        private _filters;
        filters: StiFiltersCollection;
        private _filterMode;
        filterMode: StiFilterMode;
        private _enabled;
        enabled: boolean;
        private _textColor;
        textColor: Color;
        private _backColor;
        backColor: Color;
        private _font;
        font: Font;
        private _canAssignExpression;
        canAssignExpression: boolean;
        private _assignExpression;
        assignExpression: string;
        private _style;
        style: string;
        private _borderSides;
        borderSides: StiConditionBorderSides;
        private _permissions;
        permissions: StiConditionPermissions;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossDataBand extends StiDataBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        restoreState(stateName: string): void;
        keepHeaderTogether: boolean;
        keepFooterTogether: boolean;
        keepChildTogether: boolean;
        keepGroupTogether: boolean;
        printAtBottom: boolean;
        printOnAllPages: boolean;
        setColumnModeToParent(): void;
        getColumnModeFromParent(): void;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        isRightToLeft: boolean;
        getDockStyle(): StiDockStyle;
        minWidth: number;
        maxWidth: number;
        defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        columnCurrent: number;
        readonly headerSize: number;
        createNew(): StiComponent;
        private _columnMode;
        columnMode: boolean;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossFooterBand extends StiFooterBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        printAtBottom: boolean;
        printOnAllPages: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossGroupFooterBand extends StiGroupFooterBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly сomponentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        printAtBottom: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossGroupHeaderBand extends StiGroupHeaderBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        printOnAllPages: boolean;
        printAtBottom: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossHeaderBand extends StiHeaderBand implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        growToHeight: boolean;
        resetPageNumber: boolean;
        startNewPage: boolean;
        startNewPageIfLessThan: number;
        printAtBottom: boolean;
        printOnAllPages: boolean;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly isCross: boolean;
        getDockStyle(): StiDockStyle;
        setDockStyle(value: StiDockStyle): void;
        minWidth: number;
        maxWidth: number;
        defaultClientRectangle: RectangleD;
        selectRectangle: RectangleD;
        displayRectangle: RectangleD;
        readonly headerSize: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiIndicator implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiIndicator;
        static loadFromXml(text: string): StiIndicator;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    class StiDataBarIndicator extends StiIndicator implements IStiDataBarIndicator, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _brushType;
        brushType: StiBrushType;
        private _positiveColor;
        positiveColor: Color;
        private _negativeColor;
        negativeColor: Color;
        private _positiveBorderColor;
        positiveBorderColor: Color;
        private _negativeBorderColor;
        negativeBorderColor: Color;
        private _showBorder;
        showBorder: boolean;
        private _value;
        value: number;
        private _minimum;
        minimum: number;
        private _maximum;
        maximum: number;
        private _direction;
        direction: StiDataBarDirection;
        constructor(brushType?: StiBrushType, positiveColor?: Color, negativeColor?: Color, showBorder?: boolean, positiveBorderColor?: Color, negativeBorderColor?: Color, direction?: StiDataBarDirection, value?: number, minimum?: number, maximum?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import StiIcon = Stimulsoft.Report.Components.StiIcon;
    class StiIconSetHelper {
        static getIconSet(iconSet: StiIconSet): StiIcon[];
        static getIcons(iconSet: StiIconSet): string[];
        static getIcon(icon: StiIcon): string;
        private static getIcon2;
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiIconSetIndicator extends StiIndicator implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _icon;
        icon: StiIcon;
        private _alignment;
        alignment: ContentAlignment;
        constructor(icon?: StiIcon, alignment?: ContentAlignment);
    }
}
declare module Stimulsoft.Report.Components {
    var IStiAnchor: string;
    interface IStiAnchor {
        anchor: StiAnchorMode;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiAutoWidth: string;
    interface IStiAutoWidth {
        autoWidth: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiBorderColor: string;
    interface IStiBorderColor {
        borderColor: Color;
    }
}
declare module Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiBrush: string;
    interface IStiBrush {
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Components {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    var IStiBusinessObject: string;
    interface IStiBusinessObject {
        businessObject: StiBusinessObject;
        businessObjectGuid: string;
        isBusinessObjectEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCanGrow: string;
    interface IStiCanGrow {
        canGrow: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCanShrink: string;
    interface IStiCanShrink {
        canShrink: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiClone: string;
    interface IStiClone {
        container: StiContainer;
    }
}
declare module Stimulsoft.Report.Components {
    import ICloneable = Stimulsoft.System.ICloneable;
    var IStiComponent: string;
    interface IStiComponent extends ICloneable, IStiGrowToHeight, IStiPrintOn, IStiName {
        report: StiReport;
        parent: StiContainer;
        growToHeight: boolean;
        printOn: StiPrintOnType;
        printable: boolean;
        enabled: boolean;
        dockStyle: StiDockStyle;
        name: string;
        isDesigning: boolean;
        guid: string;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiComponentGuid: string;
    interface IStiComponentGuid {
        guid: string;
        newGuid(): any;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiComponentsOwnerRenderer: string;
    interface IStiComponentsOwnerRenderer {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiConditions: string;
    interface IStiConditions {
        conditions: StiConditionsCollection;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCrossTab: string;
    interface IStiCrossTab {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiCrossTabField: string;
    interface IStiCrossTabField {
    }
}
declare module Stimulsoft.Report.Components {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrushType = Stimulsoft.Report.Components.StiBrushType;
    var IStiDataBarIndicator: string;
    interface IStiDataBarIndicator {
        brushType: StiBrushType;
        positiveColor: Color;
        negativeColor: Color;
        positiveBorderColor: Color;
        negativeBorderColor: Color;
        showBorder: boolean;
        direction: StiDataBarDirection;
    }
}
declare module Stimulsoft.Report.Components {
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    var IStiDataRelation: string;
    interface IStiDataRelation {
        dataRelation: StiDataRelation;
        dataRelationName: string;
    }
}
declare module Stimulsoft.Report.Components {
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    var IStiDataSource: string;
    interface IStiDataSource {
        dataSource: StiDataSource;
        dataSourceName: string;
        isDataSourceEmpty: boolean;
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiEditable: string;
    interface IStiEditable {
        editable: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiFilter: string;
    interface IStiFilter {
        filterMethodHandler: Function;
        filterMode: StiFilterMode;
        filters: StiFiltersCollection;
        filterOn: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    var IStiFont: string;
    var ImplementsIStiFont: any[];
    interface IStiFont {
        font: Font;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiGroup: string;
    interface IStiGroup {
        sortDirection: StiGroupSortDirection;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiGrowToHeight: string;
    interface IStiGrowToHeight {
        growToHeight: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiIgnoreBorderWhenExport: string;
    interface IStiIgnoreBorderWhenExport {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiIndicatorCondition: string;
    interface IStiIndicatorCondition {
        createIndicator(component: StiText): StiIndicator;
        reset(): any;
    }
}
declare module Stimulsoft.Report.Components {
    interface IStiInteractionClass {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepChildTogether: string;
    interface IStiKeepChildTogether {
        keepChildTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepDetailsTogether: string;
    interface IStiKeepDetailsTogether {
        keepDetailsTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepFooterTogether: string;
    interface IStiKeepFooterTogether {
        keepFooterTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepGroupFooterTogether: string;
    interface IStiKeepGroupFooterTogether {
        keepGroupFooterTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepGroupTogether: string;
    interface IStiKeepGroupTogether {
        keepGroupTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepHeaderTogether: string;
    interface IStiKeepHeaderTogether {
        keepHeaderTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiKeepReportSummaryTogether: string;
    interface IStiKeepReportSummaryTogether {
        keepReportSummaryTogether: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiMasterComponent: string;
    interface IStiMasterComponent {
        masterComponent: StiComponent;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiOddEvenStyles: string;
    interface IStiOddEvenStyles {
        evenStyle: string;
        oddStyle: string;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPageBreak: string;
    interface IStiPageBreak {
        newColumnBefore: boolean;
        newColumnAfter: boolean;
        newPageBefore: boolean;
        newPageAfter: boolean;
        breakIfLessThan: number;
        skipFirst: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintAtBottom: string;
    interface IStiPrintAtBottom {
        printAtBottom: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintIfDetailEmpty: string;
    interface IStiPrintIfDetailEmpty {
        printIfDetailEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintIfEmpty: string;
    interface IStiPrintIfEmpty {
        printIfEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintOn: string;
    interface IStiPrintOn {
        printOn: StiPrintOnType;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintOnAllPages: string;
    interface IStiPrintOnAllPages {
        printOnAllPages: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiPrintOnEvenOddPages: string;
    interface IStiPrintOnEvenOddPages {
        printOnEvenOddPages: StiPrintOnEvenOddPagesType;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiRenderMaster: string;
    interface IStiRenderMaster {
        renderMaster(): any;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiResetPageNumber: string;
    interface IStiResetPageNumber {
        resetPageNumber: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    interface IStiSeriesParent {
        parent: StiComponent;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiShape: string;
    interface IStiShape {
    }
}
declare module Stimulsoft.Report.Components {
    var IStiShift: string;
    interface IStiShift {
        shift: boolean;
        shiftMode: StiShiftMode;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    var IStiSimpleBorder: string;
    /**
     *  Interface describes a frame of an element.
     */
    interface IStiSimpleBorder {
        /**
         *  Gets or sets frame of the element.
         */
        border2: StiSimpleBorder;
    }
}
declare module Stimulsoft.Report.Components {
    var IStiSort: string;
    interface IStiSort {
        sort: Array<string>;
    }
}
declare module Stimulsoft.Report.Components {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    var IStiText: string;
    interface IStiText {
        text: string;
        textValue: string;
        setText(getValue: Object): any;
        linesOfUnderline: StiPenStyle;
        hideZeros: boolean;
        processingDuplicates: StiProcessingDuplicatesType;
        onlyText: boolean;
        maxNumberOfLines: number;
        getTextInternal(): string;
        setTextInternal(value: string): any;
    }
}
declare module Stimulsoft.Report.Components {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiTextBrush: string;
    interface IStiTextBrush {
        textBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    var IStiTextFont: string;
    interface IStiTextFont {
        getFont(): Font;
        setFontName(fontName: string): any;
        setFontSize(fontSize: number): any;
        growFontSize(): any;
        shrinkFontSize(): any;
        setFontBoldStyle(isBold: boolean): any;
        setFontItalicStyle(isItalic: boolean): any;
        setFontUnderlineStyle(isUnderline: boolean): any;
    }
}
declare namespace Stimulsoft.Report.Components {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    var IStiTextFormat: string;
    var ImplementsIStiTextFormat: any[];
    /**
     * Desribes formatting of the text.
     */
    interface IStiTextFormat {
        /**
         * Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
    }
}
declare module Stimulsoft.Report.Components {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    var IStiTextHorAlignment: string;
    var ImplementsIStiTextHorAlignment: any[];
    interface IStiTextHorAlignment {
        horAlignment: StiTextHorAlignment;
    }
}
declare module Stimulsoft.Report.Components {
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    var IStiTextOptions: string;
    interface IStiTextOptions {
        textOptions: StiTextOptions;
    }
}
declare module Stimulsoft.Report.Components {
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    var IStiUnitConvert: string;
    interface IStiUnitConvert {
        convert(oldUnit: StiUnit, newUnit: StiUnit): any;
    }
}
declare module Stimulsoft.Report.Components {
    enum StiShapeDirection {
        Up = 0,
        Down = 1,
        Left = 2,
        Right = 3
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiShapeTypeService extends StiService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): StiShapeTypeService;
        static createFromJsonObject(jObject: StiJson): StiShapeTypeService;
        loadFromXml(xmlNode: XmlNode): void;
        static convertFromXml(xmlNode: XmlNode): StiShapeTypeService;
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        private _arrowWidth;
        arrowWidth: number;
        private _arrowHeight;
        arrowHeight: number;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection, arrowWidth?: number, arrowHeight?: number);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiBentArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiChevronShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiComplexArrowShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiDiagonalDownLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiDiagonalUpLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiDivisionShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiEqualShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartCardShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartCollateShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartDecisionShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartManualInputShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartOffPageConnectorShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiFlowchartPreparationShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiFlowchartSortShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFrameShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiHorizontalLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiLeftAndRightLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiMinusShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiMultiplyShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiOctagonShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _autoSize;
        autoSize: boolean;
        private _bevel;
        bevel: number;
        createNew(): StiShapeTypeService;
        constructor(autoSize?: boolean, bevel?: number);
    }
}
declare module Stimulsoft.Report.Components {
    class StiOvalShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiParallelogramShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiPlusShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiRectangleShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiRegularPentagonShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRoundedRectangleShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _round;
        round: number;
        createNew(): StiShapeTypeService;
        constructor(round?: number);
    }
}
declare module Stimulsoft.Report.Components {
    class StiSnipDiagonalSideCornerRectangleShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiSnipSameSideCornerRectangleShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiTopAndBottomLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    class StiTrapezoidShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTriangleShapeType extends StiShapeTypeService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): Object;
        private _direction;
        direction: StiShapeDirection;
        createNew(): StiShapeTypeService;
        constructor(direction?: StiShapeDirection);
    }
}
declare module Stimulsoft.Report.Components {
    class StiVerticalLineShapeType extends StiShapeTypeService {
        readonly componentId: StiComponentId;
        createNew(): StiShapeTypeService;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetExcelValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetCheckedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetExcelValueEventHandler: EventHandler;
    class StiGetExcelValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import StiGetExcelValueEvent = Stimulsoft.Report.Events.StiGetExcelValueEvent;
    import StiGetCheckedEvent = Stimulsoft.Report.Events.StiGetCheckedEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    class StiCheckBox extends StiComponent implements IStiBorder, IStiTextBrush, IStiBrush, IStiBreakable, IStiEditable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _brush;
        brush: StiBrush;
        private _border;
        border: StiBorder;
        private _textBrush;
        textBrush: StiBrush;
        private _editable;
        editable: boolean;
        clone(cloneProperties: boolean): StiCheckBox;
        private _canBreak;
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        invokeEvents(): void;
        private static eventGetChecked;
        protected onGetChecked(e: StiValueEventArgs): void;
        invokeGetChecked(sender: StiComponent, e: StiValueEventArgs): void;
        getCheckedEvent: StiGetCheckedEvent;
        private static eventGetExcelValue;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        getExcelValueEvent: StiGetExcelValueEvent;
        private _checkedValue;
        checkedValue: Object;
        private _contourColor;
        contourColor: Color;
        private _size;
        size: number;
        private _checkStyle;
        checkStyle: StiCheckStyle;
        private _values;
        values: string;
        private _checkStyleForTrue;
        checkStyleForTrue: StiCheckStyle;
        private _checkStyleForFalse;
        checkStyleForFalse: StiCheckStyle;
        private _checked;
        checked: string;
        private _excelDataValue;
        excelDataValue: string;
        private _excelValue;
        excelValue: string;
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiFormatService extends StiService implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static createFromJsonObject(jObject: StiJson): StiFormatService;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFormatFromXml(xmlNode: XmlNode, report?: StiReport): StiFormatService;
        static loadFromJsonObjectInternal(jObject: StiJson): StiFormatService;
        readonly position: Number;
        readonly sample: Object;
        readonly nativeFormatString: string;
        readonly isFormatStringFromVariable: boolean;
        private _stringFormat;
        stringFormat: string;
        format(arg: any): string;
        format2(format: string, arg: any): string;
        createNew(): StiFormatService;
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    class StiCustomFormatService extends StiFormatService {
        readonly sample: Object;
        createNew(): StiFormatService;
        constructor(stringFormat?: string);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiTimeFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly sample: Object;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        createNew(): StiFormatService;
        constructor(stringFormat?: string);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDateFormatService extends StiFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly sample: Object;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        private static formatQuarter;
        private _nullDisplay;
        nullDisplay: string;
        createNew(): StiFormatService;
        constructor(stringFormat?: string, nullDisplay?: string);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    import StiTextFormatState = Stimulsoft.Report.Components.StiTextFormatState;
    class StiNumberFormatService extends StiFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private bits;
        nullDisplay: string;
        negativePattern: number;
        decimalSeparator: string;
        decimalDigits: number;
        groupSeparator: string;
        groupSize: number;
        useGroupSeparator: boolean;
        useLocalSetting: boolean;
        readonly sample: Object;
        readonly nativeFormatString: string;
        stiEquals(obj: Object): boolean;
        state: StiTextFormatState;
        fillLocalSetting(format: NumberFormatInfo): void;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: Object): string;
        createNew(): StiFormatService;
        constructor(negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    class StiCurrencyFormatService extends StiNumberFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _positivePattern;
        positivePattern: number;
        private _symbol;
        symbol: string;
        readonly nativeFormatString: string;
        readonly sample: Object;
        stiEquals(obj: Object): boolean;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        private formatAsCurrency;
        private getCurrencySymbol;
        private getPositivePattern;
        private getNegativePattern;
        formatStr(format: NumberFormatInfo, arg: Object): string;
        createNew(): StiFormatService;
        constructor(positivePattern?: number, negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, symbol?: string, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import NumberFormatInfo = Stimulsoft.System.Globalization.NumberFormatInfo;
    class StiPercentageFormatService extends StiCurrencyFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        formatStr(format: NumberFormatInfo, arg: Object): string;
        createNew(): StiFormatService;
        constructor(positivePattern?: number, negativePattern?: number, decimalPlaces?: number, decimalSeparator?: string, decimalDigits?: number, groupSeparator?: string, groupSize?: number, symbol?: string, useGroupSeparator?: boolean, useLocalSetting?: boolean, nullDisplay?: string, state?: StiTextFormatState);
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiGeneralFormatService extends StiFormatService {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly sample: string;
        stiEquals(obj: Object): boolean;
        static default: StiGeneralFormatService;
        createNew(): StiFormatService;
        constructor();
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetValueEventHandler: EventHandler;
    class StiGetValueEventArgs extends EventArgs {
        value: string;
        storeToPrinted: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiSimpleText extends StiComponent implements IStiText, IStiEditable, IStiJsonReportObject {
        private static ImplementsStiSimpleText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected static propertyGlobalizedName: string;
        globalizedName: string;
        clone(cloneProperties: boolean): StiSimpleText;
        memberwiseClone(): StiSimpleText;
        getTextWithoutZero(text: string): string;
        setText(getValue?: Object, value?: string): void;
        private setTextTo;
        private _linesOfUnderline;
        linesOfUnderline: StiPenStyle;
        linesOfUnderlining: boolean;
        private _hideZeros;
        hideZeros: boolean;
        mergeDuplicates: boolean;
        private static propertyProcessingDuplicates;
        processingDuplicates: StiProcessingDuplicatesType;
        private static propertyMaxNumberOfLines;
        maxNumberOfLines: number;
        processText(text: string): string;
        private static propertyOnlyText;
        onlyText: boolean;
        private _editable;
        editable: boolean;
        processAtEnd: boolean;
        protected static propertyProcessAt: string;
        processAt: StiProcessAt;
        invokeRenderTo(textBox: StiSimpleText): void;
        private _text;
        text: string;
        getTextInternal(): string;
        setTextInternal(value: string): void;
        private _textValue;
        textValue: string;
        private static eventGetValue;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        checkDuplicates(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueEvent: StiGetValueEvent;
        private static eventTextProcess;
        protected onTextProcess(e: StiValueEventArgs): void;
        invokeTextProcess(sender: StiComponent, e: StiValueEventArgs): void;
        private applyConditionsAssignExpression;
        _totalValueHelp: string;
        totalValueHelp: string;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGetExcelValueEvent = Stimulsoft.Report.Events.StiGetExcelValueEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGetExcelValueEventArgs = Stimulsoft.Report.Events.StiGetExcelValueEventArgs;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiText extends StiSimpleText implements IStiTextOptions, IStiAutoWidth, IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiTextFormat, IStiBreakable, IStiGlobalizationProvider, IStiEditable, IStiJsonReportObject {
        private static ImplementsStiText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        parseTextFromXml(xmlNode: XmlNode): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private _indicator;
        indicator: StiIndicator;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private static propertyCanBreak;
        canBreak: boolean;
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private static propertyAutoWidth;
        autoWidth: boolean;
        protected static propertyRenderTo: string;
        renderTo: string;
        invokeRenderTo(textFrom: StiSimpleText): void;
        private getVisibleTextForRenderTo;
        private _horAlignment;
        horAlignment: StiTextHorAlignment;
        private _vertAlignment;
        vertAlignment: StiVertAlignment;
        private _font;
        font: Font;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        private _textBrush;
        textBrush: StiBrush;
        private _textFormat;
        textFormat: StiFormatService;
        private _format;
        format: string;
        private _textOptions;
        textOptions: StiTextOptions;
        clone(cloneProperties: boolean): StiText;
        memberwiseClone(): StiText;
        convertTextMargins(rect: RectangleD, convert: boolean): RectangleD;
        convertTextBorders(rect: RectangleD, convert: boolean): RectangleD;
        getTextForPaint(): string;
        getActualSize(): SizeD;
        prepare(): void;
        private _excelDataValue;
        excelDataValue: string;
        excelValue: string;
        invokeEvents(): void;
        private static eventGetExcelValue;
        protected onGetExcelValue(e: StiGetExcelValueEventArgs): void;
        invokeGetExcelValue(sender: StiComponent, e: StiGetExcelValueEventArgs): void;
        getExcelValueEvent: StiGetExcelValueEvent;
        protected static propertyNullValue: string;
        nullValue: string;
        protected static propertyType: string;
        type: StiSystemTextType;
        wordWrap: boolean;
        rightToLeft: boolean;
        trimming: StringTrimming;
        angle: number;
        private static propertyLineSpacing;
        lineSpacing: number;
        private static propertyExportAsImage;
        exportAsImage: boolean;
        private static propertyTextQuality;
        textQuality: StiTextQuality;
        private static propertyAllowHtmlTags;
        allowHtmlTags: boolean;
        private static propertyMargins;
        margins: StiMargins;
        private static propertyShrinkFontToFit;
        shrinkFontToFit: boolean;
        private static propertyShrinkFontToFitMinimumSize;
        shrinkFontToFitMinimumSize: number;
        createNew(): StiComponent;
        checkAllowHtmlTags(): boolean;
        getActualFont(text: string, minFontSize?: number): Font;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD): void;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiContourText extends StiText implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _contourColor;
        contourColor: Color;
        private _size;
        size: number;
        constructor(rect?: RectangleD, text?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPrimitive extends StiComponent {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        canShrink: boolean;
        canGrow: boolean;
        shift: boolean;
        useParentStyles: boolean;
        dockStyle: StiDockStyle;
        growToHeight: boolean;
        readonly localizedCategory: string;
        readonly componentType: StiComponentType;
        readonly priority: number;
        clientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        setDisplayRectangle(value: RectangleD): void;
        setDirectDisplayRectangle(rect: RectangleD): void;
        constructor(rect?: RectangleD, isSuper?: boolean);
        protected construct(rect?: RectangleD | any): void;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLinePrimitive extends StiPrimitive implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly invalidateOnMouseOver: boolean;
        defaultClientRectangle: RectangleD;
        private _style;
        style: StiPenStyle;
        private _color;
        color: Color;
        private _size;
        size: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossLinePrimitive extends StiLinePrimitive {
        static nullGuid: string;
        onRemoveComponent(): void;
        canContainIn(component: StiComponent): boolean;
        linked: boolean;
        left: number;
        top: number;
        height: number;
        storedStartPoint: StiStartPointPrimitive;
        getStartPoint(cont?: StiContainer): StiStartPointPrimitive;
        storedEndPoint: StiEndPointPrimitive;
        getEndPoint(cont?: StiContainer): StiEndPointPrimitive;
        isParentContainerSelected(point: StiPointPrimitive): boolean;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPointPrimitive extends StiPrimitive implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        isSelected: boolean;
        private _referenceToGuid;
        referenceToGuid: string;
        width: number;
        height: number;
        storedColumn: number;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiEndPointPrimitive extends StiPointPrimitive {
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorizontalLinePrimitive extends StiLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): Object;
        private _border;
        border: StiBorder;
        private _startCap;
        startCap: StiCap;
        private _endCap;
        endCap: StiCap;
        height: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Image = Stimulsoft.System.Drawing.Image;
    var StiGetImageDataEventHandler: EventHandler;
    class StiGetImageDataEventArgs extends EventArgs {
        value: Image;
        constructor(image?: Image);
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiExpressionHelper {
        static parseText(page: StiPage, text: string): string;
        static parseBool(page: StiPage, text: string): boolean;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetImageDataEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetImageURLEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageHelper {
        static getImageFromObject(imageObject: Object): Image;
        private static getImageName;
        static isXml(data: number[]): boolean;
        static isSvg(data: number[]): boolean;
        static isIcon(data: number[]): boolean;
        static isWmf(data: number[]): boolean;
        static isEmf(data: number[]): boolean;
        static isBmp(data: number[]): boolean;
        static isJpeg(data: number[]): boolean;
        static isGif(data: number[]): boolean;
        static isPng(data: number[]): boolean;
        static isTiff(data: number[]): boolean;
        static isImage(data: any): boolean;
        static isImage2(data: number[]): boolean;
        static isImage3(str: string): boolean;
    }
}
declare module Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiFileImageCache {
        private static imageCache;
        static createNewCache(): string;
        static getImageCacheName(cache: string, cacheImageGuid: string): string;
        static saveImage(image: Image, path: string): void;
        static loadImage(path: string): Image;
        static exist(cacheGuid: string): boolean;
        static clear(): void;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiView extends StiComponent implements IStiHorAlignment, IStiVertAlignment, IStiBorder, IStiExportImage, IStiExportImageExtended, IStiBrush, IStiJsonReportObject {
        private static ImplementsStiView;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): StiView;
        private _horAlignment;
        /** Gets or sets the horizontal alignment of an object. */
        horAlignment: StiHorAlignment;
        private _vertAlignment;
        /** Gets or sets the vertical alignment of an object. */
        vertAlignment: StiVertAlignment;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        /** Gets or sets border of the component. */
        border: StiBorder;
        private _brush;
        /** Gets or sets a brush to fill a component. */
        brush: StiBrush;
        getActualSize(): SizeD;
        getRealSize(): SizeD;
        setPage(value: StiPage): void;
        private _smoothing;
        /** Gets or sets smoothing mode for drawing image. */
        smoothing: boolean;
        private _isCachedImage;
        isCachedImage: boolean;
        private _objectToDraw;
        /** Gets or sets the WPF visual object that appeared as a result of the component rendering. This property accepts objects of two types: DrawingVisual and ImageSource. */
        objectToDraw: Object;
        private _imageToDraw;
        /** Gets or sets the image that appeared as a result of the component rendering. */
        imageToDraw: Image;
        private _stretch;
        /** Gets or sets value, indicates that this component will stretch the image till the image will get size equal in its size on the page. */
        stretch: boolean;
        private _multipleFactor;
        /** Gets or sets value to multiply by it an image size. */
        multipleFactor: number;
        private _aspectRatio;
        /** Gets or sets value, indicates that the image will save its aspect ratio. */
        aspectRatio: boolean;
        getImageFromSource(): Image;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetImageDataEventArgs = Stimulsoft.Report.Events.StiGetImageDataEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiGetImageDataEvent = Stimulsoft.Report.Events.StiGetImageDataEvent;
    import StiGetImageURLEvent = Stimulsoft.Report.Events.StiGetImageURLEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiBreakable = Stimulsoft.Report.Components.IStiBreakable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiImage extends StiView implements IStiBreakable, IStiJsonReportObject {
        private static ImplementsStiImage;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        protected getImageFromFile(): Image;
        protected getImageFromUrl(): Image;
        /** Returns the image from specified data column. */
        protected getImageFromDataColumn(): Image;
        /** Returns the image being get as a result of rendering. */
        getImageFromSource(): Image;
        private static propertyCanBreak;
        /** Gets or sets value which indicates whether the component can or cannot break its contents on several pages. */
        canBreak: boolean;
        /** Divides content of components in two parts.Returns result of dividing.If true, then component is successful divided. */
        break(dividedComponent: StiComponent, devideFactor: number, REFdivideLine: any): boolean;
        private _imageURLValue;
        imageURLValue: Object;
        invokeEvents(): void;
        private static eventGetImageURL;
        protected onGetImageURL(e: StiValueEventArgs): void;
        invokeGetImageURL(sender: Object, e: StiValueEventArgs): void;
        getImageURLEvent: StiGetImageURLEvent;
        private static eventGetImageData;
        protected onGetImageData(e: StiGetImageDataEventArgs): void;
        invokeGetImageData(sender: Object, e: StiGetImageDataEventArgs): void;
        defaultClientRectangle: RectangleD;
        getImageDataEvent: StiGetImageDataEvent;
        private static propertyProcessingDuplicates;
        /** Gets or sets value which indicates how report engine processes duplicated images. */
        processingDuplicates: StiImageProcessingDuplicatesType;
        private _imageRotation;
        /** Gets or sets value which indicates how to rotate an image before output. */
        imageRotation: StiImageRotation;
        private _image;
        /** Gets or sets the image. */
        image: Image;
        private static propertyMargins;
        /** Gets or sets image margins. */
        margins: StiMargins;
        private _file;
        /** Gets or sets the path to the file that contains the image. */
        file: string;
        private _dataColumn;
        /** Gets or sets a name of the column that contains the image. */
        dataColumn: string;
        private _imageURL;
        imageURL: string;
        private _imageData;
        imageData: string;
        convertImageMargins(rect: RectangleD, convert: boolean): RectangleD;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRectanglePrimitive extends StiCrossLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _border;
        border: StiBorder;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        width: number;
        private _topSide;
        topSide: boolean;
        private _leftSide;
        leftSide: boolean;
        private _bottomSide;
        bottomSide: boolean;
        private _rightSide;
        rightSide: boolean;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetDataUrlEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetDataUrlEventArgs = Stimulsoft.Report.Events.StiGetDataUrlEventArgs;
    import StiGetDataUrlEvent = Stimulsoft.Report.Events.StiGetDataUrlEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiEditable = Stimulsoft.Report.Components.IStiEditable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiRichText extends StiSimpleText implements IStiEditable, IStiBorder, IStiGlobalizationProvider, IStiBackColor, IStiJsonReportObject {
        private static implementsStiRichText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        protected static propertyCanBreak: string;
        canBreak: boolean;
        clone(cloneProperties: boolean): StiRichText;
        private static eventGetDataUrl;
        protected onGetDataUrl(e: StiGetDataUrlEventArgs): void;
        invokeGetDataUrl(sender: StiComponent, e: StiGetDataUrlEventArgs): void;
        getDataUrlEvent: StiGetDataUrlEvent;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        private _border;
        border: StiBorder;
        private _margins;
        margins: StiMargins;
        private _defaultFont;
        defaultFont: Font;
        private _defaultColor;
        defaultColor: Color;
        private _wordWrap;
        wordWrap: boolean;
        private _detectUrls;
        detectUrls: boolean;
        private _backColor;
        backColor: Color;
        private _dataColumn;
        dataColumn: string;
        private _wysiwyg;
        wysiwyg: boolean;
        private _rightToLeft;
        rightToLeft: boolean;
        private _dataUrl;
        dataUrl: string;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRoundedRectanglePrimitive extends StiRectanglePrimitive implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        private _round;
        round: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import IStiBorderColor = Stimulsoft.Report.Components.IStiBorderColor;
    import IStiShape = Stimulsoft.Report.Components.IStiShape;
    class StiShape extends StiComponent implements IStiBrush, IStiBorderColor, IStiExportImageExtended, IStiExportImage, IStiShape, IStiJsonReportObject {
        private _implementsStiShape;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): StiShape;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        defaultClientRectangle: RectangleD;
        private _style;
        style: StiPenStyle;
        private _size;
        size: number;
        private _shapeType;
        shapeType: StiShapeTypeService;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStartPointPrimitive extends StiPointPrimitive {
        readonly componentId: StiComponentId;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiTextInCells extends StiText {
        private static ImplementsTextInCells;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        protected static propertyCellWidth: string;
        cellWidth: number;
        protected static propertyCellHeight: string;
        cellHeight: number;
        protected static propertyHorSpacing: string;
        horSpacing: number;
        protected static propertyVertSpacing: string;
        vertSpacing: number;
        wordWrap: boolean;
        rightToLeft: boolean;
        protected static propertyContinuousText: string;
        continuousText: boolean;
        getActualSize(): SizeD;
        static splitByCells(masterTextInCells: StiTextInCells, renderedComponent: StiComponent, textString: string): StiContainer;
        static splitByCells2(masterTextInCells: StiTextInCells, renderedComponent: StiComponent, textString: string, measure: boolean): StiContainer;
        static replaceContainerWithContentCells(comp: StiComponent, cont: StiContainer): void;
        createNew(): StiComponent;
        constructor(rect?: RectangleD, text?: string);
    }
}
declare module Stimulsoft.Report.Components {
    class StiTextInCellsHelper {
        static trimEndWhiteSpace(inputString: string): string;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiCap = Stimulsoft.Base.Drawing.StiCap;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVerticalLinePrimitive extends StiCrossLinePrimitive implements IStiBorder, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties: boolean): Object;
        private _border;
        border: StiBorder;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _startCap;
        startCap: StiCap;
        private _endCap;
        endCap: StiCap;
        width: number;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components.Table {
    enum StiTableStyle {
        StyleNone = 0,
        Style11 = 11,
        Style12 = 12,
        Style13 = 13,
        Style14 = 14,
        Style15 = 15,
        Style16 = 16,
        Style17 = 17,
        Style18 = 18,
        Style19 = 19,
        Style31 = 31,
        Style32 = 32,
        Style33 = 33,
        Style34 = 34,
        Style35 = 35,
        Style36 = 36,
        Style37 = 37,
        Style38 = 38,
        Style39 = 39,
        Style41 = 41,
        Style42 = 42,
        Style43 = 43,
        Style44 = 44,
        Style45 = 45,
        Style46 = 46,
        Style47 = 47,
        Style48 = 48,
        Style49 = 49,
        Style51 = 51,
        Style52 = 52,
        Style53 = 53,
        Style54 = 54,
        Style55 = 55,
        Style56 = 56,
        Style57 = 57,
        Style58 = 58,
        Style59 = 59
    }
    enum StiTablceCellType {
        Text = 0,
        Image = 1,
        CheckBox = 2,
        RichText = 3
    }
    enum StiTableAutoWidth {
        None = 0,
        Page = 1,
        Table = 2
    }
    enum StiTableAutoWidthType {
        None = 0,
        LastColumns = 1,
        FullTable = 2
    }
}
declare module Stimulsoft.Report.Components.Table {
    var IStiTableCell: string;
    interface IStiTableCell {
        joinCells: number[];
        parentJoin: number;
        join: boolean;
        id: number;
        joinWidth: number;
        joinHeight: number;
        merged: boolean;
        changeTopPosition: boolean;
        changeLeftPosition: boolean;
        changeRightPosition: boolean;
        cellType: StiTablceCellType;
        cellDockStyle: StiDockStyle;
        column: number;
        fixedWidth: boolean;
        tableTag: Object;
        parentJoinCell: StiComponent;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        setJoinSize(): any;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
    }
}
declare module Stimulsoft.Report.Components.Table {
    var IStiTableComponent: string;
    interface IStiTableComponent {
    }
}
declare module Stimulsoft.Report.Components.Table {
    class StiColumnSize {
        private _widths;
        private _fixedColumn;
        setFixedColumn(indexCol: number, width: number): void;
        add(indexCol: number, width: number): void;
        addLastNotFixed(width: number): void;
        subtract(indexCol: number, width: number): void;
        setWidth(indexCol: number, width: number): void;
        getFixed(index: number): boolean;
        readonly length: number;
        getCountNotFixedColumn(): number;
        getWidth(indexCol: number): number;
        normalize(): void;
        constructor(size: number);
    }
}
declare module Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTable extends StiDataBand implements IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTable;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean, cloneComponents: boolean): StiTable;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        canGrow: boolean;
        readonly localizedName: string;
        readonly localizedCategory: string;
        isConverted: boolean;
        private _dockableTable;
        dockableTable: boolean;
        private _autoWidth;
        autoWidth: StiTableAutoWidth;
        private _autoWidthType;
        autoWidthType: StiTableAutoWidthType;
        private _rowCount;
        rowCount: number;
        private _columnCount;
        columnCount: number;
        private _footerRowsCount;
        footerRowsCount: number;
        private _headerRowsCount;
        headerRowsCount: number;
        readonly defaultHeightCell: number;
        private _headerPrintOn;
        headerPrintOn: StiPrintOnType;
        private _headerCanGrow;
        headerCanGrow: boolean;
        private _headerCanShrink;
        headerCanShrink: boolean;
        private _headerCanBreak;
        headerCanBreak: boolean;
        private _headerPrintAtBottom;
        headerPrintAtBottom: boolean;
        private _headerPrintIfEmpty;
        headerPrintIfEmpty: boolean;
        private _headerPrintOnAllPages;
        headerPrintOnAllPages: boolean;
        private _headerPrintOnEvenOddPages;
        headerPrintOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _footerPrintOn;
        footerPrintOn: StiPrintOnType;
        private _footerCanGrow;
        footerCanGrow: boolean;
        private _footerCanShrink;
        footerCanShrink: boolean;
        private _footerCanBreak;
        footerCanBreak: boolean;
        private _footerPrintAtBottom;
        footerPrintAtBottom: boolean;
        private _footerPrintIfEmpty;
        footerPrintIfEmpty: boolean;
        private _footerPrintOnAllPages;
        footerPrintOnAllPages: boolean;
        private _footerPrintOnEvenOddPages;
        footerPrintOnEvenOddPages: StiPrintOnEvenOddPagesType;
        private _numberID;
        numberID: number;
        readonly columns: number;
        readonly columnWidth: number;
        readonly columnGaps: number;
        readonly minRowsInColumn: number;
        minHeight: number;
        maxHeight: number;
        minSize: SizeD;
        rightToLeft: boolean;
        width: number;
        height: number;
        defaultClientRectangle: RectangleD;
        dockable: boolean;
        readonly headerStartColor: Color;
        readonly headerEndColor: Color;
        changeGrowToHeightAtCell(cell: StiComponent): void;
        private _tableStyle;
        tableStyle: StiTableStyle;
        private refreshTableStyle;
        applyStyleNone(): void;
        private applyStyleNoneForCell;
        private applyStyle1;
        private applyStyle3;
        private applyStyle4;
        private applyStyle5;
        private changeRowCount;
        private changeColumnCount;
        createJoin(REFsumWidth: any, REFsumHeight: any, REFjoinWidth: any, REFjoinHeight: any): number[];
        private getCountSelectedCells;
        private getCountJoinSelectedCells;
        private findLeftSelectedElement;
        private findRightSelectedElement;
        changeTableCellContentInImage(cell: StiTableCell | StiTableCellCheckBox | StiTableCellRichText): any;
        changeTableCellContentInText(cell: StiTableCellImage | StiTableCellCheckBox | StiTableCellRichText): void;
        changeTableCellContentInCheckBox(cell: StiTableCellImage | StiTableCell | StiTableCellRichText): void;
        changeTableCellContentInRichText(cell: StiTableCell | StiTableCellImage | StiTableCellCheckBox): void;
        getColumnForCell(cell: IStiTableCell): number;
        private setCellID;
        createCell(): void;
        private setStyleForCell;
        private addNewRows;
        private deleteLastRows;
        private addTableNewColumns;
        private deleteTableColumns;
        insertColumnToLeft(numberColumn: number): void;
        insertColumnToRight(numberColumn: number): void;
        insertRowAbove(numberRow: number): void;
        insertRowBelow(numberRow: number): void;
        deleteRows(firstRow: number, lastRow: number): StiComponent[];
        deleteColumns(firstColumn: number, lastColumn: number): Array<StiComponent>;
        distributeRows(): void;
        distributeColumns(): void;
        autoSizeCells(): void;
        private resizeWidthCellsAfterChanges;
        private resizeHeightCellsAfterChanges;
        private resizeWidthCell;
        private resizeHeightCell;
        startRenderTableBand(REFnewTableComponents: any): StiDataBand;
        private startRenderTable;
        private reverseCells;
        private setFilter;
        private setInteraction;
        private getParentJoin;
        private isEqualRows;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCell extends StiText implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCell;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCell;
        readonly locked: boolean;
        readonly linked: boolean;
        canGrow: boolean;
        readonly autoWidth: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellCheckBox extends StiCheckBox implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCellCheckBox;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCellCheckBox;
        readonly locked: boolean;
        readonly linked: boolean;
        canShrink: boolean;
        canGrow: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellImage extends StiImage implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCellImage;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCellImage;
        readonly locked: boolean;
        readonly linked: boolean;
        canShrink: boolean;
        canGrow: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Components.Table {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTableCellRichText extends StiRichText implements IStiTableCell, IStiTableComponent, IStiJsonReportObject {
        private static ImplementsStiTableCellRichText;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private loadJoinCellsFromXml;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiTableCellRichText;
        readonly locked: boolean;
        readonly linked: boolean;
        canShrink: boolean;
        canGrow: boolean;
        private _cellDockStyle;
        cellDockStyle: StiDockStyle;
        private _parentJoinCell;
        parentJoinCell: StiComponent;
        _joinCells: number[];
        joinCells: number[];
        _parentJoin: number;
        parentJoin: number;
        _join: boolean;
        join: boolean;
        private _id;
        id: number;
        private _joinWidth;
        joinWidth: number;
        private _joinHeight;
        joinHeight: number;
        readonly merged: boolean;
        readonly changeTopPosition: boolean;
        readonly changeLeftPosition: boolean;
        readonly changeRightPosition: boolean;
        private _tableTag;
        tableTag: Object;
        private _cellType;
        cellType: StiTablceCellType;
        private _fixedWidth;
        fixedWidth: boolean;
        private _column;
        column: number;
        getJoinComponentByGuid(id: number): StiComponent;
        getJoinComponentByIndex(index: number): StiComponent;
        containsGuid(id: number): boolean;
        private createJoin;
        private deleteJoin;
        private getNewClientRectangle;
        setJoinSize(): void;
        getRealHeightAfterInsertRows(): number;
        getRealHeight(): number;
        getRealTop(): number;
        getRealWidth(): number;
        getRealLeft(): number;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Components.TextFormats {
    class StiNegativeColorChecker {
        static isNegativeInRed(format: StiFormatService): boolean;
    }
}
declare module Stimulsoft.Report.Components.TextFormats {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBooleanFormatService extends StiFormatService implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        private bits;
        falseValue: string;
        trueValue: string;
        falseDisplay: string;
        trueDisplay: string;
        nullDisplay: string;
        readonly sample: Object;
        stiEquals(obj: Object): boolean;
        format(arg: any): string;
        format2(stringFormat: string, arg: any): string;
        createNew(): StiFormatService;
        constructor(falseValue?: string, trueValue?: string, falseDisplay?: string, trueDisplay?: string, nullDisplay?: string);
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionSortDirection = Stimulsoft.Report.Components.StiInteractionSortDirection;
    import StiDrillDownMode = Stimulsoft.Report.Components.StiDrillDownMode;
    class StiInteraction implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadInteractionFromJsonObject(jObject: StiJson): StiInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode): Stimulsoft.Report.Components.StiInteraction;
        loadFromXml(xmlNode: XmlNode): void;
        getReport(): Object;
        clone(): StiInteraction;
        isDefault(): boolean;
        private _sortingEnabled;
        sortingEnabled: boolean;
        private _sortingColumn;
        sortingColumn: string;
        private _sortingIndex;
        sortingIndex: number;
        private _sortingDirection;
        sortingDirection: StiInteractionSortDirection;
        private _drillDownEnabled;
        drillDownEnabled: boolean;
        private _drillDownReport;
        drillDownReport: string;
        private _drillDownMode;
        drillDownMode: StiDrillDownMode;
        private _drillDownParameter1;
        drillDownParameter1: StiDrillDownParameter;
        private _drillDownParameter2;
        drillDownParameter2: StiDrillDownParameter;
        private _drillDownParameter3;
        drillDownParameter3: StiDrillDownParameter;
        private _drillDownParameter4;
        drillDownParameter4: StiDrillDownParameter;
        private _drillDownParameter5;
        drillDownParameter5: StiDrillDownParameter;
        drillDownPage: StiPage;
        private _drillDownPageGuid;
        drillDownPageGuid: string;
        bookmark: string;
        hyperlink: string;
        tag: string;
        toolTip: string;
        getSortDataBandName(): string;
        getSortColumns(): string[];
        getSortColumnsString(): string;
        parentComponent: StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiBandInteraction extends StiInteraction implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        collapsingEnabled: boolean;
        selectionEnabled: boolean;
        collapseGroupFooter: boolean;
        collapsed: string;
        selectedLine: number;
    }
}
declare module Stimulsoft.Report.Components {
    class StiBookmark {
        add(name: string): void;
        private _bookmarks;
        bookmarks: StiBookmarksCollection;
        private _text;
        text: string;
        private _componentGuid;
        componentGuid: string;
        private _isManualBookmark;
        isManualBookmark: boolean;
        private _pageIndex;
        pageIndex: number;
        constructor(text?: string, parentComponent?: Object);
    }
}
declare module Stimulsoft.Report.Components {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiBookmarksCollection extends CollectionBase<StiBookmark> {
        add(bookmark: StiBookmark): void;
        addRange(bookmarks: StiBookmark[]): any;
        addRange(bookmarks: StiBookmarksCollection): any;
        contains(bookmark: StiBookmark): boolean;
        indexOf(bookmark: StiBookmark): number;
        indexOf(name: string): number;
        insert(index: number, bookmark: StiBookmark): void;
        remove(bookmark: StiBookmark): void;
        getByName(name: string): StiBookmark;
        getByIndex(index: number): StiBookmark;
        setByIndex(index: number, bookmark: StiBookmark): void;
    }
}
declare module Stimulsoft.Report.Components {
    class StiComponentHelper {
        static fillComponentPlacement(component: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiComponentsCollection extends CollectionBase<StiComponent> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        loadDocumentFromXml(xmlNode: XmlNode): void;
        clone(): StiComponentsCollection;
        memberwiseClone(): StiComponentsCollection;
        toList(): StiComponent[];
        private addCore;
        add(component: StiComponent): void;
        addRange(components: StiComponent[] | StiComponentsCollection): void;
        contains(component: StiComponent): boolean;
        indexOf(name: string): number;
        indexOf(component: StiComponent): number;
        insertRange(index: number, components: StiComponentsCollection): void;
        insert(index: number, component: StiComponent): void;
        remove(component: StiComponent): any;
        remove(component: StiComponent, clearParent: boolean): any;
        protected onComponentAdded(e: EventArgs): void;
        invokeComponentAdded(sender: Object, e: EventArgs): void;
        protected onComponentRemoved(e: EventArgs): void;
        invokeComponentRemoved(sender: Object, e: EventArgs): void;
        getByIndex(index: number): StiComponent;
        setByIndex(index: number, component: StiComponent): void;
        getByName(name: string): StiComponent;
        setByName(name: string, component: StiComponent): void;
        sortBySelectionTick(): void;
        sortByPriority(): void;
        sortByTopPosition(): void;
        sortByBottomPosition(): void;
        sortByLeftPosition(): void;
        sortByRightPosition(): void;
        sortBandsByTopPosition(): void;
        sortBandsByLeftPosition(): void;
        getComponentByName(componentName: string, container: StiContainer): StiComponent;
        getPageByAlias(alias: string): StiPage;
        setParent(parent: StiContainer): void;
        private parent;
        constructor(parent?: StiContainer);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCrossHeaderInteraction extends StiInteraction implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _collapsingEnabled;
        collapsingEnabled: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    var IStiEnumerator: string;
    interface IStiEnumerator {
        first(): any;
        prior(): any;
        next(): any;
        last(): any;
        position: number;
        count: number;
        isEof: boolean;
        isBof: boolean;
        isEmpty: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBusinessObject implements ICloneable, IStiStateSaveRestore, IStiEnumerator, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _states;
        protected readonly states: StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private _inherited;
        inherited: boolean;
        protected positionValue: number;
        position: number;
        countFiltered: number;
        readonly count: number;
        protected isBofValue: boolean;
        isBof: boolean;
        protected isEofValue: boolean;
        isEof: boolean;
        private _isEmpty;
        readonly isEmpty: boolean;
        private enumeratorReset;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        clone(): StiBusinessObject;
        currentObject: Object;
        readonly current: Object;
        private readonly report;
        private _businessObjects;
        businessObjects: StiBusinessObjectsCollection;
        private _columns;
        columns: StiDataColumnsCollection;
        private _guid;
        guid: string;
        private _category;
        category: string;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _businessObjectValue;
        businessObjectValue: Object;
        private _dictionary;
        dictionary: StiDictionary;
        private _parentBusinessObject;
        parentBusinessObject: StiBusinessObject;
        private _ownerBand;
        ownerBand: StiDataBand;
        private _key;
        key: string;
        private static _fieldsIgnoreList;
        static fieldsIgnoreList: Hashtable;
        getLevel(): number;
        private checkEnumerator;
        setPrevValue(): void;
        setNextValue(): void;
        restoreCurrentValue(): void;
        getTopParentBusinessObject(): StiBusinessObject;
        createEnumerator(): void;
        private sortData;
        private sortDataByGroups;
        filterData(): void;
        private destroyEnumerator;
        setDetails(): void;
        private updateChilds;
        private getBusinessObjectDataFromParent;
        getColumnIndex(columnName: string): number;
        getBusinessObjectData(isColumnsRetrieve?: boolean): Object;
        getFullName(): string;
        getCorrectFullName(): string;
        toString(): string;
        connect(): void;
        disconnect(): void;
        private isEnumeratorCreated;
        private specPrevValue;
        private specNextValue;
        private specNextValueRead;
        private specMoveNextResult;
        private specStoredCurrentValue;
        enumerator: IEnumerator;
        protected rowToLevel: Hashtable;
        specSetPrevValue: boolean;
        specSetNextValue: boolean;
        specFilterData: boolean;
        specSortGroup: boolean;
        specTotalsCalculation: boolean;
        previousResetException: boolean;
        getByName(name: string): Object;
        constructor(category?: string, name?: string, alias?: string, guid?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Components {
    class StiDataHelper {
        static setData(component: StiComponent, reinit: boolean, masterComponent?: StiComponent): void;
        static needGroupSort(band: StiDataBand): boolean;
        static getFilterEventHandler(component: StiComponent, dataSource: Object): Object;
        static getFilterExpression(filter: StiFilter, fullColumnName: string, report: StiReport): string;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    class StiDrillDownParameter implements /*IStiDefault,*/ IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        isDefault(): boolean;
        private _name;
        name: string;
        private _expression;
        expression: StiExpression;
        private _interaction;
        interaction: StiInteraction;
    }
}
declare module Stimulsoft.Report.Components {
    class StiFilterHelper {
        static convertStringToCondition(condition: string): StiFilterCondition;
        static convertConditionToString(condition: StiFilterCondition): string;
        static convertStringToDataType(dataType: string): StiFilterDataType;
        static convertDataTypeToString(dataType: StiFilterDataType): string;
        static setFilter(comp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFiltersCollection extends CollectionBase<StiFilter> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiFiltersCollection;
        add(filter: StiFilter): void;
        addRange(filters: StiFilter[]): any;
        addRange(filters: StiFiltersCollection): any;
        contains(filter: StiFilter): boolean;
        indexOf(filter: StiFilter): number;
        insert(index: number, filter: StiFilter): void;
        remove(filter: StiFilter): void;
        getByIndex(index: number): StiFilter;
        setByIndex(index: number, filter: StiFilter): void;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiMargins implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defRight?: number, defTop?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromText(text: string): StiMargins;
        static loadFromXml(xmlNode: XmlNode): StiMargins;
        clone(): Object;
        private _left;
        left: number;
        private _right;
        right: number;
        private _top;
        top: number;
        private _bottom;
        bottom: number;
        readonly isEmpty: boolean;
        static empty: StiMargins;
        static create(all?: number): StiMargins;
        constructor(left?: number, right?: number, top?: number, bottom?: number);
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetExcelSheetEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiColumnEndRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiColumnBeginRenderEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Components {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import PaperSize = Stimulsoft.System.Drawing.Printing.PaperSize;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPageHelper {
        static getPaperSizeFromPaperKind(paperKind: PaperKind): PaperSize;
        static getPaperSize(page: StiPage, paperSize: PaperSize): SizeD;
    }
}
declare module Stimulsoft.Report.Engine {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiComponentInfo implements ICloneable {
        implements(): string[];
        clone(): StiComponentInfo;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiPageInfo extends StiComponentInfo {
        overlays: StiComponentsCollection;
        indexOfStartRenderedPages: number;
        masterDataBand: StiDataBand;
        isReportTitlesRendered: boolean;
        renderedCount: number;
        positionFromTop: number;
        positionFromBottom: number;
    }
}
declare module Stimulsoft.Report.Units {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiUnit {
        static saveToJsonObject(unit: StiUnit): StiJson;
        static loadFromJsonObject(jObject: StiJson): StiUnit;
        static loadFromXml(xmlNode: XmlNode): StiUnit;
        static getUnitFromReportUnit(reportUnit: StiReportUnitType): StiUnit;
        private static _centimeters;
        static readonly Centimeters: StiCentimetersUnit;
        private static _hundredthsOfInch;
        static readonly HundredthsOfInch: StiHundredthsOfInchUnit;
        private static _inches;
        static readonly Inches: StiInchesUnit;
        private static _millimeters;
        static readonly Millimeters: StiMillimetersUnit;
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
        protected convertRectangleToHInches(rect: RectangleD): RectangleD;
        protected convertRectangleFromHInches(rect: RectangleD): RectangleD;
        protected convertSizeToHInches(size: SizeD): SizeD;
        protected convertSizeFromHInches(size: SizeD): SizeD;
    }
}
declare module Stimulsoft.Report.Components {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiWatermark implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiWatermark;
        private _font;
        font: Font;
        private _textBrush;
        textBrush: StiBrush;
        private shouldSerializeTextBrush;
        private _text;
        text: string;
        private _angle;
        angle: number;
        private _enabled;
        enabled: boolean;
        private _showImageBehind;
        showImageBehind: boolean;
        private _showBehind;
        showBehind: boolean;
        private _rightToLeft;
        rightToLeft: boolean;
        private _imageMultipleFactor;
        imageMultipleFactor: number;
        private _imageTransparency;
        imageTransparency: number;
        private _image;
        image: Image;
        private _imageHyperlink;
        imageHyperlink: string;
        private cachedImage;
        getImage(report: StiReport): Image;
        private _imageAlignment;
        imageAlignment: ContentAlignment;
        private _imageTiling;
        imageTiling: boolean;
        private _imageStretch;
        imageStretch: boolean;
        private _aspectRatio;
        aspectRatio: boolean;
        private _enabledExpression;
        enabledExpression: string;
        private getTransparentedImage;
        private disposeCachedImage;
        constructor(textBrush?: StiBrush, text?: string, angle?: number, font?: Font, showBehind?: boolean, enabled?: boolean, aspectRatio?: boolean, rightToLeft?: boolean);
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetExcelSheetEventHandler: EventHandler;
    class StiGetExcelSheetEventArgs extends EventArgs {
        value: string;
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetExcelSheetEventArgs = Stimulsoft.Report.Events.StiGetExcelSheetEventArgs;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiColumnBeginRenderEvent = Stimulsoft.Report.Events.StiColumnBeginRenderEvent;
    import StiColumnEndRenderEvent = Stimulsoft.Report.Events.StiColumnEndRenderEvent;
    import StiGetExcelSheetEvent = Stimulsoft.Report.Events.StiGetExcelSheetEvent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiShiftMode = Stimulsoft.Report.Components.StiShiftMode;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiPageInfo = Stimulsoft.Report.Components.StiPageInfo;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiWatermark = Stimulsoft.Report.Components.StiWatermark;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiResetPageNumber = Stimulsoft.Report.Components.IStiResetPageNumber;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiReportPage = Stimulsoft.Base.IStiReportPage;
    class StiPage extends StiPanel implements IStiResetPageNumber, IStiReportPage, IStiJsonReportObject {
        private static ImplementsStiPage;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        private _resetPageNumber;
        resetPageNumber: boolean;
        convertToHInches(unit: StiUnit, value: number): number;
        convertFromHInchesRect(unit: StiUnit, rect: RectangleD): RectangleD;
        convertFromHInches(unit: StiUnit, value: number): number;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        parseExpression(text: string): string;
        private _pageInfo;
        readonly pageInfo: StiPageInfo;
        readonly isAutomaticDock: boolean;
        left: number;
        top: number;
        getWidth(): number;
        setWidth(value: number): void;
        getHeight(): number;
        setHeight(value: number): void;
        readonly right: number;
        readonly bottom: number;
        clientRectangle: RectangleD;
        getDisplayRectangle(): RectangleD;
        shiftMode: StiShiftMode;
        printable: boolean;
        page: StiPage;
        parent: StiContainer;
        invokeEvents(): void;
        private static eventBeginRender;
        protected onBeginRender(): void;
        invokeBeginRender(): void;
        beginRenderEvent: StiBeginRenderEvent;
        private static eventRendering;
        protected onRendering(): void;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        protected onEndRender(): void;
        invokeEndRender(): void;
        endRenderEvent: StiEndRenderEvent;
        private static eventColumnBeginRender;
        protected onColumnBeginRender(): void;
        invokeColumnBeginRender(sender?: any): void;
        columnBeginRenderEvent: StiColumnBeginRenderEvent;
        private static eventColumnEndRender;
        protected onColumnEndRender(): void;
        invokeColumnEndRender(sender?: any): void;
        columnEndRenderEvent: StiColumnEndRenderEvent;
        private static eventGetExcelSheet;
        protected onGetExcelSheet(e: StiGetExcelSheetEventArgs): void;
        invokeGetExcelSheet(sender: StiComponent, e: StiGetExcelSheetEventArgs): void;
        getExcelSheetEvent: StiGetExcelSheetEvent;
        private _excelSheetValue;
        excelSheetValue: string;
        private _excelSheet;
        excelSheet: string;
        readonly zoom: number;
        readonly gridSize: number;
        private _printOnPreviousPage;
        printOnPreviousPage: boolean;
        private _printHeadersFootersFromPreviousPage;
        printHeadersFootersFromPreviousPage: boolean;
        private _paperSize;
        paperSize: PaperKind;
        private _paperSourceOfFirstPage;
        paperSourceOfFirstPage: string;
        private _paperSourceOfOtherPages;
        paperSourceOfOtherPages: string;
        private _numberOfCopies;
        numberOfCopies: number;
        private _unlimitedBreakable;
        unlimitedBreakable: boolean;
        private _largeHeight;
        largeHeight: boolean;
        private _largeHeightFactor;
        largeHeightFactor: number;
        private _largeHeightAutoFactor;
        largeHeightAutoFactor: number;
        private _currentWidthSegment;
        currentWidthSegment: number;
        private _currentHeightSegment;
        currentHeightSegment: number;
        private _stopBeforePrint;
        stopBeforePrint: number;
        private _skip;
        skip: boolean;
        private _stretchToPrintArea;
        stretchToPrintArea: boolean;
        private _titleBeforeHeader;
        titleBeforeHeader: boolean;
        private _unlimitedHeight;
        unlimitedHeight: boolean;
        private _unlimitedWidth;
        unlimitedWidth: boolean;
        private _offsetRectangle;
        offsetRectangle: RectangleD;
        private _orientation;
        orientation: StiPageOrientation;
        locked: boolean;
        linked: boolean;
        private _pageWidth;
        pageWidth: number;
        private _pageHeight;
        pageHeight: number;
        private _segmentPerWidth;
        segmentPerWidth: number;
        private _segmentPerHeight;
        segmentPerHeight: number;
        private _watermark;
        watermark: StiWatermark;
        private _margins;
        margins: StiMargins;
        private _mirrorMargins;
        mirrorMargins: boolean;
        private _report;
        report: StiReport;
        readonly unit: StiUnit;
        private _reportUnit;
        reportUnit: StiUnit;
        private _drillDownActivated;
        drillDownActivated: boolean;
        readonly isDashboard: boolean;
        readonly isPage: boolean;
        private _cacheGuid;
        cacheGuid: string;
        newCacheGuid(): void;
        private getIsPageTotalDataBand;
        clearPage(): void;
        private removeNewPageContainers;
        private getComponentsCount2;
        getComponentsCount(): number;
        resizePage(factorX: number, factorY: number, allowPageMarginsRescaling?: boolean): void;
        toString(): string;
        constructor(report?: StiReport, isSuper?: boolean);
        protected construct(report?: StiReport | any): void;
    }
}
declare module Stimulsoft.Report.Components {
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiPagesCollection extends CollectionBase<StiPage> implements IStiStateSaveRestore, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        toList(): StiPage[];
        add(page: StiPage): void;
        addV2Internal(page: StiPage): void;
        addRange(pages: StiPagesCollection): any;
        addRange(pages: StiPage[]): any;
        contains(page: StiPage): boolean;
        indexOf(page: StiPage): number;
        insert(index: number, page: StiPage): void;
        remove(page: StiPage): any;
        remove(startIndex: number, endCount: number): any;
        getPageWithoutCache(pageIndex: number): StiPage;
        getByIndex(index: number): StiPage;
        setByIndex(index: number, page: StiPage): void;
        getByName(name: string): StiPage;
        setByName(name: string, page: StiPage): void;
        protected onClear(): void;
        protected onInsertComplete(index: number, value: Object): void;
        protected onRemoveComplete(index: number, value: Object): void;
        protected onClearComplete(): void;
        getComponentByName(componentName: string): StiComponent;
        private static setParent;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private _canUseCacheMode;
        canUseCacheMode: boolean;
        private _report;
        report: StiReport;
        private _cacheMode;
        cacheMode: boolean;
        readonly containsDashboards: boolean;
        private quickCachedPages;
        notCachedPages: StiPage[];
        isNotSavedPage(page: StiPage): boolean;
        markPageAsNotSaved(page: StiPage): void;
        getPage(page: StiPage): StiPage;
        savePage(page: StiPage): void;
        protected onPageAdded(e: EventArgs): void;
        invokePageAdded(sender: Object, e: EventArgs): void;
        protected onPageRemoved(e: EventArgs): void;
        invokePageRemoved(sender: Object, e: EventArgs): void;
        protected onPageCleared(e: EventArgs): void;
        invokePageCleared(sender: Object, e: EventArgs): void;
        constructor(report: StiReport, originalPages?: StiPagesCollection);
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParameter implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly isDefault: boolean;
        private _name;
        name: string;
        private _expression;
        expression: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiParametersCollection extends CollectionBase<StiParameter> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiParametersCollection;
        private addCore;
        add(parameter: StiParameter): void;
        addRange(parameters: StiParametersCollection): void;
        addRange2(parameters: StiParameter[]): void;
        contains(parameter: StiParameter): boolean;
        indexOf(parameter: StiParameter): number;
        indexOf2(name: string): number;
        insertRange(index: number, parameters: StiParametersCollection): void;
        insert(index: number, parameter: StiParameter): void;
        remove(parameters: StiParametersCollection): void;
        remove2(parameter: StiParameter): void;
        getByIndex(index: number): StiParameter;
        setByIndex(index: number, value: any): void;
        getByName(name: string): StiParameter;
        setByName(name: string, value: any): void;
        copyTo(array: any[], index: number): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    class StiRestrictionsHelper {
        static isAllowChange(comp: StiComponent): boolean;
        static isAllowDelete2(restrictions: StiRestrictions): boolean;
        static isAllowDelete(comp: StiComponent): boolean;
        static isAllowMove(comp: StiComponent): boolean;
        static isAllowSelect(comp: StiComponent): boolean;
        static isAllowResize(comp: StiComponent): boolean;
        static isAllowChangePosition(comp: StiComponent): boolean;
    }
}
declare module Stimulsoft.Report.Components {
    class StiSortHelper {
        static getColumnIndexInSorting(sorts: string[], columnName: string): number;
        static getColumnSortDirection(sorts: string[], columnName: string): StiInteractionSortDirection;
        static changeColumnSortDirection(sorts: string[], columnName: string): string[];
        static isColumnExistInSorting(sorts: string[], columnName: string): boolean;
        static addColumnToSorting(sorts: string[], columnName: string, isAscending: boolean): string[];
    }
}
declare module Stimulsoft.Report.Components {
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiStandardTextRenderer {
        static measureString(maxWidth: number, font: Font, textBox: StiText): SizeD;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    enum StiSortDirection {
        Asc = 0,
        Desc = 1,
        None = 2
    }
    enum StiSummaryType {
        None = 0,
        Sum = 1,
        Average = 2,
        Min = 3,
        Max = 4,
        Count = 5,
        CountDistinct = 6,
        Image = 7
    }
    enum StiSummaryValues {
        AllValues = 0,
        SkipZerosAndNulls = 1,
        SkipNulls = 2
    }
    enum StiSortType {
        ByValue = 0,
        ByDisplayValue = 1
    }
    enum StiFieldType {
        Column = 0,
        Row = 1,
        Cell = 2
    }
    enum StiSummaryDirection {
        LeftToRight = 0,
        UpToDown = 1
    }
    enum StiEnumeratorType {
        None = 0,
        Arabic = 1,
        Roman = 2,
        ABC = 3
    }
    enum StiEnumeratorSeparator {
        Dot = 0,
        Dash = 1,
        Colon = 2,
        RoundBrackets = 3,
        SquareBrackets = 4
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiCell {
        clone(): StiCell;
        size: SizeD;
        isChangeWidthForRightToLeft: boolean;
        isNumeric: boolean;
        isNegativeColor: boolean;
        isImage: boolean;
        field: StiCrossField;
        private _text;
        text: string;
        hyperlinkValue: Object;
        toolTipValue: Object;
        tagValue: Object;
        parentCell: StiCell;
        value: Object;
        width: number;
        height: number;
        summaryIndex: number;
        level: number;
        parentGuid: string;
        guid: string;
        isCrossSummary: boolean;
        keepMergedCellsTogether: boolean;
        private _drillDownParameters;
        drillDownParameters: any;
        constructor(text?: string, value?: number, width?: number, height?: number, field?: StiCrossField);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiColumn {
        hyperlinkValue: Object;
        tagValue: Object;
        toolTipValue: Object;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        cols: StiColumnCollection;
        value: Object;
        displayValue: Object;
        othersText: string;
        constructor(value: Object, displayValue: Object);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiColumnCollection extends CollectionBase<StiColumn> {
        private directionFactor;
        private compare;
        private sortType;
        private items;
        insert(position: number, value: StiColumn): void;
        add2(value: Object, displayValue: Object): void;
        add(col: StiColumn): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        clear(): void;
        getByValue(value: Object): StiColumn;
        getByIndex(index: number): StiColumn;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiGrid {
        private readonly gridSize;
        report: StiReport;
        fields: Hashtable;
        designTime: boolean;
        widths: number[];
        heights: number[];
        coordX: number[];
        coordY: number[];
        cells: StiCell[][];
        rowCount: number;
        colCount: number;
        maxWidth: number;
        maxHeight: number;
        setTextOfCell(x: number, y: number, value: string): void;
        private align;
        private getCellTotalWidth;
        private getCellTotalHeight;
        doAutoSize(): void;
        private getFieldWidth;
        private getFieldHeight;
        setCell(cellX: number, cellY: number, cellWidth: number, cellHeight: number, text: Object, value: Object, field: StiCrossField, isNumeric: boolean, hyperlink: Object, toolTip: Object, tag: Object, drillDownParameters: any, level?: number, parentGuid?: string, guid?: string): StiCell;
        private cellExists;
        setCellField(cellX: number, cellY: number, field: StiCrossField): void;
        init(colCount: number, rowCount: number): void;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiCross extends StiGrid {
        crossTab: StiCrossTab;
        private strNull;
        static emptyField: string;
        emptyField: string;
        private oneCellSize;
        private oneCellWidth;
        private oneCellHeight;
        private summaryDirection;
        private colsHeaderHeight;
        private rowsHeaderWidth;
        private widthCorrection;
        private heightCorrection;
        private colsWidth;
        private rowsHeight;
        private columnsCell;
        private rowsCell;
        private invokeEvents2;
        private invokeEvents;
        private addRowTotal;
        private addColTotal;
        private sortRows;
        private sortCols;
        private createRowTotals;
        private createRowTotals2;
        private createColTotals;
        private createColTotals2;
        private getDataFromDataRow;
        private getValueFromDataRow;
        private allowTotal;
        private getRow;
        private getColumn;
        private calculateTopN;
        private processTopNRows;
        private fillOtherRows;
        private processTopNColumns;
        private fillOtherColumns;
        private getSumFiledIndex;
        private calculateDataTable;
        private calculateDataRow;
        private copyRows;
        private copyCols;
        private convertToDecimal;
        private isAllowConvertToDecimal;
        private getSummary2;
        private getSummaryResult;
        private copySummaries;
        private copySummary;
        private getSummary;
        private isHideZeros;
        private isDateTime;
        private static convertValueToString;
        private setCellValue;
        private static checkNegativeColor;
        private getColumnTotalCell;
        private getRowTotalCell;
        private getRowsArray;
        private getRowsArray2;
        private getColsArray;
        private getColsArray2;
        private getRowsHeaderWidth;
        private getRowsHeaderWidth2;
        private getColsHeaderHeight;
        private getColsHeaderHeight2;
        private getRowsHeight;
        private getColsWidth;
        private enumerateRows;
        private enumerateColumns;
        private checkSeparators;
        create(table: DataTable, report: StiReport, direction: StiSummaryDirection, emptyValue: string): void;
        clear(): boolean;
        getCorrectedColumnsHeaderHeight(): number;
        private readonly isSummaryPresent;
        private readonly isRowTitlePresent;
        private readonly isTopLinePresent;
        readonly isTopCrossTitleVisible: boolean;
        readonly isLeftCrossTitleVisible: boolean;
        readonly isCrossTitleEnabled: boolean;
        readonly isCrossTitlePrintOnAllPages: boolean;
        private readonly isShowSummarySubHeaders;
        private readonly isSummarySubHeadersPresent;
        private readonly isLeftTopLinePresent;
        private readonly isRightTopLinePresent;
        readonly isRowsEmpty: boolean;
        readonly isColsEmpty: boolean;
        readonly isSummariesEmpty: boolean;
        rows: StiRowCollection;
        cols: StiColumnCollection;
        colTitleFields: StiComponentsCollection;
        rowTitleFields: StiComponentsCollection;
        private _rowFields;
        rowFields: StiComponentsCollection;
        private _colFields;
        colFields: StiComponentsCollection;
        private _sumFields;
        sumFields: StiComponentsCollection;
        private _sumHeaderFields;
        sumHeaderFields: StiComponentsCollection;
        summaryContainer: StiSummaryContainer;
        leftCrossTitle: StiCrossTitle;
        rightCrossTitle: StiCrossTitle;
        summaryCrossTitle: StiCrossTitle;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiRow {
        hyperlinkValue: Object;
        tagValue: Object;
        toolTipValue: Object;
        drillDownParameters: any;
        isTotal: boolean;
        level: number;
        rows: StiRowCollection;
        value: Object;
        displayValue: Object;
        othersText: string;
        constructor(value: Object, displayValue: Object);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiRowCollection extends CollectionBase<StiRow> {
        private directionFactor;
        private compare;
        private sortType;
        private items;
        insert(position: number, value: StiRow): void;
        add2(value: Object, displayValue: Object): void;
        add(row: StiRow): void;
        clear(): void;
        sort(direction: StiSortDirection, sortType: StiSortType): void;
        getByValue(value: Object): StiRow;
        getByIndex(index: number): StiRow;
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    class StiSummary {
        sums: Object[][];
        hyperlinkValues: Object[];
        tagValues: Object[];
        toolTipValues: Object[];
        drillDownParameters: any[];
        constructor(level: number);
    }
}
declare module Stimulsoft.Report.CrossTab.Core {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiSummaryContainer {
        private level;
        private dataCol;
        getSummary(col: StiColumn, row: StiRow, create?: boolean): StiSummary;
        getDataCol(): Hashtable;
        constructor(level: number);
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetCrossValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetCrossValueEventArgs extends EventArgs {
        value: Object;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetDisplayCrossValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiProcessCellEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiCell = Stimulsoft.Report.CrossTab.Core.StiCell;
    class StiProcessCellEventArgs extends EventArgs {
        cell: StiCell;
        column: number;
        row: number;
        value: number;
        text: string;
    }
}
declare module Stimulsoft.Report.CrossTab {
    enum StiCrossHorAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        None = 3,
        Width = 4
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiRestrictions = Stimulsoft.Report.Components.StiRestrictions;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTextBrush = Stimulsoft.Report.Components.IStiTextBrush;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiCrossTabField = Stimulsoft.Report.Components.IStiCrossTabField;
    class StiCrossField extends StiText implements IStiTextHorAlignment, IStiVertAlignment, IStiBorder, IStiFont, IStiBrush, IStiTextBrush, IStiCrossTabField, IStiJsonReportObject {
        private static ImplementsStiCrossField;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected readonly defaultHorAlignment: StiTextHorAlignment;
        locked: boolean;
        linked: boolean;
        protected onProcessCell(e: StiProcessCellEventArgs): void;
        invokeProcessCell(e: StiProcessCellEventArgs): void;
        processCellEvent: StiProcessCellEvent;
        readonly helpUrl: string;
        toString(): string;
        readonly localizedCategory: string;
        getRestrictions(): StiRestrictions;
        setRestrictions(value: StiRestrictions): void;
        getTextBoxFromField(): StiText;
        readonly cellText: string;
        private _mergeHeaders;
        mergeHeaders: boolean;
        originalValue: any;
        disabledByCondition: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossCell extends StiCrossField implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        paint(g: Stimulsoft.System.Drawing.Graphics): void;
        protected onGetCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetCrossValue(e: StiGetCrossValueEventArgs): void;
        getCrossValueEvent: StiGetCrossValueEvent;
        private val;
        value: string;
        getValue(): string;
        setValue(value: string): void;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiSortType = Stimulsoft.Report.CrossTab.Core.StiSortType;
    import StiSortDirection = Stimulsoft.Report.CrossTab.Core.StiSortDirection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossHeader extends StiCrossCell implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected onGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        invokeGetDisplayCrossValue(e: StiGetCrossValueEventArgs): void;
        getDisplayCrossValueEvent: StiGetDisplayCrossValueEvent;
        setValue(value: string): void;
        private _displayValue;
        displayValue: string;
        total: StiCrossTotal;
        readonly isTotalVisible: boolean;
        private _headerLevel;
        headerLevel: number;
        private _headerValue;
        headerValue: string;
        private _totalGuid;
        totalGuid: string;
        private _showTotal;
        showTotal: boolean;
        private _sortDirection;
        sortDirection: StiSortDirection;
        private _sortType;
        sortType: StiSortType;
        private _printOnAllPages;
        printOnAllPages: boolean;
        topN: StiDataTopN;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossColumn extends StiCrossHeader implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        private _enumeratorType;
        enumeratorType: StiEnumeratorType;
        private _enumeratorSeparator;
        enumeratorSeparator: string;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossTotal extends StiCrossField {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly cellText: string;
        readonly componentId: StiComponentId;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossColumnTotal extends StiCrossTotal {
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiEnumeratorType = Stimulsoft.Report.CrossTab.Core.StiEnumeratorType;
    class StiCrossRow extends StiCrossHeader implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        private _enumeratorType;
        enumeratorType: StiEnumeratorType;
        private _enumeratorSeparator;
        enumeratorSeparator: string;
        getCrossRowTitle(): StiCrossTitle;
        getCrossRowTotal(): StiCrossRowTotal;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossRowTotal extends StiCrossTotal {
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiSummaryType = Stimulsoft.Report.CrossTab.Core.StiSummaryType;
    import StiSummaryValues = Stimulsoft.Report.CrossTab.Core.StiSummaryValues;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossSummary extends StiCrossCell implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties: boolean): StiCrossSummary;
        protected readonly defaultHorAlignment: StiTextHorAlignment;
        private _aspectRatio;
        aspectRatio: boolean;
        private _stretch;
        stretch: boolean;
        private _imageHorAlignment;
        imageHorAlignment: StiHorAlignment;
        private _imageVertAlignment;
        imageVertAlignment: StiVertAlignment;
        private _crossColumnValue;
        crossColumnValue: string;
        private _crossRowValue;
        crossRowValue: string;
        private _indexOfSelectValue;
        indexOfSelectValue: number;
        readonly cellText: string;
        private _summary;
        summary: StiSummaryType;
        private _summaryValues;
        summaryValues: StiSummaryValues;
        private _useStyleOfSummaryInRowTotal;
        useStyleOfSummaryInRowTotal: boolean;
        private _useStyleOfSummaryInColumnTotal;
        useStyleOfSummaryInColumnTotal: boolean;
        readonly localizedName: string;
        private _showPercents;
        showPercents: boolean;
        createNew(): StiComponent;
        constructor();
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossSummaryHeader extends StiCrossField {
        readonly cellText: string;
        readonly localizedName: string;
        readonly componentId: StiComponentId;
        createNew(): StiComponent;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiFillParametersEventHandler: EventHandler;
    class StiFillParametersEventArgs extends EventArgs {
        private val;
        value: {
            key: string;
            value: any;
        }[];
        constructor(value?: {
            key: string;
            value: any;
        }[]);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiSubReportsHelper {
        static getMasterDataBand(parent: StiContainer): StiDataBand;
        static getParentBand(parent: StiContainer): StiBand;
        static renderSubReport(containerOfSubReport: StiContainer, subReport: StiSubReport): void;
        static specialSubReportHeight: number;
        private static renderInternalSubReport;
        private static renderExternalSubReport;
        static renderDataBandsInContainer(containerOfDataBands: StiContainer, container: StiContainer, skipStaticBands?: boolean): void;
    }
}
declare module Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleConditionsCollection extends CollectionBase<StiStyleCondition> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleConditionsCollection;
        add(condition: StiStyleCondition): any;
        /** Creates a new object of the type StiStyleCondition. */
        add(elements: StiStyleConditionElement[]): any;
        addRange(conditions: StiStyleCondition[]): any;
        addRange(conditions: StiStyleConditionsCollection): any;
        contains(condition: StiStyleCondition): boolean;
        indexOf(condition: StiStyleCondition): number;
        insert(index: number, condition: StiStyleCondition): void;
        remove(condition: StiStyleCondition): void;
        getByIndex(index: number): StiStyleCondition;
        setByIndex(index: number, condition: StiStyleCondition): void;
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiBaseStyle extends StiService implements IStiBaseStyle, ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): Object;
        stiEquals(obj: Object, allowEqualName?: boolean, allowEqualDescription?: boolean): boolean;
        static getStyle(component: StiComponent, styleElements?: StiStyleElements | StiBaseStyle, componentStyle?: StiBaseStyle): StiBaseStyle;
        /** Gets the style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /** Sets style to the component. */
        setStyleToComponent(component: StiComponent): void;
        /** Gets a style from the components. */
        getStyleFromComponents(comps: StiComponentsCollection, styleElements: StiStyleElements): void;
        /** Returns string representation of the style. */
        toString(): string;
        private _collectionName;
        /** Gets or sets a name of the styles collection. */
        collectionName: string;
        private _conditions;
        /** Gets or sets a collection of the style conditions. */
        conditions: StiStyleConditionsCollection;
        private _description;
        /** Gets or sets a style description. */
        description: string;
        private _name;
        /** Gets or sets a style name. */
        name: string;
        dashboardName: string;
        report: StiReport;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossTabStyle extends StiBaseStyle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        backColor: Color;
        color: Color;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        /**
         *  Gets a style from the component.
         *  @param component Component.
         */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /**
         *  Sets style to a component.
         *  @param component Component.
         */
        setStyleToComponent(component: StiComponent): void;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiSummaryDirection = Stimulsoft.Report.CrossTab.Core.StiSummaryDirection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiFilterEngine = Stimulsoft.Report.Components.StiFilterEngine;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import IStiCrossTab = Stimulsoft.Report.Components.IStiCrossTab;
    import IStiSort = Stimulsoft.Report.Components.IStiSort;
    import IStiDataRelation = Stimulsoft.Report.Components.IStiDataRelation;
    import IStiPrintIfEmpty = Stimulsoft.Report.Components.IStiPrintIfEmpty;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    class StiCrossTab extends StiContainer implements IStiDataSource, IStiFilter, IStiCrossTab, IStiSort, IStiDataRelation, IStiPrintIfEmpty, IStiBusinessObject, IStiJsonReportObject {
        private static ImplementsStiCrossTab;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly helpUrl: string;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        private _printIfEmpty;
        printIfEmpty: boolean;
        readonly dataRelation: StiDataRelation;
        private _dataRelationName;
        dataRelationName: string;
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isDataSourceEmpty: boolean;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        private _sort;
        sort: string[];
        readonly canBreak: boolean;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEof: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        position: number;
        readonly count: number;
        clone(): StiCrossTab;
        packService(): void;
        private _crossTabInfo;
        readonly crossTabInfo: StiCrossTabInfo;
        private _filterEngine;
        filterEngine: StiFilterEngine;
        private _filterMode;
        filterMode: StiFilterMode;
        filterMethodHandler: Function;
        private _filters;
        filters: Stimulsoft.Report.Components.StiFiltersCollection;
        filter: string;
        private _filterOn;
        filterOn: boolean;
        canContainIn(component: StiComponent): boolean;
        readonly localizedCategory: string;
        readonly priority: number;
        defaultClientRectangle: RectangleD;
        readonly componentType: StiComponentType;
        readonly localizedName: string;
        private _crossTabStyleIndex;
        crossTabStyleIndex: number;
        private _crossTabStyleColor;
        crossTabStyleColor: Object;
        crossTabStyle: string;
        setComponentStyle(value: string): void;
        updateStyles(): void;
        getCellColor(): Color;
        applyFieldStyle(field: StiCrossField): void;
        private _horAlignment;
        horAlignment: StiCrossHorAlignment;
        private _printTitleOnAllPages;
        printTitleOnAllPages: boolean;
        private _summaryDirection;
        summaryDirection: StiSummaryDirection;
        private _keepCrossTabTogether;
        keepCrossTabTogether: boolean;
        private _emptyValue;
        emptyValue: string;
        private _wrap;
        wrap: boolean;
        private _wrapGap;
        wrapGap: number;
        private _rightToLeft;
        rightToLeft: boolean;
        createNew(): StiComponent;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.CrossTab {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiCrossTabHelper {
        static getCellRect(masterCrossTab: StiCrossTab, colIndex: number, rowIndex: number): RectangleD;
        static getCellsRect(masterCrossTab: StiCrossTab, startCol: number, startRow: number, endCol: number, endRow: number): SizeD;
        static renderCells(masterCrossTab: StiCrossTab, outContainer: StiContainer, startCol: number, startRow: number, endCol: number, endRow: number, rect: RectangleD): void;
        static createCrossForCrossTabDataSource(masterCrossTab: StiCrossTab): DataTable;
        static buildCrossForCrossTabDataSource(masterCrossTab: StiCrossTab, designTime: boolean): DataTable;
        static buildCross(masterCrossTab: StiCrossTab, designTime: boolean): void;
        static getEndCol(masterCrossTab: StiCrossTab, startCol: number, rect: RectangleD): number;
        static getEndRow(masterCrossTab: StiCrossTab, startRow: number, rect: RectangleD): number;
        static getPageSegmentsRequired(masterCrossTab: StiCrossTab): number;
        static checkMergedRowCells(masterCrossTab: StiCrossTab, startRow: number, endRow: number, startCol: number, endCol: number): number;
        static isColFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static isRowFieldsEmpty(masterCrossTab: StiCrossTab): boolean;
        static createCross(masterCrossTab: StiCrossTab): void;
        static isCrossTabRendering: boolean;
        static makeRightToLeft(masterCrossTab: StiCrossTab): void;
        static calculateMaxAndMin(outContainer: StiContainer, REFmaxLeft: any, REFmaxRight: any, startIndex: number): void;
        static makeHorAlignmentByWidth(outContainer: StiContainer, startIndex: number): void;
        static clearCross(masterCrossTab: StiCrossTab): void;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiCross = Stimulsoft.Report.CrossTab.Core.StiCross;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiCrossTabInfo extends StiComponentInfo {
        defaultWidth: number;
        defaultHeight: number;
        startRow: number;
        startCol: number;
        hidedCells: Hashtable;
        cross: StiCross;
        renderRect: RectangleD;
        finishRender: boolean;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCrossTabParams {
        private _startRow;
        startRow: number;
        private _startColumn;
        startColumn: number;
        private _renderingIsFinished;
        renderingIsFinished: boolean;
        private _allowRendering;
        allowRendering: boolean;
        private _destinationRectangle;
        destinationRectangle: RectangleD;
        private _destinationContainer;
        destinationContainer: StiContainer;
        shiftX: number;
    }
}
declare module Stimulsoft.Report.CrossTab {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiCrossTitle extends StiCrossField implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly localizedName: string;
        private _printOnAllPages;
        printOnAllPages: boolean;
        private _typeOfComponent;
        typeOfComponent: string;
        readonly cellText: string;
        createNew(): StiComponent;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    var IStiDashboardExportSettings: string;
    interface IStiDashboardExportSettings {
        renderBorders: boolean;
        renderSingleElement: boolean;
        renderSinglePage: boolean;
        orientation: StiPageOrientation;
        paperSize: PaperKind;
        openAfterExport: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    import StiDataType = Stimulsoft.Report.Export.StiDataType;
    var IStiDataDashboardExportSettings: string;
    interface IStiDataDashboardExportSettings extends IStiDashboardExportSettings {
        dataType: StiDataType;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    var IStiExcelDashboardExportSettings: string;
    interface IStiExcelDashboardExportSettings extends IStiDashboardExportSettings {
        width: number;
        height: number;
        imageQuality: number;
        exportDataOnly: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    var IStiImageDashboardExportSettings: string;
    interface IStiImageDashboardExportSettings extends IStiDashboardExportSettings {
        imageType: StiImageType;
        scale: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Export {
    var IStiPdfDashboardExportSettings: string;
    interface IStiPdfDashboardExportSettings extends IStiDashboardExportSettings {
        autoPrint: boolean;
        imageQuality: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    class StiBorderElementHelper {
        static getBorderContentRect(rect: RectangleD, element: IStiElement, skipMinimalSize?: boolean): RectangleD;
        static getBorderContentRect2(rect: RectangleD, border: StiSimpleBorder, scale: number, skipMinimalSize?: boolean): RectangleD;
        static getBorderContentRect3(rect: RectangleD, border: StiBorder, scale: number, skipMinimalSize?: boolean): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiCrossLinkedFilterHelper {
        static isCrossLinkedFilter(filterElement: IStiFilterElement): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiDashboardImageHyperlinkCache {
        private static cache;
        static get(hyperlink: string, app: IStiApp): Image;
        private static getCacheKey;
        private static getFromCache;
        private static addToCache;
        static clean(appKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiDashboardRecentHelper {
        private static dbsFiles;
        private static reportFiles;
        private static getSettingsPath;
        private static getNewSettingsPath;
        static save(): boolean;
        private static load;
        static add(report: StiReport, path: string, autoSave?: boolean): void;
        static add2(containsDashboards: boolean, path: string, autoSave?: boolean): void;
        static remove(path: string): void;
        static containsDbs(path: string): boolean;
        static containsFile(path: string): boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiElementScale {
        static factor(element: IStiElement | StiComponent): number;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiIndicatorElementMouseOverHelper {
        private static indicatorElement;
        private static mouseOverPoint;
        static setMouseOverPoint(indicator: IStiIndicatorElement, point: PointD): void;
        static getMouseOverPoint(indicator: IStiIndicatorElement, useZoom?: boolean): PointD;
        static resetMouseOverPoint(indicator: IStiIndicatorElement): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiMarginHelper {
        static applyMargin(element: IStiElement, rect: RectangleD, scale?: number): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPaddingHelper {
        static applyPadding(element: IStiElement, rect: RectangleD, scale: number): RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTableElementClickEventArgs extends EventArgs {
        dataTable: StiDataTable;
        columnKey: string;
        rect: RectangleD;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementClickRightHelper {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableElementMouseOverHelper {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTablePartDrawer {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Helpers {
    class StiTableSizer {
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiElementStyle extends StiBaseStyle {
        ident: StiElementStyleIdent;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiControlElementStyle extends StiElementStyle {
        localizedName: string;
        backColor: Color;
        foreColor: Color;
        glyphColor: Color;
        separatorColor: Color;
        selectedBackColor: Color;
        selectedForeColor: Color;
        selectedGlyphColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        hotGlyphColor: Color;
        hotSelectedBackColor: Color;
        hotSelectedForeColor: Color;
        hotSelectedGlyphColor: Color;
        font: Font;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import StiDialogStyle = Stimulsoft.Report.Styles.StiDialogStyle;
    class StiCustomControlElementStyle extends StiControlElementStyle {
        private styleName;
        сomponentId: StiComponentId;
        readonly localizedName: string;
        ident: StiElementStyleIdent;
        constructor(style: StiDialogStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        separatorColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoiseControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        backColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        selectedBackColor: System.Drawing.Color;
        selectedForeColor: System.Drawing.Color;
        glyphColor: System.Drawing.Color;
        separatorColor: System.Drawing.Color;
        selectedGlyphColor: System.Drawing.Color;
        hotBackColor: System.Drawing.Color;
        hotForeColor: System.Drawing.Color;
        hotGlyphColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
        hotSelectedForeColor: System.Drawing.Color;
        hotSelectedGlyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseControlElementStyle extends StiControlElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        selectedBackColor: System.Drawing.Color;
        hotSelectedBackColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiDashboardStyle extends StiElementStyle {
        localizedName: string;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
        readonly borderColor: Color;
        drawStyleForGallery(g: Graphics, rect: Rectangle): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        borderColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleForeColor: Color;
        titleBackColor: Color;
        borderColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoiseDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        borderColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        borderColor: System.Drawing.Color;
        foreColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
        titleBackColor: System.Drawing.Color;
        titleForeColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSlateGrayDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseDashboardStyle extends StiDashboardStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: Color;
        backColor: Color;
        titleBackColor: Color;
        titleForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiIndicatorElementStyle extends StiElementStyle {
        localizedName: string;
        glyphColor: Color;
        backColor: Color;
        foreColor: Color;
        hotBackColor: Color;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        readonly localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        foreColor: Color;
        constructor(style: StiIndicatorStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: Color;
        backColor: Color;
        positiveColor: Color;
        negativeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseIndicatorElementStyle extends StiIndicatorElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        glyphColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPivotElementStyle extends StiElementStyle {
        localizedName: string;
        cellBackColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBluePivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBluePivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiCrossTabStyle = Stimulsoft.Report.Styles.StiCrossTabStyle;
    class StiCustomPivotElementStyle extends StiPivotElementStyle {
        private name2;
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        columnHeaderForeColor: Color;
        rowHeaderBackColor: Color;
        rowHeaderForeColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
        cellForeColor: Color;
        lineColor: Color;
        constructor(style: StiCrossTabStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBluePivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayPivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoisePivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenPivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangePivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverPivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayPivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        columnHeaderBackColor: System.Drawing.Color;
        columnHeaderForeColor: System.Drawing.Color;
        rowHeaderBackColor: System.Drawing.Color;
        rowHeaderForeColor: System.Drawing.Color;
        hotColumnHeaderBackColor: System.Drawing.Color;
        hotRowHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoisePivotElementStyle extends StiPivotElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        columnHeaderBackColor: Color;
        rowHeaderBackColor: Color;
        hotColumnHeaderBackColor: Color;
        hotRowHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiProgressElementStyle extends StiElementStyle {
        localizedName: string;
        foreColor: Color;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiAliceBlueProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        foreColor: System.Drawing.Color;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiBlueProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        readonly localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        foreColor: Color;
        backColor: Color;
        constructor(style: StiProgressStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkBlueProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkGrayProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkTurquoiseProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiGreenProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiOrangeProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSilverProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSlateGrayProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        backColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiTurquoiseProgressElementStyle extends StiProgressElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        trackColor: System.Drawing.Color;
        bandColor: System.Drawing.Color;
        seriesColors: System.Drawing.Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTableElementStyle extends StiElementStyle {
        localizedName: string;
        cellBackColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        footerColor: Color;
        footerForeground: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellWinLossNegative: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
        cellIndicatorNeutral: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAliceBlueTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBlueTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        cellForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiCustomTableElementStyle extends StiTableElementStyle {
        private name2;
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        constructor(style: StiTableStyle);
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiDarkBlueTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkGrayTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiDarkTurquoiseTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGreenTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOrangeTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSilverTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        cellForeColor: Color;
        alternatingCellBackColor: Color;
        alternatingCellForeColor: Color;
        headerBackColor: Color;
        headerForeColor: Color;
        selectedCellBackColor: Color;
        selectedCellForeColor: Color;
        hotHeaderBackColor: Color;
        lineColor: Color;
        backColor: Color;
        cellDataBarsOverlapped: Color;
        cellDataBarsPositive: Color;
        cellDataBarsNegative: Color;
        cellWinLossPositive: Color;
        cellSparkline: Color;
        cellIndicatorPositive: Color;
        cellIndicatorNegative: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    class StiSlateGrayTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: System.Drawing.Color;
        cellForeColor: System.Drawing.Color;
        alternatingCellBackColor: System.Drawing.Color;
        alternatingCellForeColor: System.Drawing.Color;
        headerBackColor: System.Drawing.Color;
        headerForeColor: System.Drawing.Color;
        selectedCellBackColor: System.Drawing.Color;
        selectedCellForeColor: System.Drawing.Color;
        hotHeaderBackColor: System.Drawing.Color;
        lineColor: System.Drawing.Color;
        backColor: System.Drawing.Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTurquoiseTableElementStyle extends StiTableElementStyle {
        сomponentId: StiComponentId;
        localizedName: string;
        ident: StiElementStyleIdent;
        cellBackColor: Color;
        alternatingCellBackColor: Color;
        selectedCellBackColor: Color;
        headerBackColor: Color;
        hotHeaderBackColor: Color;
    }
}
declare namespace Stimulsoft.Report.Maps {
    enum StiMapSource {
        Manual = 0,
        DataColumns = 1
    }
    enum StiDisplayNameType {
        None = 1,
        Full = 2,
        Short = 3
    }
    enum StiMapMode {
        Choropleth = 0,
        Online = 1
    }
    enum StiMapID {
        World = 1,
        Australia = 2,
        Austria = 3,
        Brazil = 4,
        Canada = 5,
        China = 6,
        ChinaWithHongKongAndMacau = 7,
        ChinaWithHongKongMacauAndTaiwan = 8,
        Taiwan = 9,
        EU = 10,
        Europe = 11,
        France = 12,
        Germany = 13,
        Italy = 14,
        Netherlands = 15,
        Russia = 16,
        UK = 17,
        UKCountries = 18,
        USAAndCanada = 19,
        NorthAmerica = 20,
        SouthAmerica = 21,
        USA = 22,
        Albania = 23,
        Andorra = 24,
        Argentina = 25,
        ArgentinaFD = 26,
        Armenia = 27,
        Azerbaijan = 28,
        Belarus = 29,
        Belgium = 30,
        Bolivia = 31,
        BosniaAndHerzegovina = 32,
        Bulgaria = 33,
        Chile = 34,
        Colombia = 35,
        Croatia = 36,
        Cyprus = 37,
        CzechRepublic = 38,
        Denmark = 39,
        Ecuador = 40,
        Estonia = 41,
        FalklandIslands = 42,
        Finland = 43,
        Georgia = 44,
        Greece = 45,
        Guyana = 46,
        Hungary = 47,
        Iceland = 48,
        India = 49,
        Indonesia = 50,
        Ireland = 51,
        Israel = 52,
        Japan = 53,
        Kazakhstan = 54,
        Latvia = 55,
        Liechtenstein = 56,
        Lithuania = 57,
        Luxembourg = 58,
        Macedonia = 59,
        Malaysia = 60,
        Malta = 61,
        Mexico = 62,
        Moldova = 63,
        Monaco = 64,
        Montenegro = 65,
        NewZealand = 66,
        Norway = 67,
        Paraguay = 68,
        Peru = 69,
        Philippines = 70,
        Poland = 71,
        Portugal = 72,
        Romania = 73,
        SanMarino = 74,
        SaudiArabia = 75,
        Serbia = 76,
        Slovakia = 77,
        Slovenia = 78,
        SouthAfrica = 79,
        SouthKorea = 80,
        Spain = 81,
        Suriname = 82,
        Sweden = 83,
        Switzerland = 84,
        Thailand = 85,
        Turkey = 86,
        Ukraine = 87,
        Uruguay = 88,
        Vatican = 89,
        Venezuela = 90,
        Vietnam = 91,
        MiddleEast = 92,
        Oman = 93,
        Qatar = 94
    }
    enum StiMapStyleIdent {
        Style21 = 0,
        Style24 = 1,
        Style25 = 2,
        Style26 = 3,
        Style27 = 4,
        Style28 = 5,
        Style29 = 6,
        Style30 = 7,
        Style31 = 8,
        Style32 = 9,
        Style33 = 10
    }
    enum StiMapType {
        None = 0,
        Individual = 4,
        Group = 1,
        Heatmap = 2,
        HeatmapWithGroup = 3
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private defaultColors;
        private defaultHeatmapColors;
        individualColor: Color;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        foreColor: Color;
        borderSize: number;
        borderColor: Color;
        labelShadowForeground: Color;
        labelForeground: Color;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Maps {
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiMapStyleFX extends StiMapStyle {
        localizeName: string;
        allowDashboard: boolean;
        styleId: StiMapStyleIdent;
        styleIdent: StiElementStyleIdent;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    enum StiElementStyleIdent {
        Auto = 1,
        Blue = 2,
        Orange = 3,
        Green = 4,
        Turquoise = 5,
        SlateGray = 6,
        DarkBlue = 7,
        DarkGray = 8,
        DarkGreen = 9,
        DarkTurquoise = 10,
        Silver = 11,
        AliceBlue = 12,
        Custom = 13
    }
    enum StiItemSelectionMode {
        One = 0,
        Multi = 1
    }
    enum StiDateSelectionMode {
        Single = 0,
        Range = 1,
        AutoRange = 2
    }
    enum StiInitialDateRangeSelection {
        DayTomorrow = 0,
        DayToday = 1,
        DayYesterday = 2,
        WeekNext = 3,
        WeekCurrent = 4,
        WeekPrevious = 5,
        MonthNext = 6,
        MonthCurrent = 7,
        MonthPrevious = 8,
        QuarterNext = 9,
        QuarterCurrent = 10,
        QuarterPrevious = 11,
        QuarterFirst = 12,
        QuarterSecond = 13,
        QuarterThird = 14,
        QuarterFourth = 15,
        YearNext = 16,
        YearCurrent = 17,
        YearPrevious = 18,
        Last7Days = 19,
        Last14Days = 20,
        Last30Days = 21,
        DateToWeek = 22,
        DateToMonth = 23,
        DateToQuarter = 24,
        DateToYear = 25
    }
    enum StiProgressElementMode {
        Pie = 0,
        Circle = 1,
        DataBars = 2
    }
    enum StiDateCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5
    }
    enum StiTableSizeMode {
        AutoSize = 0,
        Fit = 1
    }
    enum StiChartLabelsPosition {
        None = 0,
        Center = 1,
        InsideEnd = 2,
        Outside = 3,
        TwoColumns = 4
    }
    enum StiInteractionIdent {
        Chart = 1,
        TableColumn = 2,
        RegionMap = 3,
        Table = 4
    }
    enum StiAvailableInteractionOnHover {
        ShowToolTip = 1,
        ShowHyperlink = 2,
        None = 0,
        All = 3
    }
    enum StiAvailableInteractionOnClick {
        ShowDashboard = 1,
        OpenHyperlink = 2,
        ApplyFilter = 4,
        DrillDown = 8,
        None = 0,
        All = 15
    }
    enum StiAvailableInteractionOnDataManipulation {
        AllowSorting = 1,
        AllowFiltering = 2,
        AllowDrillDown = 4,
        All = 7,
        None = 0
    }
    enum StiInteractionOnHover {
        None = 0,
        ShowToolTip = 1,
        ShowHyperlink = 2
    }
    enum StiInteractionOnClick {
        None = 0,
        ShowDashboard = 1,
        OpenHyperlink = 2,
        ApplyFilter = 3,
        DrillDown = 4
    }
    enum StiInteractionOpenHyperlinkDestination {
        NewTab = 0,
        CurrectTab = 1
    }
    enum StiElementMeterAction {
        None = 0,
        Rename = 1,
        Delete = 2,
        ClearAll = 3
    }
    enum StiOnlineMapLocationType {
        Auto = 0,
        AdminDivision1 = 1,
        AdminDivision2 = 2,
        CountryRegion = 3,
        Neighborhood = 4,
        PopulatedPlace = 5,
        Postcode1 = 6,
        Postcode2 = 7,
        Postcode3 = 8,
        Postcode4 = 9
    }
    enum StiOnlineMapLocationColorType {
        Single = 0,
        ColorEach = 1,
        Group = 2,
        Value = 3
    }
    enum StiOnlineMapValueViewMode {
        Bubble = 0,
        Value = 1
    }
    enum StiOnlineMapCulture {
        ar_SA = 0,
        eu = 1,
        bg = 2,
        bg_BG = 3,
        ca = 4,
        ku_Arab = 5,
        zh_CN = 6,
        zh_HK = 7,
        zh_Hans = 8,
        zh_TW = 9,
        zh_Hant = 10,
        cs = 11,
        cs_CZ = 12,
        da = 13,
        da_DK = 14,
        nl_BE = 15,
        nl = 16,
        nl_NL = 17,
        en_AU = 18,
        en_CA = 19,
        en_IN = 20,
        en_GB = 21,
        en_US = 22,
        fi = 23,
        fi_FI = 24,
        fr_BE = 25,
        fr_CA = 26,
        fr = 27,
        fr_FR = 28,
        fr_CH = 29,
        gl = 30,
        de = 31,
        de_DE = 32,
        el = 33,
        he = 34,
        he_IL = 35,
        hi = 36,
        hi_IN = 37,
        hu = 38,
        hu_HU = 39,
        is_IS = 40,
        it = 41,
        it_IT = 42,
        ja = 43,
        ja_JP = 44,
        ko = 45,
        Ko_KR = 46,
        ky_Cyrl = 47,
        lv = 48,
        lv_LV = 49,
        lt = 50,
        lt_LT = 51,
        nb = 52,
        nb_NO = 53,
        nn = 54,
        pl = 55,
        pl_PL = 56,
        pt_BR = 57,
        pt_P = 58,
        ru = 59,
        ru_RU = 60,
        es_MX = 61,
        es = 62,
        es_ES = 63,
        es_US = 64,
        sv = 65,
        sv_SE = 66,
        tt_Cyrl = 67,
        th = 68,
        th_TH = 69,
        tr = 70,
        tr_TR = 71,
        uk = 72,
        uk_UA = 73,
        ug_Arab = 74,
        ca_ES_valencia = 75,
        vi = 76,
        vi_VN = 77
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap33StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        readonly borderColor: Color;
        readonly individualColor: Color;
        readonly colors: Color[];
        readonly heatmapColors: Color[];
        readonly defaultColor: Color;
        readonly backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap32StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        readonly borderColor: Color;
        readonly individualColor: Color;
        readonly colors: Color[];
        readonly heatmapColors: Color[];
        readonly defaultColor: Color;
        readonly backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap31StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        readonly borderColor: Color;
        readonly individualColor: Color;
        readonly colors: Color[];
        readonly heatmapColors: Color[];
        readonly defaultColor: Color;
        readonly backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap30StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        readonly borderColor: Color;
        readonly individualColor: Color;
        readonly colors: Color[];
        readonly heatmapColors: Color[];
        readonly defaultColor: Color;
        readonly backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap29StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        readonly individualColor: Color;
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        borderColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap28StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        colors: Color[];
        readonly individualColor: Color;
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
        borderColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap27StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        individualColor: Color;
        borderColor: Color;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap26StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        individualColor: Color;
        borderColor: Color;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap25StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        individualColor: Color;
        borderColor: Color;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap24StyleFX extends StiMapStyleFX {
        readonly allowDashboard: boolean;
        readonly styleIdent: StiElementStyleIdent;
        readonly dashboardName: string;
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        individualColor: Color;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Styles {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDialogStyle extends StiBaseStyle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): any;
        /**
         *  Gets or sets the font for drawing this style.
         */
        font: Font;
        private sshouldSerializeFont;
        foreColor: Color;
        private shouldSerializeForeColor;
        backColor: Color;
        private shouldSerializeBackColor;
        glyphColor: Color;
        private shouldSerializeGlyphColor;
        separatorColor: Color;
        private shouldSerializeSeparatorColor;
        selectedBackColor: Color;
        private shouldSerializeSelectedBackColor;
        selectedForeColor: Color;
        private shouldSerializeSelectedForeColor;
        selectedGlyphColor: Color;
        private shouldSerializeSelectedGlyphColor;
        hotBackColor: Color;
        private shouldSerializeHotBackColor;
        hotForeColor: Color;
        private shouldSerializeHotForeColor;
        hotGlyphColor: Color;
        private shouldSerializeHotGlyphColor;
        hotSelectedBackColor: Color;
        private shouldSerializeHotSelectedBackColor;
        hotSelectedForeColor: Color;
        private shouldSerializeHotSelectedForeColor;
        hotSelectedGlyphColor: Color;
        private shouldSerializeHotSelectedGlyphColor;
        /**
         *  Gets or sets a value which indicates whether a report engine can use Font for dialog controls.
         */
        allowUseFont: boolean;
        /**
         *  Gets or sets a value which indicates whether a report engine can use BackColor for dialog controls.
         */
        allowUseBackColor: boolean;
        /**
         *  Gets or sets a value which indicates whether a report engine can use ForeColor for dialog controls.
         */
        allowUseForeColor: boolean;
        /**
         *  Gets a style from the component.
         *  @param component Component
         *  @param styleElements Elements of style
         *  @param componentStyle Odd/Even/Component style of component, if present
         */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): any;
        /**
         *  Sets style to a component.
         *  @param component Component.
         */
        setStyleToComponent(component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    /**
     *  Describes the class that contains a style for Map components.
     */
    class StiTableStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        backColor: Color;
        dataColor: Color;
        dataForeground: Color;
        selectedDataColor: Color;
        selectedDataForeground: Color;
        alternatingDataColor: Color;
        alternatingDataForeground: Color;
        headerColor: Color;
        headerForeground: Color;
        hotHeaderColor: Color;
        footerColor: Color;
        footerForeground: Color;
        gridColor: Color;
        private getColor;
        /**
         *  Gets a style from the component.
         *  @param component Component.
         */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /**
         *  Sets style to a component.
         *  @param component Component.
         */
        setStyleToComponent(component: StiComponent): void;
        /**
         *  Creates a new object of the type StiTableStyle.
         *  @param name Style name.
         *  @param description Style description.
         */
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrushType = Stimulsoft.Report.StiBrushType;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartStyle extends StiBaseStyle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        border: StiBorder;
        brush: StiBrush;
        chartAreaBrush: StiBrush;
        chartAreaBorderColor: Color;
        chartAreaShowShadow: boolean;
        seriesLighting: boolean;
        seriesShowShadow: boolean;
        seriesLabelsLineColor: Color;
        trendLineColor: Color;
        trendLineShowShadow: boolean;
        seriesLabelsBrush: StiBrush;
        seriesLabelsColor: Color;
        seriesLabelsBorderColor: Color;
        legendBrush: StiBrush;
        legendLabelsColor: Color;
        legendBorderColor: Color;
        legendTitleColor: Color;
        axisTitleColor: Color;
        axisLineColor: Color;
        axisLabelsColor: Color;
        markerVisible: boolean;
        interlacingHorBrush: StiBrush;
        interlacingVertBrush: StiBrush;
        gridLinesHorColor: Color;
        gridLinesVertColor: Color;
        brushType: StiBrushType;
        styleColors: Color[];
        basicStyleColor: Color;
        allowUseBorderFormatting: boolean;
        allowUseBorderSides: boolean;
        allowUseBrush: boolean;
        /** Gets a style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Styles {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTableStyle = Stimulsoft.Report.StiTableStyle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMapStyleFX = Stimulsoft.Report.Maps.StiMapStyleFX;
    import StiDialogStyle = Stimulsoft.Report.Styles.StiDialogStyle;
    import StiCrossTabStyle = Stimulsoft.Report.Styles.StiCrossTabStyle;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import StiMapStyleIdent = Stimulsoft.Report.Maps.StiMapStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import FontFamily = Stimulsoft.System.Drawing.FontFamily;
    import StiChartStyle = Stimulsoft.Report.Styles.StiChartStyle;
    class StiDashboardStyleHelper {
        private static iconFontFamily;
        private static cloneColors;
        static getCopyChartStyle(chartStyle: IStiChartStyle, element: IStiChartElement): StiChartStyle;
        static getCopyTableStyle(tableStyle: StiTableElementStyle): StiTableStyle;
        static convertToReportGaugeStyle(element: IStiGaugeElement): StiGaugeStyle;
        static convertToReportPivotTableStyle(element: IStiPivotTableElement): StiCrossTabStyle;
        static convertToReportIndicatorStyle(element: IStiIndicatorElement): StiIndicatorStyle;
        static convertToReportProgressStyle(element: IStiProgressElement): StiProgressStyle;
        static convertToReportRegionMapStyle(element: IStiRegionMapElement): StiMapStyle;
        static convertToReportControlStyle(element: IStiControlElement): StiDialogStyle;
        static getDashboardBackColor(dashboard: IStiDashboard, isViewer: boolean): Color;
        static isDarkStyle(dashboard: IStiDashboard): boolean;
        static isDarkStyle3(element: IStiElement): boolean;
        static isDarkStyle2(ident: StiElementStyleIdent): boolean;
        static getFont(element: IStiControlElement): Font;
        static getForeColor(element: IStiElement, defaultColor?: Color): Color;
        static getStyleForeColor(element: IStiElement): Color;
        static getForeColor2(ident: StiElementStyleIdent): Color;
        static getNativeForeColor(element?: IStiElement): Color;
        static getSelectedForeColor(element: IStiControlElement): Color;
        static getSelectedBackColor(element: IStiControlElement): Color;
        static getGlyphColor2(element: IStiControlElement): Color;
        static getGlyphColor(element: IStiIndicatorElement): Color;
        static getSeparatorColor(element: IStiControlElement): Color;
        static getBackColor(element: IStiElement, defaultColor?: Color): Color;
        static getStyleBackColor(element: IStiElement): Color;
        static getHotBackColor(element: IStiElement): Color;
        static getBackColor2(style: StiElementStyleIdent): Color;
        static getTitleForeColor(element: IStiElement): Color;
        static getGaugeStyle(element: IStiGaugeElement): IStiGaugeStyle;
        static getGaugeStyle2(style: StiElementStyleIdent): IStiGaugeStyle;
        static getChartStyle(element: IStiChartElement): IStiChartStyle;
        static getChartStyle2(style: StiElementStyleIdent): IStiChartStyle;
        static getMapStyleIdent(element: IStiRegionMapElement): StiMapStyleIdent;
        static getMapStyle(element: IStiRegionMapElement): StiMapStyleFX;
        static getMapStyle2(style: StiElementStyleIdent): StiMapStyleFX;
        static getControlStyle(element: IStiElement): StiControlElementStyle;
        static getIndicatorStyle(element: IStiIndicatorElement): StiIndicatorElementStyle;
        static getProgressStyle(element: IStiProgressElement): StiProgressElementStyle;
        static getTableStyle(element: IStiTableElement): StiTableElementStyle;
        static getPivotTableStyle(element: IStiPivotTableElement): StiPivotElementStyle;
        static getStyle(element: IStiElement): StiElementStyleIdent;
        static getIconFontFamily(): FontFamily;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Visuals {
    import Promise = Stimulsoft.System.Promise;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    var IStiGaugeVisualSvgHelper: string;
    interface IStiGaugeVisualSvgHelper {
        writeGaugeAsync(writer: XmlTextWriter, svgData: StiSvgData, needAnimation: boolean): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Visuals {
    import Promise = Stimulsoft.System.Promise;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    var IStiIndicatorVisualSvgHelper: string;
    interface IStiIndicatorVisualSvgHelper {
        writeIndicatorAsync(writer: XmlTextWriter, svgData: StiSvgData): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard.Visuals {
    import Promise = Stimulsoft.System.Promise;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    var IStiProgressVisualSvgHelper: string;
    interface IStiProgressVisualSvgHelper {
        writeProgressAsync(writer: XmlTextWriter, svgData: StiSvgData): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiChartArea: string;
    var ImplementsIStiChartArea: any[];
    interface IStiChartArea {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    var IStiChartDashboardInteraction: string;
    var ImplementsIStiChartDashboardInteraction: string[];
    interface IStiChartDashboardInteraction extends IStiDashboardInteraction {
        allowUserDrillDown: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    import IStiRetrieval = Stimulsoft.Data.Engine.IStiRetrieval;
    var IStiElement: string;
    var ImplementsIStiElement: any[];
    interface IStiElement extends IStiReportComponent, IStiRetrieval {
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        getNestedPages(): List<StiPage>;
        key: string;
        report: StiReport;
        page: StiPage;
        name: string;
        zoom: number;
        isDefined: boolean;
        isDesigning: boolean;
        isEnabled: boolean;
        isQuerable: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiGroupElement: string;
    var ImplementsIStiGroupElement: any[];
    interface IStiGroupElement {
        group: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiDashboardElementStyle: string;
    var ImplementsIStiDashboardElementStyle: any[];
    interface IStiDashboardElementStyle {
        style: StiElementStyleIdent;
        customStyleName: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    var IStiConvertibleElement: string;
    var ImplementsIStiConvertibleElement: any[];
    interface IStiConvertibleElement {
        convertFrom(element: IStiElement): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    var IStiChartElement: string;
    var ImplementsIStiChartElement: any[];
    interface IStiChartElement extends IStiElement, IStiUserFilters, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiDataFilters, IStiConvertibleElement {
        addValue(dataColumn: StiDataColumn): any;
        getValue2(dataColumn: StiDataColumn): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        getValueByIndex(index: number): IStiMeter;
        insertValue(index: number, meter: IStiMeter): any;
        removeValue(index: number): any;
        removeAllValues(): any;
        createNewValue(): IStiMeter;
        addEndValue(dataColumn: StiDataColumn): any;
        getEndValue2(dataColumn: StiDataColumn): IStiMeter;
        getEndValue(meter: IStiMeter): IStiMeter;
        getEndValueByIndex(index: number): IStiMeter;
        insertEndValue(index: number, meter: IStiMeter): any;
        removeEndValue(index: number): any;
        removeAllEndValues(): any;
        createNewEndValue(): IStiMeter;
        addCloseValue(dataColumn: StiDataColumn): any;
        getCloseValue2(dataColumn: StiDataColumn): IStiMeter;
        getCloseValue(meter: IStiMeter): IStiMeter;
        getCloseValueByIndex(index: number): IStiMeter;
        insertCloseValue(index: number, meter: IStiMeter): any;
        removeCloseValue(index: number): any;
        removeAllCloseValues(): any;
        createNewCloseValue(): IStiMeter;
        addLowValue(dataColumn: StiDataColumn): any;
        getLowValue2(dataColumn: StiDataColumn): IStiMeter;
        getLowValue(meter: IStiMeter): IStiMeter;
        getLowValueByIndex(index: number): IStiMeter;
        insertLowValue(index: number, meter: IStiMeter): any;
        removeLowValue(index: number): any;
        removeAllLowValues(): any;
        createNewLowValue(): IStiMeter;
        addHighalue(dataColumn: StiDataColumn): any;
        getHighValue2(dataColumn: StiDataColumn): IStiMeter;
        getHighValue(meter: IStiMeter): IStiMeter;
        getHighValueByIndex(index: number): IStiMeter;
        insertHighValue(index: number, meter: IStiMeter): any;
        removeHighValue(index: number): any;
        removeAllHighValues(): any;
        createNewHighValue(): IStiMeter;
        addArgument(dataColumn: StiDataColumn): any;
        getArgument2(dataColumn: StiDataColumn): IStiMeter;
        getArgument(meter: IStiMeter): IStiMeter;
        getArgumentByIndex(index: number): IStiMeter;
        insertArgument(index: number, meter: IStiMeter): any;
        removeArgument(index: number): any;
        removeAllArguments(): any;
        createNewArgument(): any;
        addWeight(dataColumn: StiDataColumn): any;
        getWeight2(dataColumn: StiDataColumn): IStiMeter;
        getWeight(meter: IStiMeter): IStiMeter;
        getWeightByIndex(index: number): IStiMeter;
        insertWeight(index: number, meter: IStiMeter): any;
        removeWeight(index: number): any;
        removeAllWeights(): any;
        createNewWeight(): any;
        addSeries(dataColumn: StiDataColumn): any;
        getSeries2(dataColumn: StiDataColumn): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        getSeries3(): IStiMeter;
        insertSeries(meter: IStiMeter): any;
        removeSeries(): any;
        createNewSeries(): any;
        convertToBubble(): any;
        convertFromBubble(): any;
        checkBrowsableProperties(): any;
        getChartSeriesTypes(seriesTypeStr: string): List<string>;
        isAxisAreaChart: boolean;
        isPieChart: boolean;
        isDoughnutChart: boolean;
        argumentFormat: StiFormatService;
        valueFormat: StiFormatService;
        colorEach: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiChartLabels: string;
    var ImplementsIStiChartLabels: any[];
    interface IStiChartLabels {
        position: StiChartLabelsPosition;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiItemElement: string;
    var ImplementsIStiItemElement: any[];
    interface IStiItemElement {
        selectionMode: StiItemSelectionMode;
        showAllValue: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import Promise = Stimulsoft.System.Promise;
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    var IStiFilterElement: string;
    var ImplementsIStiFilterElement: any[];
    interface IStiFilterElement extends IStiAppCell, IStiConvertibleElement {
        getParentKey(): string;
        setParentKey(key: string): any;
        applyDefaultFiltersAsync(): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiFilterElement = Stimulsoft.Report.Dashboard.IStiFilterElement;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    var IStiControlElement: string;
    var ImplementsIStiControlElement: any[];
    interface IStiControlElement extends IStiElement, IStiDashboardElementStyle, IStiUserFilters, IStiFilterElement, IStiFont, IStiForeColor, IStiBackColor, IStiTextFormat {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiItemElement = Stimulsoft.Report.Dashboard.IStiItemElement;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiControlElement = Stimulsoft.Report.Dashboard.IStiControlElement;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiComboBoxElement: string;
    var ImplementsIStiComboBoxElement: any[];
    interface IStiComboBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        addKeyMeter2(dataColumn: StiDataColumn): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(dataColumn: StiDataColumn): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        createNextMeter(dataColumn: StiDataColumn): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    var IStiPanel: string;
    var ImplementsIStiPanel: any[];
    interface IStiPanel extends IStiElement, IStiBackColor {
        getElements(nested: boolean, group: string): List<IStiElement>;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    import IStiPanel = Stimulsoft.Report.Dashboard.IStiPanel;
    import IStiDashboardElementStyle = Stimulsoft.Report.Dashboard.IStiDashboardElementStyle;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    var IStiDashboard: string;
    var ImplementsIStiDashboard: any[];
    interface IStiDashboard extends IStiPanel, IStiQueryObject, IStiDashboardElementStyle {
        getUserFilters(element: IStiElement): List<StiDataFilterRule>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiDashboardDrillDownParameter: string;
    var ImplementsIStiDashboardDrillDownParameter: any[];
    interface IStiDashboardDrillDownParameter {
        name: string;
        expression: string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import List = Stimulsoft.System.Collections.List;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    var IStiDashboardInteraction: string;
    var ImplementsIStiDashboardInteraction: string[];
    interface IStiDashboardInteraction extends ICloneable, IStiDefault {
        ident: StiInteractionIdent;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        hyperlinkDestination: StiInteractionOpenHyperlinkDestination;
        toolTip: string;
        hyperlink: string;
        drillDownPageKey: string;
        getDrillDownParameters(): List<IStiDashboardDrillDownParameter>;
        setDrillDownParameters(drillDownParameters: any[]): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiDatePickerElement: string;
    var ImplementsIStiDatePickerElement: any[];
    interface IStiDatePickerElement extends IStiControlElement, IStiDataFilters {
        addValueMeter2(dataColumn: StiDataColumn): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        condition: StiDateCondition;
        selectionMode: StiDateSelectionMode;
        initialRangeSelection: StiInitialDateRangeSelection;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    var IStiElementInteraction: string;
    interface IStiElementInteraction {
        dashboardInteraction: IStiDashboardInteraction;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    var IStiElementLayout: string;
    var ImplementsIStiElementLayout: any[];
    interface IStiElementLayout {
        layout: StiElementLayout;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiFixedHeightElement: string;
    var ImplementsIStiFixedHeightElement: any[];
    interface IStiFixedHeightElement {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiGaugeRangeMode = Stimulsoft.Report.Gauge.StiGaugeRangeMode;
    import StiGaugeRangeType = Stimulsoft.Report.Gauge.StiGaugeRangeType;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiGaugeElement: string;
    var ImplementsIStiGaugeElement: any[];
    interface IStiGaugeElement extends IStiElement, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters, IStiConvertibleElement {
        addValue2(dataColumn: StiDataColumn): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addSeries2(dataColumn: StiDataColumn): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        rangeType: StiGaugeRangeType;
        rangeMode: StiGaugeRangeMode;
        getRanges(): List<IStiGaugeRange>;
        addRange(): IStiGaugeRange;
        removeRange(index: number): any;
        createdDefaultRanges(): any;
        calculationMode: StiGaugeCalculationMode;
        type: StiGaugeType;
        minimum: number;
        maximum: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiGaugeRange: string;
    var ImplementsIStiGaugeRange: any[];
    interface IStiGaugeRange {
        color: Color;
        start: number;
        end: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    interface IStiHtmlTextHelper {
        setFontName(textObj: any, text: string, fontName: string, defaultColor: Color): string;
        setFontSize(textObj: any, text: string, fontSize: number, defaultColor: Color): string;
        growFontSize(textObj: any, text: string, defaultColor: Color): string;
        shrinkFontSize(textObj: any, text: string, defaultColor: Color): string;
        setFontBoldStyle(textObj: any, text: string, isBold: boolean, defaultColor: Color): string;
        setFontItalicStyle(textObj: any, text: string, isItalic: boolean, defaultColor: Color): string;
        setFontUnderlineStyle(textObj: any, text: string, isUnderline: boolean, defaultColor: Color): string;
        setColor(textObj: any, text: string, color: Color, defaultColor: Color): string;
        setHorAlignment(textObj: any, text: string, alignment: StiTextHorAlignment, defaultColor: Color): string;
        getFont(textObj: any, text: string, defaultColor: Color): Font;
        getColor(textObj: any, text: string, defaultColor: Color): Color;
        getHorAlign(textObj: any, text: string, defaultColor: Color): StiTextHorAlignment;
        getSimpleText(htmlText: string, defaultColor: Color): string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Image = Stimulsoft.System.Drawing.Image;
    var IStiImageElement: string;
    var ImplementsIStiImageElement: any[];
    interface IStiImageElement extends IStiElement {
        image: Image;
        imageHyperlink: string;
        aspectRatio: boolean;
        copyAllImageProperties(element: IStiImageElement): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    var IStiIndicatorElement: string;
    var ImplementsIStiIndicatorElement: any[];
    interface IStiIndicatorElement extends IStiElement, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiDataFilters {
        addValue2(dataColumn: StiDataColumn): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addTarget2(dataColumn: StiDataColumn): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        addSeries2(dataColumn: StiDataColumn): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        iconSet: StiFontIconSet;
        icon: StiFontIcons;
        glyphColor: Color;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiListBoxElement: string;
    var ImplementsIStiListBoxElement: any[];
    interface IStiListBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        addKeyMeter2(dataColumn: StiDataColumn): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(dataColumn: StiDataColumn): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        createNextMeter(dataColumn: StiDataColumn): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiMargin: string;
    var ImplementsIStiMargin: any[];
    /**
     *  Describes margins around component.
     */
    interface IStiMargin {
        /**
         *  Gets or sets a margin of the element.
         */
        margin: StiMargin;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiNegativeSeriesColors: string;
    var ImplementsIStiNegativeSeriesColors: any[];
    interface IStiNegativeSeriesColors {
        negativeSeriesColors: Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiOnlineMapElement: string;
    var ImplementsIStiOnlineMapElement: any[];
    interface IStiOnlineMapElement extends IStiElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        createNextMeter(dataColumn: StiDataColumn): any;
        addLatitudeMeter2(dataColumn: StiDataColumn): any;
        addLatitudeMeter(meter: IStiMeter): any;
        getLatitudeMeter(): IStiMeter;
        removeLatitudeMeter(): any;
        createNewLatitudeMeter(): any;
        addLongitudeMeter2(dataColumn: StiDataColumn): any;
        addLongitudeMeter(meter: IStiMeter): any;
        getLongitudeMeter(): IStiMeter;
        removeLongitudeMeter(): any;
        createNewLongitudeMeter(): any;
        addLocationMeter2(dataColumn: StiDataColumn): any;
        addLocationMeter(meter: IStiMeter): any;
        getLocationMeter(): IStiMeter;
        removeLocationMeter(): any;
        createNewLocationMeter(): any;
        addLocationColorMeter2(dataColumn: StiDataColumn): any;
        addLocationColorMeter(meter: IStiMeter): any;
        getLocationColorMeter(): IStiMeter;
        removeLocationColorMeter(): any;
        createNewLocationColorMeter(): any;
        addLocationValueMeter2(dataColumn: StiDataColumn): any;
        addLocationValueMeter(meter: IStiMeter): any;
        getLocationValueMeter(): IStiMeter;
        removeLocationValueMeter(): any;
        createNewLocationValueMeter(): any;
        locationType: StiOnlineMapLocationType;
        culture: StiOnlineMapCulture;
        locationColor: Color;
        locationColorType: StiOnlineMapLocationColorType;
        valueViewMode: StiOnlineMapValueViewMode;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiPadding: string;
    var ImplementsIStiPadding: any[];
    /**
     *  Describes padding around component.
     */
    interface IStiPadding {
        /**
         *  Gets or sets a padding of the element.
         */
        padding: StiPadding;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    var IStiPivotTableCreator: string;
    var ImplementsIStiPivotTableCreator: any[];
    interface IStiPivotTableCreator {
        create(element: IStiPivotTableElement, dataTable: StiDataTable): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiPivotGridContainer: string;
    var ImplementsIStiPivotGridContainer: any[];
    interface IStiPivotGridContainer {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiPivotTableElement: string;
    var ImplementsIStiPivotTableElement: any[];
    interface IStiPivotTableElement extends IStiElement, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters, IStiConvertibleElement {
        createNewColumn(): any;
        getColumn2(dataColumn: StiDataColumn): IStiMeter;
        getColumn(meter: IStiMeter): IStiMeter;
        getColumnByIndex(index: number): IStiMeter;
        insertColumn(index: number, meter: IStiMeter): any;
        removeColumn(index: number): any;
        removeAllColumns(): any;
        createNewRow(): any;
        getRow2(dataColumn: StiDataColumn): IStiMeter;
        getRow(meter: IStiMeter): IStiMeter;
        getRowByIndex(index: number): IStiMeter;
        insertRow(index: number, meter: IStiMeter): any;
        removeRow(index: number): any;
        removeAllRows(): any;
        createNewSummary(): any;
        getSummary2(dataColumn: StiDataColumn): IStiMeter;
        getSummary(meter: IStiMeter): IStiMeter;
        getSummaryByIndex(index: number): IStiMeter;
        insertSummary(index: number, meter: IStiMeter): any;
        removeSummary(index: number): any;
        removeAllSummaries(): any;
        createNextMeter(dataColumn: StiDataColumn): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import IStiDataTransformationElement = Stimulsoft.Data.Engine.IStiDataTransformationElement;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiProgressElement: string;
    var ImplementsIStiProgressElement: any[];
    interface IStiProgressElement extends IStiElement, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiDataTopN, IStiDataTransformationElement, IStiGroupElement, IStiDataFilters, IStiConvertibleElement {
        colorEach: boolean;
        addValue2(dataColumn: StiDataColumn): any;
        addValue(meter: IStiMeter): any;
        removeValue(): any;
        getValue(): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        createNewValue(): any;
        addTarget2(dataColumn: StiDataColumn): any;
        addTarget(meter: IStiMeter): any;
        removeTarget(): any;
        getTarget(): IStiMeter;
        getTarget(meter: IStiMeter): IStiMeter;
        createNewTarget(): any;
        addSeries2(dataColumn: StiDataColumn): any;
        addSeries(meter: IStiMeter): any;
        removeSeries(): any;
        getSeries(): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        createNewSeries(): any;
        mode: StiProgressElementMode;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import StiMapID = Stimulsoft.Report.Maps.StiMapID;
    import StiMapSource = Stimulsoft.Report.Maps.StiMapSource;
    import StiMapType = Stimulsoft.Report.Maps.StiMapType;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiDisplayNameType = Stimulsoft.Report.Maps.StiDisplayNameType;
    var IStiRegionMapElement: string;
    var ImplementsIStiRegionMapElement: any[];
    interface IStiRegionMapElement extends IStiElement, IStiDashboardElementStyle, IStiUserFilters, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        mapID: StiMapID;
        dataFrom: StiMapSource;
        mapData: string;
        mapType: StiMapType;
        showValue: boolean;
        colorEach: boolean;
        shortValue: boolean;
        showName: StiDisplayNameType;
        getMapData(): List<StiMapData>;
        createNextMeter(dataColumn: StiDataColumn): any;
        addKeyMeter2(dataColumn: StiDataColumn): any;
        addKeyMeter(meter: IStiMeter): any;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): any;
        createNewKeyMeter(): any;
        addNameMeter2(dataColumn: StiDataColumn): any;
        addNameMeter(meter: IStiMeter): any;
        getNameMeter(): IStiMeter;
        removeNameMeter(): any;
        createNewNameMeter(): any;
        addValueMeter2(dataColumn: StiDataColumn): any;
        addValueMeter(meter: IStiMeter): any;
        getValueMeter(): IStiMeter;
        removeValueMeter(): any;
        createNewValueMeter(): any;
        addGroupMeter2(dataColumn: StiDataColumn): any;
        addGroupMeter(meter: IStiMeter): any;
        getGroupMeter(): IStiMeter;
        removeGroupMeter(): any;
        createNewGroupMeter(): any;
        addColorMeter2(dataColumn: StiDataColumn): any;
        addColorMeter(meter: IStiMeter): any;
        getColorMeter(): IStiMeter;
        removeColorMeter(): any;
        createNewColorMeter(): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    var IStiSeriesColors: string;
    var ImplementsIStiSeriesColors: any[];
    interface IStiSeriesColors {
        seriesColors: Color[];
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiShapeTypeService = Stimulsoft.Report.Components.StiShapeTypeService;
    var IStiShapeElement: string;
    var ImplementsIStiShapeElement: any[];
    interface IStiShapeElement extends IStiElement {
        shapeType: StiShapeTypeService;
        stroke: Color;
        fill: StiBrush;
        size: number;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiSkipOwnFilter: string;
    var ImplementsIStiSkipOwnFilter: any[];
    interface IStiSkipOwnFilter {
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    var IStiTableDashboardInteraction: string;
    var ImplementsIStiTableDashboardInteraction: string[];
    interface IStiTableDashboardInteraction extends IStiDashboardInteraction {
        allowUserSorting: boolean;
        allowUserFiltering: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiConvertibleElement = Stimulsoft.Report.Dashboard.IStiConvertibleElement;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiUserFilters = Stimulsoft.Data.Engine.IStiUserFilters;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    import IStiUserSorts = Stimulsoft.Data.Engine.IStiUserSorts;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTableSizeMode = Stimulsoft.Report.Dashboard.StiTableSizeMode;
    var IStiTableElement: string;
    var ImplementsIStiTableElement: any[];
    interface IStiTableElement extends IStiElement, IStiUserSorts, IStiUserFilters, IStiDashboardElementStyle, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters, IStiFont, IStiConvertibleElement {
        createMeters(tableElement: IStiTableElement): any;
        createMeters2(dataSource: StiDataSource): any;
        createMeter3(dataColumn: StiDataColumn): any;
        removeMeter(index: number): any;
        removeAllMeters(): any;
        insertMeter(index: number, meter: IStiMeter): any;
        insertNewDimension(index: number): any;
        insertNewMeasure(index: number): any;
        getMeasure(dataColumn: StiDataColumn): IStiMeter;
        getDimension(dataColumn: StiDataColumn): IStiMeter;
        headerFont: Font;
        headerForeColor: Color;
        sizeMode: StiTableSizeMode;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiTableElementAutoSizer: string;
    var ImplementsIStiTableElementAutoSizer: any[];
    interface IStiTableElementAutoSizer {
        autoMeasureToTable(tableElement: IStiTableElement): any;
        autoMeasureToColumn(tableElement: IStiTableElement): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiTextElement: string;
    var ImplementsIStiTextElement: any[];
    interface IStiTextElement extends IStiElement {
        text: string;
        getSimpleText(): string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    var IStiTitle: string;
    var ImplementsIStiTitle: any[];
    interface IStiTitle extends IStiFont, IStiHorAlignment, IStiForeColor, IStiBackColor {
        /**
         *  Gets or sets title text.
         */
        text: string;
        /**
         *  Gets or sets visibility of title.
         */
        visible: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    var IStiTitleElement: string;
    var ImplementsIStiTitleElement: any[];
    interface IStiTitleElement {
        title: IStiTitle;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiTreeViewBoxElement: string;
    var ImplementsIStiTreeViewBoxElement: any[];
    interface IStiTreeViewBoxElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        getKeyMeter(dataColumn: StiDataColumn): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): any;
        removeKeyMeter(index: number): any;
        removeAllKeyMeters(): any;
        addKey(dataColumn: StiDataColumn): any;
        addNewKeyMeter(): IStiMeter;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
    import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
    import IStiTransformSorts = Stimulsoft.Data.Engine.IStiTransformSorts;
    import IStiDataFilters = Stimulsoft.Data.Engine.IStiDataFilters;
    var IStiTreeViewElement: string;
    var ImplementsIStiTreeViewElement: any[];
    interface IStiTreeViewElement extends IStiControlElement, IStiItemElement, IStiTransformActions, IStiTransformFilters, IStiTransformSorts, IStiGroupElement, IStiDataFilters {
        getKeyMeter(dataColumn: StiDataColumn): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): any;
        removeKeyMeter(index: number): any;
        removeAllKeyMeters(): any;
        addKey(dataColumn: StiDataColumn): any;
        addNewKeyMeter(): IStiMeter;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiOnlineMapLastImageCache {
        private static cache;
        private static getKey;
        static getLastImage(element: IStiOnlineMapElement): Image;
        static existsLastImage(element: IStiOnlineMapElement): boolean;
        static storeLastImage(element: IStiOnlineMapElement, image: Image): void;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiPivotToConvertedStateCache {
        private static cache;
        private static getIntKey;
        private static getKey;
        static isConverted(element: IStiPivotTableElement): boolean;
        static putTrue(element: IStiPivotTableElement): void;
        static putFalse(element: IStiPivotTableElement): void;
        private static put;
        static contains(element: IStiPivotTableElement): boolean;
        static clean(reportKey?: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiPivotTableToCrossTabCache {
        private static cache;
        private static getKey;
        static get(element: IStiPivotTableElement): StiCrossTab;
        static put(element: IStiPivotTableElement, crossTab: StiCrossTab): void;
        static contains(element: IStiPivotTableElement): boolean;
        static remove(element: IStiPivotTableElement): void;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiPivotToContainerCache {
        private static cache;
        static get(element: IStiPivotTableElement): IStiPivotGridContainer;
        static put(element: IStiPivotTableElement, container: IStiPivotGridContainer): void;
        static remove(element: IStiPivotTableElement): void;
        static contains(element: IStiPivotTableElement): boolean;
        static clean(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiReportComponent = Stimulsoft.Base.IStiReportComponent;
    class StiReportParser {
        private static cache;
        static parse(expression: string, component: IStiReportComponent, allowCache?: boolean): string;
        private static parseOrDefault;
        private static tryParse;
        private static getCacheKey;
        static addToCache(expression: string, result: string, component: IStiReportComponent): void;
        static getFromCache(expression: string, component: IStiReportComponent): string;
        static cleanCache(reportKey: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiApp = Stimulsoft.Base.IStiApp;
    class StiCacheCleaner {
        static clean(element?: IStiElement | IStiAppDictionary | IStiApp | string): void;
        static clean1(element: IStiElement): void;
        static clean2(dictionary: IStiAppDictionary): void;
        static clean3(app: IStiApp): void;
        static clean4(reportKey?: string): void;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiDashboardAssembly {
        static readonly isAssemblyLoaded: boolean;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    class StiDashboardCreator {
        static createDashboard(report: StiReport): IStiDashboard;
        static createDashboardElement(typeComponent: string): StiComponent;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiDashboardDesignAssembly {
        static getHtmlTextHelper(): IStiHtmlTextHelper;
    }
}
declare namespace Stimulsoft.Report.Export {
    /**
     *  Enumeration for setting compression scheme of the exported Tiff image.
     */
    enum StiTiffCompressionScheme {
        Default = 20,
        LZW = 2,
        CCITT3 = 3,
        CCITT4 = 4,
        Rle = 5,
        None = 6
    }
    /**
     *  Enumeration which sets an exported mode for the Html export.
     */
    enum StiHtmlExportMode {
        /**
         *  A span tag of the HTML will be used for the exporting of the rendered document.
         */
        Span = 1,
        /**
         *  A div tag of the HTML will be used for the exporting of the rendered document.
         */
        Div = 2,
        /**
         *  A table tag of the HTML will be used for the exporting of the rendered document.
         */
        Table = 3
    }
    /**
     *  Enumeration which sets a quality of images which will be exported.
     */
    enum StiHtmlExportQuality {
        /**
         *  Sets a high quality of the exported images.
         */
        High = 1,
        /**
         *  Sets a low quality of the exported images.
         */
        Low = 2
    }
    /**
     *  Enumeration describes possible user access privileges to the pdf document.
     *  User access privileges are managed by the user password.
     *  Owner with the correct owner password has all possible privileges for the content of the
     *  pdf document and a rule for setting document permissions.
     */
    enum StiUserAccessPrivileges {
        /**
         *  User password allows only opening the pdf document, decrypt it, and display it on the screen.
         */
        None = 0,
        /**
         *  User password allows opening the pdf document, decrypt it, display it on the screen and print
         *  its content.
         */
        PrintDocument = 1,
        /**
         *  User password allows modifying the content of the pdf document.
         */
        ModifyContents = 2,
        /**
         *  User password allows copying text and graphics objects from the content of the pdf document.
         */
        CopyTextAndGraphics = 4,
        /**
         *  User password allows adding or modifying text annotations in the content of the pdf document.
         */
        AddOrModifyTextAnnotations = 8,
        /**
         *  User password allows all modifications on the content of the pdf document.
         */
        All = 15
    }
    /**
     *  Enumeration which sets an encryption key length of the resulting pdf file.
     */
    enum StiPdfEncryptionKeyLength {
        /**
         *  RC4 algorithm, 40 bit encryption key length (Acrobat 3).
         */
        Bit40 = 1,
        /**
         *  RC4 algorithm, 128 bit encryption key length (Acrobat 5).
         */
        Bit128 = 2,
        /**
         *  AES algorithm, 128 bit encryption key length, revision 4 (Acrobat 7).
         */
        Bit128_r4 = 3,
        /**
         *  AES algorithm, 256 bit encryption key length, revision 5 (Acrobat 9).
         */
        Bit256_r5 = 4,
        /**
         *  AES algorithm, 256 bit encryption key length, revision 6 (Acrobat X).
         */
        Bit256_r6 = 5
    }
    /**
     *  Enumeration which sets an image compression method for PDF export.
     */
    enum StiPdfImageCompressionMethod {
        /**
         *  A Jpeg method (DCTDecode) will be used for the exporting of the rendered document.
         */
        Jpeg = 1,
        /**
         *  A Flate method (FlateDecode) will be used for the exporting of the rendered document.
         */
        Flate = 2,
        /**
         *  A Indexed method (IndexedColors + FlateDecode) will be used for the exporting of the rendered document.
         */
        Indexed = 3
    }
    /**
     *  Enumeration which sets an AutoPrint mode for pdf files
     */
    enum StiPdfAutoPrintMode {
        /**
         *  Do not use AutoPrint feature
         */
        None = 1,
        /**
         *  Use printing with print dialog
         */
        Dialog = 2,
        /**
         *  Use silent printing
         */
        Silent = 3
    }
    /**
     *  Enumeration describes a type of the border.
     */
    enum StiTxtBorderType {
        /**
         *  A border which consists of "+","-","|" symbols.
         */
        Simple = 1,
        /**
         *  A border which consists of character graphics symbols.
         *  A Single type of the border.
         */
        UnicodeSingle = 2,
        /**
         *  A border consists of character graphics symbols.
         *  A Double type of the border.
         */
        UnicodeDouble = 3
    }
    /**
     *  Enumeration describes a type of palette of the PCX file.
     */
    enum StiPcxPaletteType {
        /**
         *  Monochrome palette (1 bit)
         */
        Monochrome = 1,
        /**
         *  Color palette (24 bit)
         */
        Color = 2
    }
    /**
     *  Enumeration describes a type of dithering for monochrome PCX file.
     */
    enum StiMonochromeDitheringType {
        /**
         *  Without dithering.
         *  Low quality, small size of file.
         */
        None = 1,
        /**
         *  Floyd-Steinberg dithering.
         *  Good quality, big size of file.
         */
        FloydSteinberg = 2,
        /**
         *  Ordered dithering with Bayer matrix 4x4.
         *  Poor quality, medium size of file.
         */
        Ordered = 3
    }
    /**
     *  Enumeration describes a type of the images for the exports.
     */
    enum StiImageType {
        Bmp = 1,
        Gif = 2,
        Jpeg = 3,
        Pcx = 4,
        Png = 5,
        Tiff = 6,
        Emf = 7,
        Svg = 8,
        Svgz = 9
    }
    /**
     *  Enumeration describes a type of the html exports.
     */
    enum StiHtmlType {
        Html = 1,
        Html5 = 2,
        Mht = 3
    }
    /**
     *  Enumeration describes a type of the chart in the html exports.
     */
    enum StiHtmlChartType {
        Image = 1,
        Vector = 2,
        AnimatedVector = 3
    }
    /**
     *  Enumeration describes a type of the excel exports.
     */
    enum StiExcelType {
        /**
         *  Excel format from Office 97 to Office 2003.
         */
        ExcelBinary = 1,
        /**
         *  Xml Excel format starts from Office 2003.
         */
        ExcelXml = 2,
        /**
         *  Excel format starts from Office 2007.
         */
        Excel2007 = 3
    }
    /**
     *  Enumeration describes a type of the data exports.
     */
    enum StiDataType {
        Csv = 1,
        Dbf = 2,
        Dif = 3,
        Sylk = 4,
        Xml = 5,
        Json = 6
    }
    /**
     *  Enumeration which defines a position of the export item in the export menu.
     */
    enum StiExportPosition {
        Pdf = 0,
        Xps = 1,
        Ppt2007 = 2,
        Html = 10,
        Html5 = 11,
        Mht = 12,
        Txt = 20,
        Rtf = 21,
        Word2007 = 22,
        Odt = 23,
        Excel = 30,
        ExcelXml = 31,
        Excel2007 = 32,
        Ods = 33,
        Data = 40,
        Dbf = 41,
        Xml = 42,
        Dif = 43,
        Sylk = 44,
        Image = 50,
        Bmp = 50,
        Gif = 51,
        Jpeg = 52,
        Pcx = 53,
        Png = 54,
        Tiff = 55,
        Emf = 60,
        Svg = 61,
        Svgz = 62
    }
    enum StiHtmlExportBookmarksMode {
        BookmarksOnly = 1,
        ReportOnly = 2,
        All = 3
    }
    /**
     *  Enumeration for setting Code Pages.
     */
    enum StiDbfCodePages {
        /**
         *  A parameter indicating that the code page of the exported document will not be specified.
         */
        Default = 0,
        /**
         *  A code page of the exported document is U.S. MS-DOS. Code page number 437.
         */
        USDOS = 437,
        /**
         *  A code page of the exported document is Mazovia (Polish) MS-DOS. Code page number 620.
         */
        MazoviaDOS = 620,
        /**
         *  A code page of the exported document is Greek MS-DOS (437G). Code page number 737.
         */
        GreekDOS = 737,
        /**
         *  A code page of the exported document is International MS-DOS. Code page number 850.
         */
        InternationalDOS = 850,
        /**
         *  A code page of the exported document is Eastern European MS-DOS. Code page number 852.
         */
        EasternEuropeanDOS = 852,
        /**
         *  A code page of the exported document is Icelandic MS-DOS. Code page number 861.
         */
        IcelandicDOS = 861,
        /**
         *  A code page of the exported document is Nordic MS-DOS. Code page number 865.
         */
        NordicDOS = 865,
        /**
         *  A code page of the exported document is Russian MS-DOS. Code page number 866.
         */
        RussianDOS = 866,
        /**
         *  A code page of the exported document is Kamenicky (Czech) MS-DOS. Code page number 895.
         */
        KamenickyDOS = 895,
        /**
         *  A code page of the exported document is Turkish MS-DOS. Code page number 857.
         */
        TurkishDOS = 857,
        /**
         *  A code page of the exported document is EasternEuropean MS-DOS. Code page number 1250.
         */
        EasternEuropeanWindows = 1250,
        /**
         *  A code page of the exported document is Russian Windows. Code page number 1251.
         */
        RussianWindows = 1251,
        /**
         *  A code page of the exported document is Windows ANSI. Code page number 1252.
         */
        WindowsANSI = 1252,
        /**
         *  A code page of the exported document is Greek Windows. Code page number 1253.
         */
        GreekWindows = 1253,
        /**
         *  A code page of the exported document is Turkish Windows. Code page number 1254.
         */
        TurkishWindows = 1254,
        /**
         *  A code page of the exported document is Standard Macintosh. Code page number 10000.
         */
        StandardMacintosh = 10000,
        /**
         *  A code page of the exported document is Greek Macintosh. Code page number 10006.
         */
        GreekMacintosh = 10006,
        /**
         *  A code page of the exported document is Russian Macintosh. Code page number 10007.
         */
        RussianMacintosh = 10007,
        /**
         *  A code page of the exported document is Eastern European Macintosh. Code page number 10029.
         */
        EasternEuropeanMacintosh = 10029
    }
    /**
     *  Enumeration for the types of data for the export.
     */
    enum StiExportDataType {
        /**
         *  A string type.
         */
        String = 0,
        /**
         *  An Integer32 type.
         */
        Int = 1,
        /**
         *  An Integer64 type.
         */
        Long = 2,
        /**
         *  A Float type.
         */
        Float = 3,
        /**
         *  A Double type.
         */
        Double = 4,
        /**
         *  A Data type.
         */
        Date = 5,
        /**
         *  A Boolean type.
         */
        Bool = 6
    }
    /**
     *  Enumeration for setting format of the exported images.
     */
    enum StiImageFormat {
        /**
         *  Images are exported in the color mode.
         */
        Color = 1,
        /**
         *  Images are exported in the grayscale mode.
         */
        Grayscale = 2,
        /**
         *  Images are exported in the monochrome mode.
         */
        Monochrome = 3
    }
    /**
     *  Enumeration for setting modes of the rtf export.
     */
    enum StiRtfExportMode {
        /**
         *
         */
        Table = 4,
        /**
         *
         */
        Frame = 1,
        /**
         *
         */
        WinWord = 2,
        /**
         *
         */
        TabbedText = 3
    }
    /**
     *  Enumeration for setting modes of the data export.
     */
    enum StiDataExportMode {
        /**
         *
         */
        Data = 1,
        /**
         *
         */
        Headers = 2,
        /**
         *
         */
        DataAndHeaders = 3,
        /**
         *
         */
        Footers = 4,
        /**
         *
         */
        HeadersFooters = 6,
        /**
         *
         */
        DataAndHeadersFooters = 7,
        /**
         *
         */
        AllBands = 15
    }
    /**
     *  Enumeration for setting modes of restrict editing
     */
    enum StiWord2007RestrictEditing {
        /**
         *  No restrictions
         */
        No = 1,
        /**
         *  Except Editable fields
         */
        ExceptEditableFields = 2,
        /**
         *  Yes
         */
        Yes = 3
    }
    /**
     *  Enumeration for setting modes of restrict editing
     */
    enum StiExcel2007RestrictEditing {
        /**
         *  No restrictions
         */
        No = 1,
        /**
         *  Except Editable fields
         */
        ExceptEditableFields = 2,
        /**
         *  Yes
         */
        Yes = 3
    }
    /**
     *  Enumeration for setting modes of restrict editing
     */
    enum StiPdfAllowEditable {
        /**
        ///
         */
        No = 1,
        /**
        ///
         */
        Yes = 2
    }
    /**
     *  Enumeration for setting modes of using of image resolution
     */
    enum StiImageResolutionMode {
        /**
        ///
         */
        Exactly = 1,
        /**
        ///
         */
        NoMoreThan = 2,
        /**
         *
         */
        Auto = 3
    }
    /**
     *  Enumeration for setting modes of compliance
     */
    enum StiPdfComplianceMode {
        /**
        ///
         */
        None = 0,
        /**
        ///
         */
        A1 = 1,
        /**
         *
         */
        A2 = 2,
        /**
         *
         */
        A3 = 3
    }
    /**
     *  Enumeration for setting modes of Excel sheet view
     */
    enum StiExcelSheetViewMode {
        /**
         *
         */
        Normal = 1,
        /**
         *
         */
        PageLayout = 2,
        /**
         *
         */
        PageBreakPreview = 3
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Promise = Stimulsoft.System.Promise;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiDashboardExport {
        static exportAsync(report: StiReport, stream: MemoryStream, settings: StiExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Report.Dashboards {
    import IStiTableElementAutoSizer = Stimulsoft.Report.Dashboard.IStiTableElementAutoSizer;
    import IStiProgressVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiProgressVisualSvgHelper;
    import IStiIndicatorVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiIndicatorVisualSvgHelper;
    import IStiGaugeVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiGaugeVisualSvgHelper;
    class StiDashboardHelperCreator {
        static createTableElementAutoSizer(): IStiTableElementAutoSizer;
        static createProgressVisualSvgHelper(): IStiProgressVisualSvgHelper;
        static createIndicatorVisualSvgHelper(): IStiIndicatorVisualSvgHelper;
        static createGaugeVisualSvgHelper(): IStiGaugeVisualSvgHelper;
    }
}
import StiElementMeterAction = Stimulsoft.Report.StiElementMeterAction;
declare namespace Stimulsoft.Report.Dashboard {
    class StiElementChangedArgs {
        action: StiElementMeterAction;
        oldName: string;
        newName: string;
        static createEmptyArgs(): StiElementChangedArgs;
        static createRenamingArgs(oldName: string, newName: string): StiElementChangedArgs;
        static createDeletingArgs(name: string): StiElementChangedArgs;
        static createClearingAllArgs(): StiElementChangedArgs;
    }
}
import IStiTransformActions = Stimulsoft.Data.Engine.IStiTransformActions;
import IStiTransformFilters = Stimulsoft.Data.Engine.IStiTransformFilters;
declare namespace Stimulsoft.Report.Dashboard {
    class StiElementChangedProcessor {
        static processElementChanging(element: any, args: StiElementChangedArgs): void;
        private static processElementRenaming;
        private static processElementClearing;
        private static processElementDeleting;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Promise = Stimulsoft.System.Promise;
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiElementDataCache {
        private static worker;
        private static elements;
        private static cache;
        private static pivotCreator;
        static tryToGetOrCreateAsync(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreateAsync(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreatePivotAsync(element: IStiPivotTableElement, creator: IStiPivotTableCreator, option?: StiDataRequestOption): Promise<IStiPivotGridContainer>;
        static getOrCreateWithProgressAsync(element: IStiElement, option?: StiDataRequestOption): Promise<StiDataTable>;
        static getOrCreatePivotWithProgressAsync(element: IStiPivotTableElement, creator: IStiPivotTableCreator, option?: StiDataRequestOption): Promise<IStiPivotGridContainer>;
        static get(element: IStiElement): StiDataTable;
        static createAsync(element: IStiElement, option: StiDataRequestOption): Promise<StiDataTable>;
        static add(element: IStiElement, dataTable: StiDataTable): void;
        private static initWorkerAsync;
        static getKey(element: IStiElement): string;
        static cleanCache(reportKey: string): void;
        private static getUserFilters;
        private static getUserSorts;
        private static getDataFilters;
        private static getTransformActions;
        private static getTransformFilters;
        private static getTransformSorts;
        private static getDrillDownFilters;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiElementLayout implements IStiJsonReportObject, ICloneable {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiElementLayout;
        static createFromXml(xmlNode: XmlNode): StiElementLayout;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): StiElementLayout;
        readonly isDefault: boolean;
        fullScreenButton: boolean;
        saveButton: boolean;
        StiElementLayout(): void;
        constructor(saveButton?: boolean, fullScreenButton?: boolean);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    class StiGroupElementHelper {
        static getGroup(element: IStiElement): string;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Type = Stimulsoft.System.Type;
    class StiInvokeMethodsHelper {
        static invokeStaticMethod(assemblyName: string, className: string, methodName: string, parameters?: any[], parametersTypes?: Type[]): any;
        static setPropertyValue(obj: any, propertyName: string, value: any): void;
        static getPropertyValue(obj: any, propertyName: string): any;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    /**
     *  Describes the class that realizes object margin.
     */
    class StiMargin implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets left margin size on the object.
         */
        left: number;
        /**
         *  Gets or sets top margin size on the object.
         */
        top: number;
        /**
         *  Gets or sets right margin size on the object.
         */
        right: number;
        /**
         *  Gets or sets bottom margin size on the object.
         */
        bottom: number;
        readonly isEmpty: boolean;
        /**
         *  Tests to see whether the specified object is a SizeD with the same dimensions as this SizeD.
         *  @param obj The Object to test.
         *  @returns This method returns true if obj is a SizeD and has the same width and height as this SizeD; otherwise, false.
         */
        stiEquals(obj: any): boolean;
        static empty: StiMargin;
        /**
         *  Creates a new object of the type StiMargin.
         *  @param all The margin size for all sides of the object.
         */
        static create(all?: number): StiMargin;
        /**
         *  Creates a new object of the type StiMargin.
         *  @param left Left margin size on the object.
         *  @param top Top margin size on the object.
         *  @param right Right margin size on the object.
         *  @param bottom Bottom margin size on the object.
         */
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    /**
     *  Describes the class that realizes object padding.
     */
    class StiPadding implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode, defLeft?: number, defTop?: number, defRight?: number, defBotttom?: number): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets left padding size on the object.
         */
        left: number;
        /**
         *  Gets or sets top padding size on the object.
         */
        top: number;
        /**
         *  Gets or sets right padding size on the object.
         */
        right: number;
        /**
         *  Gets or sets bottom padding size on the object.
         */
        bottom: number;
        readonly isEmpty: boolean;
        /**
         *  Tests to see whether the specified object is a SizeD with the same dimensions as this SizeD.
         *  @param obj The Object to test.
         *  @returns This method returns true if obj is a SizeD and has the same width and height as this SizeD; otherwise, false.
         */
        stiEquals(obj: any): boolean;
        static empty: StiPadding;
        /**
         *  Creates a new object of the type StiPadding.
         *  @param all The padding size for all sides of the object.
         */
        static create(all?: number): StiPadding;
        /**
         *  Creates a new object of the type StiPadding.
         *  @param left Left padding size on the object.
         *  @param top Top padding size on the object.
         *  @param right Right padding size on the object.
         *  @param bottom Bottom padding size on the object.
         */
        constructor(left: number, top: number, right: number, bottom: number);
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    class StiPredefinedColors {
        static sets: List<Color[]>;
        static negativeSets: List<Color[]>;
    }
}
declare namespace Stimulsoft.Report.Dashboard {
    import Font = Stimulsoft.System.Drawing.Font;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiStringMeasureCache {
        private static stringToSize;
        static getSize(font: Font, str: string): Size;
        static putSize(font: Font, str: string, size: Size): void;
        private static getHashCode;
    }
}
declare module Stimulsoft.Report {
    import Range = Stimulsoft.Report.Range;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    class RangeConverter extends TypeConverter {
        readonly GetPropertiesSupported: boolean;
        static rangeToString(range: Range): string;
        static stringToRange(str: string): Range;
        convertTo(context: any, culture: CultureInfo, value: any, destinationType: Stimulsoft.System.Type): any;
        canConvertFrom(context: any, sourceType: Stimulsoft.System.Type): boolean;
        canConvertTo(context: any, destinationType: Stimulsoft.System.Type): boolean;
        convertFrom(context: any, culture: CultureInfo, value: any): any;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiHundredthsOfInchUnit extends StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiCentimetersUnit extends StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiMillimetersUnit extends Stimulsoft.Report.Units.StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Design {
    import StiAction = Stimulsoft.Base.Drawing.StiAction;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiQuickInfoType = Stimulsoft.Report.Components.StiQuickInfoType;
    class StiDesignerInfo {
        clone(report: StiReport): StiDesignerInfo;
        private _forceDesigningMode;
        forceDesigningMode: boolean;
        private _quickInfoType;
        quickInfoType: StiQuickInfoType;
        private _generateLocalizedName;
        generateLocalizedName: boolean;
        private _showDimensionLines;
        showDimensionLines: boolean;
        private _quickInfoOverlay;
        quickInfoOverlay: boolean;
        private _isComponentsMoving;
        isComponentsMoving: boolean;
        private _currentAction;
        currentAction: StiAction;
        private _isTableMode;
        isTableMode: boolean;
        private _drawEventMarkers;
        drawEventMarkers: boolean;
        private _drawMarkersWhenMoving;
        drawMarkersWhenMoving: boolean;
        private _runDesignerAfterInsert;
        runDesignerAfterInsert: boolean;
        private _useLastFormat;
        useLastFormat: boolean;
        private _autoSaveInterval;
        autoSaveInterval: number;
        private _enableAutoSaveMode;
        enableAutoSaveMode: boolean;
        private _showOrder;
        showOrder: boolean;
        private _alignToGrid;
        alignToGrid: boolean;
        private _autoSaveReportToReportClass;
        autoSaveReportToReportClass: boolean;
        private _showHeaders;
        showHeaders: boolean;
        private _showGrid;
        showGrid: boolean;
        private _showInteractive;
        showInteractive: boolean;
        private _zoom;
        zoom: number;
        private _showRulers;
        showRulers: boolean;
        private _gridSizePoints;
        gridSizePoints: number;
        private _gridSizePixels;
        gridSizePixels: number;
        private _gridSizeCentimetres;
        gridSizeCentimetres: number;
        private _gridSizeHundredthsOfInch;
        gridSizeHundredthsOfInch: number;
        private _gridSizeInch;
        gridSizeInch: number;
        private _gridSizeMillimeters;
        gridSizeMillimeters: number;
        readonly gridSize: number;
        private _fillBands;
        fillBands: boolean;
        private _fillCrossBands;
        fillCrossBands: boolean;
        private _fillContainer;
        fillContainer: boolean;
        private _fillComponent;
        fillComponent: boolean;
        private _useComponentColor;
        useComponentColor: boolean;
        private _gridMode;
        gridMode: StiGridMode;
        private _report;
        report: StiReport;
        getFillColor(color: Color): Color;
        constructor(report?: StiReport);
    }
}
declare namespace Stimulsoft.Report.Design {
    class StiExpressionPacker {
        static packExpression(expressionStr: string, report: StiReport, useBraces: boolean): string;
        static unPackExpression(expressionStr: string, report: StiReport, useBraces: boolean): string;
        private static isValidName;
        static getCorrectedAlias(report: StiReport, alias: string): string;
        private static addWord;
        private static buildDictionary;
        private static buildBusinessObject;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Promise = Stimulsoft.System.Promise;
    class StiDataAdapterService extends StiService {
        readonly serviceCategory: string;
        readonly serviceType: Type;
        readonly isObjectAdapter: boolean;
        getDataCategoryName(data: StiData): string;
        static getDataAdapter(dataSource: StiDataSource): StiDataAdapterService;
        static getDataAdapter2(data: StiData): StiDataAdapterService;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        isAdapterDataType(type: Type): boolean;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): Promise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiDataStoreAdapterService extends StiDataAdapterService {
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFileAdapterService extends StiDataStoreAdapterService {
        readonly serviceName: string;
        getDataCategoryName(data: StiData): string;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    class StiDataLeader {
        private static fetchAll;
        static regData(database: StiDatabase, dictionary: StiDictionary, loadData: boolean): void;
        static regDataAsync(database: StiDatabase, dictionary: StiDictionary, loadData: boolean): Promise<void>;
        static getColumnsFromData(adapter: StiDataAdapterService, data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        static getColumnsFromDataAsync(adapter: StiDataAdapterService, data: StiData, dataSource: StiDataSource): Promise<StiDataColumnsCollection>;
        static connectDataSourceToData(adapter: StiDataAdapterService, dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        static connectDataSourceToDataAsync(adapter: StiDataAdapterService, dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        static retrieveDataAsync(dataSource: StiSqlSource, schemaOnly?: boolean): Promise<void>;
        static connect(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): void;
        static connectAsync(dataSource: StiDataSource, datas: StiDataCollection, loadData?: boolean): Promise<void>;
        static disconnect(dataSource: StiDataSource): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCsvAdapterService extends StiFileAdapterService {
        readonly name: string;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        getDataSourceType(): Stimulsoft.System.Type;
        getDataTypes(): Stimulsoft.System.Type[];
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        checkConvertNulls(dataSource: StiCsvSource): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiNoSqlAdapterService extends StiDataStoreAdapterService {
        getDataCategoryName(data: StiData): string;
        testConnection(connectionString: string): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMongoDbAdapterService extends StiNoSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    /**
     *  Describes the adapter of the data transformation.
     */
    class StiDataTransformationAdapterService extends StiDataStoreAdapterService {
        /**
         *  Gets a service name.
         */
        serviceName: string;
        isObjectAdapter: boolean;
        /**
         *  Calls the form for Data Source edition.
         *
         *  @param dictionary Dictionary in which Data Source is located.
         *  @param dataSource Data Source.
         *  @returns Result of gialog form.
         */
        edit(dictionary: StiDictionary, dataSource: StiDataSource): boolean;
        /**
         *  Calls the form for a new Data Source edition.
         *
         * @param dictionary Dictionary in which Data Source is located.
         * @param dataSource Data Source.
         * @returns>Result of gialog form.
         */
        new(dictionary: StiDictionary, dataSource: StiDataSource): boolean;
        /**
         *  Returns the array of data types to which the Data Source may refer.
         *
         * @returns Array of data types.
         */
        getDataTypes(): Type[];
        /**
         *  Returns a collection of columns of data.
         *
         * @param data Data to find column.
         * @returns> Collection of columns found.
         */
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        /**
         *  Returns a collection of parameters of data.
         *
         * @param data Data to find parameters.
         * @returns Collection of parameters found.
         */
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        /**
         *  Returns name of category for data.
         */
        getDataCategoryName(data: StiData): string;
        /**
         *  Returns the type of the Data Source.
         *
         * @returns The type of Data Source.
         */
        getDataSourceType(): Type;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import Type = Stimulsoft.System.Type;
    class StiVirtualAdapterService extends StiDataStoreAdapterService {
        readonly serviceName: string;
        readonly isObjectAdapter: boolean;
        getDataTypes(): Type[];
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): Promise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource, connectionString: string): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataCategoryName(data: StiData): string;
        getDataSourceType(): Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Promise = Stimulsoft.System.Promise;
    class StiSqlAdapterService extends StiDataStoreAdapterService {
        readonly url: string;
        readonly serviceName: string;
        readonly name: string;
        getDatabaseSpecificName(name: string): string;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource, connectionString: string): Promise<StiDataColumnsCollection>;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        getDataSourceType(): Stimulsoft.System.Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        callRemoteApi(command: any, timeout: number): Promise<string>;
        private static callTurn;
        process(report: StiReport, command: any, timeout: number): Promise<any>;
        testConnectionAsync(report: StiReport, connectionString: string): Promise<string>;
        createConnectionInDataStore(dictionary: StiDictionary, database: StiSqlDatabase): void;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string): Promise<DataTable>;
        constructor();
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiODataAdapterService extends StiSqlAdapterService {
        readonly serviceName: string;
        getDataSourceType(): Stimulsoft.System.Type;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
        testConnectionAsync(report: StiReport, connectionString: string): Promise<string>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiFirebirdAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiMySqlAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDatabaseSpecificName(name: string): string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiOracleAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import Promise = Stimulsoft.System.Promise;
    class StiPostgreSQLAdapterService extends StiSqlAdapterService {
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    class StiCustomAdapterService extends StiSqlAdapterService {
        private processUserFunction;
        static registerCustomAdapterService(options: {
            name: string;
            process: (command: any, callback: (result: any) => void) => void;
        }): StiCustomAdapterService;
        private _name;
        readonly name: string;
        getDataSourceType(): Stimulsoft.System.Type;
        callRemoteApi(command: any, timeout: number): Promise<string>;
        retrieveDataAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString: string): Promise<DataTable>;
        retrieveSchemaAsync(report: StiReport, dataSource: StiSqlSource, connectionString: string, queryString?: string): Promise<StiDataSchema>;
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    import Type = Stimulsoft.System.Type;
    class StiBuilder {
        private static typeToBuilder;
        static getBuilder(componentType: Type): StiBuilder;
        setReportVariables(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        prepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        unPrepare(masterComp: Stimulsoft.Report.Components.StiComponent): void;
        internalRender(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
        render(masterComp: Stimulsoft.Report.Components.StiComponent): Stimulsoft.Report.Components.StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiComponentBuilder extends StiBuilder {
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
        render(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiContainerBuilder extends StiComponentBuilder {
        /** Returns a panel for the component rendering.*/
        static getRenderContainer(comp: StiComponent, type?: Stimulsoft.System.Type): StiContainer;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiBandBuilder extends StiContainerBuilder {
        static getChildBands(masterBand: StiBand): StiComponentsCollection;
        static getSubReports(masterBand: StiBand): StiComponentsCollection;
        prepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterGroupHeaderBand: StiGroupHeaderBand): StiDataBand;
        static getCurrentConditionValue(masterGroupHeaderBand: StiGroupHeaderBand): Object;
        static getCurrentSummaryExpressionValue(masterGroupHeaderBand: StiGroupHeaderBand): Object;
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import ICloneable = Stimulsoft.System.ICloneable;
    import List = Stimulsoft.System.Collections.List;
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import Promise = Stimulsoft.System.Promise;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    class StiDataSource implements ICloneable, IStiAppDataSource, IStiStateSaveRestore, IStiEnumerator, IStiName, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        getNameInSource(): string;
        getName(): string;
        /**
         *  Returns a DataTable with data from this datasource.
         *  @returns The DataTable with data.
         */
        getDataTable2Async(allowConnectToData: boolean): Promise<DataTable>;
        /**
         *  Returns reference to the dictionary which contains this datasource.
         *  @returns Reference to the app.
         */
        getDictionary(): IStiAppDictionary;
        /**
         *  Returns an enumeration of the data columns from this dictionary.
         *  @returns The enumeration of the data columns.
         */
        fetchColumns(): List<IStiAppDataColumn>;
        /**
         *  Returns a connection to data for this data source.
         *  @returns Reference to the connection.
         */
        getConnection(): IStiAppConnection;
        /**
         *  Returns an enumeration of the parent data relations for this data source.
         *  @returns The enumeration of the data relations.
         */
        fetchParentRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        /**
         *  Returns an enumeration of the child data relations for this data source.
         *  @returns The enumeration of the data relations.
         */
        fetchChildRelations(activePreferred: boolean): List<IStiAppDataRelation>;
        /**
         *  Returns an array of values for the specified column in the specified position.
         *  @param names An array of names of the data column.
         *  @returns The enumeration of the data column values.
         */
        fetchColumnValues(names: string[]): List<any[]>;
        getKey(): string;
        setKey(key: string): void;
        private _inherited;
        inherited: boolean;
        readonly current: Object;
        moveNext(): boolean;
        reset(): void;
        getEnumerator(): IEnumerator;
        private _name;
        name: string;
        protected positionValue: number;
        position: number;
        readonly realCount: number;
        readonly count: number;
        protected isBofValue: boolean;
        /** Gets value indicates that this position specifies to the beginning of data. */
        isBof: boolean;
        protected isEofValue: boolean;
        /** Gets value indicates that this position specifies to the data end. */
        isEof: boolean;
        /** Gets value indicates that no data. */
        readonly isEmpty: boolean;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        clone(): StiDataSource;
        memberwiseClone(): StiDataSource;
        private _states;
        protected readonly states: StiStatesManager;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        clearAllStates(): void;
        private nameOfDataBandWhichInitDataSource;
        isInited: boolean;
        initForSubreport: boolean;
        xmlRefAttrValue: string;
        private relationNameStored;
        private resFilterMethod;
        private resSortColumns;
        private isEqualSort;
        setData(dataBand: StiDataBand, relationName: string, filterMethod: Object, sortColumns: string[], reinit: boolean, component: StiComponent): void;
        getConditions(dataBand: StiDataBand): Object[][][];
        setDetails(relationName: string): void;
        setFilter(filterMethod: Object): void;
        setSort(conditions: Object[][][], sortColumns: string[], component: StiComponent, databand: StiDataBand, groupHeaders: StiComponentsCollection): void;
        resetDetailsRows(): void;
        resetData(): void;
        getDataRow(index: number): DataRow;
        /** Returns the parent row with data for the indicated relation. */
        getParentData(relation: string): StiDataRow;
        /** Returns the colection of Parent relations. */
        getParentRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        /** Returns a collection of Child relations. */
        getChildRelations(): Stimulsoft.Report.Dictionary.StiDataRelationsCollection;
        /** Returns the parent Data Source by the relation name. */
        getParentDataSource(relationName: string, allowRelationName?: boolean): StiDataSource;
        /** Returns the child Data Source by the relation name. */
        getChildDataSource(relationName: string): StiDataSource;
        protected invokeConnecting(): void;
        protected invokeDisconnecting(): void;
        connectAsync(datas: StiDataCollection, loadData: boolean): Promise<void>;
        connect(datas: StiDataCollection, loadData: boolean): void;
        protected getDataAdapterType(): Type;
        protected readonly dataAdapterType: string;
        fillColumns(): void;
        getDataAdapter(): StiDataAdapterService;
        private _parameters;
        parameters: StiDataParametersCollection;
        getDataTable(table?: DataTable): DataTable;
        getByName(columnName: string): Object;
        getData(columnName: string, index?: number): Object;
        getColumnIndex(columnName: string): number;
        private _rows;
        rows: StiRowsCollection;
        columnsIndexs: Hashtable;
        calcColumns: Hashtable;
        detailRows: DataRow[];
        rowToLevel: Hashtable;
        synchronizeColumns(): void;
        checkColumnsIndexs(): void;
        toString(): string;
        getLevel(): number;
        getCategoryName(): string;
        createNew(): StiDataSource;
        private _isCloud;
        readonly isCloud: boolean;
        private _dictionary;
        dictionary: StiDictionary;
        private _dataTable;
        dataTable: Stimulsoft.System.Data.DataTable;
        readonly isConnected: boolean;
        private _columns;
        columns: StiDataColumnsCollection;
        connectionOrder: number;
        disconnect(): void;
        connectOnStart: boolean;
        getByColumnName(columnName: string): Object;
        private _alias;
        alias: string;
        private _key;
        key: string;
        parentRelationList(activePreferred?: boolean): List<StiDataRelation>;
        childRelationList(activePreferred?: boolean): List<StiDataRelation>;
        constructor(name: string, alias: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataStoreSource extends StiDataSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        getCategoryName(): string;
        dataName: string;
        private _nameInSource;
        nameInSource: string;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Type = Stimulsoft.System.Type;
    class StiDataTableSource extends StiDataStoreSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        getCategoryName(): string;
        getDataAdapterType(): Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Type = Stimulsoft.System.Type;
    import Promise = Stimulsoft.System.Promise;
    class StiDataTableAdapterService extends StiDataStoreAdapterService {
        readonly serviceName: string;
        readonly isObjectAdapter: boolean;
        getDataCategoryName(data: StiData): string;
        getColumnsFromDataAsync(data: StiData, dataSource: StiDataSource): Promise<StiDataColumnsCollection>;
        getColumnsFromData(data: StiData, dataSource: StiDataSource): StiDataColumnsCollection;
        getParametersFromData(data: StiData, dataSource: StiDataSource): StiDataParametersCollection;
        setDataSourceNames(data: StiData, dataSource: StiDataSource): void;
        create(dictionary: StiDictionary, addToDictionary?: boolean): StiDataSource;
        getDataSourceType(): Type;
        getDataTypes(): Type[];
        getDataFromDataSource(dictionary: StiDictionary, dataSource: StiDataSource): StiData;
        connectDataSourceToDataAsync(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): Promise<void>;
        connectDataSourceToData(dictionary: StiDictionary, dataSource: StiDataSource, loadData: boolean): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAggregateFunctionService {
        readonly serviceName: string;
        init(): void;
        reset(): void;
        calcItem(value: Object): any;
        getValue(): Object;
        setValue(value: Object): any;
        isFirstInit: boolean;
        readonly recureParam: boolean;
        private _runningTotal;
        runningTotal: boolean;
        constructor(runningTotal?: boolean);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAvgDateFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAvgFunctionService extends StiAggregateFunctionService {
        private summary;
        private count;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAvgTimeFunctionService extends StiAggregateFunctionService {
        private avgValue;
        private count;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCountDistinctFunctionService extends StiAggregateFunctionService {
        private counter;
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCountFunctionService extends StiAggregateFunctionService {
        private counter;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFirstFunctionService extends StiAggregateFunctionService {
        private value;
        private first;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiLastFunctionService extends StiAggregateFunctionService {
        private value;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxFunctionService extends StiAggregateFunctionService {
        private maximum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMaxTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private maximum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMedianFunctionService extends StiAggregateFunctionService {
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinDateFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinFunctionService extends StiAggregateFunctionService {
        private minimum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinStrFunctionService extends StiAggregateFunctionService {
        private values;
        static ascComparison(str1: string, str2: string): number;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMinTimeFunctionService extends StiAggregateFunctionService {
        private valueProcessed;
        private minimum;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiModeFunctionService extends StiAggregateFunctionService {
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiRankOrder = Stimulsoft.Report.StiRankOrder;
    class StiRankFunctionService extends StiAggregateFunctionService {
        private hash;
        private sortOrder;
        private dense;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
        constructor(runningTotal: boolean, dense?: boolean, sortOrder?: StiRankOrder);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumDistinctFunctionService extends StiAggregateFunctionService {
        private summary;
        private values;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object, valueToSum?: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumFunctionService extends StiAggregateFunctionService {
        private summary;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumNullableFunctionService extends StiAggregateFunctionService {
        private summary;
        private hasValues;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSumTimeFunctionService extends StiAggregateFunctionService {
        private sumValue;
        readonly serviceName: string;
        init(): void;
        calcItem(value: Object): void;
        getValue(): Object;
        setValue(value: Object): void;
        readonly recureParam: boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiBusinessObjectCategory {
        private _category;
        category: string;
        constructor(category: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiBusinessObjectData {
        private _category;
        category: string;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _businessObjectValue;
        businessObjectValue: Object;
        constructor(category: string, name: string, alias: string, value: Object);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFileDataSource extends StiDataStoreSource {
        readonly componentId: StiComponentId;
        path: string;
        codePage: number;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCsvSource extends StiFileDataSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        getDataAdapterType(): Stimulsoft.System.Type;
        separator: string;
        convertEmptyStringToNull: boolean;
        createNew(): StiDataSource;
        constructor(path?: string, name?: string, alias?: string, codePage?: number, separator?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    class StiSqlSource extends StiDataTableSource implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _allowExpressions;
        allowExpressions: boolean;
        private _type;
        type: StiSqlSourceType;
        private _commandTimeout;
        commandTimeout: number;
        private _reconnectOnEachRow;
        reconnectOnEachRow: boolean;
        private _sqlCommand;
        sqlCommand: string;
        getDataAdapterType(): Stimulsoft.System.Type;
        updateParameters(): void;
        retrieveDataAsync(schemaOnly?: boolean): Promise<void>;
        getFinalSqlCommand(): string;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiNoSqlSource extends StiSqlSource {
        query: string;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMongoDbSource extends StiNoSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiFilter = Stimulsoft.Report.Components.IStiFilter;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import Type = Stimulsoft.System.Type;
    class StiVirtualSource extends StiDataStoreSource implements IStiFilter, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _filterMethodHandler;
        filterMethodHandler: Function;
        private _filterOn;
        filterOn: boolean;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: Stimulsoft.Report.Components.StiFiltersCollection;
        protected getDataAdapterType(): Type;
        private _groupColumns;
        groupColumns: string[];
        private _results;
        results: string[];
        private _sort;
        sort: string[];
        connectToData(): void;
        private compare;
        private initTotals;
        private addRow;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiODataSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFirebirdSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMySqlSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiOracleSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiPostgreSQLSource extends StiSqlSource {
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiCustomSource extends StiSqlSource {
        static registerCustomSource(): void;
        getDataAdapterType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiDataSource;
        constructor(nameInSource?: string, name?: string, alias?: string, sqlCommand?: string, connectOnStart?: boolean, reconnectOnEachRow?: boolean, commandTimeout?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiFunctions {
        private static functionsToCompile;
        private static functionsToCompileLower;
        private static functions;
        private static functionsLower;
        static removeFunction(functionName: string): void;
        static getFunctionsList(functionName: string): Array<StiFunction>;
        static getFunctionsGrouppedInCategories(): Hashtable;
        static getFunctions(categoryOrIsCompile: string | boolean): Array<StiFunction>;
        static getFunctionsEx(report: StiReport, functionName: string, isCompile: boolean): StiFunction[];
        static getCategories(): Array<string>;
        static getAssebliesOfFunctions(): string[];
        static addFunction(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[], jsFunction?: Function): StiFunction;
        static StiFunctions(): void;
    }
}
declare module Stimulsoft.Report.Engine {
    enum StiTokenType {
        Empty = 0,
        Delimiter = 1,
        Variable = 2,
        SystemVariable = 3,
        DataSourceField = 4,
        BusinessObjectField = 5,
        Number = 6,
        Function = 7,
        Method = 8,
        Property = 9,
        Component = 10,
        Cast = 11,
        String = 12,
        Dot = 13,
        Comma = 14,
        Colon = 15,
        SemiColon = 16,
        Shl = 17,
        Shr = 18,
        Assign = 19,
        Equal = 20,
        NotEqual = 21,
        LeftEqual = 22,
        Left = 23,
        RightEqual = 24,
        Right = 25,
        Not = 26,
        Or = 27,
        And = 28,
        Xor = 29,
        DoubleOr = 30,
        DoubleAnd = 31,
        Question = 32,
        Plus = 33,
        Minus = 34,
        Mult = 35,
        Div = 36,
        Percent = 37,
        LParenthesis = 38,
        RParenthesis = 39,
        LBracket = 40,
        RBracket = 41,
        Identifier = 42,
        Unknown = 43
    }
    enum StiAsmCommandType {
        PushValue = 2000,
        PushVariable = 2001,
        PushSystemVariable = 2002,
        PushDataSourceField = 2003,
        PushBusinessObjectField = 2004,
        PushFunction = 2005,
        PushMethod = 2006,
        PushProperty = 2007,
        PushComponent = 2008,
        PushArrayElement = 2009,
        CopyToVariable = 2010,
        Add = 2020,
        Sub = 2021,
        Mult = 2022,
        Div = 2023,
        Mod = 2024,
        Power = 2025,
        Neg = 2026,
        Cast = 2027,
        Not = 2028,
        CompareLeft = 2029,
        CompareLeftEqual = 2030,
        CompareRight = 2031,
        CompareRightEqual = 2032,
        CompareEqual = 2033,
        CompareNotEqual = 2034,
        Shl = 2035,
        Shr = 2036,
        And = 2037,
        And2 = 2038,
        Or = 2039,
        Or2 = 2040,
        Xor = 2041,
        Jump = 2042,
        JumpTrue = 2043,
        JumpFalse = 2044
    }
    enum StiSystemVariableType {
        Column = 0,
        Line = 1,
        LineThrough = 2,
        LineABC = 3,
        LineRoman = 4,
        GroupLine = 5,
        PageNumber = 6,
        PageNumberThrough = 7,
        PageNofM = 8,
        PageNofMThrough = 9,
        TotalPageCount = 10,
        TotalPageCountThrough = 11,
        IsFirstPage = 12,
        IsFirstPageThrough = 13,
        IsLastPage = 14,
        IsLastPageThrough = 15,
        PageCopyNumber = 16,
        ReportAlias = 17,
        ReportAuthor = 18,
        ReportChanged = 19,
        ReportCreated = 20,
        ReportDescription = 21,
        ReportName = 22,
        Time = 23,
        Today = 24,
        ConditionValue = 25,
        ConditionTag = 26,
        Sender = 27,
        DateTimeNow = 28,
        DateTimeToday = 29
    }
    enum StiPropertyType {
        Year = 0,
        Month = 1,
        Day = 2,
        Hour = 3,
        Minute = 4,
        Second = 5,
        Date = 6,
        Length = 7,
        From = 8,
        To = 9,
        FromDate = 10,
        ToDate = 11,
        FromTime = 12,
        ToTime = 13,
        SelectedLine = 14,
        Name = 15,
        TagValue = 16,
        Days = 17,
        Hours = 18,
        Milliseconds = 19,
        Minutes = 20,
        Seconds = 21,
        Ticks = 22,
        TotalDays = 23,
        TotalHours = 24,
        TotalMinutes = 25,
        TotalSeconds = 26,
        TotalMilliseconds = 27,
        Count = 28,
        BusinessObjectValue = 29
    }
    enum StiFunctionType {
        NameSpace = 0,
        Count = 1,
        CountDistinct = 2,
        Avg = 3,
        AvgD = 4,
        AvgDate = 5,
        AvgI = 6,
        AvgTime = 7,
        Max = 8,
        MaxD = 9,
        MaxDate = 10,
        MaxI = 11,
        MaxStr = 12,
        MaxTime = 13,
        Median = 14,
        MedianD = 15,
        MedianI = 16,
        Min = 17,
        MinD = 18,
        MinDate = 19,
        MinI = 20,
        MinStr = 21,
        MinTime = 22,
        Mode = 23,
        ModeD = 24,
        ModeI = 25,
        Sum = 26,
        SumD = 27,
        SumDistinct = 28,
        SumI = 29,
        SumTime = 30,
        First = 31,
        Last = 32,
        rCount = 33,
        rCountDistinct = 34,
        rAvg = 35,
        rAvgD = 36,
        rAvgDate = 37,
        rAvgI = 38,
        rAvgTime = 39,
        rMax = 40,
        rMaxD = 41,
        rMaxDate = 42,
        rMaxI = 43,
        rMaxStr = 44,
        rMaxTime = 45,
        rMedian = 46,
        rMedianD = 47,
        rMedianI = 48,
        rMin = 49,
        rMinD = 50,
        rMinDate = 51,
        rMinI = 52,
        rMinStr = 53,
        rMinTime = 54,
        rMode = 55,
        rModeD = 56,
        rModeI = 57,
        rSum = 58,
        rSumD = 59,
        rSumDistinct = 60,
        rSumI = 61,
        rSumTime = 62,
        rFirst = 63,
        rLast = 64,
        iCount = 65,
        iCountDistinct = 66,
        iAvg = 67,
        iAvgD = 68,
        iAvgDate = 69,
        iAvgI = 70,
        iAvgTime = 71,
        iMax = 72,
        iMaxD = 73,
        iMaxDate = 74,
        iMaxI = 75,
        iMaxStr = 76,
        iMaxTime = 77,
        iMedian = 78,
        iMedianD = 79,
        iMedianI = 80,
        iMin = 81,
        iMinD = 82,
        iMinDate = 83,
        iMinI = 84,
        iMinStr = 85,
        iMinTime = 86,
        iMode = 87,
        iModeD = 88,
        iModeI = 89,
        iSum = 90,
        iSumD = 91,
        iSumDistinct = 92,
        iSumI = 93,
        iSumTime = 94,
        iFirst = 95,
        iLast = 96,
        riCount = 97,
        riCountDistinct = 98,
        riAvg = 99,
        riAvgD = 100,
        riAvgDate = 101,
        riAvgI = 102,
        riAvgTime = 103,
        riMax = 104,
        riMaxD = 105,
        riMaxDate = 106,
        riMaxI = 107,
        riMaxStr = 108,
        riMaxTime = 109,
        riMedian = 110,
        riMedianD = 111,
        riMedianI = 112,
        riMin = 113,
        riMinD = 114,
        riMinDate = 115,
        riMinI = 116,
        riMinStr = 117,
        riMinTime = 118,
        riMode = 119,
        riModeD = 120,
        riModeI = 121,
        riSum = 122,
        riSumD = 123,
        riSumDistinct = 124,
        riSumI = 125,
        riSumTime = 126,
        riFirst = 127,
        riLast = 128,
        cCount = 129,
        cCountDistinct = 130,
        cAvg = 131,
        cAvgD = 132,
        cAvgDate = 133,
        cAvgI = 134,
        cAvgTime = 135,
        cMax = 136,
        cMaxD = 137,
        cMaxDate = 138,
        cMaxI = 139,
        cMaxStr = 140,
        cMaxTime = 141,
        cMedian = 142,
        cMedianD = 143,
        cMedianI = 144,
        cMin = 145,
        cMinD = 146,
        cMinDate = 147,
        cMinI = 148,
        cMinStr = 149,
        cMinTime = 150,
        cMode = 151,
        cModeD = 152,
        cModeI = 153,
        cSum = 154,
        cSumD = 155,
        cSumDistinct = 156,
        cSumI = 157,
        cSumTime = 158,
        cFirst = 159,
        cLast = 160,
        crCount = 161,
        crCountDistinct = 162,
        crAvg = 163,
        crAvgD = 164,
        crAvgDate = 165,
        crAvgI = 166,
        crAvgTime = 167,
        crMax = 168,
        crMaxD = 169,
        crMaxDate = 170,
        crMaxI = 171,
        crMaxStr = 172,
        crMaxTime = 173,
        crMedian = 174,
        crMedianD = 175,
        crMedianI = 176,
        crMin = 177,
        crMinD = 178,
        crMinDate = 179,
        crMinI = 180,
        crMinStr = 181,
        crMinTime = 182,
        crMode = 183,
        crModeD = 184,
        crModeI = 185,
        crSum = 186,
        crSumD = 187,
        crSumDistinct = 188,
        crSumI = 189,
        crSumTime = 190,
        crFirst = 191,
        crLast = 192,
        ciCount = 193,
        ciCountDistinct = 194,
        ciAvg = 195,
        ciAvgD = 196,
        ciAvgDate = 197,
        ciAvgI = 198,
        ciAvgTime = 199,
        ciMax = 200,
        ciMaxD = 201,
        ciMaxDate = 202,
        ciMaxI = 203,
        ciMaxStr = 204,
        ciMaxTime = 205,
        ciMedian = 206,
        ciMedianD = 207,
        ciMedianI = 208,
        ciMin = 209,
        ciMinD = 210,
        ciMinDate = 211,
        ciMinI = 212,
        ciMinStr = 213,
        ciMinTime = 214,
        ciMode = 215,
        ciModeD = 216,
        ciModeI = 217,
        ciSum = 218,
        ciSumD = 219,
        ciSumDistinct = 220,
        ciSumI = 221,
        ciSumTime = 222,
        ciFirst = 223,
        ciLast = 224,
        criCount = 225,
        criCountDistinct = 226,
        criAvg = 227,
        criAvgD = 228,
        criAvgDate = 229,
        criAvgI = 230,
        criAvgTime = 231,
        criMax = 232,
        criMaxD = 233,
        criMaxDate = 234,
        criMaxI = 235,
        criMaxStr = 236,
        criMaxTime = 237,
        criMedian = 238,
        criMedianD = 239,
        criMedianI = 240,
        criMin = 241,
        criMinD = 242,
        criMinDate = 243,
        criMinI = 244,
        criMinStr = 245,
        criMinTime = 246,
        criMode = 247,
        criModeD = 248,
        criModeI = 249,
        criSum = 250,
        criSumD = 251,
        criSumDistinct = 252,
        criSumI = 253,
        criSumTime = 254,
        criFirst = 255,
        criLast = 256,
        pCount = 257,
        pCountDistinct = 258,
        pAvg = 259,
        pAvgD = 260,
        pAvgDate = 261,
        pAvgI = 262,
        pAvgTime = 263,
        pMax = 264,
        pMaxD = 265,
        pMaxDate = 266,
        pMaxI = 267,
        pMaxStr = 268,
        pMaxTime = 269,
        pMedian = 270,
        pMedianD = 271,
        pMedianI = 272,
        pMin = 273,
        pMinD = 274,
        pMinDate = 275,
        pMinI = 276,
        pMinStr = 277,
        pMinTime = 278,
        pMode = 279,
        pModeD = 280,
        pModeI = 281,
        pSum = 282,
        pSumD = 283,
        pSumDistinct = 284,
        pSumI = 285,
        pSumTime = 286,
        pFirst = 287,
        pLast = 288,
        prCount = 289,
        prCountDistinct = 290,
        prAvg = 291,
        prAvgD = 292,
        prAvgDate = 293,
        prAvgI = 294,
        prAvgTime = 295,
        prMax = 296,
        prMaxD = 297,
        prMaxDate = 298,
        prMaxI = 299,
        prMaxStr = 300,
        prMaxTime = 301,
        prMedian = 302,
        prMedianD = 303,
        prMedianI = 304,
        prMin = 305,
        prMinD = 306,
        prMinDate = 307,
        prMinI = 308,
        prMinStr = 309,
        prMinTime = 310,
        prMode = 311,
        prModeD = 312,
        prModeI = 313,
        prSum = 314,
        prSumD = 315,
        prSumDistinct = 316,
        prSumI = 317,
        prSumTime = 318,
        prFirst = 319,
        prLast = 320,
        piCount = 321,
        piCountDistinct = 322,
        piAvg = 323,
        piAvgD = 324,
        piAvgDate = 325,
        piAvgI = 326,
        piAvgTime = 327,
        piMax = 328,
        piMaxD = 329,
        piMaxDate = 330,
        piMaxI = 331,
        piMaxStr = 332,
        piMaxTime = 333,
        piMedian = 334,
        piMedianD = 335,
        piMedianI = 336,
        piMin = 337,
        piMinD = 338,
        piMinDate = 339,
        piMinI = 340,
        piMinStr = 341,
        piMinTime = 342,
        piMode = 343,
        piModeD = 344,
        piModeI = 345,
        piSum = 346,
        piSumD = 347,
        piSumDistinct = 348,
        piSumI = 349,
        piSumTime = 350,
        piFirst = 351,
        piLast = 352,
        priCount = 353,
        priCountDistinct = 354,
        priAvg = 355,
        priAvgD = 356,
        priAvgDate = 357,
        priAvgI = 358,
        priAvgTime = 359,
        priMax = 360,
        priMaxD = 361,
        priMaxDate = 362,
        priMaxI = 363,
        priMaxStr = 364,
        priMaxTime = 365,
        priMedian = 366,
        priMedianD = 367,
        priMedianI = 368,
        priMin = 369,
        priMinD = 370,
        priMinDate = 371,
        priMinI = 372,
        priMinStr = 373,
        priMinTime = 374,
        priMode = 375,
        priModeD = 376,
        priModeI = 377,
        priSum = 378,
        priSumD = 379,
        priSumDistinct = 380,
        priSumI = 381,
        priSumTime = 382,
        priFirst = 383,
        priLast = 384,
        CountAllLevels = 385,
        CountAllLevelsOnlyChilds = 386,
        CountOnlyChilds = 387,
        Rank = 388,
        Abs = 389,
        Acos = 390,
        Asin = 391,
        Atan = 392,
        Ceiling = 393,
        Cos = 394,
        Div = 395,
        Exp = 396,
        Floor = 397,
        Log = 398,
        Maximum = 399,
        Minimum = 400,
        Round = 401,
        Sign = 402,
        Sin = 403,
        Sqrt = 404,
        Tan = 405,
        Truncate = 406,
        DateDiff = 407,
        DateSerial = 408,
        Day = 409,
        DayOfWeek = 410,
        DayOfYear = 411,
        DaysInMonth = 412,
        DaysInYear = 413,
        Hour = 414,
        Minute = 415,
        Month = 416,
        Second = 417,
        TimeSerial = 418,
        Year = 419,
        MonthName = 420,
        WeekOfYear = 421,
        WeekOfMonth = 422,
        DateToStr = 423,
        DateToStrPl = 424,
        DateToStrRu = 425,
        DateToStrUa = 426,
        DateToStrPt = 427,
        DateToStrPtBr = 428,
        Insert = 429,
        Length = 430,
        Remove = 431,
        Replace = 432,
        Roman = 433,
        Substring = 434,
        ToCurrencyWords = 435,
        ToCurrencyWordsEnGb = 436,
        ToCurrencyWordsEnIn = 437,
        ToCurrencyWordsEs = 438,
        ToCurrencyWordsFr = 439,
        ToCurrencyWordsNl = 440,
        ToCurrencyWordsPl = 441,
        ToCurrencyWordsPt = 442,
        ToCurrencyWordsPtBr = 443,
        ToCurrencyWordsRu = 444,
        ToCurrencyWordsThai = 445,
        ToCurrencyWordsTr = 446,
        ToCurrencyWordsUa = 447,
        ToCurrencyWordsZh = 448,
        ToLowerCase = 449,
        ToProperCase = 450,
        ToUpperCase = 451,
        ToWords = 452,
        ToWordsEs = 453,
        ToWordsEnIn = 454,
        ToWordsFa = 455,
        ToWordsPl = 456,
        ToWordsPt = 457,
        ToWordsRu = 458,
        ToWordsTr = 459,
        ToWordsUa = 460,
        Trim = 461,
        TryParseDecimal = 462,
        TryParseDouble = 463,
        TryParseLong = 464,
        Arabic = 465,
        Persian = 466,
        ToOrdinal = 467,
        Left = 468,
        Mid = 469,
        Right = 470,
        StrToNullableDateTime = 471,
        IsNull = 472,
        Next = 473,
        NextIsNull = 474,
        Previous = 475,
        PreviousIsNull = 476,
        IIF = 477,
        Choose = 478,
        Switch = 479,
        ToString = 480,
        Format = 481,
        SystemConvertToBoolean = 482,
        SystemConvertToByte = 483,
        SystemConvertToChar = 484,
        SystemConvertToDateTime = 485,
        SystemConvertToDecimal = 486,
        SystemConvertToDouble = 487,
        SystemConvertToInt16 = 488,
        SystemConvertToInt32 = 489,
        SystemConvertToInt64 = 490,
        SystemConvertToSByte = 491,
        SystemConvertToSingle = 492,
        SystemConvertToString = 493,
        SystemConvertToUInt16 = 494,
        SystemConvertToUInt32 = 495,
        SystemConvertToUInt64 = 496,
        MathRound = 497,
        MathPow = 498,
        AddAnchor = 499,
        GetAnchorPageNumber = 500,
        GetAnchorPageNumberThrough = 501,
        ConvertRtf = 502,
        ParseInt = 503,
        ParseDouble = 504,
        ParseDecimal = 505,
        ParseDateTime = 506,
        StringIsNullOrEmpty = 507,
        StringIsNullOrWhiteSpace = 508,
        EngineHelperJoinColumnContent = 509,
        EngineHelperToQueryString = 510,
        m_Substring = 1000,
        m_ToString = 1001,
        m_ToLower = 1002,
        m_ToUpper = 1003,
        m_IndexOf = 1004,
        m_StartsWith = 1005,
        m_EndsWith = 1006,
        m_Parse = 1007,
        m_Contains = 1008,
        m_GetData = 1009,
        m_ToQueryString = 1010,
        m_AddYears = 1011,
        m_AddMonths = 1012,
        m_AddDays = 1013,
        m_AddHours = 1014,
        m_AddMinutes = 1015,
        m_AddSeconds = 1016,
        m_AddMilliseconds = 1017,
        m_MethodNameSpace = 1018,
        op_Add = 2020,
        op_Sub = 2021,
        op_Mult = 2022,
        op_Div = 2023,
        op_Mod = 2024,
        op_Power = 2025,
        op_Neg = 2026,
        op_Cast = 2027,
        op_Not = 2028,
        op_CompareLeft = 2029,
        op_CompareLeftEqual = 2030,
        op_CompareRight = 2031,
        op_CompareRightEqual = 2032,
        op_CompareEqual = 2033,
        op_CompareNotEqual = 2034,
        op_Shl = 2035,
        op_Shr = 2036,
        op_And = 2037,
        op_And2 = 2038,
        op_Or = 2039,
        op_Or2 = 2040,
        op_Xor = 2041,
        UserFunction = 3000
    }
    enum StiMethodType {
        Substring = 1000,
        ToString = 1001,
        ToLower = 1002,
        ToUpper = 1003,
        IndexOf = 1004,
        StartsWith = 1005,
        EndsWith = 1006,
        Parse = 1007,
        Contains = 1008,
        GetData = 1009,
        ToQueryString = 1010,
        AddYears = 1011,
        AddMonths = 1012,
        AddDays = 1013,
        AddHours = 1014,
        AddMinutes = 1015,
        AddSeconds = 1016,
        AddMilliseconds = 1017,
        GetCurrentConditionValue = 1018,
        MethodNameSpace = 1019
    }
    enum StiParameterNumber {
        Param1 = 1,
        Param2 = 2,
        Param3 = 4,
        Param4 = 8
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Type = Stimulsoft.System.Type;
    class StiParserMethodInfo {
        name: StiFunctionType;
        number: number;
        arguments: Type[];
        returnType: Type;
        constructor(name: StiFunctionType, numberr: number, argumentss: Array<Type>, returnType?: Type);
    }
    class StiParser_Properties {
        protected get_category(par: Object): number;
        protected report: StiReport;
        protected expressionPosition: number;
        private static _typesList;
        static readonly typesList: Hashtable;
        private static _systemVariablesList;
        static readonly systemVariablesList: Hashtable;
        private static _propertiesList;
        static readonly propertiesList: Hashtable;
        private static _functionsList;
        static readonly functionsList: Hashtable;
        private static _methodsList;
        static readonly methodsList: Hashtable;
        private static _parametersList;
        static readonly parametersList: Hashtable;
        private _componentsList;
        readonly componentsList: Hashtable;
        private static _methodsHash;
        static readonly methodsHash: Hashtable;
        private static _constantsList;
        static readonly constantsList: Hashtable;
        protected static namespaceObj: Object;
        private static _namespacesList;
        static readonly namespacesList: Hashtable;
        private lockUserFunctionsList;
        private _userFunctionsList;
        readonly userFunctionsList: Hashtable;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Type = Stimulsoft.System.Type;
    enum ParserErrorCode {
        SyntaxError = 0,
        IntegralConstantIsTooLarge = 1,
        ExpressionIsEmpty = 2,
        DivisionByZero = 3,
        UnexpectedEndOfExpression = 4,
        NameDoesNotExistInCurrentContext = 5,
        UnprocessedLexemesRemain = 6,
        LeftParenthesisExpected = 7,
        RightParenthesisExpected = 8,
        FieldMethodOrPropertyNotFound = 9,
        OperatorCannotBeAppliedToOperands = 10,
        FunctionNotFound = 11,
        NoOverloadForMethodTakesNArguments = 12,
        FunctionHasInvalidArgument = 13,
        FunctionNotYetImplemented = 14,
        MethodHasInvalidArgument = 15,
        ItemDoesNotContainDefinition = 16,
        NoMatchingOverloadedMethod = 17,
        TheTypeOrNamespaceNotExistInTheNamespace = 18
    }
    class StiParserException {
        message: string;
        baseMessage: string;
        position: number;
        length: number;
        constructor(message: string);
    }
    class StiParser_Check extends StiParser_Properties {
        private static errorsList;
        protected throwError(code: ParserErrorCode, token?: StiToken, message1?: string, message2?: string, message3?: string, message4?: string): void;
        checkTypes(asmList: Array<StiAsmCommand>): void;
        private getMethodResultType;
        private getPropertyType;
        private getArrayElementType;
        protected get_systemVariable(name: Object): Object;
        static isImplicitlyCastableTo(from: Type, to: Type): boolean;
        protected getTypeName(value: any): string;
        report: StiReport;
        protected checkParserMethodInfo(type: StiFunctionType, args: any[]): number;
        getParserMethodInfo(type: StiFunctionType, args: Array<Type>): StiParserMethodInfo;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiParser_Lexer extends StiParser_Check {
        protected position: number;
        protected inputExpression: string;
        protected hashAliases: Hashtable;
        protected tokenPos: number;
        protected tokensList: Array<StiToken>;
        protected component: StiComponent;
        private getNextLexem;
        private static isWhiteSpace;
        private buildAliases;
        private buildBusinessObject;
        private static isValidName;
        private static getCorrectedAlias;
        private static replaceBackslash;
        private scanNumber;
        private postProcessTokensList;
        private getDataSourceByName;
        private getDataRelationByName;
        private getDataColumnByName;
        protected makeTokensList(): void;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmOperations extends StiParser_Lexer {
        protected op_Add(par1: Object, par2: Object): Object;
        protected op_Sub(par1: Object, par2: Object): Object;
        protected op_Mult(par1: Object, par2: Object): Object;
        protected op_Div(par1: Object, par2: Object): Object;
        protected op_Mod(par1: Object, par2: Object): Object;
        protected op_Pow(par1: Object, par2: Object): Object;
        protected op_Neg(par1: Object): Object;
        protected op_Not(par1: Object): Object;
        protected op_Cast(par1: Object, par2: Object): Object;
        protected op_CompareLeft(par1: Object, par2: Object): Object;
        protected op_CompareLeftEqual(par1: Object, par2: Object): Object;
        protected op_CompareRight(par1: Object, par2: Object): Object;
        protected op_CompareRightEqual(par1: Object, par2: Object): Object;
        protected op_CompareEqual(par1: Object, par2: Object): Object;
        protected op_CompareNotEqual(par1: Object, par2: Object): Object;
        protected op_Shl(par1: Object, par2: Object): Object;
        protected op_Shr(par1: Object, par2: Object): Object;
        protected op_And(par1: Object, par2: Object): Object;
        protected op_Or(par1: Object, par2: Object): Object;
        protected op_Xor(par1: Object, par2: Object): Object;
        protected op_And2(par1: Object, par2: Object): Object;
        protected op_Or2(par1: Object, par2: Object): Object;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmProperties extends StiParser_AsmOperations {
        protected call_property(name: Object, argsList: Array<any>): any;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmMethods extends StiParser_AsmProperties {
        protected call_method(name: Object, argsList: Array<any>): Object;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import CalendarWeekRule = Stimulsoft.System.Globalization.CalendarWeekRule;
    import DayOfWeek = Stimulsoft.System.DayOfWeek;
    class StiFunctionsDate {
        private static isCreated;
        static create(): void;
        static dateDiff(date1: DateTime, date2: DateTime): TimeSpan;
        static year(date: DateTime): number;
        static month(date: DateTime): number;
        static hour(date: DateTime): number;
        static minute(date: DateTime): number;
        static second(date: DateTime): number;
        static day(date: DateTime): number;
        static dayOfWeek(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static monthName(date: DateTime, loc?: boolean | string, upperCase?: boolean): string;
        static dayOfYear(date: DateTime): number;
        static dateSerial(year: number, month: number, day: number): DateTime;
        static timeSerial(hours: number, minutes: number, seconds: number): TimeSpan;
        static daysInMonth(yearOrDate: number | DateTime, month: number): number;
        static daysInYear(yearOrDate: number | DateTime): number;
        static weekOfYear(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
        static weekOfMonth(date: DateTime, firstDayOfWeek?: DayOfWeek, calendarWeekRule?: CalendarWeekRule): number;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_AsmFunctions extends StiParser_AsmMethods {
        protected call_func(name: Object, argsList: Array<any>): Object;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    class StiParser_Parser extends StiParser_AsmFunctions {
        protected currentToken: StiToken;
        protected asmList: Array<StiAsmCommand>;
        protected eval_exp(): void;
        private eval_exp0;
        private eval_exp01;
        private eval_exp1;
        private eval_exp10;
        private eval_exp11;
        private eval_exp12;
        private eval_exp14;
        private eval_exp15;
        private eval_exp16;
        private eval_exp17;
        private eval_exp18;
        private eval_exp2;
        private eval_exp3;
        private eval_exp4;
        private eval_exp5;
        private eval_exp6;
        private eval_exp62;
        private eval_exp7;
        private atom;
        private get_args_count;
        private get_args;
        private get_token;
    }
}
declare module Stimulsoft.Report.Engine.StiParser {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    class StiParserData {
        data: Object;
        asmList: Array<StiAsmCommand>;
        asmList2: Array<StiAsmCommand>;
        conditionAsmList: Array<StiAsmCommand>;
        parser: StiParser;
        constructor(data: Object, asmList: Array<StiAsmCommand>, parser: StiParser, conditionAsmList?: Array<StiAsmCommand>);
    }
    class StiFilterParserData {
        component: StiComponent;
        expression: string;
        constructor(component: StiComponent, expression: string);
    }
    class StiToken {
        type: StiTokenType;
        value: string;
        valueObject: Object;
        position: number;
        length: number;
        constructor(type?: StiTokenType, position?: number, length?: number);
        toString(): string;
    }
    class StiAsmCommand {
        type: StiAsmCommandType;
        parameter1: Object;
        parameter2: Object;
        position: number;
        length: number;
        constructor(type: StiAsmCommandType, parameter1?: Object, parameter2?: Object);
        toString(): string;
    }
    class StiParser extends StiParser_Parser {
        private sender;
        executeAsm(objectAsmList: Object): Object;
        private getVariableValue;
        private call_arrayElement;
        protected get_systemVariable(name: Object): Object;
        static parseTextValue(inputExpression: string, component: StiComponent, sender?: Object, REFstoreToPrint?: any, executeIfStoreToPrint?: boolean, returnAsmList?: boolean, parser?: StiParser): Object;
        private parseToAsm;
        private static checkForStoreToPrint;
        static checkExpression(inputExpression: string, component: StiComponent): StiParserException;
        static checkForDataBandsUsedInPageTotals(stiText: StiText): void;
        static prepareReportVariables(report: StiReport): void;
        static prepareVariableValue(varr: StiVariable, report: StiReport, textBox?: StiText, fillItems?: boolean): Object;
        private static getExpressionValue;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourceHelper {
        static getDatabaseFromDataSource(dataSource: StiDataSource): StiDatabase;
        static getDataSourcesFromDatabase(report: StiReport, database: StiDatabase): List<StiDataSource>;
        static getUsedDataSourcesNamesList(report: StiReport): string[];
        static getUsedDataSourcesNames(report: StiReport): Hashtable;
        static checkExpression(expression: string, component: StiComponent, datasourcesNames: Hashtable): void;
        private static addDataSourceName;
        private static addDataSourceColumn;
        private static addRelation;
        private static addSort;
        static getDataSourcesUsedInRequestFromUsersVariables(report: StiReport): Hashtable;
    }
}
declare module Stimulsoft.Report.Dictionary {
    enum StiVariableInitBy {
        Value = 0,
        Expression = 1
    }
    enum StiDateTimeType {
        Date = 0,
        DateAndTime = 1,
        Time = 2
    }
    enum StiItemsInitializationType {
        Items = 0,
        Columns = 1
    }
    enum StiTypeMode {
        Value = 0,
        NullableValue = 1,
        List = 2,
        Range = 3
    }
    enum StiSortOrder {
        Asc = 0,
        Desc = 1
    }
    enum StiAutoSynchronizeMode {
        None = 0,
        IfDictionaryEmpty = 1,
        Always = 2
    }
    enum StiRestrictionTypes {
        None = 0,
        DenyEdit = 1,
        DenyDelete = 2,
        DenyMove = 4,
        DenyShow = 8
    }
    enum StiDataType {
        BusinessObject = 0,
        DataSource = 1,
        DataRelation = 2,
        DataColumn = 3,
        Database = 4,
        Resource = 5,
        Variable = 6,
        Total = 7
    }
    enum StiTotalEvent {
        Never = 0,
        OnEachRecord = 1,
        OnGroupChanged = 2,
        OnPageChanged = 3,
        OnColumnChanged = 4,
        OnEachNewBand = 5,
        OnExpressionChanged = 6
    }
    enum StiResourceType {
        Image = 0,
        Csv = 1,
        Dbf = 2,
        Json = 3,
        Xml = 4,
        Xsd = 5,
        Excel = 6,
        Rtf = 7,
        Txt = 8,
        Report = 9,
        ReportSnapshot = 10,
        FontTtc = 11,
        FontTtf = 12,
        FontOtf = 13,
        FontEot = 14,
        FontWoff = 15,
        Pdf = 16,
        Word = 17
    }
    enum StiPropertiesProcessingType {
        All = 0,
        Browsable = 1
    }
    enum StiFieldsProcessingType {
        All = 0,
        Browsable = 1
    }
    enum StiConnectionOrder {
        None = 0,
        Standard = 1,
        Sql = 2
    }
    enum StiSqlSourceType {
        Table = 0,
        StoredProcedure = 1
    }
    enum StiColumnsSynchronizationMode {
        KeepAbsentColumns = 0,
        RemoveAbsentColumns = 1
    }
    enum StiSelectionMode {
        FromVariable = 0,
        Nothing = 1,
        First = 2
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiUndefinedDataSource extends StiDataTableSource {
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    import List = Stimulsoft.System.Collections.List;
    class StiDataSourcesCollection extends CollectionBase<StiDataSource> implements IStiJsonReportObject, ICloneable, IComparer<Object> {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dictionary;
        private directionFactor;
        compare(x: Object, y: Object): number;
        private _cachedDataSources;
        readonly cachedDataSources: Hashtable;
        fetchAllDataTransformations(): List<StiDataTransformation>;
        fetchAllVirtualDataSources(): List<StiVirtualSource>;
        toList(): Array<StiDataSource>;
        add(dataSource: StiDataSource): void;
        addRange(datas: StiDataSource[]): any;
        addRange(datas: StiDataSourcesCollection): any;
        contains(dataSource: StiDataSource | string): boolean;
        indexOf(dataSource: StiDataSource): number;
        insert(index: number, dataSource: StiDataSource): void;
        onClear(): void;
        remove(dataSource: StiDataSource): void;
        getByIndex(index: number): StiDataSource;
        setByIndex(index: number, data: StiDataSource): void;
        getByName(name: string): StiDataSource;
        getByXmlRef(xmlRef: string): StiDataSource;
        setByName(name: string, value: StiDataSource): void;
        readonly items: StiDataSource[];
        clone(): Object;
        sort(order?: StiSortOrder, sortColumns?: boolean): void;
        clearParametersExpression(): void;
        connectAsync(loadData: boolean, datas?: StiDataCollection): Promise<void>;
        connect(loadData: boolean, datas?: StiDataCollection): void;
        disconnect(): void;
        constructor(dictionary: StiDictionary);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    enum StiDataTransformationMode {
        Dimension = 0,
        Measure = 1
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import List = Stimulsoft.System.Collections.List;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import Type = Stimulsoft.System.Type;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import StiDataRequestOption = Stimulsoft.Data.Engine.StiDataRequestOption;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    /**
     *  Describes the object which helps in data transformation.
     */
    class StiDataTransformation extends StiDataStoreSource implements IStiQueryObject, IStiJsonReportObject {
        private static ImplementsStiDataTransformation;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        retrieveUsedDataNames(group: string): List<string>;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        getKey(): string;
        isDataSource: true;
        /**
         *  Returns a DataTable with data from this datasource.
         *  @returns The DataTable with data.
         */
        getDataTable2Async(allowConnectToData: boolean): Promise<DataTable>;
        getDataAdapterType(): Type;
        sorts: List<StiDataSortRule>;
        filters: List<StiDataFilterRule>;
        actions: List<StiDataActionRule>;
        retrieveDataTableAsync(option: StiDataRequestOption): Promise<DataTable>;
        connectToDataAsync(): Promise<void>;
        getMeters(group?: string): List<IStiMeter>;
        getMeter(column: StiDataTransformationColumn): IStiMeter;
        componentId: StiComponentId;
        createNew(): StiDataSource;
        /**
         *  Creates a new object of the type StiDataTransformation.
         */
        constructor(nameInSource?: string, name?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary.Design {
    import Type = Stimulsoft.System.Type;
    class StiDataColumnConverter {
        static convertTypeToString(type: Type): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import Type = Stimulsoft.System.Type;
    class StiDataColumn implements IStiJsonReportObject, ICloneable, IStiName, IStiAppDataColumn, IStiInherited {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataColumn;
        memberwiseClone(): StiDataColumn;
        getNameInSource(): string;
        /**
         *  Returns a name of the data column.
         *  @returns The name of the data column.
         */
        getName(): string;
        /**
         *  Returns a type of the data column.
         *  @returns The name of the data column.
         */
        getDataType(): Type;
        getKey(): string;
        setKey(key: string): void;
        private _name;
        name: string;
        inherited: boolean;
        dataColumnsCollection: StiDataColumnsCollection;
        private _dataSource;
        dataSource: StiDataSource;
        private _businessObject;
        businessObject: StiBusinessObject;
        private _index;
        index: number;
        private _nameInSource;
        nameInSource: string;
        private _alias;
        alias: string;
        private _type;
        type: Stimulsoft.System.Type;
        private _key;
        key: string;
        getColumnPath(): string;
        toString(): string;
        static getDataColumnFromColumnName(dictionary: StiDictionary, column: string, allowRelationName?: boolean): StiDataColumn;
        static getRelationName(dictionary: StiDictionary, dataSource: StiDataSource, relationName: string): string;
        static getDataFromBusinessObject(dictionary: StiDictionary, column: string): Object;
        static getBusinessObjectFromDataColumn(dictionary: StiDictionary, column: string): StiBusinessObject;
        static getDataFromDataColumn(dictionary: StiDictionary, column: string, useRelationName?: boolean): Object;
        static getDataSourceFromDataColumn(dictionary: StiDictionary, column: string): StiDataSource;
        static getColumnNameFromDataColumn(dictionary: StiDictionary, column: string): string;
        static getDataListFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number, firstPositionInDataSource?: boolean): any[];
        static getDatasFromDataColumn(dictionary: StiDictionary, column: string, maxRows?: number, firstPositionInDataSource?: boolean): any[];
        constructor(nameInSource?: string, name?: string, alias?: string, type?: Stimulsoft.System.Type, key?: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    /**
     * Describes a data transformation column.
     */
    class StiDataTransformationColumn extends StiDataColumn implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         * Gets or sets an expression of the calculated column.
         */
        expression: string;
        /**
         *  Gets or sets the type of the resource.
         */
        mode: StiDataTransformationMode;
        getDictionaryColumn(): StiDataColumn;
        /**
         *  Creates a new object of the type StiCalcDataColumn.
         *  @param name Name of column.let
         *  @param alias Alias of column.let
         *  @param type Type of data of column.let
         *  @param key Key string.let
         */
        constructor(name?: string, alias?: string, type?: Type, expression?: string, key?: string, mode?: StiDataTransformationMode);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    class StiDataTransformationMeter {
        getUniqueCode(): number;
        expression: string;
        label: string;
        constructor(expression: string, label: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionTransformationMeter extends StiDataTransformationMeter implements IStiDimensionMeter {
        private static ImplementsStiDimensionTransformationMeter;
        implements(): string[];
        getUniqueCode(): number;
        /**
         * Gets or sets unically object identificator.
         */
        key: string;
        constructor(expression: string, label: string, key: string);
    }
}
declare namespace Stimulsoft.Report.Dictionary {
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    class StiMeasureTransformationMeter extends StiDataTransformationMeter implements IStiMeasureMeter {
        private static ImplementsStiMeasureTransformationMeter;
        implements(): string[];
        getUniqueCode(): number;
        /**
         *  Gets or sets unically object identificator.
         */
        key: string;
        constructor(expression: string, label: string, key: string);
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiDataLoaderHelperData = Stimulsoft.Base.StiDataLoaderHelperData;
    class StiUniversalDataLoader {
        static loadMutiple(report: StiReport, path: string, filter: string, binary: boolean): StiDataLoaderHelperData[];
        static loadSingle(report: StiReport, path: string, binary: boolean): StiDataLoaderHelperData;
    }
}
declare module Stimulsoft.Report.Events {
    class StiDisconnectedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiDisconnectingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiConnectedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiConnectingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiDisconnectedEvent = Stimulsoft.Report.Events.StiDisconnectedEvent;
    import StiDisconnectingEvent = Stimulsoft.Report.Events.StiDisconnectingEvent;
    import StiConnectedEvent = Stimulsoft.Report.Events.StiConnectedEvent;
    import StiConnectingEvent = Stimulsoft.Report.Events.StiConnectingEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    enum Order {
        Name = 100,
        Alias = 200,
        ConnectionString = 300,
        FirstRowIsHeader = 350,
        PathSchema = 400,
        PathData = 500,
        XmlType = 600,
        PromptUserNameAndPassword = 700,
        SaveDataInReportResources = 800
    }
    class StiDatabase extends StiService implements IStiInherited, IStiAppConnection, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _inherited;
        inherited: boolean;
        getName(): string;
        getKey(): string;
        setKey(key: string): void;
        ß: any;
        readonly serviceCategory: string;
        readonly serviceType: Type;
        protected onConnecting(e: EventArgs): void;
        invokeConnecting(): void;
        connectingEvent: StiConnectingEvent;
        protected onConnected(e: EventArgs): void;
        invokeConnected(): void;
        connectedEvent: StiConnectedEvent;
        protected onDisconnecting(e: EventArgs): void;
        invokeDisconnecting(): void;
        disconnectingEvent: StiDisconnectingEvent;
        protected onDisconnected(e: EventArgs): void;
        invokeDisconnected(): void;
        disconnectedEvent: StiDisconnectedEvent;
        readonly serviceName: string;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _key;
        key: string;
        readonly connectionType: StiConnectionType;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        toString(): string;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): Promise<void>;
        createNew(): StiDatabase;
        constructor(name?: string, alias?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiResource implements IStiName, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        clone(): StiResource;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        inherited: boolean;
        private _name;
        name: string;
        alias: string;
        availableInTheViewer: boolean;
        private _content;
        content: number[];
        private _packAndEncryptContent;
        packAndEncryptContent: string;
        key: string;
        type: StiResourceType;
        dataSet: DataSet;
        getResourceAsImage(): Image;
        toString(): string;
        getContentType(): string;
        getFileExt(): string;
        constructor(name?: string, alias?: string, inherited?: boolean, type?: StiResourceType, content?: number[], availableInTheViewer?: boolean);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDialogInfo implements IStiJsonReportObject {
        jsonLoadedBindingVariableName: string;
        xmlLoadedBindingVariable: XmlNode;
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        private _dateTimeType;
        dateTimeType: StiDateTimeType;
        private _itemsInitializationType;
        itemsInitializationType: StiItemsInitializationType;
        private _keysColumn;
        keysColumn: string;
        private _valuesColumn;
        valuesColumn: string;
        private _bindingVariable;
        bindingVariable: StiVariable;
        private _bindingValuesColumn;
        bindingValuesColumn: string;
        private _mask;
        mask: string;
        private _allowUserValues;
        allowUserValues: boolean;
        private _bindingValue;
        bindingValue: boolean;
        private _keys;
        keys: string[];
        private _values;
        values: string[];
        private _valuesBinding;
        valuesBinding: Object[];
        readonly isDefault: boolean;
        static convert(value: Object): string;
        getDialogInfoItems(type: Stimulsoft.System.Type): StiDialogInfoItem[];
        setDialogInfoItems(items: StiDialogInfoItem[], type: Stimulsoft.System.Type): void;
        constructor();
    }
    class StiDialogInfoItem {
        readonly componentId: StiComponentId;
        readonly propName: string;
        private _keyObject;
        keyObject: Object;
        private _keyObjectTo;
        keyObjectTo: Object;
        private _valueBinding;
        valueBinding: Object;
        private _value;
        value: string;
        toString(dateTimeType: StiDateTimeType): string;
    }
    class StiRangeDialogInfoItem extends StiDialogInfoItem {
    }
    class StiStringDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: string;
    }
    class StiGuidDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Guid;
        constructor();
    }
    class StiCharDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Char;
        constructor();
    }
    class StiBoolDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: boolean;
        constructor();
    }
    class StiImageDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Drawing.Image;
        constructor();
    }
    class StiDateTimeDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.DateTime;
        constructor();
    }
    class StiTimeSpanDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.TimeSpan;
        constructor();
    }
    class StiDoubleDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Double;
        constructor();
    }
    class StiDecimalDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Decimal;
        constructor();
    }
    class StiLongDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: Stimulsoft.System.Long;
        constructor();
    }
    class StiExpressionDialogInfoItem extends StiDialogInfoItem {
        readonly componentId: StiComponentId;
        key: string;
        constructor();
    }
    class StiStringRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: string;
        to: string;
        constructor();
    }
    class StiGuidRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Guid;
        to: Stimulsoft.System.Guid;
        constructor();
    }
    class StiByteArrayRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        /**
         *  Gets or sets value which will be used as From key of range item in GUI.
         */
        readonly from: number[];
        form: number[];
        /**
         *  Gets or sets value which will be used as To key of range item in GUI.
         */
        to: number[];
    }
    class StiCharRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Char;
        to: Stimulsoft.System.Char;
        constructor();
    }
    class StiDateTimeRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.DateTime;
        to: Stimulsoft.System.DateTime;
        constructor();
    }
    class StiTimeSpanRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.TimeSpan;
        to: Stimulsoft.System.TimeSpan;
        constructor();
    }
    class StiDoubleRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Double;
        to: Stimulsoft.System.Double;
        constructor();
    }
    class StiDecimalRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Decimal;
        to: Stimulsoft.System.Decimal;
        constructor();
    }
    class StiLongRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: Stimulsoft.System.Long;
        to: Stimulsoft.System.Long;
        constructor();
    }
    class StiExpressionRangeDialogInfoItem extends StiRangeDialogInfoItem {
        readonly componentId: StiComponentId;
        from: string;
        to: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DateTime = Stimulsoft.System.DateTime;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiName = Stimulsoft.Report.IStiName;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import Type = Stimulsoft.System.Type;
    import IClonable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    class StiVariable extends StiExpression implements IStiName, IStiInherited, IClonable, IStiAppVariable, IStiJsonReportObject {
        private convertTypeToJsonString;
        private convertJsonStringToType;
        saveToJsonObject(): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        static loadFromXml(xmlNode: XmlNode, report: StiReport): StiVariable;
        static convertFromStringToDialogInfo(str: string, report: StiReport): StiDialogInfo;
        private static parseStringArray;
        getName(): string;
        getValue(): any;
        getKey(): string;
        setKey(key: string): void;
        private _inherited;
        inherited: boolean;
        private _name;
        name: string;
        readonly applyFormat: boolean;
        private _dialogInfo;
        dialogInfo: StiDialogInfo;
        private _alias;
        alias: string;
        private _type;
        type: Type;
        private _readOnly;
        readOnly: boolean;
        private _requestFromUser;
        requestFromUser: boolean;
        private _allowUseAsSqlParameter;
        allowUseAsSqlParameter: boolean;
        private _category;
        category: string;
        private _description;
        description: string;
        readonly isCategory: boolean;
        valueObject: Object;
        initByExpressionFrom: string;
        initByExpressionTo: string;
        getValueProp(): string;
        setValueProp(value: string): void;
        function: boolean;
        private _initBy;
        initBy: StiVariableInitBy;
        private _selection;
        selection: StiSelectionMode;
        private _key;
        key: string;
        private getRangeValues;
        static getValue(str: string, type: Type): Object;
        private setValue;
        getNativeValue(): string;
        static getDateTimeFromValue(value: string): DateTime;
        static getValueFromDateTime(value: Stimulsoft.System.DateTime): string;
        eval(report: StiReport): Object;
        toString(): string;
        constructor(category?: string, name?: string, alias?: string, description?: string, typeT?: Type, value?: string, readOnly?: boolean, initBy?: StiVariableInitBy, requestFromUser?: boolean, dialogInfo?: StiDialogInfo, key?: string, allowUseAsSqlParameter?: boolean, selection?: StiSelectionMode);
    }
}
declare module Stimulsoft.Report {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    enum StiNamingRule {
        Simple = 0,
        Advanced = 1
    }
    class StiNameCreation {
        static namingRule: StiNamingRule;
        private static removeSpacesFromName;
        static createSimpleName(report: StiReport, baseName: string): string;
        static createName(report: StiReport, baseName: string, addOne?: boolean, removeIncorrectSymbols?: boolean, forceAdvancedNamingRule?: boolean): string;
        static createResourceName(report: StiReport, baseName: string): string;
        static createConnectionName(report: StiReport, baseName: string): string;
        static isResourceNameExists(report: StiReport, name: string): boolean;
        static isConnectionNameExists(report: StiReport, name: string): boolean;
        static createColumnName(dataSource: StiDataSource, baseName: string): string;
        static isColumnNameExists(dataSource: StiDataSource, name: string): boolean;
        static isValidName(report: StiReport, name: string): boolean;
        static exists(checkedObject: Object, report: StiReport, name: string): boolean;
        static checkName(checkedObject: Object, report: StiReport, name: string, messageBoxCaption: string, isValid?: boolean): boolean;
        private static getObjectWithName;
        static generateName1(report: StiReport, localizedName: string, name: string): string;
        static generateName2(report: StiReport, localizedName: string, type: Stimulsoft.System.Type): string;
        static generateName(component: StiComponent): string;
        static generateName4(relation: StiDataRelation): string;
        static generateName5(dataSource: StiDataSource): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiFileDatabase extends StiDatabase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        createDataSources(dictionary: StiDictionary): void;
        parsePathExpression(dictionary: StiDictionary, path: string): string;
        pathData: string;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCsvDatabase extends StiFileDatabase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly serviceName: string;
        createNew(): StiDatabase;
        readonly componentId: StiComponentId;
        separator: string;
        codePage: number;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        regData(dictionary: StiDictionary, loadData: boolean): any;
        constructor(name?: string, pathData?: string, codePage?: number, separator?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiExcelDatabase extends StiFileDatabase {
        createNew(): StiDatabase;
        readonly serviceName: string;
        readonly componentId: StiComponentId;
        private _firstRowIsHeader;
        firstRowIsHeader: boolean;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        private getDataSet;
        getDataSetPrivate(workbook: Stimulsoft.ExternalLibrary.XLSX.IWorkBook): DataSet;
        private getType;
        constructor(name?: string, pathData?: string, key?: string, firstRowIsHeader?: boolean);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Promise = Stimulsoft.System.Promise;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    class StiJsonDatabase extends StiFileDatabase {
        createNew(): StiDatabase;
        readonly serviceName: string;
        private getDataSet;
        private getDataSetAsync;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): Promise<void>;
        constructor(name?: string, pathData?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Promise = Stimulsoft.System.Promise;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiXmlDatabase extends StiFileDatabase implements IStiJsonReportObject {
        createNew(): StiDatabase;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly serviceName: string;
        private _pathSchema;
        pathSchema: string;
        private _xmlType;
        xmlType: StiXmlType;
        private getDataSet;
        private getDataSetAsync;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        regDataAsync(dictionary: StiDictionary, loadData: boolean): Promise<void>;
        getDatabaseInformation(dictionary: StiDictionary): StiDatabaseInformation;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        constructor(name?: string, pathSchema?: string, pathData?: string, key?: string, xmlType?: StiXmlType);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataSchema = Stimulsoft.Base.StiDataSchema;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiNoSqlDatabase extends StiDatabase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly connectionType: StiConnectionType;
        connectionString: string;
        connectionStringEncrypted: string;
        promptUserNameAndPassword: boolean;
        readonly canEditConnectionString: boolean;
        protected readonly dataAdapterType: string;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        protected getDataAdapterType(): Stimulsoft.System.Type;
        getDataAdapter(): StiNoSqlAdapterService;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformation(): StiDatabaseInformation;
        protected getDatabaseInformationTables(dataSchema: StiDataSchema): DataTable[];
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getConnectionStringHelper(): string;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMongoDbDatabase extends StiNoSqlDatabase {
        createNew(): StiDatabase;
        readonly componentId: StiComponentId;
        protected getDataAdapterType(): Stimulsoft.System.Type;
        createDataSource(nameInSource: string, name: string): StiNoSqlSource;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import DataTable = Stimulsoft.System.Data.DataTable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Promise = Stimulsoft.System.Promise;
    class StiSqlDatabase extends StiDatabase implements IStiJsonReportObject {
        private static encryptedId;
        createNew(): StiDatabase;
        readonly serviceName: string;
        readonly componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        protected readonly dataAdapterType: string;
        readonly connectionType: StiConnectionType;
        private _connectionString;
        connectionString: string;
        connectionStringEncrypted: string;
        private _promptUserNameAndPassword;
        promptUserNameAndPassword: boolean;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapter(): StiSqlAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        regData(dictionary: StiDictionary, loadData: boolean): void;
        applyDatabaseInformation(information: StiDatabaseInformation, report: StiReport, informationAll?: StiDatabaseInformation): void;
        protected applyDatabaseInformationTables(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationViews(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationProcedures(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation): void;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        getDatabaseInformationAsync(dictionary: StiDictionary): Promise<StiDatabaseInformation>;
        private static getDatabaseInformationTables;
        private static getDatabaseInformationViews;
        private static getDatabaseInformationProcedures;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiODataDatabase extends StiSqlDatabase {
        createNew(): StiDatabase;
        readonly serviceName: string;
        readonly componentId: StiComponentId;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getConnectionStringHelper(): string;
        mapUserNameAndPassword(userName: string, password: string): string;
        readonly connectionType: StiConnectionType;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFirebirdDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiMySqlDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        createNew(): StiDatabase;
        readonly serviceName: string;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiOracleDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiPostgreSQLDatabase extends StiSqlDatabase {
        readonly componentId: StiComponentId;
        readonly serviceName: string;
        createNew(): StiDatabase;
        createDataSource(nameInSource: string, name: string): StiSqlSource;
        getDataAdapterType(): Stimulsoft.System.Type;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiCustomDatabase extends StiSqlDatabase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private dataAdapter;
        static registerCustomDatabase(options: {
            serviceName: string;
            sampleConnectionString: string;
            process: (command: any, callback: (result: any) => void) => void;
        }): void;
        createNew(): StiDatabase;
        private _serviceName;
        readonly serviceName: string;
        createDataSource(nameInSource: string, name: string): StiCustomSource;
        getDataAdapter(): StiSqlAdapterService;
        getDataAdapterType(): Stimulsoft.System.Type;
        protected applyDatabaseInformationSource(information: StiDatabaseInformation, report: StiReport, informationAll: StiDatabaseInformation, dataTable: DataTable, type?: StiSqlSourceType): void;
        private _sampleConnectionString;
        getSampleConnectionString(): string;
        constructor(name?: string, alias?: string, connectionString?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDatabaseCollection extends CollectionBase<StiDatabase> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        toList(): StiDatabase[];
        add(data: StiDatabase): void;
        addRange(datas: StiDatabase[]): any;
        addRange(datas: StiDatabaseCollection): any;
        contains(data: StiDatabase | string): boolean;
        indexOf(data: StiDatabase | string): number;
        insert(index: number, data: StiDatabase): void;
        remove(data: StiDatabase): any;
        remove(name: string): any;
        getByIndex(index: number): StiDatabase;
        setByIndex(index: number, data: StiDatabase): void;
        getByName(name: string): StiDatabase;
        setByName(name: string, value: StiDatabase): void;
        clone(): StiDatabaseCollection;
        memberwiseClone(): StiDatabaseCollection;
        private dictionary;
        constructor(dictionary: StiDictionary);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiUndefinedDatabase extends StiDatabase {
        constructor(name?: string, alias?: string, connectionString?: string, promptUserNameAndpassword?: boolean, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    enum StiConnectionType {
        Sql = 0,
        NoSql = 1,
        Other = 2,
        Rest = 3,
        Custom = 4
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparable = Stimulsoft.System.IComparable;
    import Type = Stimulsoft.System.Type;
    class StiFunction implements IComparable {
        implements(): string[];
        compareTo(obj: Object): number;
        private _useFullPath;
        useFullPath: boolean;
        private _category;
        category: string;
        private _groupFunctionName;
        groupFunctionName: string;
        private _functionName;
        functionName: string;
        private _description;
        description: string;
        private _typeOfFunction;
        typeOfFunction: string;
        private _returnType;
        returnType: Type;
        private _returnDescription;
        returnDescription: string;
        private _argumentTypes;
        argumentTypes: Type[];
        private _argumentNames;
        argumentNames: string[];
        private _argumentDescriptions;
        argumentDescriptions: string[];
        jsFunction: Function;
        toString(): string;
        getLongFunctionString(language: StiReportLanguageType): string;
        getFunctionString(language: StiReportLanguageType, addFunctionName?: boolean): string;
        convertTypeToString(typeT: Type, language: StiReportLanguageType): string;
        constructor(category: string, groupFunctionName: string, functionName: string, description: string, typeOfFunction: string, returnType: Type, returnDescription?: string, argumentTypes?: Type[], argumentNames?: string[], argumentDescriptions?: string[]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsMath {
        private static isCreated;
        static create(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsPrintState {
        private static isCreated;
        static create(): void;
        static isNull(dataSource: any, dataColumn: string): boolean;
        static next(dataSource: any, dataColumn: string): any;
        static nextIsNull(dataSource: any, dataColumn: string): any;
        static previous(dataSource: any, dataColumn: string): any;
        static previousIsNull(dataSource: any, dataColumn: string): any;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsProgrammingShortcut {
        private static isCreated;
        static create(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DateTime = Stimulsoft.System.DateTime;
    class StiFunctionsStrings {
        private static isCreated;
        static create(): void;
        static toProperCase(str: string): string;
        static substring(str: Object, startIndex: number, length: number): string;
        static left(str: Object, length: number): string;
        static right(str: Object, length: number): string;
        static mid(str: Object, startIndex: number, length: number): string;
        static roman(value: number): string;
        static abc(value: number | string): string;
        static arabic(value: number | string): string;
        static persian(value: number | string): string;
        static toWords(value: number, upperCase?: boolean, femaleEs?: boolean): string;
        static dateToStr(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWords(value: number, upperCase: boolean, showCents: boolean, dollars?: string, cents?: string): string;
        static toCurrencyWords2(value: number, upperCase?: boolean | string, showCents?: boolean | number | string, dollars?: string | boolean, cents?: string): string;
        static toOrdinal(value: number): string;
        static toWordsRu(value: number, upperCase?: boolean): string;
        static dateToStrRu(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsRu(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static toCurrencyWordsThai(value: number): string;
        private static SP_STRtNumToMny;
        private static SP_XCGtNumToMny;
        private static reverseString;
        private static tC_0;
        private static tC_1;
        private static tC_2;
        private static tC_3;
        private static tC_4;
        private static tC_5;
        private static tC_6;
        private static tC_7;
        private static tC_8;
        private static tC_9;
        private static tC_01;
        private static tC_10;
        private static tC_20;
        private static tC_100;
        private static tC_1000;
        private static tC_10000;
        private static tC_100000;
        private static tC_1000000;
        private static tC_Baht;
        private static tC_Satang;
        private static tC_Complete;
        static toWordsUa(value: number, uppercase?: boolean, gender?: Stimulsoft.Report.Func.Gender): string;
        static dateToStrUa(value: DateTime, upperCase?: boolean): string;
        static toCurrencyWordsUa(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static toWordsPt(value: number, upperCase: boolean): string;
        static toCurrencyWordsPt(value: number, upperCase: boolean, showCents: boolean): string;
        static toCurrencyWordsPtBr(value: number): string;
        static DateToStrPt(value: DateTime): string;
        static dateToStrPtBr(value: DateTime): string;
        static toCurrencyWordsFr(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEs(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsEs(value: number, upperCase: boolean): string;
        static toWordsEs2(value: number, upperCase: boolean, female: boolean): string;
        static toCurrencyWordsNl(numberr: number, currencyISO: string, decimals: number): string;
        static toCurrencyWordsEnGb(numberr: number, currencyISO: string, decimals: number): string;
        static toWordsPl(value: number, upperCase: boolean): string;
        static dateToStrPl(value: DateTime, upperCase: boolean): string;
        static toCurrencyWordsPl(value: number, currencyISO: string, showCents: boolean, upperCase: boolean): string;
        static toWordsEnIn(value: number, blankIfZero: boolean): string;
        static toCurrencyWordsEnIn(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        static toWordsFa(value: number): string;
        static toWordsZh(value: number): string;
        static toCurrencyWordsZh(value: number): string;
        static toWordsTr(value: number): string;
        static toCurrencyWordsTr(value: number): string;
        static toCurrencyWordsTr2(value: number, currencyName: string, showZeroCents: boolean): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiFunctionsTotals {
        private static isCreated;
        static create(): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiAliasAttribute {
        private _alias;
        alias: string;
        constructor(alias: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiBusinessObjectSort implements IComparer<Object> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private businessObject;
        compare(x: Object, y: Object): number;
        compareValues(value1: Object, value2: Object, ascendary?: boolean): number;
        clear(): void;
        constructor(sortColumns: string[], businessObject: StiBusinessObject, rowToConditions: Hashtable, conditions: Object[][][]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiBusinessObjectToDataSet {
        private dataSet;
        private relations;
        private uniques;
        private level;
        convertBusinessObjectToDataSet(name: string, obj: Object): DataSet;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiAppCalcDataColumn = Stimulsoft.Base.IStiAppCalcDataColumn;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiCalcDataColumn extends StiDataColumn implements IStiJsonReportObject, IStiAppCalcDataColumn {
        private static ImplementsStiCalcDataColumn;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _value;
        value: string;
        expression: string;
        constructor(name?: string, alias?: string, typeT?: Type, value?: string, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiData {
        private _viewData;
        viewData: Object;
        private _data;
        data: Object;
        private _name;
        name: string;
        private _alias;
        alias: string;
        private _isReportData;
        isReportData: boolean;
        private _isBusinessObjectData;
        isBusinessObjectData: boolean;
        OriginalConnectionState: Object;
        toString(): string;
        constructor(name: string, data: Object, viewData?: Object);
    }
}
declare module Stimulsoft.Report {
    class StiNameValidator {
        private static cache;
        static correctName(str: string, checkKeywords?: boolean, report?: StiReport): string;
        private static checkKeyword;
        static correctBusinessObjectName(str: string): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiDataBuilder {
        static getColumnFromPath(path: string, dictionary: StiDictionary): StiDataColumn;
        static getColumnFromPath2(path: string, dataSource: StiDataSource): StiDataColumn;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    class StiDataCollection extends CollectionBase<StiData> {
        toList(): StiData[];
        add(data: StiData): void;
        addRange(data: StiData[]): void;
        indexOf(data: StiData): number;
        insert(index: number, data: StiData): void;
        remove(data: StiData): void;
        getByIndex(index: number): StiData;
        setByIndex(index: number, value: StiData): void;
        getByName(name: string): StiData;
        setByName(name: string, value: StiData): void;
        readonly items: StiData[];
        regData(name: string, alias: string, data: any, jsonRelationDirection?: JsonRelationDirection): void;
        private regDataDataTable;
        private regDataDataSet;
        private regDataDataTable2;
        private regDataDataSet2;
        regDataStiDataCollection(datas: StiDataCollection): void;
        clearReportDatabase(): void;
        contains(data: StiData | string): boolean;
        getData(typeData: Type): StiDataCollection;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataColumn = Stimulsoft.System.Data.DataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Type = Stimulsoft.System.Type;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiDataColumnsCollection extends CollectionBase<StiDataColumn> implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private decodeTypeName;
        loadFromXml(node: XmlNode): void;
        static checkType(typeName: string, type: Type): Type;
        cachedDataColumns: Hashtable;
        private directionFactor;
        dataSource: StiDataSource;
        private businessObject;
        toList(): Array<StiDataColumn>;
        onInsert(value: Object): void;
        add(column: StiDataColumn): any;
        add(name: string, typeT: Type): any;
        add(name: string, alias: string, type: Type): any;
        addRange(columns: StiDataColumn[] | StiDataColumnsCollection): void;
        contains(column: StiDataColumn | string): boolean;
        indexOf(column: StiDataColumn): number;
        insert(index: number, column: StiDataColumn): void;
        remove(column: StiDataColumn): void;
        getByIndex(index: number): StiDataColumn;
        setByIndex(index: number, value: StiDataColumn): void;
        getByName(name: string): StiDataColumn;
        setByName(name: string, value: StiDataColumn): void;
        sort(order: StiSortOrder): void;
        constructor(source?: StiBusinessObject | StiDataSource | Array<StiDataColumn> | Array<DataColumn>);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiExpression = Stimulsoft.Report.Expressions.StiExpression;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParameter extends StiExpression implements IStiName, IStiInherited, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        dataParametersCollection: StiDataParametersCollection;
        private _inherited;
        inherited: boolean;
        private _name;
        name: string;
        readonly applyFormat: boolean;
        expression: string;
        getParameterValue(): Object;
        private _parameterValue;
        parameterValue: Object;
        private _dataSource;
        dataSource: StiDataSource;
        private _type;
        type: number;
        private _size;
        size: number;
        private _key;
        key: string;
        toString(): string;
        constructor(name?: string, value?: string, type?: number, size?: number, key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDataParametersCollection extends CollectionBase<StiDataParameter> implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private dataSource;
        private cachedDataParameters;
        toList(): Array<StiDataParameter>;
        onInsert(index: number, value: Object): void;
        add(parameter: StiDataParameter): void;
        addRange(parameters: StiDataParameter[] | StiDataParametersCollection): void;
        contains(parameter: StiDataParameter | string): boolean;
        indexOf(parameter: StiDataParameter): number;
        insert(index: number, parameter: StiDataParameter): void;
        remove(parameter: StiDataParameter): void;
        getByIndex(index: number): StiDataParameter;
        setByIndex(index: number, value: StiDataParameter): void;
        getByName(name: string): StiDataParameter;
        setByName(name: string, value: StiDataParameter): void;
        constructor(dataSource?: StiDataSource);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import List = Stimulsoft.System.Collections.List;
    class StiDataRelation implements IStiName, IStiInherited, ICloneable, IStiAppDataRelation, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private parseStringArray;
        private _inherited;
        inherited: boolean;
        private _name;
        name: string;
        getName(): string;
        /**
         *  Returns reference to the dictionary which contains this datasource.
         *  @returns Reference to the app.
         */
        getDictionary(): IStiAppDictionary;
        /**
         *  Returns parent data source of this relation.
         *  @returns Reference to the data source.
         */
        getParentDataSource(): IStiAppDataSource;
        /**
         *  Returns child data source of this relation.
         *  @returns Reference to the data source.
         */
        getChildDataSource(): IStiAppDataSource;
        /**
         *  Returns an enumeration of the parent column keys of the data relation.
         *  @returns An reference to the enumeration.
         */
        fetchParentColumns(): List<string>;
        /**
         *  Returns an enumeration of the child column keys of the data relation.
         *  @returns An reference to the enumeration.
         */
        fetchChildColumns(): List<string>;
        /**
         *  Returns the status of the relation.
         *  @returns The status of the relation.
         */
        getActiveState(): boolean;
        getKey(): string;
        setKey(key: string): void;
        clone(): Object;
        private _dictionary;
        dictionary: StiDictionary;
        private _parentSource;
        parentSource: StiDataSource;
        private _childSource;
        childSource: StiDataSource;
        private _parentColumns;
        parentColumns: string[];
        private _childColumns;
        childColumns: string[];
        private _relationName;
        relationName: string;
        private _nameInSource;
        nameInSource: string;
        private _alias;
        alias: string;
        IsCloud: boolean;
        /**
         *  Gets or sets value which indicates that this data relation is active.
         */
        active: boolean;
        private _key;
        key: string;
        toString(): string;
        constructor(nameInSource?: string, name?: string, alias?: string, parentSource?: StiDataSource, childSource?: StiDataSource, parentColumns?: string[], childColumns?: string[], key?: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataRelationSetName {
        static setName(dataRelation: StiDataRelation, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDataRelationsCollection extends CollectionBase<StiDataRelation> implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDataRelationsCollection;
        private dictionary;
        cachedDataRelations: Hashtable;
        toList(): Array<StiDataRelation>;
        add(relation: StiDataRelation): void;
        addRange(relations: StiDataRelation[] | StiDataRelationsCollection): void;
        contains(relation: StiDataRelation | string): boolean;
        indexOf(relation: StiDataRelation): number;
        insert(index: number, relation: StiDataRelation): void;
        remove(relation: StiDataRelation): void;
        getByIndex(index: number): StiDataRelation;
        setByIndex(index: number, value: StiDataRelation): void;
        getByName(name: string): StiDataRelation;
        setByName(name: string, value: StiDataRelation): void;
        readonly items: StiDataRelation[];
        constructor(dictionary: StiDictionary);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataRetrieval {
        dispose(): void;
        private buildTokens;
        private _usedColumns;
        readonly usedColumns: Hashtable;
        private _usedRelations;
        readonly usedRelations: Hashtable;
        private _usedDataSources;
        readonly usedDataSources: Hashtable;
        retrieval(report: StiReport): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataRow = Stimulsoft.System.Data.DataRow;
    class StiDataRow {
        createDataRow(dataRow: StiDataRow): StiDataRow;
        private _row;
        row: DataRow;
        private dataSource;
        readonly dictionary: StiDictionary;
        getByColumnName(columnName: string): Object;
        getParentData(relation: string): StiDataRow;
        constructor(dataSource: StiDataSource, dataRow: DataRow);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiDataSort implements IComparer<DataRow> {
        private sortColumns;
        private rowToConditions;
        private conditions;
        private hashValues;
        private dataSource;
        private textComp;
        private static nullObject;
        compare(x: DataRow, y: DataRow): number;
        private compareRows;
        compareValues(value1: Object, value2: Object, ascendary?: boolean): number;
        clear(): void;
        constructor(rowToConditions: Hashtable, conditions: Object[][][], sortColumns: string[], dataSource: StiDataSource);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import StiService = Stimulsoft.Base.Services.StiService;
    import Type = Stimulsoft.System.Type;
    import StiDataTableSource = Stimulsoft.Report.Dictionary.StiDataTableSource;
    import DataSet = Stimulsoft.System.Data.DataSet;
    class StiDataTableSetNameService extends StiService {
        readonly serviceCategory: string;
        readonly serviceType: Type;
        setName(dataTableSource: StiDataTableSource, report: StiReport, dataSet: DataSet, name: string): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    import DataTable = Stimulsoft.System.Data.DataTable;
    class StiDatabaseInformation {
        private _tables;
        readonly tables: DataTable[];
        private _views;
        readonly views: DataTable[];
        private _storedProcedures;
        readonly storedProcedures: DataTable[];
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiAppDataColumn = Stimulsoft.Base.IStiAppDataColumn;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDatabaseCollection = Stimulsoft.Report.Dictionary.StiDatabaseCollection;
    import StiBusinessObjectsCollection = Stimulsoft.Report.Dictionary.StiBusinessObjectsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Promise = Stimulsoft.System.Promise;
    import List = Stimulsoft.System.Collections.List;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDataRelation = Stimulsoft.Base.IStiAppDataRelation;
    import IStiAppVariable = Stimulsoft.Base.IStiAppVariable;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import IStiAppConnection = Stimulsoft.Base.IStiAppConnection;
    class StiDictionary implements ICloneable, IStiAppDictionary, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiDictionary;
        /**
         *  Returns an enumeration of the data source from this dictionary.
         *  @returns The enumeration of the data source.
         */
        fetchDataSources(): List<IStiAppDataSource>;
        /**
         *  Returns an enumeration of the data relations from this dictionary.
         *  @returns The enumeration of the data relations.
         */
        fetchDataRelations(): List<IStiAppDataRelation>;
        /**
         *  Returns an enumeration of the variables from this dictionary.
         *  @returns The enumeration of the variables.
         */
        fetchVariables(): List<IStiAppVariable>;
        /**
         *  Returns datasource from the data dictionary by its name.
         *  @param name A name of the datasource.
         *  @returns The datasource from the data dictionary.Returns null, if datasource with specified name is not exists.
         */
        getDataSourceByName(name: string): IStiAppDataSource;
        /**
         *  Returns data column from the data dictionary by its name.
         *  @param name A name of the data column.
         *  @returns The data column from the data dictionary. Returns null, if data column with specified name is not exists.
         */
        getColumnByName(name: string): IStiAppDataColumn;
        /**
         *  Returns variable from the data dictionary by its name.
         *
         *  @param name A name of the variable.
         *  @returns The variable from the data dictionary. Returns null, if variable with specified name not exists.
         */
        getVariableByName(name: string): IStiAppVariable;
        /**
         *  Returns true if a specified name is a name of a system variable.
         *
         *  @param name The name of the system variable.
         *  @returns True, if the specified name is the name of system variable.
         */
        isSystemVariable(name: string): boolean;
        /**
         *  Returns value of a specified system variable.
         *
         *  @param name A name of the system variable.
         *  @returns The value of the specified system variable.
         */
        getSystemVariableValue(name: string): any;
        getApp(): IStiApp;
        /**
         *  Opens specified connections to the data. Opens all connections if none of them is specified.
         */
        openConnections(connections: List<IStiAppConnection>): List<IStiAppConnection>;
        /**
         *  Closes all specified connections. Closes all connections if none of them is specified.
         */
        closeConnections(connections: List<IStiAppConnection>): void;
        private _cachedUserNamesAndPasswords;
        cachedUserNamesAndPasswords: Hashtable;
        private _useInternalData;
        useInternalData: boolean;
        private _restrictions;
        restrictions: StiRestrictions;
        static autoSynchronize: StiAutoSynchronizeMode;
        static doAutoSynchronize(report: StiReport): void;
        private _cacheDataSet;
        cacheDataSet: DataSet;
        private _report;
        report: StiReport;
        private _dataStore;
        dataStore: StiDataCollection;
        private _variables;
        variables: StiVariablesCollection;
        private _resources;
        resources: StiResourcesCollection;
        private _dataSources;
        dataSources: StiDataSourcesCollection;
        private _databases;
        databases: StiDatabaseCollection;
        private _businessObjects;
        businessObjects: StiBusinessObjectsCollection;
        private _relations;
        relations: StiDataRelationsCollection;
        readonly isRequestFromUserVariablesPresent: boolean;
        private equalsColumns;
        createDatabases(loadData: boolean): void;
        createDatabasesAsync(loadData: boolean): Promise<void>;
        removeUnusedData(): void;
        removeUnusedDataSourcesV2(): void;
        retrievalData(REFusedRelations: any, REFusedDataSources: any, REFusedColumns: any): void;
        getUnusedRelationsFromDataStore(): StiDataRelationsCollection;
        private synchronize2;
        synchronize(): void;
        synchronizeBusinessObjects(): void;
        synchronizeColumns(data: StiData, dataSource: StiDataSource): void;
        synchronizeColumnsAsync(data: StiData, dataSource: StiDataSource): Promise<void>;
        synchronizeColumns3(data: StiBusinessObjectData, source: StiBusinessObject): void;
        synchronizeColumns2(data: Object, source: StiBusinessObject): void;
        clear(): void;
        private disposeCacheDataSet;
        renameDatabase(database: StiDatabase, newName: string): void;
        connectToDatabasesAsync(databases?: List<StiDatabase>, loadData?: boolean): Promise<void>;
        connectAsync(loadData?: boolean, dataSources?: StiDataSource[]): Promise<void>;
        connect(loadData?: boolean, dataSources?: StiDataSource[]): void;
        connectVirtualDataSources(): void;
        connectDataTransformationsAsync(): Promise<void>;
        connectCrossTabDataSources(): void;
        disconnect(): void;
        private disconnectingDatabases;
        private disconnectedDatabases;
        private disconnectingConnectionInDataStore;
        private checkRelation;
        private equalsRelationColumns;
        private getRelationName;
        regRelations2(virtualSources?: boolean): void;
        regRelation(relation: StiDataRelation, virtualSources: boolean): void;
        constructor(report?: StiReport);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import DataRow = Stimulsoft.System.Data.DataRow;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiGroupSummaryDataSort implements IComparer<DataRow> {
        private groupSummaries;
        private groupLines;
        private baseRowOrder;
        private groupHeaders;
        compare(row1: DataRow, row2: DataRow): number;
        private compareValues;
        clear(): void;
        constructor(groupSummaries: Hashtable, groupLines: Hashtable, groupHeaders: StiComponentsCollection, baseRowOrder: Hashtable);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalBusinessObjectSort implements IComparer<Object> {
        compare(x: Object, y: Object): number;
        private getParentValue;
        process(): void;
        private createTree;
        private setLevelAndSort;
        private createRowList;
        private businessObject;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        constructor(businessObject: StiBusinessObject, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    class StiHierarchicalDataSort implements IComparer<Object> {
        private dataSource;
        private keyColumn;
        private masterKeyColumn;
        private parentValue;
        private sortColumns;
        compare(x: Object, y: Object): number;
        private getParentValue;
        process(rowToConditions: Hashtable): void;
        private createTree;
        private setLevelAndSort;
        private createRowList;
        constructor(dataSource: StiDataSource, band: StiHierarchicalBand, sortColumns: string[]);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiResourcesCollection extends CollectionBase<StiResource> implements IComparer<StiResource>, IStiJsonReportObject {
        implements(): string[];
        clone(): StiResourcesCollection;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        loadFromXml(xmlNode: XmlNode): void;
        private directionFactor;
        compare(x: StiResource, y: StiResource): number;
        sort(order?: StiSortOrder): void;
        toList(): Array<StiResource>;
        add(resource: StiResource): void;
        addRange(resources: StiResourcesCollection): void;
        contains(resource: StiResource): boolean;
        indexOf(resource: StiResource): number;
        insert(index: number, resource: StiResource): void;
        remove(resource: StiResource): void;
        getByIndex(index: number): StiResource;
        setByIndex(index: number, data: StiResource): void;
        getByName(name: string): StiResource;
        getByAlias(alias: string): StiResource;
        setByName(name: string, value: StiResource): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiRestrictions {
        private restrictionsDataSource;
        private restrictionsDataRelation;
        private restrictionsDataColumn;
        private restrictionsDatabase;
        private restrictionsVariable;
        private restrictionsTotal;
        private restrictionsBusinessObject;
        clear(): void;
        private getHashtable;
        add(name: string, dataType: StiDataType, type: StiRestrictionTypes): void;
        isAllowEdit(name: string, dataType: StiDataType): boolean;
        isAllowDelete(name: string, dataType: StiDataType): boolean;
        isAllowShow(name: string, dataType: StiDataType): boolean;
        isAllowMove(name: string, dataType: StiDataType): boolean;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiRow {
        private dataSource;
        private rowIndex;
        getByName(columnName: string): Object;
        constructor(dataSource: StiDataSource, rowIndex: number);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IEnumerator = Stimulsoft.System.Collections.IEnumerator;
    class StiRowsCollection implements IEnumerator {
        getEnumerator(): IEnumerator;
        readonly current: Object;
        moveNext(): boolean;
        reset(): void;
        getbyIndex(rowIndex: number): StiRow;
        readonly count: number;
        private dataSource;
        constructor(dataSource: StiDataSource);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiStrFix {
        static Del_(str: string): string;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiSystemVariablesHelper {
        static getSystemVariableInfo(variable: string): string;
        static getSystemVariables(report: StiReport): string[];
        protected static systemVariablesV2: string[];
        static getSystemVariablesV2(): string[];
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiType {
        private _name;
        name: string;
        private _type;
        type: Stimulsoft.System.Type;
        static getTypes(): StiTypesCollection;
        static getBaseTypes(): StiTypesCollection;
        static getTypeModeFromType(type: Stimulsoft.System.Type, REFtypeMode: any): System.Type;
        static getTypeFromTypeMode(type: Stimulsoft.System.Type, typeMode: StiTypeMode): Stimulsoft.System.Type;
        toString(): string;
        constructor(name: string, type: Stimulsoft.System.Type);
    }
}
declare module Stimulsoft.Report.Dictionary {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiTypesCollection extends CollectionBase<StiType> {
        add(type: StiType): void;
        addRange(type: StiType[]): void;
        contains(type: StiType): boolean;
        indexOf(type: StiType): number;
        insert(index: number, type: StiType): void;
        remove(type: StiType): void;
        getByIndex(index: number): StiType;
        setByIndex(index: number, value: StiType): void;
        getByName(name: string): StiType;
        setByName(name: string, value: StiType): void;
        get(type: Stimulsoft.System.Type): StiType;
        set(type: Stimulsoft.System.Type, value: StiType): void;
        readonly items: StiType[];
        regType(name: string, type: Stimulsoft.System.Type): void;
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiUserNameAndPassword {
        private _userName;
        readonly userName: string;
        private _password;
        readonly password: string;
        constructor(userName: string, password: string);
    }
}
declare module Stimulsoft.Report.Dictionary {
    class StiVariableAsParameterHelper {
    }
}
declare module Stimulsoft.Report.Dictionary {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiVariablesCollection extends CollectionBase<StiVariable> implements IComparer<StiVariable>, ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson, report?: StiReport): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        private directionFactor;
        compare(x: StiVariable, y: StiVariable): number;
        sort(order?: StiSortOrder): void;
        toList(): Array<StiVariable>;
        add(variable: StiVariable): void;
        addRange(variables: StiVariablesCollection): void;
        contains(name: string): boolean;
        containsCategory(name: string): boolean;
        indexOf(data: string | StiVariable): number;
        insert(index: number, variable: StiVariable): void;
        remove(data: string | StiVariable): void;
        getByIndex(index: number): StiVariable;
        setByIndex(index: number, data: StiVariable): void;
        getByName(name: string): StiVariable;
        setByName(name: string, value: StiVariable): void;
        readonly items: Array<StiVariable>;
        clone(): Object;
        moveCategoryTo(fromCategory: string, toCategory: string): void;
        getFirstCategoryIndex(category: string): number;
        getLastCategoryIndex(category: string): number;
        renameCategory(oldName: string, newName: string): void;
        removeCategory(category: string): void;
        getVariablesCount(category: string): number;
    }
}
declare module Stimulsoft.Report.Engine {
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiChartBuilder extends StiComponentBuilder {
        static renderAtEnd(masterChart: IStiChart): void;
        static renderChart(masterChart: IStiChart): StiComponent;
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCloneBuilder extends StiContainerBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiFooterBand): StiDataBand;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnFooterBandBuilder extends StiFooterBandBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiHeaderBand = Stimulsoft.Report.Components.StiHeaderBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiHeaderBandBuilder extends StiBandBuilder {
        static getMaster(masterHeaderBand: StiHeaderBand): StiDataBand;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiColumnHeaderBandBuilder extends StiHeaderBandBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiCrossLinePrimitiveBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiCrossTabParams = Stimulsoft.Report.CrossTab.StiCrossTabParams;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiCrossHeader = Stimulsoft.Report.CrossTab.StiCrossHeader;
    class StiCrossTabBuilder extends StiContainerBuilder {
        static getCollapsingName(header: StiCrossHeader): string;
        static getCollapsingName2(componentName: string, level: number, value: string): string;
        static isCollapsed(masterHeader: StiCrossHeader): boolean;
        static isCollapsed2(masterHeader: StiCrossHeader, level: number, textValue: string): boolean;
        static setCollapsed(masterHeader: StiCrossHeader, isCollapsed: boolean): void;
        static makeHorAlignment(masterCrossTab: StiCrossTab, outContainer: StiContainer, startIndex: number, parentWidth: number, pageSegment: number): void;
        renderCrossTabOnPage(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle, endCol: any, endRow: any): void;
        makeHorAlignment(master: StiCrossTab, destination: StiContainer, startIndex: number, parentWidth: number, segmentPerWidth: number): void;
        finalizeCross(renderedComponent: StiContainer): void;
        private renderCrossTabSegment;
        private renderColHeaders;
        private allColFieldsPresentOnAllPages;
        private getEndColumn;
        private getEndRow;
        private renderRowHeaders;
        private renderCorner;
        renderCrossTabOnDataBand(pars: StiCrossTabParams, masterCrossTab: StiCrossTab, renderedComponent: StiContainer): StiComponent;
        renderCrossTab(pars: StiCrossTabParams, masterCrossTab: StiCrossTab): StiComponent;
        renderCrossTabUnlimitedBreakable(pars: StiCrossTabParams, master: StiCrossTab, destination: StiContainer, rect: Rectangle): void;
        private getPageForCrossTab;
        private getActualHeaderRowCount;
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiGroupHeaderBand = Stimulsoft.Report.Components.StiGroupHeaderBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiDataBandBuilder extends StiBandBuilder {
        getGroupHeaders(masterDataBand: StiDataBand): StiComponentsCollection;
        getGroupFooters(masterDataBand: StiDataBand): StiComponentsCollection;
        groupsComparison(masterDataBand: StiDataBand): void;
        findHeaders(masterDataBand: StiDataBand): void;
        findHierarchicalHeaders(masterDataBand: StiDataBand): void;
        findFooters(masterDataBand: StiDataBand): void;
        findHierarchicalFooters(masterDataBand: StiDataBand): void;
        findEmptyBands(masterDataBand: StiDataBand): void;
        findGroupHeaders(masterDataBand: StiDataBand): void;
        findGroupFooters(masterDataBand: StiDataBand): void;
        findDetailDataBands(masterDataBand: any): StiDataBand;
        private isParentOrCurrentBO;
        findSubReports(masterDataBand: StiDataBand): void;
        findDetails(masterDataBand: StiDataBand): void;
        resetHeaders(masterDataBand: StiDataBand): void;
        resetHierarchicalHeaders(masterDataBand: StiDataBand): void;
        resetFooters(masterDataBand: StiDataBand): void;
        resetHierarchicalFooters(masterDataBand: StiDataBand): void;
        resetEmptyBands(masterDataBand: StiDataBand): void;
        resetGroupHeaders(masterDataBand: StiDataBand): void;
        resetGroupFooters(masterDataBand: StiDataBand): void;
        resetDetailDataBands(masterDataBand: StiDataBand): void;
        resetDetails(masterDataBand: StiDataBand): void;
        addKeepLevelAtLatestDataBand(masterDataBand: StiDataBand): void;
        addKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepLevel(masterDataBand: StiDataBand): void;
        removeKeepGroupHeaders(masterDataBand: StiDataBand): void;
        removeKeepHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        allowKeepDetails(masterDataBand: StiDataBand): boolean;
        addKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetails(masterDataBand: StiDataBand): void;
        removeKeepDetailsRow(masterDataBand: StiDataBand): void;
        startBands(masterDataBand: StiDataBand, bands: StiComponentsCollection): void;
        /** Starts monitoring of specified band OnAllPages.*/
        startBand(masterDataBand: StiDataBand, band: StiBand): void;
        /** Ends monitoring of band OnAllPages.*/
        endBands(masterDataBand: StiDataBand): void;
        getGroupHeaderResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        getGroupFooterResult(masterDataBand: StiDataBand, groupHeaderBand: StiGroupHeaderBand): boolean;
        linkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        resetLinkGroupHeadersAndGroupFooters(masterDataBand: StiDataBand): void;
        static prepareGroupResults(masterDataBand: StiDataBand): void;
        /** Renders all group headers of this databand.*/
        renderGroupHeaders(masterDataBand: StiDataBand): void;
        renderGroupFooters(masterDataBand: StiDataBand): void;
        static setDetails(masterDataBand: StiDataBand): void;
        renderDetailDataBands(masterDataBand: StiDataBand): void;
        /** Returns databand on which specified container in splaced.*/
        private getParentDataBand;
        /** Returns true if specified detail DataBand can be printed.*/
        private isAllow;
        allowDetailDataBands(masterDataBand: StiDataBand): boolean;
        isDenyDetailsOnFirstPage(masterDataBand: StiDataBand): boolean;
        /** Gets value indicates that all detail components are empty.*/
        static isDetailDataSourcesEmpty(masterDataBand: StiDataBand): boolean;
        static isPrintIfDetailEmpty(masterDataBand: StiDataBand): boolean;
        renderHeaders(masterDataBand: StiDataBand, keepHeaders: boolean[]): void;
        renderHierarchicalHeaders(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        addFooterMarker(masterDataBand: StiDataBand, footerMaster: StiFooterBand): void;
        renderMarkerFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderFootersOnLastPage(masterDataBand: StiDataBand): void;
        renderFootersOnAllPages(masterDataBand: StiDataBand): void;
        renderHierarchicalFooters(masterDataBand: StiDataBand, allowIndent: boolean, level: number): void;
        renderReportTitles(masterDataBand: StiDataBand): void;
        renderReportSummaries(masterDataBand: StiDataBand): void;
        checkKeepReportSummaryTogether(masterDataBand: StiDataBand): boolean;
        block(masterDataBand: StiDataBand): void;
        unBlock(masterDataBand: StiDataBand): void;
        checkHierarchicalHeaders(masterDataBand: StiDataBand): void;
        checkHierarchicalFooters(masterDataBand: StiDataBand): void;
        renderBand(masterDataBand: StiDataBand, band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): void;
        renderColumns(masterDataBand: StiDataBand): void;
        registerEmptyBands(masterDataBand: StiDataBand): void;
        static isCollapsed(masterDataBand: StiContainer, isRendering: boolean): boolean;
        /** Sets system variables which are specific for the specified component.*/
        setReportVariables(masterComp: StiComponent): void;
        prepare(masterComp: StiComponent): void;
        /** Clears a component after rendering.*/
        unPrepare(masterComp: StiComponent): void;
        private static invokeCollapsedEvent;
        render(masterComp: StiComponent): StiComponent;
        renderMaster(masterDataBand: StiDataBand): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGaugeBuilder extends StiComponentBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiGroupFooterBand = Stimulsoft.Report.Components.StiGroupFooterBand;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGroupFooterBandBuilder extends StiBandBuilder {
        static getMaster(masterFooterBand: StiGroupFooterBand): StiDataBand;
        setReportVariables(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiHierarchicalBand = Stimulsoft.Report.Components.StiHierarchicalBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiHierarchicalBandBuilder extends StiDataBandBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
        private isCollapsed;
        static createIndention(masterHierarchical: StiHierarchicalBand, container: StiContainer, level: number): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiViewBuilder extends StiComponentBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiImageBuilder extends StiViewBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiMapBuilder extends StiComponentBuilder {
        static renderMap(masterMap: StiMap): StiMap;
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPageBuilder extends StiContainerBuilder {
        prepare(masterComp: StiComponent): void;
        unPrepare(masterComp: StiComponent): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiPointPrimitiveBuilder extends StiComponentBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    class StiReportBuilder {
        static renderSingleReport(masterReport: StiReport, renderState: StiRenderState): void;
        static renderSubReports(ownerReport: StiReport, renderState: StiRenderState): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSimpleTextBuilder extends StiComponentBuilder {
        prepare(masterComp: StiComponent): void;
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSubReportBuilder extends StiContainerBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiTextInCellsBuilder extends StiSimpleTextBuilder {
        internalRender(masterComp: StiComponent): StiComponent;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiBandInfo extends StiComponentInfo {
        forceCanBreak: boolean;
        forceCanGrow: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiContainerInfo extends StiComponentInfo {
        dataBandPosition: number;
        dataSourceRow: Stimulsoft.System.Data.DataRow;
        businessObjectCurrent: Object;
        isAutoRendered: boolean;
        ignoreResetPageNumber: boolean;
        isColumns: boolean;
        renderStep: number;
        setSegmentPerWidth: number;
        parentBand: StiBand;
    }
}
declare module Stimulsoft.Report.Components {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiDataBandInfo extends StiComponentInfo {
        groupHeaders: StiComponentsCollection;
        groupFooters: StiComponentsCollection;
        groupHeaderComponents: StiComponentsCollection;
        groupFooterComponents: StiComponentsCollection;
        detailDataBands: StiComponentsCollection;
        details: StiComponentsCollection;
        subReports: StiComponentsCollection;
        emptyBands: StiComponentsCollection;
        headers: StiComponentsCollection;
        hierarchicalHeaders: StiComponentsCollection;
        footersOnAllPages: StiComponentsCollection;
        footersOnLastPage: StiComponentsCollection;
        hierarchicalFooters: StiComponentsCollection;
        groupHeaderResults: Array<boolean>;
        groupFooterResults: Array<boolean>;
        reportTitles: Array<StiReportTitleBand>;
        reportSummaries: Array<StiReportSummaryBand>;
        detailDataBandsFromSubReports: Hashtable;
        storedParentBookmark: StiBookmark;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiFooterBandInfo extends StiComponentInfo {
        isTableFooter: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupFooterBandInfo extends StiComponentInfo {
        printAtBottomComponent: StiComponent;
        groupHeader: StiGroupHeaderBand;
        isTableGroupFooter: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiGroupHeaderBandInfo extends StiComponentInfo {
        skipKeepGroups: boolean;
        groupFooter: StiGroupFooterBand;
        silentModeEnabled: boolean;
        oldSilentMode: boolean;
        isTableGroupHeader: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHeaderBandInfo extends StiComponentInfo {
        isTableHeader: boolean;
    }
}
declare module Stimulsoft.Report.Components {
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    class StiHierarchicalBandInfo extends StiComponentInfo {
        specifiedLevel: number;
        finalFooterCalculation: boolean;
    }
}
declare module Stimulsoft.Report.Engine {
    var IStiReportProperty: string;
    interface IStiReportProperty {
        getReport(): Object;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    class StiBandsOnAllPages {
        private bands;
        engine: StiEngine;
        private _denyRendering;
        /** If the property is true then bands rendering on all pages is blocked. The property is used to
         * output headers, with the height higher than one page, on all pages.*/
        denyRendering: boolean;
        /** Starts monitoring of this band for rendering OnAllPages.*/
        add(dataBand: StiDataBand, band: StiBand): void;
        /** Ends monitoring of this band for rendering OnAllPages. All bands which are dependent on the specified DataBand are removed.*/
        remove(dataBand: StiDataBand): void;
        private allowRenderBand;
        /** Outputs bands, which were previously added to the collection of bands, which are output on all pages, on a new page.*/
        render(): void;
        private renderBand;
        isBandInBandsList(band: StiBand): boolean;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    class StiBookmarksHelper {
        static getBookmark(bookmark: StiBookmark, name: string): StiBookmark;
        static prepareBookmark(bookmark: StiBookmark): void;
        static createBookmark(text: string, componentGuid?: string): StiBookmark;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiBreakableHelper {
        engine: StiEngine;
        isCanBreak(container: StiContainer): boolean;
        isNeedBreak(container: StiContainer): boolean;
        break(originalContainer: StiContainer): StiContainer;
        setCanBreak(container: StiContainer): void;
        processBreakable(container: StiContainer): StiContainer;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiColumnDirection = Stimulsoft.Report.Components.StiColumnDirection;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiColumnsContainer extends StiContainer {
        private countOfItems;
        columns: number;
        columnWidth: number;
        columnGaps: number;
        columnDirection: StiColumnDirection;
        rightToLeft: boolean;
        minRowsInColumn: number;
        private engine;
        /** Adds a specified container into the container of columns. The CountOfItems field is increased on 1.*/
        addContainer(container: StiContainer): void;
        /** Returns the height of space to place a container into the current container of colimns.*/
        howMuchAdditionalSpaceNeeded(currentHeight: number, container: StiContainer): number;
        /** Finishes column formation in the container of columns. All containers are placed on their proper places.*/
        finishColumns(onlyCalc?: boolean): number;
        /** Returns the number of a column on the current moment. The number starts with 1.*/
        getCurrentColumn(): number;
        /** Returns the number of output databands in the last row. The method can be used only for the  AcrossThenDown mode.*/
        getLengthOfLastRow(): number;
        constructor(engine?: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    class StiColumnsOnDataBand {
        engine: StiEngine;
        private _enabled;
        /** Gets or sets value which indicates about current state of column on DataBand mode.*/
        enabled: boolean;
        /** Adds a container of columns to the current page.
         * A container of columns is used to output columns on a databand.*/
        renderColumns(dataBand: StiDataBand): StiColumnsContainer;
        /** Returns a container of columns that is the last on a page.
         * If after a container of columns other bands were output then return null.*/
        getColumns(): StiColumnsContainer;
        /** Creates and returns a container to output columns on a Databand.*/
        createColumns(dataBand: StiDataBand): StiColumnsContainer;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiColumnsOnPanel {
        engine: StiEngine;
        readonly count: number;
        readonly rightToLeft: boolean;
        readonly columnGaps: number;
        private _currentColumn;
        currentColumn: number;
        getColumnWidth(): number;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiEmptyBandsHelper {
        engine: StiEngine;
        private emptyBand;
        register(emptyBands: StiComponentsCollection): void;
        clear(): void;
        private createEmptyBandContainer;
        render(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiFooterBand = Stimulsoft.Report.Components.StiFooterBand;
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import IStiPageBreak = Stimulsoft.Report.Components.IStiPageBreak;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiEngine {
        /** If true then it is allowed to add any Bookmarks. If false then
         * add Bookmarks of components which the IsRendered property = false
         * (in other words it is rendered first time). This property allows adding Bookmarks
         * for static components only once (to avoid duplication).*/
        isDynamicBookmarksMode: boolean;
        /** This property is set to true for printing CrossBands.*/
        isCrossBandsMode: boolean;
        /** Returns true if the first DataBand is printed on the current page. */
        isFirstDataBandOnPage: boolean;
        /** Returns true if the last DataBand is printed on the current page.*/
        isLastDataBandOnPage: boolean;
        /** Contains the list of bands which should be passed when rendering.*/
        printOnAllPagesIgnoreList: Hashtable;
        private printOnAllPagesIgnoreList2;
        /** A class helps to output the progress bar when report rendering.*/
        /** Contains a collection of bands which should be output on all pages.*/
        bandsOnAllPages: StiBandsOnAllPages;
        /** If true then the Render method of a container will not render components of the
         * Master type. This property is used with the RenderSimpleComponents method of a page.
         * It is used to deny master components and render simple ones.*/
        denyRenderMasterComponentsInContainer: boolean;
        /** Contains a collection of bands which should be output on the bottom of a page.
         * The list is filled when stream rendering and the list is cleared when rendering
         * of the current stream is finished.*/
        printAtBottom: StiPrintAtBottom;
        /** Cotnains a collection of Footers which should be output on the bottom of a page.
         * The list is filled when stream rendering and the list is cleared when rendering
         * of the current stream is finished.*/
        footersOnAllPages: StiFootersOnAllPages;
        /** An object helps to output static bands on a page.*/
        staticBands: StiStaticBandsHelper;
        /** This object helps to print groups of bands from containers which are placed directly on a page.*/
        threads: StiThreads;
        /** An object helps to work with IStiBreakable interface.*/
        breakable: StiBreakableHelper;
        /** If true then it is impossible to change stream of printing.*/
        denyChangeThread: boolean;
        /** Contains a list of Slave Engines.*/
        slaveEngines: Hashtable;
        /** If an engine is slave then this reference indicates the parent report engine. */
        masterEngine: StiEngine;
        /** Used to output EmptyBands in the current container.*/
        emptyBands: StiEmptyBandsHelper;
        pageNumbers: StiPageNumberHelper;
        /** Used to output columns on the DataBand.*/
        columnsOnDataBand: StiColumnsOnDataBand;
        /** Used to output columns on the Panel.*/
        columnsOnPanel: StiColumnsOnPanel;
        /** Contains a freespace in a container in what the printing is done.*/
        freeSpace: number;
        /** Contains a freespace in a container in what the printing is done. Used to output Cross bands only.*/
        crossFreeSpace: number;
        /** Indicates the current position bands output on the X axis.*/
        positionX: number;
        /** Indicates the current position bands output on the Y axis.*/
        positionY: number;
        /** Indicates the current position bands output on the Y axis on the bottom of a page.*/
        positionBottomY: number;
        /** Gets or sets a container in what rendering of bands is done.*/
        containerForRender: StiContainer;
        /** Gets or sets a page in what rendering of bands is done.*/
        page: StiPage;
        /** Gets or sets a page from a template. This page is being rendered in the current moment.*/
        templatePage: StiPage;
        /** Gets or sets a container from a template. This page is being rendered in the current moment. If a page is output then
         * the TemplateContainer property is equal in TemplatePage.*/
        templateContainer: StiContainer;
        /** Gets or sets a report that is being rendered in the current moment.*/
        report: StiReport;
        /** Gets or sets a master report that is being rendered in the current moment.*/
        masterReport: StiReport;
        /** If true then UnlimitedHeight property is ignored when NewPage method is called.*/
        ignoreUnlimitedHeightForNewPage: boolean;
        /** Contains a list of stored bands for keepFirstDetailTogether property*/
        keepFirstDetailTogetherList: Hashtable;
        keepFirstDetailTogetherTablesList: Hashtable;
        specialContainerHeight: number;
        specialContainerHeight2: number;
        static specialContainerHeight2: number;
        startIndexPageForPageTotal: number;
        indexPageForPageTotal: number;
        private childsBandHash;
        silentMode: boolean;
        renderState: StiRenderState;
        indexOfLatestDataBand: StiIndex;
        generateNewPageBeforeBand: boolean;
        ignoreSkipFirst: boolean;
        generateNewColumnBeforeBand: boolean;
        /** Коллекция служит для определения случая пропуска генерации новой страницы или новой колонки при помощи свойства SkipFirst.
         * Если бэнд уже пропускал один раз генерацию новой страницы или колонки, то он заносится в эту коллекцию.*/
        pageBreakSkipFirstCollection: Hashtable;
        indexOfStartList: number;
        skipFirstPageBeforePrintEvent: boolean;
        firstCallNewPage: boolean;
        /** Флаг устанавливается во время рендеринга StiBandsOnAllPages для того,
         * чтобы датабэнды, которые выводятся на каждой странице, не обнуляли этот список*/
        denyClearPrintOnAllPagesIgnoreList: boolean;
        duplilcatesLastValues: Hashtable;
        anchorsArguments: Hashtable;
        private needResetPageNumberForNewPage;
        private _parserConversionStore;
        parserConversionStore: Hashtable;
        hashParentStyles: Hashtable;
        private _hashUseParentStyles;
        hashUseParentStyles: Hashtable;
        lastInvokeTextProcessValueEventArgsValue: Object;
        atLeastOneDatabandRenderedOnPage: boolean;
        lastFreeSpaceOnPageAfterNewList: number;
        bandsInProgress: StiBand[];
        allowEndOfPageProcessing: boolean;
        private flagRenderColumnsOnDataBandOnNewPage;
        private componentPlacementRemakeTable;
        hashCheckSize: Hashtable;
        hashDataSourceReferencesCounter: Hashtable;
        offsetNewColumnY: number;
        latestProgressValue: number;
        newList(skipStaticBands?: boolean): void;
        newColumn(ignoreKeepContainers?: boolean): void;
        newPage(ignoreKeepContainers?: boolean): void;
        private newContainer;
        newDestination(ignoreKeepContainers?: boolean): void;
        /** Adds a FooterMarker (special container) into the current container of output.
         * A container-marker is used for the engine to know on what place in a container
         * of output FooterBands for PrintOnAllPages should be replaced after their rendering is complete.*/
        addFooterMarker(footerMaster: StiFooterBand): void;
        /** Adds a container-marker of the beginning of grouping before the last rendered DataBand.*/
        addKeepLevelAtLatestDataBand(): void;
        /** Adds a container-marker of the beginning of grouping into the current position of output in the stream.*/
        addLevel(): void;
        /** Adds a container-marker of the end of grouping into the current position of output in the stream.*/
        removeLevel(): void;
        private getChildBands;
        clearPageBreakSkipFirst(): void;
        canGenerateNewContainer(pageBreak: IStiPageBreak): boolean;
        removeBandFromPageBreakSkipList(pageBreak: IStiPageBreak): void;
        processPageAfterRendering(page: StiPage, final: boolean): void;
        processLastPageAfterRendering(): void;
        private processRendering;
        private reprocessRuntimeVariables;
        finalClear(): void;
        private isPrintAtBottomOrFooterOnAllPages;
        private changeEngineParamsByKeep;
        private setNewColumnParameters;
        setNewPageParameters(): void;
        private processNewContainerBefore;
        private processNewContainerAfter;
        private processNewContainerInDetailBands;
        private searchStartOfKeepContainer;
        private moveKeepComponentsOnNextContainer;
        private correctPrintOnAllPagesIgnoreListBeforeNewList;
        private isNeedToPrintOddEven;
        private isNeedToSkip;
        renderFootersOnAllPages(outContainer: StiContainer, startIndex?: number, REFmarkerContainer?: any): void;
        renderEmptyBands(containerForRender: StiContainer, selectedContainer: StiContainer): void;
        renderPrintAtBottom(container: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        finishContainer(containerForRender: StiContainer): void;
        finishResetPageNumberContainer(containerForRender: StiContainer, isFinal: boolean): void;
        finishColumns(containerForRender: StiContainer): void;
        /** Adds a specified container into the container for output.*/
        addContainerToDestination(container: StiContainer): void;
        invokePageAfterPrint(): void;
        addPageToRenderedPages(page: StiPage): void;
        private checkFreeSpace1;
        private checkFreeSpace2;
        private storeLatestDataBand;
        private setReportVariables;
        checkForDuplicate(textName: string, value: string, tag: string): boolean;
        resetProcessingDuplicates1(componentName: string): void;
        resetProcessingDuplicates2(component: StiSimpleText): void;
        getSumTagsOnPage(page: StiPage, componentName: string): number;
        getComponentByNameFromRenderedPage(page: StiPage, componentName: string): StiComponent;
        renderBand(band: StiBand, ignorePageBreaks?: boolean, allowRenderingEvents?: boolean): StiComponentsCollection;
        private internalRenderBand;
        private checkContainerOnTable;
        renderContainer(container: StiContainer, isPrintAtBottom?: boolean, isFooterOnAllPages?: boolean): StiContainer;
        private internalRenderColumnsContainer;
        private internalRenderContainerToColumns;
        private internalRenderContainer;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFooterMarkerContainer extends StiContainer {
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiFootersOnAllPages {
        private bands;
        engine: StiEngine;
        add(container: StiContainer): void;
        canProcess(band: StiBand): boolean;
        render(outContainer: StiContainer, startIndex: number, REFmarkerContainer: any): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiIndex {
        index: number;
        indexInColumnContainer: number;
        constructor(index: number, indexInColumnContainer?: number);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiLevelContainer extends StiContainer {
    }
}
declare module Stimulsoft.Report.Engine {
    class StiLevelEndContainer extends StiLevelContainer {
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    class StiLevelStartContainer extends StiLevelContainer {
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiNewPageContainer extends StiContainer {
        constructor();
    }
}
declare module Stimulsoft.Report.Engine {
    import IStiOddEvenStyles = Stimulsoft.Report.Components.IStiOddEvenStyles;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiOddEvenStylesHelper {
        static applyOddEvenStyles(report: StiReport, styles: IStiOddEvenStyles, cont: StiContainer): StiBaseStyle;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataBand = Stimulsoft.Report.Components.StiDataBand;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageHelper {
        static createListOfDataBands(page: StiPage, dataBandsOnPage: StiDataBand[], dataBandsInContainers: StiDataBand[], subReportsOnPage: StiSubReport[], crossTabsOnPage: StiCrossTab[]): void;
        static getReportTitles(page: StiPage): Stimulsoft.Report.Components.StiReportTitleBand[];
        static getReportSummaries(page: StiPage): Stimulsoft.Report.Components.StiReportSummaryBand[];
        static renderSimpleComponents(page: StiPage, outContainer: StiContainer): void;
        static prepareBookmark(page: StiPage): void;
        static renderPage(page: StiPage): void;
        static renderOverlays(masterPage: StiPage, renderedPage: StiPage): void;
        static getPageFromTemplate(templatePage: StiPage): StiPage;
    }
}
declare module Stimulsoft.Report.Engine {
    class StiPageNumber {
        resetPageNumber: boolean;
        pageNumber: number;
        totalPageCount: number;
        pageNumberThrough: number;
        totalPageCountThrough: number;
        segmentPerWidth: number;
        segmentPerHeight: number;
        readonly step: number;
        fixedPosition: boolean;
    }
}
declare module Stimulsoft.Report.Engine {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiPageNumberCollection extends CollectionBase<StiPageNumber> {
        add(pageNumber: StiPageNumber): void;
        getByIndex(index: number): StiPageNumber;
        setByIndex(index: number, value: StiPageNumber): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiPageNumberHelper {
        private engine;
        private finished;
        private _clearPageNumbersOnFinish;
        clearPageNumbersOnFinish: boolean;
        private _pageNumbers;
        pageNumbers: StiPageNumberCollection;
        resetPageNumber(pageIndex?: number): void;
        addPageNumber(pageIndex: number, segmentPerWidth: number, segmentPerHeight: number): void;
        getPageNumber(page: StiPage): number;
        getPageNumber(pageIndex: number): number;
        getTotalPageCount(page: StiPage): number;
        getTotalPageCount(pageIndex: number): number;
        getPageNumberThrough(page: StiPage): any;
        getPageNumberThrough(pageIndex: number): any;
        getTotalPageCountThrough(pageIndex: number): number;
        /** Calculates the PageNumber and TotalPageCount values for each page in the specified range.*/
        private setSystemVariables;
        /** Counts the PageNumber, TotalPageCount, PageNumberThrough, and TotalPageCountThrough values for every page.*/
        processPageNumbers(): void;
        clear(): void;
        clearNotFixed(): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    enum TypeOfDuplicates {
        Text = 0,
        Image = 1
    }
    class StiMergeComparer implements IComparer<StiComponent> {
        compare(x: StiComponent, y: StiComponent): number;
    }
    class StiPostProcessDuplicatesHelper {
        private static isImageEqual;
        static postProcessDuplicates(comps: StiComponentsCollection, parentCont: Hashtable, typeOfDuplicates?: TypeOfDuplicates): void;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiCrossLinePrimitive = Stimulsoft.Report.Components.StiCrossLinePrimitive;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiLinePrimitive = Stimulsoft.Report.Components.StiLinePrimitive;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPostProcessProvider {
        private static nullGuid;
        static postProcessPages(pages: StiPagesCollection): void;
        private static removeAllPointPrimitives;
        static postProcessPrimitives(page: StiPagesCollection | Stimulsoft.Report.Components.StiPage): void;
        static postProcessPrimitivesInContainer(container: StiContainer): void;
        static postProcessPrimitivesInContainer2(container: StiContainer, pages: StiPagesCollection, REFstartPointsHash: any, REFendPointsHash: any, REFlines: any, REFendPoints: any): void;
        private static processOneEndPoint;
        private static processOnePrimitive;
        static addPrimitive(crossLine: StiCrossLinePrimitive, startPos: PointD, endPos: PointD, page: StiContainer): void;
        static copyStyles(dest: StiLinePrimitive, source: StiLinePrimitive): void;
        static postProcessPage(page: Stimulsoft.Report.Components.StiPage, isFirstPage: boolean, isLastPage: boolean, clearPage?: boolean): void;
        private static postProcessPrintOn;
        private static allowPrintOn;
    }
}
declare module Stimulsoft.Report.Engine {
    import StiBand = Stimulsoft.Report.Components.StiBand;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiPrintAtBottom {
        private bands;
        engine: StiEngine;
        canProcess(band: StiBand): boolean;
        add(container: StiContainer): void;
        render(outContainer: StiContainer, startIndex: number, markerContainer: StiContainer): void;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Promise = Stimulsoft.System.Promise;
    class StiRenderProvider {
        static render(report: StiReport, state: StiRenderState): void;
        static StiRenderProviderV2_AddAnchor_Rendering(sender: any, e: EventArgs): void;
        static connectToDataAsync(report: StiReport): Promise<void>;
        static connectToData(report: StiReport): void;
        private static disconnectFromData;
        private static isDialogsOnStartExist;
        private static renderFormsOnStart;
        private static renderFormsOnEnd;
        private static checkDialogsInPreview;
        static clearPagesWhichLessThenFromPageAndGreaterThenToPage(report: StiReport, state: StiRenderState): void;
        private static initCacheMode;
        private static removeAllPagesLessThenFromPageAndGreaterThenToPage;
        private static finishAllPagesInNotCachedPagesArray;
        static processPageToCache(report: StiReport, page: StiPage, final: boolean): void;
        static isFirstPage(report: StiReport, page: StiPage): boolean;
        static isLastPage(report: StiReport, page: StiPage): boolean;
        private static renderFirstPass;
        static clearPagesForFirstPass(report: StiReport): void;
        private static getNumberOfPass;
        private static madeCollate;
        private static madeMirrorMargins;
        private static initReport;
        private static clearTotals;
        private static prepareSubReportsAndDrillDownPages;
        private static renderReport;
        static renderTable(report: StiReport): void;
        private static finishProgressForm;
    }
}
declare module Stimulsoft.Report.Engine {
    class StiRenderState {
        latestProgressValue: number;
        private _fromPage;
        readonly fromPage: number;
        private _toPage;
        readonly toPage: number;
        private _showProgress;
        showProgress: boolean;
        private _isSubReportMode;
        isSubReportMode: boolean;
        private _destroyPagesWhichNotInRange;
        readonly destroyPagesWhichNotInRange: boolean;
        private _renderOnlyPagesFromRange;
        readonly renderOnlyPagesFromRange: boolean;
        constructor(fromPage?: number, toPage?: number, showProgress?: boolean, destroyPagesWhichNotInRange?: boolean, renderOnlyPagesFromRange?: boolean);
    }
}
declare module Stimulsoft.Report.Engine {
    class StiStaticBandsHelper {
        private denyReportBands;
        private denyPageBands;
        engine: StiEngine;
        private _reservedFreeSpace;
        readonly reservedFreeSpace: number;
        private _reservedCrossFreeSpace;
        readonly reservedCrossFreeSpace: number;
        private _reservedPositionX;
        readonly reservedPositionX: number;
        private _reservedPositionY;
        readonly reservedPositionY: number;
        private _reservedPositionBottomY;
        readonly reservedPositionBottomY: number;
        render(): void;
        private renderTitleBeforeHeader;
        private renderHeaderBeforeTitle;
        private renderReportTitleBands;
        private renderPageHeaderBands;
        private renderPageFooterBands;
        private getPageHeaders;
        private getPageFooters;
        private getPageHeadersFromPage;
        private getPageFootersFromPage;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiThreads {
        isActive: boolean;
        currentPage: number;
        currentColumn: number;
        destinationName: string;
        /** Prepares a new page to output a container. A new page is not always a page*/
        newPage(): void;
        /** Sets the stream to output the specified component. If the stream does not exist then it is created.*/
        selectThreadFromContainer(container: StiContainer): void;
        /** Creates a new engine sample to output in the specified container.*/
        createContainerEngine(destinationName: string, report: StiReport, masterEngine: StiEngine, indexOfStartRenderedPages: number): StiEngine;
        getTemplateContainer(template?: StiContainer, name?: string): StiContainer;
        getDestinationContainer(): StiContainer;
        private getDestinationContainer2;
        engine: StiEngine;
        constructor(engine: StiEngine);
    }
}
declare module Stimulsoft.Report.Engine {
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    class StiVariableHelper {
        static fillItemsOfVariables(compiledReport: StiReport): void;
        static fillItemsOfVariables2(variable: StiVariable, compiledReport: StiReport): boolean;
        static setDefaultValueForRequestFromUserVariables(compiledReport: StiReport): void;
        static getDataSourcesWithRequestFromUserVariablesInCommand(report: StiReport): Array<string>;
        private static checkExpressionForVariables;
    }
}
declare module Stimulsoft.Report.Events {
    class StiAfterSelectEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiCheckedChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiClosedFormEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiClosingFormEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiEnterEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiExportEventHandler: EventHandler;
    class StiExportEventArgs extends EventArgs {
        exportFormat: StiExportFormat;
        constructor(format: StiExportFormat);
    }
}
declare module Stimulsoft.Report.Events {
    class StiExportedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiExportingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiFillDataEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetArgumentEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetBarCodeEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetDataUrlEventHandler: EventHandler;
    class StiGetDataUrlEventArgs extends EventArgs {
        value: string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetDrillDownReportEventHandler: EventHandler;
    class StiGetDrillDownReportEventArgs extends EventArgs {
        report: StiReport;
        cancel: boolean;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetFilterEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiGetZipCodeEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    /**
     * @hidden
     */
    var StiGotoCompEventHandler: EventHandler;
    /**
     * @hidden
     */
    class StiGotoCompEventArgs extends EventArgs {
        component: Stimulsoft.Report.Components.StiComponent;
        constructor(component: Stimulsoft.Report.Components.StiComponent);
    }
}
declare module Stimulsoft.Report.Events {
    class StiLoadFormEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseDownEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseMoveEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMouseUpEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiMoveFooterToBottomEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    var StiPaintEventHandler: EventHandler;
    class StiPaintEventArgs extends EventArgs implements ICloneable {
        clone(): Object;
        context: Object;
        readonly graphics: Graphics;
        clipRectangle: RectangleD;
        drawChilds: boolean;
        cancel: boolean;
        drawBorderFormatting: boolean;
        drawTopmostBorderSides: boolean;
        constructor(context: Object, clipRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Events {
    class StiPositionChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiPrintedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiPrintingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    var StiProcessExportEventHandler: EventHandler;
    class StiProcessExportEventArgs extends StiExportEventArgs {
        exportService: StiExportService;
        stream: MemoryStream;
        exportSettings: StiExportSettings;
        processed: boolean;
        constructor(format: StiExportFormat, exportService: StiExportService, stream: MemoryStream, settings: StiExportSettings);
    }
}
declare module Stimulsoft.Report.Events {
    class StiReportCacheProcessingEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiSelectedIndexChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiStateRestoreEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiStateSaveEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Events {
    class StiValueChangedEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Export {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiExportService {
        exportFormat: StiExportFormat;
        isStopped: boolean;
        /**
         *  Gets a value indicating a number of files in exported document as a result of export
         *  of one page of the rendered report.
         */
        multipleFiles: boolean;
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        exportServiceId: string;
        invokeExporting(page: StiPage, pages: StiPagesCollection, currentPass: number, maximumPass: number): void;
        invokeExporting2(value: number, maximum: number, currentPass: number, maximumPass: number): void;
    }
}
declare module Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiCsvExportService extends StiExportService {
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        multipleFiles: boolean;
        readonly getFilter: string;
        private writer;
        exportCsv(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
declare namespace Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    /**
     *  A class for the Csv export.
     */
    class StiDataExportService extends StiExportService {
        /**
         *  Gets or sets a default extension of export.
         */
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        /**
         *  Gets a group of the export in the context menu.
         */
        readonly groupCategory: string;
        /**
         *  Gets a position of the export in the context menu.
         */
        readonly position: number;
        /**
         *  Gets a name of the export in the context menu.
         */
        readonly exportNameInMenu: string;
        /**
         *  Exports a document to the stream without dialog of the saving file.
         *  @param report A report which is to be exported.
         *  @param stream A stream in which report will be exported.
         *  @param settings A settings for the report exporting.
         */
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private exportSettings;
        private report;
        private fileName;
        private sendEMail;
        /**
         *  Gets a value indicating a number of files in exported document as a result of export
         *  of one page of the rendered report.
         */
        readonly multipleFiles: boolean;
        /**
         *  Returns the filter of all available services which serves for saving, loading a document.
         *  @returns Filter.
         */
        getFilter(): string;
        /**
         *  Exports a rendered report to a csv file.
         *  @param report A report which is to be exported.
         *  @param stream A stream for export of a document.
         */
        exportData(report: StiReport, stream: MemoryStream, settings: StiDataExportSettings): void;
    }
}
declare module Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiBarCodeSvgHelper {
        static getImage(svgData: StiSvgData): Image;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBrushSvgHelper {
        static hatchData: string[];
        static writeHatchBrush(writer: XmlTextWriter, brush: any): string;
        private static hexToByteString;
        static writeGlareBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGradientBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        static writeGlassBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
    }
}
declare module Stimulsoft.Report {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCurveHelper {
        static cardinalSpline(pts: PointD[], closed: boolean): PointD[];
        private static calcCurveEnd;
        private static calcCurve;
    }
}
declare module Stimulsoft.Base.Context {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiGeom implements IStiJsonReportObject {
        private static implementsStiGeom;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        saveGeomListToJsonObject(geoms: StiSegmentGeom[], mode: StiJsonSaveMode): StiJson[];
        savePointDArrayToJsonObject(points: Point[]): StiJson[];
        saveBrushToJsonObject(brush: Object, mode: StiJsonSaveMode): string;
        saveRectToJsonObject(rect: Object): StiJson;
        static savePointDToJsonObject(pos: Point): StiJson;
        static saveRectangleToJsonObject(rect: Rectangle): StiJson;
        static saveRectangleDToJsonObject(rect: Rectangle): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushTranslateTransformGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        x: number;
        y: number;
        readonly type: StiGeomType;
        constructor(x: number, y: number);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushRotateTransformGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        angle: number;
        readonly type: StiGeomType;
        constructor(angle: number);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAnimationGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        private _animation;
        readonly animation: StiAnimation;
        interaction: StiInteractionDataGeom;
        constructor(animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredBarSeriesAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        columnRect: Object;
        upMove: boolean;
        tag: Object;
        value: Number;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, columnRect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopTransformGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiBorderAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        tag: Object;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom, toolTip: String);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiBorderGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        interaction: StiInteractionDataGeom;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiAnimation {
        constructor(duration: TimeSpan, beginTime: TimeSpan);
        duration: TimeSpan;
        beginTime: TimeSpan;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiOpacityAnimation extends StiAnimation {
        constructor(duration: TimeSpan, beginTime: TimeSpan);
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPushClipGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        clipRectangle: Rectangle;
        readonly type: StiGeomType;
        constructor(clipRectangle: Rectangle);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopClipGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiCurveGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        tension: number;
        points: Point[];
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiEllipseGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        interaction: StiInteractionDataGeom;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    class StiCachedShadowGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        sides: StiShadowSides;
        isPrinting: boolean;
        readonly type: StiGeomType;
        constructor(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiShadowGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        radius: number;
        shadowContext: StiContext;
        readonly type: StiGeomType;
        constructor(shadowContext: StiContext, rect: Rectangle, radius: number);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiTextGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        text: string;
        font: StiFontGeom;
        isRounded: boolean;
        isRotatedText: boolean;
        brush: Object;
        location: Object;
        stringFormat: StiStringFormatGeom;
        angle: number;
        antialiasing: boolean;
        maximalWidth: number;
        rotationMode: Stimulsoft.Base.Drawing.StiRotationMode;
        readonly type: StiGeomType;
        constructor(text: string, font: StiFontGeom, brush: Object, location: Object, stringFormat: StiStringFormatGeom, angle: number, antialiasing: boolean, maximalWidth: number, rotationMode: Stimulsoft.Base.Drawing.StiRotationMode, isRotatedText: boolean);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPathGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static getBoundsState: Object;
        background: Object;
        pen: StiPenGeom;
        rect: Object;
        geoms: StiSegmentGeom[];
        interaction: StiInteractionDataGeom;
        readonly type: StiGeomType;
        constructor(background: Object, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: Object, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiSegmentGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        animation: StiAnimation;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiArcSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        startAngle: number;
        sweepAngle: number;
        constructor(rect: Rectangle, startAngle: number, sweepAngle: number);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLineSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        animation: StiAnimation;
        constructor(x1: number | Point, y1: number | Point, x2?: number, y2?: number, animation?: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], animation?: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveSegmentGeom extends StiSegmentGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        tension: number;
        points: Point[];
        animation: StiAnimation;
        constructor(points: Point[], tension: number, animation?: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    class StiCloseFigureSegmentGeom extends StiSegmentGeom {
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiColumnAnimation extends StiAnimation {
        constructor(valueFrom: number, rectFrom: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
        valueFrom: number;
        rectFrom: Rectangle;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLabelAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        text: string;
        font: StiFontGeom;
        textBrush: Object;
        labelBrush: Object;
        penBorder: StiPenGeom;
        rectangle: Rectangle;
        stringFormat: StiStringFormatGeom;
        angle: number;
        rotationMode: StiRotationMode;
        drawBorder: boolean;
        readonly type: StiGeomType;
        constructor(text: string, font: StiFontGeom, textBrush: Object, LabelBrush: Object, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, rotationMode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiShadowAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        rect: Rectangle;
        radiusX: number;
        radiusY: number;
        shadowWidth: number;
        readonly type: StiGeomType;
        constructor(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static getBoundsState: Object;
        background: Object;
        pen: StiPenGeom;
        rect: Object;
        geoms: StiSegmentGeom[];
        tag: Object;
        readonly type: StiGeomType;
        constructor(background: Object, pen: StiPenGeom, geoms: StiSegmentGeom[], rect: Object, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCurveAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        points: Point[];
        tension: number;
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        columnRect: Object;
        toolTip: String;
        tag: Object;
        value: Number;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, columnRect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiEllipseAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        tag: Object;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, rect: Object, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiLinesAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        points: Point[];
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[], animation: StiAnimation);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPathElementAnimationGeom extends StiAnimationGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        background: Object;
        borderPen: StiPenGeom;
        rect: Object;
        pathGeoms: StiSegmentGeom[];
        tag: Object;
        toolTip: String;
        readonly type: StiGeomType;
        constructor(background: Object, borderPen: StiPenGeom, pathGeoms: StiSegmentGeom[], rect: Object, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom);
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLabelAnimation extends StiAnimation {
        constructor(valueFrom: number, value: number, pointFrom: Point, point: Point, duration: TimeSpan, beginTime: TimeSpan);
        pointFrom: Point;
        point: Point;
        valueFrom: number;
        value: number;
        LabelRect: Rectangle;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointsAnimation extends StiAnimation {
        constructor(pointsFrom: Point[], duration: TimeSpan, beginTime: TimeSpan);
        pointsFrom: Point[];
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieLabelAnimation extends StiAnimation {
        constructor(valueFrom: number, value: number, angleFrom: number, angle: number, clientRect: Rectangle, rectLabelFrom: Rectangle, rectLabel: Rectangle, duration: TimeSpan, beginTime: TimeSpan);
        valueFrom: number;
        value: number;
        rectLabelFrom: Rectangle;
        rectLabel: Rectangle;
        clientRect: Rectangle;
        angleFrom: number;
        angle: number;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSegmentAnimation extends StiAnimation {
        constructor(rectFrom: Rectangle, startAngleFrom: number, sweepAngleFrom: number, duration: TimeSpan, beginTime: TimeSpan);
        rectFrom: Rectangle;
        startAngleFrom: number;
        sweepAngleFrom: number;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiLineGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinesGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        pen: StiPenGeom;
        points: Point[];
        readonly type: StiGeomType;
        constructor(pen: StiPenGeom, points: Point[]);
    }
}
declare namespace Stimulsoft.Report.Export.Services.Helpers {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiContextSvgHelper {
        private static isAddStimulsoftIconFont;
        private static dx;
        private static dy;
        private static listTransformGeom;
        static writeGeoms(writer: XmlTextWriter, context: StiContext, needAnimation: boolean): void;
        static addAnimation(writer: XmlTextWriter, actions: string, begin: TimeSpan, duration: TimeSpan, numberr?: string): void;
        private static writeInteracrion;
        private static getPathData;
        private static addArcPath;
        private static round;
        private static addPiePath;
        static correctRectLabel(rotationMode: StiRotationMode, textRect: RectangleD): RectangleD;
        private static convertArcToCubicBezier;
        static writeTooltip(writer: XmlTextWriter, tooltip: string): string;
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        private static writeBorderStroke;
        private static convertSplineToCubicBezier;
        private static calculateCurveBezier;
        private static calculateCurveBezierEndPoints;
        private static writeBrush;
        private static checkPenGeom;
        private static p;
        static writeStimulsoftIconFont(): void;
    }
}
declare module Stimulsoft.Base.Context {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiContext {
        render(rect: Rectangle): void;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        drawString2(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawString(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom): StiTextGeom;
        drawRotatedString2(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString3(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString4(text: string, font: StiFontGeom, brush: Object, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString5(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString6(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number, isRotated?: boolean): StiTextGeom;
        drawRotatedString7(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        drawRotatedString8(text: string, font: StiFontGeom, brush: Object, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean): StiTextGeom;
        drawRotatedString9(text: string, font: StiFontGeom, brush: Object, pos: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, antialiasing: boolean, maximalWidth: number): StiTextGeom;
        measureString(text: string, font: StiFontGeom): Size;
        measureString2(text: string, font: StiFontGeom, width: number, sf: StiStringFormatGeom): Size;
        measureRotatedString(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        drawShadow(sg: StiContext, rect: Rectangle, radius: number): void;
        drawCachedShadow(rect: Rectangle, sides: StiShadowSides, isPrinting: boolean): void;
        createShadowGraphics(): StiContext;
        pushTranslateTransform(x: number, y: number): void;
        pushRotateTransform(angle: number): void;
        popTransform(): void;
        pushClip(clipRect: Rectangle): void;
        popClip(): void;
        drawAnimationColumn(brush: Object, borderPen: StiPenGeom, rect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationBar(brush: Object, borderPen: StiPenGeom, columnRect: Object, value: Number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationRectangle(brush: Object, pen: StiPenGeom, rect: Rectangle, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom, tooltip: String): void;
        drawAnimationPathElement(brush: Object, borderPen: StiPenGeom, path: StiSegmentGeom[], rect: Object, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawAnimationLabel(text: string, font: StiFontGeom, textBrush: Object, labelBrush: Object, penBorder: StiPenGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, drawBorder: boolean, animation: StiAnimation): void;
        drawAnimationLines(pen: StiPenGeom, points: Point[], animation: StiAnimation): void;
        drawAnimationCurve(pen: StiPenGeom, points: Point[], tension: number, animation: StiAnimation): void;
        fillDrawAnimationPath(brush: Object, pen: StiPenGeom, path: StiSegmentGeom[], rect: Object, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        fillDrawAnimationEllipse(brush: Object, pen: StiPenGeom, x: number, y: number, width: number, height: number, toolTip: String, tag: Object, animation: StiAnimation, interaction: StiInteractionDataGeom): void;
        drawLine(pen: StiPenGeom, x1: number, y1: number, x2: number, y2: number): void;
        drawLines(pen: StiPenGeom, points: Point[]): void;
        drawRectangle(pen: StiPenGeom, rect: Rectangle): void;
        drawRectangle2(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse(pen: StiPenGeom, x: number, y: number, width: number, height: number): void;
        drawEllipse2(pen: StiPenGeom, rect: Rectangle): void;
        fillEllipse(brush: Object, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        fillEllipse2(brush: Object, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        drawPath(pen: StiPenGeom, path: StiSegmentGeom[], rect: Object): void;
        fillPath(brush: Object, path: StiSegmentGeom[], rect: Object, interaction: StiInteractionDataGeom): void;
        drawCurve(pen: StiPenGeom, points: Point[], tension: number): void;
        fillRectangle(brush: Object, rect: Rectangle, interaction: StiInteractionDataGeom): void;
        fillRectangle2(brush: Object, x: number, y: number, width: number, height: number, interaction: StiInteractionDataGeom): void;
        pushSmoothingModeToAntiAlias(): void;
        popSmoothingMode(): void;
        pushTextRenderingHintToAntiAlias(): void;
        popTextRenderingHint(): void;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        geoms: StiGeom[];
        private _contextPainter;
        readonly contextPainter: StiContextPainter;
        private _options;
        readonly options: StiContextOptions;
        drawShadowRect(rect: Rectangle, shadowWidth: number, animation: StiAnimation): void;
        drawShadowRect2(rect: Rectangle, radiusX: number, radiusY: number, shadowWidth: number, animation: StiAnimation): void;
        constructor(contextPainter: StiContextPainter, isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
declare module Stimulsoft.Base.Context {
    import Size = Stimulsoft.System.Drawing.Size;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    class StiContextPainter {
        private _svgRect;
        private svgObj;
        readonly svgRect: any;
        getDefaultStringFormat(): StiStringFormatGeom;
        getGenericStringFormat(): StiStringFormatGeom;
        createShadowGraphics(isPrinting: boolean, zoom: number): StiContext;
        getPathBounds(geoms: StiSegmentGeom[]): Rectangle;
        measureString(text: string, font: StiFontGeom, width?: number, sf?: StiStringFormatGeom): Size;
        measureRotatedString1(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, angle: number): Rectangle;
        measureRotatedString2(text: string, font: StiFontGeom, rect: Rectangle, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth?: number): Rectangle;
        measureRotatedString3(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number, maximalWidth: number): Rectangle;
        measureRotatedString4(text: string, font: StiFontGeom, point: Point, sf: StiStringFormatGeom, mode: StiRotationMode, angle: number): Rectangle;
        private getStartPoint;
        render(rect: Rectangle, geoms: StiGeom[]): any;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiChartSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        static writeChart(writer: XmlTextWriter, svgData: StiSvgData, zoom: number, needAnimation: boolean): void;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeGeom {
        readonly type: StiGaugeGeomType;
        animation: StiAnimation;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPieGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiEllipseGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsArcGeometryGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly startWidth: number;
        readonly endWidth: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiPopTranformGaugeGeom extends StiGaugeGeom {
        readonly type: StiGaugeGeomType;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPushMatrixGaugeGeom extends StiGaugeGeom {
        readonly angle: number;
        readonly centerPoint: Point;
        readonly type: StiGaugeGeomType;
        constructor(angle: number, centerPoint: Point);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadialRangeGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly centerPoint: Point;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly radius1: number;
        readonly radius2: number;
        readonly radius3: number;
        readonly radius4: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRoundedRectangleGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly leftTop: number;
        readonly rightTop: number;
        readonly rightBottom: number;
        readonly leftBottom: number;
        readonly type: StiGaugeGeomType;
        constructor(rect: Rectangle, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiTextGaugeGeom extends StiGaugeGeom {
        readonly text: string;
        readonly font: Font;
        readonly foreground: StiBrush;
        readonly rect: Rectangle;
        readonly stringFormat: StringFormat;
        readonly type: StiGaugeGeomType;
        constructor(text: string, font: Font, foreground: StiBrush, rect: Rectangle, sf: StringFormat);
    }
}
declare module Stimulsoft.Report.Painters {
    import StiGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGaugeGeom;
    import StiGraphicsPathGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathGaugeGeom;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import Font = Stimulsoft.System.Drawing.Font;
    import SizeF = Stimulsoft.System.Drawing.Size;
    import PointF = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    class StiGaugeContextPainter {
        zoom: number;
        rect: RectangleF;
        gauge: IStiGauge;
        geoms: StiGaugeGeom[];
        static changeFontSize(font: Font, zoom: number): Font;
        measureString(text: string, font: Font): SizeF;
        addPieGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number): void;
        addEllipseGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addGraphicsArcGeometryGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        addPopTranformGaugeGeom(): void;
        addPushMatrixGaugeGeom(angle: number, centerPoint: PointF): void;
        addRadialRangeGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, centerPoint: PointF, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        addRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number): void;
        addRoundedRectangleGaugeGeom(rect: RectangleF, background: StiBrush, borderBrush: StiBrush, borderWidth: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        addTextGaugeGeom(text: string, font: Font, foreground: StiBrush, rect: RectangleF, sf: StringFormat): void;
        addGraphicsPathGaugeGeom(geom: StiGraphicsPathGaugeGeom): void;
        render(): void;
        constructor(gauge: IStiGauge, rect: RectangleF, zoom: number);
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    class StiScaleAnimation extends StiAnimation {
        constructor(startScaleX: number, endScaleX: number, startScaleY: number, endScaleY: number, centerX: number, centerY: number, duration: TimeSpan, beginTime: TimeSpan);
        startScaleX: number;
        startScaleY: number;
        endScaleX: number;
        endScaleY: number;
        centerX: number;
        centerY: number;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRotationAnimation extends StiAnimation {
        constructor(startAngle: number, endAngle: number, centerPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
        startAngle: number;
        endAngle: number;
        centerPoint: Point;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiTranslationAnimation extends StiAnimation {
        constructor(startPoint: Point, endPoint: Point, duration: TimeSpan, beginTime: TimeSpan);
        startPoint: Point;
        endPoint: Point;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathArcGaugeGeom extends StiGaugeGeom {
        readonly x: number;
        readonly y: number;
        readonly width: number;
        readonly height: number;
        readonly startAngle: number;
        readonly sweepAngle: number;
        readonly type: StiGaugeGeomType;
        constructor(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number);
    }
}
declare module Stimulsoft.Report.Gauge {
    enum StiGaugeGeomType {
        GraphicsPath = 0,
        GraphicsPathArc = 1,
        GraphicsPathCloseFigure = 2,
        RoundedRectangle = 3,
        Rectangle = 4,
        Pie = 5,
        Ellipse = 6,
        GraphicsArcGeometry = 7,
        PushMatrix = 8,
        PopTranform = 9,
        GraphicsPathLines = 10,
        GraphicsPathLine = 11,
        Text = 12,
        RadialRange = 13
    }
}
declare module Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    class StiGaugeSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        private static readonly PiDiv180;
        private static readonly FourDivThree;
        private static addAnimation;
        static writeGauge(writer: XmlTextWriter, svgData: StiSvgData, zoom?: number, needAnimation?: boolean): void;
        private static getPathData;
        static getArcPath(rect: Rectangle, path_: string, startAngle: number, sweepAngle: number, isSetStartPoint: boolean): string;
        private static convertArcToCubicBezier;
        private static addArcPath;
        private static addPiePath;
        private static convertArcToCubicBezier2;
        private static convertArcToCubicBezier3;
        private static round;
        static writeText(writer: XmlTextWriter, text: string, font: Font, foreground: StiBrush, point: Point, size: number): void;
        private static calculateCurveBezier;
        private static calculateCurveBezierEndPoints;
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: Rectangle): string;
        private static writeBorderStroke;
        private static rectToRectangle;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMapHelper {
        private static globalReport;
        private static globalMap;
        static isWorld(id: StiMapID): boolean;
        static isAfrica(id: StiMapID): boolean;
        static isNorthAmerica(id: StiMapID): boolean;
        static isSouthAmerica(id: StiMapID): boolean;
        static isEU(id: StiMapID): boolean;
        static isOceania(id: StiMapID): boolean;
        static isAsia(id: StiMapID): boolean;
        static getStates(id: StiMapID): string[];
        static getMapSample(): StiMap;
        static getColors(): Color[];
        static prepareIsoCode(text: string): string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapData {
        constructor(key: string);
        key: string;
        private _value;
        value: string;
        private _group;
        group: string;
        name: string;
        private _color;
        color: string;
        toString(): string;
        private invokeValueChanged;
    }
}
import Rectangle = Stimulsoft.System.Drawing.Rectangle;
import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
declare module Stimulsoft.Report.Maps {
    class StiMapSvg {
        key: string;
        data: string;
        englishName: string;
        iSOCode: string;
        rect: Rectangle;
        setMaxWidth: boolean;
        skipText: boolean;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Maps {
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import IStiDataSource = Stimulsoft.Report.Components.IStiDataSource;
    import IStiBusinessObject = Stimulsoft.Report.Components.IStiBusinessObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiMap extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiDataSource, IStiBusinessObject, IStiJsonReportObject {
        private static implementsStiMap;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(cloneProperties?: boolean): StiMap;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        readonly isDataSourceEmpty: boolean;
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        private _countData;
        countData: number;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        isEof: boolean;
        isBofValue: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        positionValue: number;
        position: number;
        readonly count: number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        readonly componentId: StiComponentId;
        readonly localizedCategory: string;
        readonly localizedName: string;
        defaultClientRectangle: RectangleD;
        private _mapStyle;
        mapStyle: StiMapStyleIdent;
        private _dataFrom;
        dataFrom: StiMapSource;
        private _colorEach;
        colorEach: boolean;
        private _stretch;
        stretch: boolean;
        private _showValue;
        showValue: boolean;
        private _shortValue;
        shortValue: boolean;
        private _displayNameType;
        displayNameType: StiDisplayNameType;
        private _mapID;
        mapID: StiMapID;
        private _mapType;
        mapType: StiMapType;
        private isMapDataChanged;
        private _mapData;
        mapData: string;
        private _keyDataColumn;
        keyDataColumn: string;
        private _nameDataColumn;
        nameDataColumn: string;
        private _valueDataColumn;
        valueDataColumn: string;
        private _groupDataColumn;
        groupDataColumn: string;
        private _colorDataColumn;
        colorDataColumn: string;
        private _latitude;
        latitude: string;
        private _longitude;
        longitude: string;
        private _mapMode;
        mapMode: StiMapMode;
        /**
         *  Internal use only.
         */
        dataTable: StiDataTable;
        private _isHashDataEmpty;
        readonly isHashDataEmpty: boolean;
        createNew(): StiComponent;
        private _hashData;
        static getDefaultMapData(mapID: StiMapID): List<StiMapData>;
        getMapData(): List<StiMapData>;
        getCurrentStyleColors(): Color[];
        static getStyleColors(style: StiMapStyleIdent): Color[];
        getStyleBackground(): StiBrush;
        static getMapStyle2(map: StiMap): StiMapStyle;
        static getMapStyle(style: StiMapStyleIdent): StiMapStyle;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Export {
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiMapSvgHelper {
        static getImage(svgData: StiSvgData): Image;
        static drawMap(xmlsWriter: XmlTextWriter, map: StiMap, x: number, y: number, width: number, height: number, animated: boolean): void;
        static render(map: StiMap, xmlsWriter: XmlTextWriter, animated: boolean, sScale: number): void;
        private static normalizeDecimal;
        private static getBorderStroke;
        static getFillBrush(brush: SolidBrush): string;
    }
}
declare module Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSvgData {
        private _x;
        /** X coordinate of the border. */
        x: number;
        private _y;
        /** Y coordinate of the border. */
        y: number;
        private _width;
        /** Width of the border. */
        width: number;
        private _height;
        /** Height of the border. */
        height: number;
        private _right;
        /** Right (X + Width) coordinate of the border. */
        readonly right: number;
        private _bottom;
        /** Bottom (Y + Height) coordinate of the border. */
        readonly bottom: number;
        component: StiComponent;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiSvgGeomWriter implements IStiExportGeomWriter {
        constructor(writer: XmlTextWriter);
        private writer;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: any): void;
        strokePath(pen: any): void;
        moveTo(point: PointD): void;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): void;
        drawLineTo(pointTo: PointD, pen: any): void;
        drawRectangle(rect: RectangleD, pen: any): void;
        drawPolyline(points: PointD[], pen: Pen): void;
        drawPolylineTo(points: PointD[], pen: any): void;
        drawPolygon(points: PointD[], pen: any): void;
        fillPolygon(points: PointD[], brush: any): void;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        setPixel(point: PointD, color: Color): void;
        drawImage(img: Image, rect: RectangleD): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        drawString(st: string, font: Font, brush: any, rect: RectangleD, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        fillRectangle(rect: RectangleD, brush: any): void;
        fillRectangle2(rect: RectangleD, color: Color): void;
        rotateTransform(angle: number): void;
        translateTransform(x: number, y: number): void;
        endTransform(): void;
        measureString(st: string, font: Font): SizeD;
        drawEllipse(rect: RectangleD, pen: any): void;
        fillEllipse(rect: RectangleD, brush: any): void;
    }
}
declare module Stimulsoft.Report.Export {
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiSvgHelper {
        private static correctFontSize;
        private static pdfCKT;
        static getLineStyleDash(penStyle: StiPenStyle, width: number): string;
        static toUnits(numberr: number): string;
        private static writeCoordinates;
        private static writeStrokeInfo;
        static writeFillInfo(writer: XmlTextWriter, color: Color): void;
        private static checkShape;
        private static writeDocument;
        static writeWatermark(writer: XmlTextWriter, xmlIndentation: number, page: StiPage, behind: boolean, pageWidth: number, pageHeight: number, imageResolution: number, zoom?: number): void;
        private static writeBorder1;
        private static writeBorder2;
        private static writeText2;
        private static writeText;
        static getStyleString(font: Font, textColor: Color): string;
        private static writeImage;
        static writeBarCode(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeShape(writer: XmlTextWriter, svgData: StiSvgData): void;
        static writeFillBrush(writer: XmlTextWriter, brush: any, rect: RectangleD): string;
        private static writeBrush;
        private static writeRoundedRectanglePrimitive;
        private static getClipPathName;
        private static writeIndicator;
        private static writeIconSetIndicatorTypePainter;
        private static writeDataBarIndicator;
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number, isDesigner?: boolean): string;
        static saveToString(report: StiReport, page: StiPage, compressed: boolean, standalone?: boolean, REFclipCounter?: any, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static writeCheckBox(writer: XmlTextWriter, svgData: StiSvgData, checkedValue: Object): void;
        private static getCheckBoxData;
        static writeTextInCells(writer: XmlTextWriter, svgData: StiSvgData): void;
    }
}
declare module Stimulsoft.Report.Export {
    class StiHtml5ExportService extends StiExportService {
        renderAsDocument: boolean;
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        private reporTmp;
        private documentFileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        getFilter(): string;
        report: StiReport;
        fileName: string;
        imageFormat: ImageFormat;
        htmlWriter: StiHtmlTextWriter;
        imageQuality: number;
        imageResolution: number;
        compressToArchive: boolean;
        private renderPage;
        private renderStartDoc;
        private renderEndDoc;
        exportHtml(report: StiReport, htmlWriter: StiHtmlTextWriter, settings: StiHtmlExportSettings): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiText = Stimulsoft.Report.Components.StiText;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiComponent = Stimulsoft.Report.Components.IStiComponent;
    class StiHtmlExportService extends StiExportService {
        renderedPagesCount: number;
        currentPassNumber: number;
        maximumPassNumber: number;
        readonly exportFormat: StiExportFormat;
        exportTo(report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, writer: StiHtmlTextWriter, settings: StiExportSettings): void;
        private exportSettings;
        private reportTmp;
        private documentFileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        clearOnFinish: boolean;
        tableRender: StiHtmlTableRender;
        htmlWriter: StiHtmlTextWriter;
        private zip;
        report: StiReport;
        private fileName;
        private startPage;
        private imageNumber;
        zoom: number;
        imageFormat: ImageFormat;
        exportQuality: StiHtmlExportQuality;
        useStylesTable: boolean;
        private isFileStreamMode;
        private imageQuality;
        imageResolution: number;
        private compressToArchive;
        private useEmbeddedImages;
        openLinksTarget: string;
        chartType: StiHtmlChartType;
        private coordX;
        private coordY;
        private strSpanDiv;
        private hyperlinksToTag;
        chartData: Hashtable;
        hashBookmarkGuid: Hashtable;
        renderStyles: boolean;
        styles: StiCellStyle[];
        insertInteractionParameters: boolean;
        htmlImageHost: StiHtmlImageHost;
        totalPageWidth: number;
        totalPageHeight: number;
        renderAsDocument: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        private addCoord;
        private formatCoords;
        formatCoord(value: number): string;
        formatColor(color: Color): string;
        formatColorRgba(color: Color): string;
        private getBorderStyle;
        setCurrentCulture(): void;
        restoreCulture(): void;
        renderFont(cell: StiHtmlTableCell, font: Font): void;
        renderTextHorAlignment(cell: StiHtmlTableCell, textOptions: any, textHorAlignment: StiTextHorAlignment): void;
        renderVertAlignment(cell: StiHtmlTableCell, textVertAlignment: StiVertAlignment, textOptions?: any, allowHtml?: boolean): void;
        renderTextAngle(textOptions: StiTextOptions): void;
        renderTextDirection(cell: StiHtmlTableCell, textOptions: StiTextOptions): void;
        renderBackColor(cell: StiHtmlTableCell, color: Color): void;
        renderTextColor(cell: StiHtmlTableCell, color: Color, forceAnyColor?: boolean): void;
        renderBorder(comp: StiComponent): void;
        private renderBorder2;
        renderBorder3(cell: StiHtmlTableCell, border: StiBorderSide, side: string, borderRadius?: number): void;
        private renderPosition;
        private getHeight;
        private getWidth;
        private renderImage;
        private renderImage2;
        private forceExportAsImage;
        private renderImage3;
        renderHyperlink(comp: StiComponent): boolean;
        private renderPage;
        private renderEndPage;
        private renderStartDoc;
        private fillBitmapBackground;
        private renderBookmarkScript;
        private renderChartScripts;
        private renderMapsScripts;
        private renderGaugeScripts;
        getGuid(comp: IStiComponent): string;
        private renderEndDoc;
        private renderBookmarkTree;
        private addBookmarkNode;
        prepareTextForHtml(text: string): string;
        static convertTextWithHtmlTagsToHtmlText(stiText: StiText, text: string): string;
        private static getParagraphString;
        renderWatermarkText(sWriter: StiHtmlTextWriter, page: StiPage, topPos?: number): void;
        renderWatermarkImage(sWriter: StiHtmlTextWriter, page: StiPage, topPos?: number): void;
        static getImage(assemblyName: string, imageName: string, makeTransparent: boolean): Image;
        static getFile(assemblyName: string, fileName: string): Uint8Array;
        private assembleGuidUsedInBookmark;
        private prepareSvg;
        prepareChartData(writer: StiHtmlTextWriter, chart: IStiChart, width: number, height: number): string;
        prepareGaugeData(writer: StiHtmlTextWriter, gauge: any, width: number, height: number): string;
        prepareMapData(writer: StiHtmlTextWriter, map: any, width: number, height: number): string;
        getChartScript(): string;
        clear(): void;
        private isComponentHasInteraction;
        exportHtml(report: StiReport, writer: StiHtmlTextWriter, settings: StiHtmlExportSettings, pages?: StiPagesCollection): void;
        constructor();
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
    }
}
declare namespace Stimulsoft.Report.Export {
    /**
     *  Class for exporting reports in the image format.
     */
    class StiImageExportService extends StiExportService {
        /**
         *  Gets or sets a default extension of export.
         */
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        /**
         *  Gets a group of the export in the context menu.
         */
        readonly groupCategory: string;
        /**
         *  Gets a name of the export in the context menu.
         */
        exportNameInMenu: string;
        /**
         *  Gets a position of the export in the context menu.
         */
        position: StiExportPosition;
        /**
         *  Returns a filter for files with bmp images.
         *  @returns> Returns a filter for files with bmp images.
         */
        getFilter(): string;
        /**
         *  Exports a document to the stream without dialog of the saving file.
         *  @param report A report which is to be exported.
         *  @param stream A stream in which report will be exported.
         *  @param settings A settings for the report exporting.
         */
        exportTo(report: StiReport, refString: {
            ref: string;
        }, settings: StiExportSettings): void;
        /**
         *  Exports a rendered document to the file as image.
         *  @param report A report which is to be exported.
         *  @param fileName A name of the file for exporting a rendered report.
         *  @param sendEMail A parameter indicating whether the exported report will be sent via e - mail.
         */
        imageSettings: StiImageExportSettings;
        report: StiReport;
        private fileName;
        private sendEMail;
        /**
         *  Exports a rendered document to the stream as an image.
         */
        exportImage(report: StiReport, refString: {
            ref: string;
        }, settings: StiImageExportSettings): void;
        private getSettings;
        /**
         *  Exports a rendered document to the stream as an image.
         */
        private exportImage1;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    /**
     *  A class for the export in the SVG image format.
     */
    class StiSvgExportService extends StiImageExportService {
        /**
         *  Gets a name of the export in the context menu.
         */
        exportNameInMenu: string;
        /**
         *  Returns a filter for files with svg images.
         *  @returns Returns a filter for files with svg images.
         */
        getFilter(): string;
    }
}
declare module Stimulsoft.Report.Export {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiExcel2007ExportService extends StiExportService {
        getDefaultExtension(): String;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        matrix: StiMatrix;
        private fontList;
        private fillList;
        private borderList;
        private xfList;
        private sstList;
        private sstHash;
        private sstHashIsTags;
        private imageList;
        private formatList;
        private sstCount;
        private sheetNameList;
        private imageListOffset;
        private printAreasList;
        private matrixList;
        private firstPageIndexList;
        private hyperlinkList;
        private minRowList;
        private maxRowList;
        private useOnePageHeaderAndFooter;
        private exportDataOnly;
        private exportObjectFormatting;
        private exportEachPageToSheet;
        private exportHorizontalPageBreaks;
        private imageResolution;
        private imageQuality;
        private imageCache;
        private restrictEditing;
        private reportCulture;
        private docCompanyString;
        private docLastModifiedString;
        private xmlIndentation;
        private wrongUrlSymbols;
        private getLineStyle;
        private refChars;
        private getRefString;
        private getRefAbsoluteString;
        private floatToString;
        private stringToUrl;
        private getFontNumber;
        private getFillNumber;
        private getBorderNumber;
        private getXFNumber;
        private getSSTNumber;
        private getFormatNumber;
        HiToTwips: number;
        private TwipsToColinfo;
        private convert;
        private compareExcellSheetNames;
        private prepareData;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeWorkbookRels;
        private writeWorkbook;
        private writeSheetRels;
        private writeSheet;
        private prepareMatrix;
        private convertAllowHtmlTagsToExcelString;
        private convertTextToExcelString;
        private writeDrawingRels;
        private writeDrawing;
        private writeStyles;
        private writeBorderData;
        private writeSST;
        private writeAdditionalData;
        private writeImage;
        exportExcel(report: StiReport, stream: MemoryStream, settings: StiExcelExportSettings): void;
    }
    class DataFont {
        Name: string;
        Bold: boolean;
        Italic: boolean;
        Underlined: boolean;
        Strikeout: boolean;
        Height: number;
        Color: Color;
        Charset: number;
        Family: number;
        constructor(Name: string, Bold: boolean, Italic: boolean, Underlined: boolean, Strikeout: boolean, Height: number, Color: Color, Charset: number, Family: number);
        stiEquals(obj: DataFont): boolean;
    }
    class DataFill {
        Type: string;
        FgColor: Color;
        BgColor: Color;
        constructor(Type: string, FgColor: Color, BgColor: Color);
        stiEquals(obj: DataFill): boolean;
    }
    class DataBorder {
        BorderLeft: StiBorderSide;
        BorderRight: StiBorderSide;
        BorderTop: StiBorderSide;
        BorderBottom: StiBorderSide;
        constructor(BorderLeft: StiBorderSide, BorderRight: StiBorderSide, BorderTop: StiBorderSide, BorderBottom: StiBorderSide);
        stiEquals(obj: DataBorder): boolean;
        private eq;
    }
    class DataXF {
        FormatIndex: number;
        FontIndex: number;
        FillIndex: number;
        BorderIndex: number;
        XFId: number;
        HorAlign: StiTextHorAlignment;
        VertAlign: StiVertAlignment;
        TextRotationAngle: number;
        TextWrapped: boolean;
        RightToLeft: boolean;
        Editable: boolean;
        equalDataXF(xf: DataXF): boolean;
        constructor(FormatIndex: number, FontIndex: number, FillIndex: number, BorderIndex: number, XFId: number, HorAlign: StiTextHorAlignment, VertAlign: StiVertAlignment, TextRotationAngle: number, TextWrapped: boolean, RightToLeft: boolean, Editable: boolean);
    }
    class ExcelImageData {
        FirstRowIndex: number;
        FirstRowOffset: number;
        FirstColumnIndex: number;
        FirstColumnOffset: number;
        LastRowIndex: number;
        LastRowOffset: number;
        LastColumnIndex: number;
        LastColumnOffset: number;
        ImageIndex: number;
        Hyperlink: string;
        constructor(FirstRowIndex: number, FirstRowOffset: number, FirstColumnIndex: number, FirstColumnOffset: number, LastRowIndex: number, LastRowOffset: number, LastColumnIndex: number, LastColumnOffset: number, ImageIndex: number, Hyperlink: string);
    }
    class CellRangeAddress {
        FirstRow: number;
        LastRow: number;
        FirstColumn: number;
        LastColumn: number;
        constructor(FirstRow: number, LastRow: number, FirstColumn: number, LastColumn: number);
    }
    class HlinkData {
        Range: CellRangeAddress;
        Description: string;
        Bookmark: string;
        constructor(Range: CellRangeAddress, Description: string, Bookmark: string);
    }
}
declare module Stimulsoft.Report.Export {
    class StiExcelXmlExportService extends StiExportService {
    }
}
declare module Stimulsoft.Report.Export {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import Image = Stimulsoft.System.Drawing.Image;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    enum StiTableLineInfo {
        Empty = 0,
        Unknown = 1,
        PageHeader = 2,
        PageFooter = 3,
        HeaderAP = 4,
        FooterAP = 5,
        HeaderD = 6,
        FooterD = 7,
        Data = 8,
        Trash = 9
    }
    class StiMatrix {
        cells: StiCell[][];
        cellsMap: StiCell[][];
        totalHeight: number;
        totalWidth: number;
        styles: StiCellStyle[];
        coordX: number[];
        coordY: number[];
        linePlacement: StiTableLineInfo[];
        parentBandName: string[];
        bordersX: StiBorderSide[][];
        bordersY: StiBorderSide[][];
        horizontalPageBreaks: number[];
        cellStyles: StiCellStyle[][];
        bookmarks: string[][];
        bookmarksTable: Hashtable;
        interactions: number[][][];
        private maxRowHeight;
        private _defaultLinePrimitiveWidth;
        private static staticRectanglePrimitive;
        private coordXCheck;
        private coordYCheck;
        private coordXNew;
        private coordYNew;
        private coordXPrim;
        private coordYPrim;
        imagesBaseRect: Hashtable;
        private leftCached;
        private topCached;
        private xcHash;
        private ycHash;
        private tagSplitCache;
        private stylesCache;
        private fontsCache;
        private createdCells;
        borderSides: StiBorderSide[];
        exportFormat: StiExportFormat;
        private isHtmlService;
        private isHtmlOrExcelXmlService;
        private isHtmlPngMode;
        report: StiReport;
        private pages;
        private addComponentWithInteractions;
        private replaceCheckboxes;
        private hyperlinksToTag;
        private maxCoordY;
        private defaultLinePrimitiveWidth;
        private setBookmarkValue;
        private static sortForMatrix;
        private round;
        private addCoord;
        static htmlScaleX: number;
        static htmlScaleY: number;
        private addCoord2;
        prepareTable(): void;
        getRange(rect: RectangleD): Rectangle;
        getStyleFromComponent(component: StiComponent, x: number, y: number, id: string): StiCellStyle;
        private getStyle;
        private renderComponent;
        private getCellRectangle;
        private cutRectangleFromCellsMap;
        isComponentHasInteraction(component: StiComponent): boolean;
        scanComponentsPlacement(optimize: boolean, exportObjectFormatting?: boolean): void;
        private processIntersectedCells;
        splitTagWithCache(inputString: string): string[];
        static splitTag(inputString: string): string[];
        static getStringsFromTag(tag: string, startPosition: number): string[];
        private copyFieldsListToFields;
        fields: DataField[];
        dataArrayLength: number;
        private fieldsList;
        private sizeX;
        private sizeY;
        private htName;
        prepareDocument(service: StiExportService, mode: StiDataExportMode): void;
        checkStylesNames(): void;
        getRealImageData(cell: StiCell, baseImage: Image): Image;
        private checkComponentPlacement;
        private lastPage;
        private lastPageId;
        private lastComps;
        getBorderSideIndex(side: StiBorderSide): number;
        static GCCollect(): void;
        clear(): void;
        constructor(pages: StiPagesCollection, checkForExcel: boolean, service: StiExportService, styles?: StiCellStyle[], dataMode?: StiDataExportMode);
    }
    class DataField {
        name: string;
        info: number[];
        formatString: string;
        dataArray: string[];
        readyName: boolean;
        readyType: boolean;
        constructor(size: number);
    }
}
declare module Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiWord2007ExportService extends StiExportService {
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        getFilter(): string;
        private _matrix;
        readonly matrix: StiMatrix;
        private _removeEmptySpaceAtBottom;
        readonly removeEmptySpaceAtBottom: boolean;
        private fontList;
        private styleList;
        private imageCache;
        private bookmarkList;
        private hyperlinkList;
        private embedsList;
        private xmlIndentation;
        private imageQuality;
        private imageResolution;
        private lineSpace;
        private lineSpace2;
        private usePageHeadersAndFooters;
        private restrictEditing;
        private headersData;
        private headersRels;
        private footersData;
        private footersRels;
        private docCompanyString;
        private docLastModifiedString;
        private checkFontsToCorrectHeight;
        private getLineStyle;
        private getColorString;
        private getStyleNumber;
        private getStyleFromComponent;
        private stringToUrl;
        private wrongUrlSymbols;
        private static readonly hiToTwips;
        private convert;
        private convertHiToTwips;
        private convertTwipsToEmu;
        private convertStringToBookmark;
        private writeFromMatrix;
        private writeCellContent;
        private writeTableInfo;
        private writeHtmlTags;
        private writeParagraphBegin;
        private writeRunProperties;
        private renderBorder2TableGetValues;
        private getLineStyle2TableGetValues;
        private writeDocument;
        private compareExcellSheetNames;
        private writePageInfo;
        private writeBorders;
        private writeBorderData;
        private writeFootNotes;
        private writeEndNotes;
        private writeHeader;
        private writeFooter;
        private writeContentTypes;
        private writeMainRels;
        private writeDocPropsApp;
        private writeDocPropsCore;
        private writeSettings;
        private writeWebSettings;
        private writeFontTable;
        private writeDocumentRels;
        private writeHeaderFooterRels;
        private writeStyles;
        private writeImage;
        private writeAdditionalData;
        exportWord(report: StiReport, stream: MemoryStream, settings: StiWord2007ExportSettings): void;
    }
}
declare module Stimulsoft.Report.Export {
    import Color = Stimulsoft.System.Drawing.Color;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPdfData {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Component: StiComponent;
        service: StiPdfExportService;
        readonly Right: number;
        readonly Top: number;
        constructor(service: StiPdfExportService);
    }
    class StiEditableObject {
        X: number;
        Y: number;
        Width: number;
        Height: number;
        Page: number;
        Text: string;
        Content: number[];
        Content2: number[];
        Multiline: boolean;
        Alignment: Stimulsoft.Base.Drawing.StiTextHorAlignment;
        FontNumber: number;
        FontSize: number;
        FontColor: Color;
        Component: StiComponent;
    }
    class StiPdfExportService extends StiExportService {
        readonly exportFormat: StiExportFormat;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        exportToAsync(onExport: Function, report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        report: StiReport;
        readonly multipleFiles: boolean;
        private imageQuality;
        private imageResolutionMain;
        private imageResolutionMode;
        private sw;
        pageStream: MemoryStream;
        private imageList;
        private imageCache;
        private imageInterpolationTable;
        private imageCacheIndexToList;
        private imageInfoList;
        private imageInfoCounter;
        private imagesCurrent;
        private fontsCounter;
        private bookmarksCounter;
        private linksCounter;
        private annotsCounter;
        annotsCurrent: number;
        private annots2Counter;
        private annots2Current;
        private unsignedSignaturesCounter;
        shadingCurrent: number;
        private tooltipsCounter;
        private colorTable;
        private alphaTable;
        pdfFont: PdfFonts;
        bidi: StiBidirectionalConvert;
        private standardPdfFonts;
        private embeddedFonts;
        useUnicodeMode: boolean;
        private reduceFontSize;
        private compressed;
        private compressedFonts;
        private encrypted;
        private usePdfA;
        private pdfComplianceMode;
        private exportRtfTextAsImage;
        private autoPrint;
        private imageCompressionMethod;
        private imageFormat;
        private monochromeDitheringType;
        private allowEditable;
        private fontGlyphsReduceNotNeed;
        private xref;
        annotsArray: Array<StiEditableObject>;
        private annots2Array;
        private unsignedSignaturesArray;
        private shadingArray;
        private hatchArray;
        private haveBookmarks;
        private haveLinks;
        haveAnnots: boolean;
        private haveTooltips;
        CodePage1252part80AF: number[];
        private CodePage1252;
        hiToTwips: number;
        private precision_digits_font;
        pdfCKT: number;
        private IDValue;
        private IDValueString;
        private IDValueStringMeta;
        private currentDateTime;
        private currentDateTimeMeta;
        private producerName;
        private creatorName;
        private keywords;
        private currentObjectNumber;
        private currentGenerationNumber;
        private keyLength;
        private lastColorStrokeA;
        private lastColorNonStrokeA;
        private colorStack;
        info: StiPdfStructure;
        private haveDigitalSignature;
        printScaling: boolean;
        private static regexEscape;
        stringReplace(st: string, oldValue: string, newValue: string): string;
        getHatchNumber(brush: StiHatchBrush): number;
        private addXref;
        convertToString(value: number, precision?: number): string;
        static convertToEscapeSequence(value: string): string;
        static convertToEscapeSequencePlusTabs(value: string): string;
        setStrokeColor(tempColor: Color): void;
        setNonStrokeColor(tempColor: Color): void;
        private colorHash1;
        private colorHash2;
        private _gsTable;
        readonly gsTable: string[][];
        pushColorToStack(): void;
        popColorFromStack(): void;
        private storeStringLine;
        private storeString;
        private convertToHexString;
        private storeMemoryStream2;
        private storeMemoryStream3;
        private storeMemoryStream4;
        private renderStartDoc;
        private renderEndDoc;
        private renderPageHeader;
        private renderPageFooter;
        private renderFontTable;
        private renderImageTable;
        private renderPatternTable;
        private writeHatchPattern;
        private writeShadingPattern;
        private renderAnnotTable;
        private renderExtGStateRecord;
        storeImageData(image: Image, imageResolution: number, isImageComponent: boolean, needSmoothing: boolean): number;
        private writeImageInfo;
        renderImage(pp: StiPdfData, imageResolution: number): void;
        private renderWatermark;
        storeShadingData1(brush: StiBrush, pageNumber: number): void;
        storeShadingData2(x: number, y: number, width: number, height: number, brush: StiBrush): number;
        storeHatchData(brush: StiBrush): void;
        private renderMetadata;
        private renderColorSpace;
        private renderAutoPrint;
        exportPdf(report: StiReport, stream: MemoryStream, settings: StiPdfExportSettings): void;
        private exportPdf1;
    }
}
declare module Stimulsoft.Report.Export {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    import Font = Stimulsoft.System.Drawing.Font;
    class PdfFontInfo {
        Widths: Array<number>;
        CharPdfNames: Array<string>;
        CH: number;
        XH: number;
        ASC: number;
        DESC: number;
        tmASC: number;
        tmDESC: number;
        tmExternal: number;
        MacAscend: number;
        MacDescend: number;
        MacLineGap: number;
        LLX: number;
        LLY: number;
        URX: number;
        URY: number;
        StemV: number;
        ItalicAngle: number;
        LineGap: number;
        NtmFlags: number;
        UnderscoreSize: number;
        UnderscorePosition: number;
        StrikeoutSize: number;
        StrikeoutPosition: number;
        UnicodeMap: Array<number>;
        UnicodeMapBack: Array<number>;
        GlyphList: Array<number>;
        GlyphBackList: Array<number>;
        GlyphRtfList: Array<number>;
        SymsToPDF: Array<number>;
        MappedSymbolsCount: number;
        NeedSyntItalic: boolean;
        NeedSyntBold: boolean;
        GlyphWidths: Array<number>;
        ChildFontsMap: Array<number>;
    }
    class pfontInfo {
        Name: string;
        PdfName: string;
        Bold: boolean;
        Italic: boolean;
        Number: number;
        Font: Font;
        ParentFontNumber: number;
        ChildFontsMap: Array<number>;
    }
    class PdfFonts extends PdfFontInfo {
        getFontMetrics(font: Font, currentFontInfo: PdfFontInfo, glyphMap: number[], report: StiReport): void;
        private standardFontQuantity;
        private standardFontNumWidths;
        private standardFontNumChars;
        firstMappedSymbol: number;
        factor: number;
        maxSymbols: number;
        useUnicode: boolean;
        WIDTHS: number[];
        fonts: Array<PdfFontInfo>;
        UnicodeMapsList: Array<number[]>;
        GlyphMapsList: Array<number[]>;
        standardPdfFonts: boolean;
        fontList: Array<pfontInfo>;
        private fontsInfoStore;
        private family_Helvetica;
        private family_Courier;
        private family_Times_Roman;
        private family_Symbol;
        private family_ZapfDingbats;
        PdfFontName: string[];
        private _currentFont;
        currentFont: number;
        InitFontsData(report: StiReport): void;
        constructor();
        getFontNumber(incomingFont: Font): number;
        storeUnicodeSymbolsInMap(sb: StringBuilder): void;
        private TtfHeaderSize;
        getCharToGlyphTable(buff: Uint8Array, fontName: string): number[];
        reduceFontSize(buff: Uint8Array, fontName: string, remakeGlyphTable: boolean): Stimulsoft.System.IO.MemoryStream;
        private scanFontFile;
        private getCmapTable;
        private copyUint8Array;
        ARG_1_AND_2_ARE_WORDS: number;
        ARGS_ARE_XY_VALUES: number;
        ROUND_XY_TO_GRID: number;
        WE_HAVE_A_SCALE: number;
        MORE_COMPONENTS: number;
        WE_HAVE_AN_X_AND_Y_SCALE: number;
        WE_HAVE_A_TWO_BY_TWO: number;
        WE_HAVE_INSTRUCTIONS: number;
        USE_MY_METRICS: number;
        OVERLAP_COMPOUND: number;
        SCALED_COMPONENT_OFFSET: number;
        UNSCALED_COMPONENT_OFFSET: number;
        TablesNames: Array<string>;
        private getTtfInfo;
        private GetUInt8;
        private GetUInt16;
        private GetUInt32;
        private GetInt16;
        private SetUInt16;
        private SetUInt32;
        clear(): void;
    }
    class FontsInfoStore {
        clear(): void;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPenGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        brush: Object;
        thickness: number;
        penStyle: Stimulsoft.Base.Drawing.StiPenStyle;
        alignment: StiPenAlignment;
        startCap: StiPenLineCap;
        endCap: StiPenLineCap;
        readonly type: StiGeomType;
        constructor(brush: Object, thickness?: number);
    }
}
declare module Stimulsoft.Report.Export {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Matrix = Stimulsoft.System.Drawing.Drawing2D.Matrix;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiPdfGeomWriter {
        private penWidthDefault;
        private precision_digits;
        private hiToTwips;
        private pdfCKT;
        private lastPoint;
        private makepath;
        private pathClosed;
        private path;
        private pageStream;
        private pdfService;
        assembleData: boolean;
        pageNumber: number;
        matrixCache: Array<Matrix>;
        private xmin;
        private xmax;
        private ymin;
        private ymax;
        private calculateMinMax;
        private convertToString;
        setPen(objPen: Object, saveState?: boolean): boolean;
        setBrush(brush: Object, rect: Rectangle, saveState?: boolean): boolean;
        private outputLineString;
        private convertArcToBezierPoints;
        convertSplineToCubicBezier(points: Point[], tension: number): Point[];
        private calculateCurveBezier;
        private calculateCurveBezierEndPoints;
        getPointString(point: Point): string;
        getLineToString(pointTo: Point): string;
        getRectString4(x: number, y: number, width: number, height: number): string;
        getRectString(rect: Rectangle): string;
        getBezierString(p1: Point, p2: Point, p3: Point): string;
        getBezierString2(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): string;
        getPolylineString(points: Point[], close: boolean, drawTo: boolean): string;
        getEllipseString4(x: number, y: number, width: number, height: number): string;
        getEllipseString(rect: Rectangle): string;
        private getPenStyleDashString;
        beginPath(): void;
        closeFigure(): void;
        endPath(): void;
        fillPath(brush: Object): void;
        strokePath(pen: Object): void;
        moveTo(point: Point): void;
        drawLine(pointFrom: Point, pointTo: Point, pen: Object): void;
        drawLineTo(pointTo: Point, pen: Object): void;
        drawRectangle(rect: Rectangle, pen: Object): void;
        fillRectangle(rect: Rectangle, brush: Object): void;
        drawPolygon(points: Point[], pen: Object): void;
        drawPolyline(points: Point[], pen: Object, close?: boolean, drawTo?: boolean): void;
        drawPolylineTo(points: Point[], pen: Object): void;
        fillPolygon(points: Point[], brush: Object): void;
        drawBezier(p1: Point, p2: Point, p3: Point, p4: Point, pen: Object): void;
        drawBezierTo(p2: Point, p3: Point, p4: Point, pen: Object): void;
        drawSpline(points: Point[], tension: number, pen: Object): void;
        drawArc(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawEllipse(rect: Rectangle, pen: Object): void;
        fillEllipse(rect: Rectangle, brush: Object): void;
        drawPie(rect: Rectangle, startAngle: number, sweepAngle: number): void;
        drawString(st: string, font: Font, brush: StiBrush, rect: Rectangle, sf: StringFormat): void;
        saveState(): void;
        restoreState(): void;
        translateTransform(x: number, y: number): void;
        rotateTransform(angle: number): void;
        setClip(rect: Rectangle): void;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): void;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): void;
        setPixel(point: PointD, color: Color): void;
        measureString(st: string, font: Font): SizeD;
        drawImage(img: Image, rect: RectangleD): void;
        constructor(stream: MemoryStream, service: StiPdfExportService, assembleData?: boolean);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushSmothingModeToAntiAliasGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopSmothingModeGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPushTextRenderingHintToAntiAliasGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiPopTextRenderingHintGeom extends StiGeom implements IStiJsonReportObject {
        readonly type: StiGeomType;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfRenderChart {
        static renderChart(pp: StiPdfData, assemble: boolean, pageNumber: number): void;
        private static getStartPoint;
        private static rectToRectangle;
        private static brushToStiBrush;
        private static checkPenGeom;
    }
}
declare module Stimulsoft.Report.Export {
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiCheckBox = Stimulsoft.Report.Components.StiCheckBox;
    class StiPdfRenderPrimitives {
        static renderBorder1(pp: StiPdfData): void;
        static renderBorder2(pp: StiPdfData): void;
        private static storeBorderSideData;
        static getPenStyleDashString(style: StiPenStyle, step: number, pp: StiPdfData): string;
        static checkShape(shape: StiShape): boolean;
        static renderShape(pp: StiPdfData, imageResolution: number): void;
        static renderRoundedRectanglePrimitive(pp: StiPdfData): void;
        static renderCheckbox(pp: StiPdfData, checkBoxValue: boolean, storeShading?: boolean): void;
        static getCheckBoxValue(checkbox: StiCheckBox): boolean;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfRenderText {
        private static hiToTwips;
        private static precision_digits_font;
        private static fontCorrectValue;
        private static boldFontStrokeWidthValue;
        private static italicAngleTanValue;
        static renderText(pp: StiPdfData): void;
        private static isWordWrapSymbol;
        private static getTabsSize;
        static renderTextFont(pp: StiPdfData): void;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfResources {
        static sRGBprofile: number[];
        static hatchData: string[];
        private static standardFontWidths;
        private static standardFontInfo;
        private static _standardFontCharsNames;
        static readonly standardFontCharsNames: string[];
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfObjInfo {
        ref: number;
        info: StiPdfStructure;
        readonly isUsed: boolean;
        addRef(): void;
        toString(): string;
    }
    class StiPdfContentObjInfo extends StiPdfObjInfo {
        content: StiPdfObjInfo;
    }
    class StiPdfXObjectObjInfo extends StiPdfObjInfo {
        mask: StiPdfObjInfo;
    }
    class StiPdfFontObjInfo extends StiPdfObjInfo {
        descendantFont: StiPdfObjInfo;
        toUnicode: StiPdfObjInfo;
        cIDSet: StiPdfObjInfo;
        encoding: StiPdfObjInfo;
        fontDescriptor: StiPdfObjInfo;
        fontFile2: StiPdfObjInfo;
    }
    class StiPdfOutlinesObjInfo extends StiPdfObjInfo {
        items: StiPdfObjInfo[];
    }
    class StiPdfShadingObjInfo extends StiPdfObjInfo {
        function: StiPdfObjInfo;
    }
    class StiPdfPatternsObjInfo extends StiPdfObjInfo {
        resources: StiPdfObjInfo;
        first: StiPdfObjInfo;
        hatchItems: StiPdfObjInfo[];
        shadingItems: StiPdfShadingObjInfo[];
    }
    class StiPdfAnnotObjInfo extends StiPdfObjInfo {
        aP: StiPdfObjInfo;
        aA: StiPdfObjInfo[];
    }
    class StiPdfCheckBoxObjInfo {
        items: StiPdfAnnotObjInfo[];
    }
    class StiPdfAcroFormObjInfo extends StiPdfObjInfo {
        annots: StiPdfAnnotObjInfo[];
        checkBoxes: StiPdfCheckBoxObjInfo[];
        unsignedSignatures: StiPdfAnnotObjInfo[];
        signatures: StiPdfAnnotObjInfo[];
        tooltips: StiPdfAnnotObjInfo[];
        annotFontItems: StiPdfFontObjInfo[];
    }
    class StiPdfStructure {
        root: StiPdfObjInfo;
        info: StiPdfObjInfo;
        colorSpace: StiPdfObjInfo;
        pages: StiPdfObjInfo;
        structTreeRoot: StiPdfObjInfo;
        optionalContentGroup: StiPdfObjInfo;
        pageList: StiPdfContentObjInfo[];
        xObjectList: StiPdfXObjectObjInfo[];
        fontList: StiPdfFontObjInfo[];
        outlines: StiPdfOutlinesObjInfo;
        patterns: StiPdfPatternsObjInfo;
        linkList: StiPdfObjInfo[];
        encode: StiPdfObjInfo;
        extGState: StiPdfObjInfo;
        acroForm: StiPdfAcroFormObjInfo;
        metadata: StiPdfObjInfo;
        destOutputProfile: StiPdfObjInfo;
        outputIntents: StiPdfObjInfo;
        embeddedJS: StiPdfContentObjInfo;
        embeddedFilesList: StiPdfContentObjInfo[];
        private objectsCounter;
        private objects;
        addRef(info: StiPdfObjInfo): void;
        createObject(addRef?: boolean): StiPdfObjInfo;
        createContentObject(addRef?: boolean): StiPdfContentObjInfo;
        createXObject(addRef?: boolean, haveMask?: boolean): StiPdfXObjectObjInfo;
        createFontObject(addRef?: boolean, useUnicodeMode?: boolean, standardPdfFonts?: boolean, embeddedFonts?: boolean, annotFont?: boolean): StiPdfFontObjInfo;
        createOutlinesObject(addRef?: boolean): StiPdfOutlinesObjInfo;
        createPatternsObject(addRef?: boolean): StiPdfPatternsObjInfo;
        createShadingObject(addRef?: boolean): StiPdfShadingObjInfo;
        createAcroFormObject(addRef?: boolean): StiPdfAcroFormObjInfo;
        createAnnotObject(addRef?: boolean, createAP?: boolean, numberAA?: number): StiPdfAnnotObjInfo;
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    import MemoryStream = Stimulsoft.System.IO.MemoryStream;
    class StiRtfExportService extends StiExportService {
        readonly defaultExtension: string;
        readonly exportFormat: StiExportFormat;
        readonly groupCategory: string;
        readonly position: number;
        readonly exportNameInMenu: string;
        getFilter(): string;
        exportTo(report: StiReport, stream: MemoryStream, settings: StiExportSettings): void;
        private report;
        private fileName;
        private sendEMail;
        readonly multipleFiles: boolean;
        private getColorNumberInt;
        private getColorNumber;
        private getFontNumber2;
        private getFontNumber3;
        private getCharsetIndex;
        private colorList;
        private fontList;
        private styleList;
        private unicodeMapArray;
        private codePageToFont;
        private charsetCount;
        private fontToCodePages;
        private baseFontNumber;
        private usePageHeadersAndFooters;
        private imageResolution;
        private imageQuality;
        private imageFormat;
        private useStyles;
        private bookmarkList;
        private usedBookmarks;
    }
}
declare module Stimulsoft.Report.Export {
    class StiExportSettings {
        getExportFormat(): StiExportFormat;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPageRangeExportSettings extends StiExportSettings {
        pageRange: StiPagesRange;
    }
}
declare module Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    class StiDataExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        dataType: StiDataType;
        dataExportMode: StiDataExportMode;
        encoding: Encoding;
        exportDataOnly: boolean;
        codePage: StiDbfCodePages;
        separator: string;
        skipColumnHeaders: boolean;
        useDefaultSystemEncoding: boolean;
        constructor(dataType?: StiDataType);
    }
}
declare module Stimulsoft.Report.Export {
    class StiCsvExportSettings extends StiDataExportSettings {
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    import Encoding = Stimulsoft.System.Text.Encoding;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiHtmlExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        htmlType: StiHtmlType;
        imageQuality: number;
        imageResolution: number;
        imageFormat: ImageFormat;
        encoding: Encoding;
        zoom: number;
        exportMode: Export.StiHtmlExportMode;
        exportQuality: StiHtmlExportQuality;
        addPageBreaks: boolean;
        bookmarksTreeWidth: number;
        exportBookmarksMode: StiHtmlExportBookmarksMode;
        useStylesTable: boolean;
        removeEmptySpaceAtBottom: boolean;
        pageHorAlignment: StiHorAlignment;
        compressToArchive: boolean;
        useEmbeddedImages: boolean;
        continuousPages: boolean;
        chartType: StiHtmlChartType;
        openLinksTarget: string;
        useWatermarkMargins: boolean;
        constructor(htmlType?: StiHtmlType);
    }
}
declare module Stimulsoft.Report.Export {
    class StiHtml5ExportSettings extends StiHtmlExportSettings {
        constructor();
    }
}
declare namespace Stimulsoft.Report.Export {
    import StiTiffCompressionScheme = Stimulsoft.Report.Export.StiTiffCompressionScheme;
    import StiPageRangeExportSettings = Stimulsoft.Report.Export.StiPageRangeExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiImageFormat = Stimulsoft.Report.Export.StiImageFormat;
    import StiMonochromeDitheringType = Stimulsoft.Report.Export.StiMonochromeDitheringType;
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    /**
     *  Base class which describes export settings for all types of exports to image formats.
     */
    class StiImageExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        /**
         *  Gets or sets image type for exported images.
         */
        imageType: StiImageType;
        /**
         *  Gets or sets image zoom factor for exported images. This property can't be used with EMF, SVG, SVGZ formats.
         */
        imageZoom: number;
        /**
         *  Gets or sets image resolution for exported images. This property can't be used with EMF, SVG, SVGZ formats.
         */
        imageResolution: number;
        /**
         *  Gets or sets value which indicates that page margins will be cut or not. This property can't be used with EMF, SVG, SVGZ formats.
         */
        cutEdges: boolean;
        /**
         *  Gets or sets image format for exported images. This property can't be used with EMF, SVG, SVGZ formats.
         */
        imageFormat: StiImageFormat;
        /**
         *  Gets or sets value which indicates that export engine will be create one solid file or multiple files (one file per page).
         *  This property can't be used with EMF, SVG, SVGZ formats.
         */
        multipleFiles: boolean;
        /**
         *  Gets or sets type of dithering. This property can't be used with EMF, SVG, SVGZ formats.
         */
        ditheringType: StiMonochromeDitheringType;
        /**
         *  Gets or sets compression scheme of TIFF format. This property can't be used with EMF, SVG, SVGZ formats.
         */
        tiffCompressionScheme: StiTiffCompressionScheme;
        constructor(imageType?: StiImageType);
    }
}
declare namespace Stimulsoft.Report.Export {
    /**
     *  Class contains settings for export to SVG image format.
     */
    class StiSvgExportSettings extends StiImageExportSettings {
        /**
         *  Gets or sets image type for exported images.
         */
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    class StiExcelExportSettings extends StiPageRangeExportSettings {
        excelType: StiExcelType;
        useOnePageHeaderAndFooter: boolean;
        exportDataOnly: boolean;
        exportPageBreaks: boolean;
        exportObjectFormatting: boolean;
        exportEachPageToSheet: boolean;
        imageQuality: number;
        imageResolution: number;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiExcel2007RestrictEditing;
        getExportFormat(): StiExportFormat;
        constructor(excelType?: StiExcelType);
    }
}
declare module Stimulsoft.Report.Export {
    class StiExcel2007ExportSettings extends StiExcelExportSettings {
        constructor();
    }
}
declare module Stimulsoft.Report.Export {
    class StiWord2007ExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        usePageHeadersAndFooters: boolean;
        imageQuality: number;
        imageResolution: number;
        removeEmptySpaceAtBottom: boolean;
        companyString: string;
        lastModifiedString: string;
        restrictEditing: StiWord2007RestrictEditing;
    }
}
declare module Stimulsoft.Report.Export {
    class StiPdfExportSettings extends StiPageRangeExportSettings {
        getExportFormat(): StiExportFormat;
        imageQuality: number;
        imageResolution: number;
        imageResolutionMode: StiImageResolutionMode;
        embeddedFonts: boolean;
        standardPdfFonts: boolean;
        compressed: boolean;
        useUnicode: boolean;
        useDigitalSignature: boolean;
        getCertificateFromCryptoUI: boolean;
        exportRtfTextAsImage: boolean;
        passwordInputUser: string;
        passwordInputOwner: string;
        userAccessPrivileges: StiUserAccessPrivileges;
        keyLength: StiPdfEncryptionKeyLength;
        creatorString: string;
        keywordsString: string;
        imageCompressionMethod: StiPdfImageCompressionMethod;
        imageIndexedColorPaletteSize: number;
        imageFormat: StiImageFormat;
        ditheringType: StiMonochromeDitheringType;
        pdfACompliance: boolean;
        pdfComplianceMode: StiPdfComplianceMode;
        autoPrintMode: StiPdfAutoPrintMode;
        allowEditable: StiPdfAllowEditable;
    }
}
declare module Stimulsoft.Report.Export {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiPdfGeomWriter = Stimulsoft.Report.Export.StiPdfGeomWriter;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Pen = Stimulsoft.System.Drawing.Pen;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    class StiBarCodeExportPainter implements Stimulsoft.Report.Painters.IStiBarCodePainter {
        private geomWriter;
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): void;
        baseRollbackTransform(context: any): void;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): void;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): void;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): void;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): void;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): void;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
        static createNew(geomWriter1: StiPdfGeomWriter): StiBarCodeExportPainter;
        constructor(geomWriter1: StiSvgGeomWriter);
    }
    interface IStiExportGeomWriter {
        beginPath(): any;
        closeFigure(): any;
        endPath(): any;
        fillPath(brush: any): any;
        strokePath(pen: any): any;
        moveTo(point: PointD): any;
        drawLine(pointFrom: PointD, pointTo: PointD, pen: any): any;
        drawLineTo(pointTo: PointD, pen: any): any;
        drawRectangle(rect: RectangleD, pen: any): any;
        fillRectangle(rect: RectangleD, color: Color): any;
        fillRectangle(rect: RectangleD, brush: any): any;
        drawPolyline(points: PointD[], pen: Pen): any;
        drawPolylineTo(points: PointD[], pen: any): any;
        drawPolygon(points: PointD[], pen: any): any;
        fillPolygon(points: PointD[], brush: any): any;
        fillEllipse(rect: RectangleD, brush: any): any;
        drawBezier(p1: PointD, p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawBezierTo(p2: PointD, p3: PointD, p4: PointD, pen: any): any;
        drawArc2(rect: RectangleD, p1: PointD, p2: PointD, pen: Pen): any;
        setPixel(point: PointD, color: Color): any;
        drawImage(img: Image, rect: RectangleD): any;
        drawText(basePoint: PointD, text: string, charsOffset: number[], font: Font, textColor: Color, angle: number, textAlign: EmfTextAlignmentMode): any;
        drawString(st: string, font: Font, brush: any, rect: RectangleD, sf: StringFormat): any;
        saveState(): any;
        restoreState(): any;
        translateTransform(x: number, y: number): any;
        rotateTransform(angle: number): any;
        measureString(st: string, font: Font): SizeD;
    }
}
declare module Stimulsoft.Report.Export {
    import StringBuilder = Stimulsoft.System.Text.StringBuilder;
    class StiBidirectionalConvert {
        private arabicTableSize;
        private ligaturesTableSize;
        private static ligaturesTable;
        private static arabicTable;
        private static arabicTableArray;
        private stSeparator;
        private modePdf;
        convert(inputString: StringBuilder, useRightToLeft: boolean): StringBuilder;
        private convertArabic;
        private symbolIsDigitOrDelimiter;
        private static symbolIsArabicOrHebrew;
        static stringContainArabicOrHebrew(st: string): boolean;
        private symbolIsBidiMark;
        private symbolIsLTRMark;
        private symbolIsRTLMark;
        clear(): void;
        constructor(modePdf?: boolean);
    }
}
declare module Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImage = Stimulsoft.Report.Components.IStiExportImage;
    class StiCell {
        clone(): StiCell;
        forceExportAsImage(exportImage: any): boolean;
        private _exportFormat;
        exportFormat: StiExportFormat;
        private _component;
        component: StiComponent;
        _exportImage: IStiExportImage;
        exportImage: IStiExportImage;
        cellStyle: StiCellStyle;
        left: number;
        top: number;
        width: number;
        private _height;
        height: number;
        text: string;
        constructor(exportFormat?: StiExportFormat);
    }
}
declare module Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
    class StiCellStyle {
        clone(): StiCellStyle;
        getHashCode(): number;
        stiEquals(obj: Object): boolean;
        static getStyleFromCache(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, internalStyleName: string, lineSpacing: number, hashStyles: Hashtable, styles: Array<StiCellStyle>, fontsCache: Hashtable, cellStyle: StiCellStyle, simplyAdd: boolean, overflow: boolean, borderRadius: number): StiCellStyle;
        border: StiBorderSide;
        borderL: StiBorderSide;
        borderR: StiBorderSide;
        borderB: StiBorderSide;
        absolutePosition: boolean;
        color: Color;
        font: Font;
        horAlignment: StiTextHorAlignment;
        vertAlignment: StiVertAlignment;
        textOptions: StiTextOptions;
        textColor: Color;
        wordWrap: boolean;
        format: string;
        overflow: boolean;
        borderRadius: number;
        lineSpacing: number;
        private _internalStyleName;
        internalStyleName: string;
        private _styleName;
        styleName: string;
        constructor(color: Color, textColor: Color, font: Font, horAlignment: StiTextHorAlignment, vertAlignment: StiVertAlignment, border: StiBorderSide, borderL: StiBorderSide, borderR: StiBorderSide, borderB: StiBorderSide, textOptions: StiTextOptions, wordWrap: boolean, format: string, lineSpacing: number, styleName?: string, overflow?: boolean, borderRadius?: number);
    }
}
declare module Stimulsoft.Report.Export {
    import ImageFormat = Stimulsoft.System.Drawing.Imaging.ImageFormat;
    import Promise = Stimulsoft.System.Promise;
    class StiExportImageHelper {
        static convertAllImages(renderedReport: StiReport, imageFormat: ImageFormat, flate?: boolean): Promise<void>;
    }
}
declare module Stimulsoft.Report.Export {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiExportUtils {
        static convertDigitsToArabic(outputString: string, digitsType: StiArabicDigitsType): string;
        private static reportVersion;
        static getReportVersion(): string;
        static saveComponentToString(component: StiComponent, imageFormat?: ImageFormat, imageQuality?: number, imageResolution?: number): string;
        static trimEndWhiteSpace(inputString: string): string;
        static trimEndWhiteSpace2(inputString: string, removeControl: boolean): string;
        static splitString(inputString: string, removeControl: boolean): Array<string>;
        static stringToUrl(input: string): string;
        private static wrongUrlSymbols;
        static additionalData: string;
        private static positivePatterns;
        private static negativePatterns;
        static getPositivePattern(patternIndex: number): string;
        static getNegativePattern(patternIndex: number): string;
    }
}
declare module Stimulsoft.Report.Export {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiHtmlImageHost {
        htmlExport: StiHtmlExportService;
        isMhtExport: boolean;
        forcePng: boolean;
        getImageString(bmp: Image): string;
        constructor(htmlExport: StiHtmlExportService);
    }
}
declare module Stimulsoft.Report.Export {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import TextWriter = Stimulsoft.System.IO.TextWriter;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    enum StiHtmlUnitType {
        Pixel = 0,
        Point = 1
    }
    class StiHtmlUnit {
        private static hiToPt;
        value: number;
        unitType: StiHtmlUnitType;
        toString(): string;
        static toPixelString(value: number): string;
        static newUnit2(value: number, unitType: StiHtmlUnitType): StiHtmlUnit;
        static newUnit(value: number, usePoints?: boolean): StiHtmlUnit;
        static isNullOrZero(unit: StiHtmlUnit): boolean;
    }
    class StiHtmlSvg {
        text: string;
    }
    class StiHtmlHyperlink {
        text: string;
        toolTip: string;
        navigateUrl: string;
        attributes: Hashtable;
        style: Hashtable;
        imageUrl: string;
        cssClass: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        openLinksTarget: string;
        id: string;
        constructor();
    }
    class StiHtmlImage {
        toolTip: string;
        imageUrl: string;
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        aspectRatio: boolean;
        multipleFactor: number;
        margins: StiMargins;
        horAlignment: number;
        vertAlignment: number;
        imageRotation: number;
        stretch: boolean;
        zoom: number;
        base64: string;
    }
    class StiHtmlTableCell {
        width: StiHtmlUnit;
        height: StiHtmlUnit;
        style: Hashtable;
        columnSpan: number;
        rowSpan: number;
        cssClass: string;
        text: string;
        toolTip: string;
        controls: any[];
        id: string;
        interaction: string;
        collapsed: string;
        sortDirection: string;
        dataBandSort: string;
        pageGuid: string;
        pageIndex: string;
        reportFile: string;
        componentIndex: string;
        editable: string;
        constructor();
    }
    class StiHtmlTableRow {
        style: Hashtable;
        cells: StiHtmlTableCell[];
        height: StiHtmlUnit;
        constructor();
    }
    class StiHtmlTable {
        backImageUrl: string;
        backgroundRepeat: string;
        backgroundPosition: string;
        width: StiHtmlUnit;
        borderWidth: number;
        cellPadding: number;
        cellSpacing: number;
        rows: Array<StiHtmlTableRow>;
        align: StiHorAlignment;
        position: string;
        static marginsKey: string;
        static pageBreakBeforeKey: string;
        static vertAlignKey: string;
        static horAlignKey: string;
        static wordwrapKey: string;
        private static wrongUrlSymbols;
        htmlExportSettings: StiHtmlExportSettings;
        static stringToUrl(input: string): string;
        renderControl(writer: StiHtmlTextWriter): void;
        private writeTableBegin;
        private writeTableEnd;
        constructor();
    }
    enum WriterMode {
        None = 0,
        BeginTag = 1,
        Attribute = 2,
        Data = 3
    }
    class StiHtmlTextWriter {
        private stream;
        private mode;
        indent: number;
        write(st: string): void;
        writeLine(st?: string): void;
        writeBeginTag(st: string): void;
        writeFullBeginTag(st: string): void;
        writeEndTag(st: string): void;
        writeFullEndTag(st: string): void;
        writeAttribute(attr: string, value: string): void;
        writeStyleAttribute(attr: string, value: string): void;
        flush(): void;
        private closeTag;
        private checkIndent;
        constructor(baseStream: TextWriter);
    }
    class StiHtmlTableRender {
        private htmlExport;
        private htmlExportSettings;
        matrix: StiMatrix;
        renderStyle(style: StiCellStyle): void;
        renderStyleTable(cell: StiHtmlTableCell, style: StiCellStyle): void;
        renderStyles(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable): void;
        renderStylesTable(useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles?: Hashtable): void;
        renderStylesTable2(useBookmarks: boolean, exportBookmarksOnly: boolean, addStyleTag: boolean, cssStyles?: Hashtable): void;
        private getWidth;
        private getHeight;
        renderTable(renderStyles: boolean, backGroundImageString: string, useBookmarks: boolean, exportBookmarksOnly: boolean, cssStyles: Hashtable, watermarkShowBehind?: boolean): void;
        constructor(htmlExport: StiHtmlExportService, htmlExportSettings: StiHtmlExportSettings, pages: StiPagesCollection);
    }
}
declare module Stimulsoft.Report.Export {
    enum EmfTextAlignmentMode {
        TA_LEFT = 0,
        TA_RIGHT = 2,
        TA_CENTER = 6,
        TA_TOP = 0,
        TA_BOTTOM = 8,
        TA_BASELINE = 24,
        TA_NOUPDATECP = 0,
        TA_UPDATECP = 1,
        TA_RTLREADING = 256,
        TA_MASK = 287
    }
}
declare module Stimulsoft.Report.Export {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiSegmentPagesDivider {
        static divide(pages: StiPagesCollection, service?: StiExportService): StiPagesCollection;
    }
}
declare module Stimulsoft.Report {
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    class StiPagesRange {
        static All: StiPagesRange;
        rangeType: StiRangeType;
        pageRanges: string;
        currentPage: number;
        stiEquals(obj: any): boolean;
        getSelectedPages(originalPages: StiPagesCollection): StiPagesCollection;
        constructor(rangeType?: StiRangeType, pageRanges?: string, currentPage?: number);
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class En {
        private static months;
        private static units;
        private static tens;
        private static addUnits;
        private static addTens;
        private static addRank;
        static decline(value: number, oneOrShowCents: string | boolean, twoOrDollars: string, cents?: string): string;
        static numToStr(value: number, uppercase?: boolean): string;
        static currToStr3(value: number, showCents: boolean): string;
        static currToStr(value: number, uppercase?: boolean, showCents?: boolean, dollars?: string, cents?: string): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    class EnGb {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
declare module Stimulsoft.Report.Func {
    class EnIn {
        static numberToStr(value: number, blankIfZero?: boolean): string;
        static currencyToStr(currencyBasicUnit: string, currencyFractionalUnit: string, value: number, decimalPlaces: number, blankIfZero?: boolean): string;
        private static numberToWords;
        private static _wordsDictionary;
        private static readonly wordsDictionary;
    }
}
declare module Stimulsoft.Report.Func {
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import ResourceManager = Stimulsoft.System.ResourceManager;
    import DateTime = Stimulsoft.System.DateTime;
    enum Gender {
        Masculine = 0,
        Feminine = 1,
        Neutral = 2
    }
    class BaseCurrency {
        readonly gender: Gender;
        readonly centsGender: Gender;
    }
    class Currency extends BaseCurrency {
        readonly dollars: string[];
        readonly cents: string[];
        readonly dollarOne: string;
        readonly dollarTwo: string;
        readonly dollarFive: string;
        readonly centOne: string;
        readonly centTwo: string;
        readonly centFive: string;
    }
    class NumToWordHelper {
        static maxValue: number;
        private static addWord;
        static addWords(integerString: string, decimalString: string, mainCurrency: string, centCurrency: string, postCurrency: string): string;
        static determinateCurrencies(culture: CultureInfo, currencyISO: string, integerPart: number, decimalPart: number, REFmainCurrency: any, REFcentCurrency: any): void;
    }
    function NumToWordException(message: string, num: number): string;
    class Resource {
        private static resourceMan;
        private static resourceCulture;
        static readonly resourceManager: ResourceManager;
        static culture: CultureInfo;
        static readonly eurBigSeparator: string;
        static readonly eurCentGender: string;
        static readonly eurCentPlural: string;
        static readonly EURCentSingle: string;
        static readonly EURGender: string;
        static readonly EURPlural: string;
        static readonly EURSingle: string;
        static readonly GBPBigSeparator: string;
        static readonly GBPCentGender: string;
        static readonly GBPCentPlural: string;
        static readonly GBPCentSingle: string;
        static readonly GBPGender: string;
        static readonly GBPPlural: string;
        static readonly GBPSingle: string;
        static readonly TooLongError: string;
    }
    class Convert {
        private static arabics;
        private static romans;
        private static subs;
        private static abc;
        private static abcRu;
        static toRoman(value: number): string;
        static toABC(value: number): string;
        static toABCNumeric(value: number): string;
        static toABCRu(value: number): string;
        static toArabic(val: number | string, useEasternDigits: boolean): string;
    }
    class EngineHelper {
        static joinColumnContent(source: StiBusinessObject | StiDataSource, columnName: string, delimiter: string, distinct?: boolean): string;
        static toQueryString<T>(list: Array<T>, quotationMark: string, dateTimeFormat: string): string;
    }
    class MonthToStr {
        private static months;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static monthName(dateTime: DateTime, cultureOrIsLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static MonthToStr(): void;
    }
    class DayOfWeekToStr {
        private static days;
        private static defaultUpperCaseList;
        private static cultureIndexes;
        static dayOfWeek(date: DateTime, cultureOrLocalized?: string | boolean, upperCase?: boolean): string;
        static addCulture(monthsNames: string[], cultureNames: string[], defaultUpperCase: boolean): void;
        static DayOfWeekToStr(): void;
    }
}
declare module Stimulsoft.Report.Func {
    class Es {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static currencies: string[][];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static determinateCurrenciesEurUsd;
        static numToStr(numberr: number, uppercase: boolean): string;
        static numToStr2(numberr: number, uppercase: boolean, female: boolean): string;
        private static convertToWord2;
    }
}
declare module Stimulsoft.Report.Func {
    class Fa {
        static convertToWord(numberr: number): string;
        private static changingNum;
    }
}
declare module Stimulsoft.Report.Func {
    class Fr {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwentys: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
declare module Stimulsoft.Report.Func {
    class Nl {
        static zeroWord: string;
        static lessWord: string;
        static triplets: string[][];
        static lessTwenty: string[];
        static tens: string[];
        static convertToWord(numberr: number, currencyISO: string, decimals: number): string;
        private static convertToWord2;
        private static calculateOver;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pl {
        private static units;
        private static tens;
        private static hundreds;
        private static thousends;
        private static million;
        private static billion;
        private static trillion;
        private static quadrillion;
        private static quintillion;
        private static zloty;
        private static grosz;
        private static dollar;
        private static cent;
        private static euro;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addRank;
        private static decline2;
        private static decline;
        private static currToStr2;
        static currToStr(value: number, currencyISO: string, showCents: boolean, uppercase: boolean): string;
        static dateToStr(date: DateTime, uppercase: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Pt {
        private static units;
        private static tens;
        private static months;
        static numToStr(value: number, uppercase: boolean): string;
        private static addRank;
        private static addUnits;
        private static addTens;
        private static decline;
        private static decline2;
        static currToStr(value: number, uppercase: boolean, showCents: boolean): string;
        static dateToStr(value: DateTime): string;
    }
}
declare module Stimulsoft.Report.Func {
    class PtBr {
        private static unid;
        private static dezena;
        private static centena;
        static numToStr(value: number): string;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ru {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency;
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addThousand;
        private static addRank;
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    class Tr {
        static Birler: string[];
        static Onlar: string[];
        static Binler: string[];
        static numToStr(value: number): string;
        static currToStr(value: number, currencyName?: string, showZeroCents?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    import DateTime = Stimulsoft.System.DateTime;
    class Ua {
        private static currencies;
        static registerCurrency(currency: Currency, currencyName: string): void;
        private static getCurrency;
        private static months;
        private static units;
        private static tens;
        private static hundreds;
        private static gendered;
        private static addUnits;
        private static addTens;
        private static addHundreds;
        private static addThousand;
        private static addRank;
        static numToStr(value: number, uppercase?: boolean, gender?: Gender): string;
        static currToStr(value: number, uppercase?: boolean, currency?: string, cents?: boolean): string;
        static decline2(value: number, one: string, two: string, five: string): string;
        static decline(value: number, currency: string, cents?: boolean): string;
        static dateToStr(date: DateTime, uppercase?: boolean): string;
    }
}
declare module Stimulsoft.Report.Func {
    class Zh {
        private static numChineseCharacter;
        static toWordsZh(num: number): string;
        static toCurrencyWordsZh(num: number): string;
        private static floatString;
        private static numberString;
        private static convert4;
        private static convertString;
        private static convert2;
        private static convert3;
    }
}
declare module Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    var IStiGlobalizationManager: string;
    interface IStiGlobalizationManager {
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
    }
}
declare module Stimulsoft.Report {
    var IStiGlobalizationManagerList: string;
    interface IStiGlobalizationManagerList {
        getTextGlobalizedNames(): string[];
        getImageGlobalizedNames(): string[];
    }
}
declare module Stimulsoft.Report {
    var IStiGlobalizationProvider: string;
    interface IStiGlobalizationProvider {
        setString(propertyName: string, value: string): any;
        getString(propertyName: string): string;
        getAllStrings(): string[];
    }
}
declare module Stimulsoft.Report {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainer implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _cultureName;
        cultureName: string;
        private _items;
        items: StiGlobalizationItemCollection;
        getAllStringsForReport(report: StiReport): Hashtable;
        localizeReport(report: StiReport): void;
        fillItemsFromReport(report: StiReport): void;
        removeUnlocalizedItemsFromReport(report: StiReport): void;
        constructor(cultureName?: string);
    }
}
declare module Stimulsoft.Report {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationContainerCollection extends CollectionBase<StiGlobalizationContainer> implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        add(data: StiGlobalizationContainer): void;
        addRange(data: StiGlobalizationContainer[]): void;
        contains(data: StiGlobalizationContainer): boolean;
        indexOf(data: StiGlobalizationContainer): number;
        insert(index: number, data: StiGlobalizationContainer): void;
        remove(data: StiGlobalizationContainer): void;
        getByIndex(index: number): StiGlobalizationContainer;
        setByIndex(index: number, value: StiGlobalizationContainer): void;
        getByName(name: string): StiGlobalizationContainer;
        setByName(name: string, value: StiGlobalizationContainer): void;
        private report;
        skipException: boolean;
        private getShortName;
        localizeReport(cultureName: string): void;
        localizeReport2(info: CultureInfo): void;
        fillItemsFromReport(): void;
        removeUnlocalizedItemsFromReport(): void;
        removeComponent(comp: StiComponent): void;
        renameComponent(comp: StiComponent, oldName: string, newName: string): void;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiGlobalizationItem implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _propertyName;
        propertyName: string;
        private _text;
        text: string;
        toString(): string;
        constructor(propertyName?: string, text?: string);
    }
}
declare module Stimulsoft.Report {
    import List = Stimulsoft.System.Collections.List;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiGlobalizationItemCollection extends CollectionBase<StiGlobalizationItem> implements IComparer<StiGlobalizationItem> {
        compare(item1: StiGlobalizationItem, item2: StiGlobalizationItem): number;
        add(data: StiGlobalizationItem): void;
        addRange(data: StiGlobalizationItem[]): void;
        contains(data: StiGlobalizationItem): boolean;
        indexOf(data: StiGlobalizationItem): number;
        insert(index: number, data: StiGlobalizationItem): void;
        remove(data: StiGlobalizationItem): void;
        toList(): List<StiGlobalizationItem>;
        getByIndex(index: number): StiGlobalizationItem;
        setByIndex(index: number, value: StiGlobalizationItem): void;
        sort(): void;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    enum StiImageType {
        GdiImage = 0,
        SvgObject = 1
    }
    enum StiFontIconSet {
        Rating = 0,
        Quarter = 1,
        Square = 2,
        Star = 3,
        Latin = 4
    }
    enum StiFontIcons {
        Latin5 = 0,
        Latin4 = 1,
        Latin3 = 2,
        Latin2 = 3,
        Latin1 = 4,
        QuarterFull = 5,
        QuarterThreeFourth = 6,
        QuarterHalf = 7,
        QuarterQuarter = 8,
        QuarterNone = 9,
        Rating4 = 10,
        Rating3 = 11,
        Rating2 = 12,
        Rating1 = 13,
        Rating0 = 14,
        Square0 = 15,
        Square1 = 16,
        Square2 = 17,
        Square3 = 18,
        Square4 = 19,
        StarFull = 20,
        StarThreeFourth = 21,
        StarHalf = 22,
        StarQuarter = 23,
        StarNone = 24,
        ArrowDown = 25,
        ArrowRight = 26,
        ArrowRightDown = 27,
        ArrowRightUp = 28,
        ArrowUp = 29,
        Check = 30,
        Circle = 31,
        CircleCheck = 32,
        CircleCross = 33,
        CircleExclamation = 34,
        Cross = 35,
        Rhomb = 36,
        Exclamation = 37,
        Flag = 38,
        Minus = 39,
        Triangle = 40,
        TriangleDown = 41,
        TriangleUp = 42,
        Home = 43,
        Cart = 44,
        Phone = 45,
        Mobile = 46,
        Mug = 47,
        Airplane = 48,
        Man = 49,
        Woman = 50,
        UserTie = 51,
        Truck = 52,
        Earth = 53,
        ManWoman = 54,
        Appleinc = 55,
        Android = 56,
        Windows8 = 57
    }
}
declare module Stimulsoft.Report {
    class StiAbbreviationNumberFormatHelper {
        static format(value: number): string;
        static format2(value: number, outPostfix: any): number;
    }
}
declare module Stimulsoft.Report.Helpers {
    class StiFileDialogHelper {
        static dataExts: string[];
        static imageExts: string[];
        static reportExts: string[];
        static textExts: string[];
        static documentExts: string[];
        static fontExts: string[];
    }
}
declare module Stimulsoft.Report {
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import List = Stimulsoft.System.Collections.List;
    class StiFontIconsHelper {
        static getContent(fontIcons: StiFontIcons): string;
        private static getNetContent;
        static getIsonSetContent(iconSet: StiFontIconSet): string;
        static getFontIcons(iconSet: StiFontIconSet): List<StiFontIcons>;
    }
}
declare module Stimulsoft.Report.Helpers {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageTransparenceHelper {
        static getTransparentedImage(source: Image, transparency: number): Image;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    /**
     *  Representation of an ISO3166-1 Country or State
     */
    class StiIsoCountry {
        names: string[];
        ruNames: string[];
        frNames: string[];
        alpha2: string;
        alpha3: string;
        ru(...names: string[]): StiIsoCountry;
        fr(...names: string[]): StiIsoCountry;
        iso(alpha2: string, alpha3?: string): StiIsoCountry;
        constructor(...names: string[]);
    }
}
declare namespace Stimulsoft.Report.Helpers {
    class StiIsoElementHelper {
        private static _countries;
        private static readonly countries;
        private static _usStates;
        private static readonly usStates;
        private static _canadaProvinces;
        private static readonly canadaProvinces;
        private static _brazilProvinces;
        private static readonly brazilProvinces;
        /**
         *  Gets ISO3166-1 Alpha2 code based on country name. Returns null, if country is not recognized.
         */
        static getIsoAlpha2FromName(name: string, mapId?: string): string;
        /**
         *  Gets ISO3166-1 Alpha3 code based on country name. Returns null, if country is not recognized.
         */
        static getIsoAlpha3FromName(name: string, mapId?: string): string;
        /**
         *  Gets ISO3166-1 Country based on its alpha3 code. Returns null, if country is not recognized.
         */
        static getCountryFromName(name: string, mapId?: string): StiIsoCountry;
        private static getCountries;
        private static isEqual;
        /**
         *  Gets ISO3166-1 Country based on its alpha3 code.
         */
        static getCountryFromAlpha3(alpha3: string, mapId?: string): StiIsoCountry;
        /**
         *  Obtain ISO3166-1 Country based on its alpha2 code.
         */
        static getCountryFromAlpha2(alpha2: string, mapId?: string): StiIsoCountry;
        private static initializeCountries;
        private static initializeUsStates;
        private static initializeCanadaProvinces;
        private static initializeBrazilProvinces;
    }
}
declare module Stimulsoft.Report.Maps.Helpers {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    class StiGssMapHelper {
        private static hash;
        static allowGss(id: StiMapID): boolean;
        static get(id: StiMapID): Dictionary<string, string>;
        static init(id: StiMapID): void;
        static isGssValue(value: string): boolean;
        private static add;
        private static initUKCountries;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import IStiMapKeyHelper = Stimulsoft.Base.Map.IStiMapKeyHelper;
    class StiMapKeyHelper implements IStiMapKeyHelper {
        getNameFromIsoAlpha2(alpha2: string, mapId?: string): string;
        getNameFromIsoAlpha3(alpha3: string, mapId?: string): string;
        normalizeName(name: string, mapId?: string): string;
        getIsoAlpha2FromName(name: string, mapId?: string): string;
        getIsoAlpha3FromName(name: string, mapId?: string): string;
        convertMapKeysToIsoAlpha2(mapKeys: List<string>, mapId: string): List<string>;
        getMapKeysFromNames(values: List<any>, mapId: string): List<string>;
        private getMapKeyFromName;
        static simplify(key: string): string;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsContainer {
        name: string;
        width: number;
        height: number;
        geoms: StiMapGeomsObject[];
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    class StiMapGeomsObject {
        name: string;
        geoms: StiMapGeom[];
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMapGeom {
        readonly geomType: StiMapGeomType;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiMoveToMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLineMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        x: number;
        y: number;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBezierMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        x3: number;
        y3: number;
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiBeziersMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
        array: number[];
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    class StiCloseMapGeom extends StiMapGeom {
        readonly geomType: StiMapGeomType;
    }
}
declare namespace Stimulsoft.Base.Maps.Geoms {
    import Point = Stimulsoft.System.Drawing.Point;
    import List = Stimulsoft.System.Collections.List;
    class StiMapGeomCollection extends List<StiMapGeom> {
        getLastPoint(): Point;
    }
}
declare module Stimulsoft.Report.Maps {
    import StiMapGeom = Stimulsoft.Base.Maps.Geoms.StiMapGeom;
    import StiMapGeomsContainer = Stimulsoft.Base.Maps.Geoms.StiMapGeomsContainer;
    class StiMapLoader {
        private static hashMaps;
        static loadResource(resourceName: string): StiMapSvgContainer;
        static getGeomsObject(resourceName: string): StiMapGeomsContainer;
        private static createGeom;
        static parsePath(text: string): StiMapGeom[];
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import StiMapSvg = Stimulsoft.Report.Maps.StiMapSvg;
    class StiMapResourceHelper {
        static getSvgBlockFromIsoAlpha2(alpha2: string, mapId?: string): StiMapSvg;
        static getSvgBlockFromName(name: string, mapId?: string): StiMapSvg;
        static getIsoAlpha2FromName(name: string, mapId?: string): string;
        static getIsoAlpha3FromName(name: string, mapId?: string): string;
        private static getResource;
        private static decodeAlpha;
    }
}
declare namespace Stimulsoft.Report.Helpers {
    import RegionInfo = Stimulsoft.System.Globalization.RegionInfo;
    class StiRegionInfoHelper {
        static getIsoAlpha2FromName(name: string): string;
        static getIsoAlpha3FromName(name: string): string;
        static getNameFromIsoAlpha2(alpha2: string): string;
        static getNameFromIsoAlpha3(alpha3: string): string;
        static getLocalizedNameFromIsoAlpha2(alpha2: string): string;
        static getLocalizedNameFromIsoAlpha3(alpha3: string): string;
        static getRegionInfoFromName(name: string): RegionInfo;
        private static getAllRegions;
    }
}
declare module Stimulsoft.Report.Helpers {
    import DataSet = Stimulsoft.System.Data.DataSet;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceArrayToDataSet {
        static get(resourceType: StiResourceType, array: number[], report?: StiReport, pathData?: string): DataSet;
    }
}
declare module Stimulsoft.Report.Helpers {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourceTypeHelper {
        static getTypeFromExtension(extension: string): StiResourceType;
        static isImageType(ext: string): boolean;
        static isTextType(ext: string): boolean;
        private static isExtensionType;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiCustomValueBase: string;
    interface IStiCustomValueBase {
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    var IStiGauge: string;
    interface IStiGauge extends IStiComponent {
        scales: any;
        drawGauge(context: StiGaugeContextPainter): any;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): any;
        customStyleName: string;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiGaugeElement: string;
    interface IStiGaugeElement {
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    var IStiGaugeStyle: string;
    interface IStiGaugeStyle extends ICloneable, IStiJsonReportObject {
        core: IStiGaugeStyleCoreXF;
        createNew(): IStiGaugeStyle;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
    }
}
declare module Stimulsoft.Report.Gauge {
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    var IStiGaugeStyleCoreXF: string;
    interface IStiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiBrush;
        borderColor: Color;
        borderWidth: number;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
        markerSkin: StiMarkerSkin;
        markerBrush: StiBrush;
        markerBorderBrush: StiBrush;
        markerBorderWidth: number;
        styleId: StiGaugeStyleId;
        gauge: IStiGauge;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiIndicatorRangeInfo: string;
    interface IStiIndicatorRangeInfo {
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiRangeBase: string;
    interface IStiRangeBase {
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    var IStiScaleBase: string;
    interface IStiScaleBase {
        prepare(gauge: IStiGauge): any;
    }
}
declare module Stimulsoft.Report.Gauge {
    enum StiGaugeRangeMode {
        Percentage = 1,
        Value = 2
    }
    enum StiGaugeRangeType {
        None = 0,
        Color = 1
    }
    enum StiGaugeCalculationMode {
        Auto = 1,
        Custom = 2
    }
    enum StiGaugeType {
        FullCircular = 0,
        HalfCircular = 1,
        Linear = 2
    }
    enum StiPlacement {
        Outside = 0,
        Overlay = 1,
        Inside = 2
    }
    enum StiGaugeElemenType {
        LinearElement = 0,
        RadialElement = 1,
        All = 2
    }
    enum StiBarRangeListType {
        LinearBar = 0,
        RadialBar = 1
    }
    enum StiLinearRangeColorMode {
        Default = 0,
        MixedColor = 1
    }
    enum StiRadialScaleSkin {
        Default = 0,
        Empty = 1,
        RadialScaleQuarterCircleNW = 2,
        RadialScaleQuarterCircleNE = 3,
        RadialScaleQuarterCircleSW = 4,
        RadialScaleQuarterCircleSE = 5,
        RadialScaleHalfCircleN = 6,
        RadialScaleHalfCircleS = 7
    }
    enum StiMarkerSkin {
        Diamond = 0,
        Rectangle = 1,
        TriangleTop = 2,
        TriangleBottom = 3,
        PentagonTop = 4,
        PentagonBottom = 5,
        Ellipse = 6,
        RectangularCalloutTop = 7,
        RectangularCalloutBottom = 8,
        TriangleLeft = 9,
        TriangleRight = 10,
        PentagonLeft = 11,
        PentagonRight = 12,
        RectangularCalloutLeft = 13
    }
    enum StiStateSkin {
        Ellipse = 0,
        Rectangle = 1,
        Diamond = 2
    }
    enum StiLinearBarSkin {
        Default = 0,
        HorizontalThermometer = 1,
        VerticalThermometer = 2
    }
    enum StiNeedleSkin {
        DefaultNeedle = 0,
        SpeedometerNeedle = 1,
        SpeedometerNeedle2 = 2,
        SimpleNeedle = 3
    }
    enum StiTickMarkSkin {
        Rectangle = 0,
        Ellipse = 1,
        Diamond = 2,
        TriangleTop = 3,
        TriangleRight = 4,
        TriangleLeft = 5,
        TriangleBottom = 6
    }
    enum StiRadiusMode {
        Auto = 0,
        Width = 1,
        Height = 2
    }
    enum StiRadialPosition {
        TopLeft = 0,
        TopRight = 1,
        BottonLeft = 2,
        BottomRight = 3,
        TopCenter = 4,
        LeftCenter = 5,
        BottomCenter = 6,
        RightCenter = 7
    }
    enum StiLabelRotationMode {
        None = 0,
        Automatic = 1,
        SurroundIn = 2,
        SurroundOut = 3
    }
    enum StiGaugeStyleId {
        StiStyle25 = 0,
        StiStyle26 = 1,
        StiStyle27 = 2,
        StiStyle28 = 3,
        StiStyle29 = 4,
        StiStyle30 = 5
    }
}
declare module Stimulsoft.Report.Maps {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiMapSvgContainer {
        name: string;
        width: number;
        height: number;
        textScale: number;
        paths: StiMapSvg[];
        hashPaths: Hashtable;
        prepare(): void;
    }
}
declare module Stimulsoft.Report.Maps {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMap21StyleFX extends StiMapStyleFX {
        readonly styleId: StiMapStyleIdent;
        readonly localizeName: string;
        individualColor: Color;
        colors: Color[];
        heatmapColors: Color[];
        defaultColor: Color;
        backColor: Color;
    }
}
declare module Stimulsoft.Report.Painters {
    import Type = Stimulsoft.System.Type;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiPainter {
        private static typePainter;
        static getPainter(componentType: Type): StiPainter;
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
        paint(component: Stimulsoft.Report.Components.StiComponent, g: Stimulsoft.System.Drawing.Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiComponentPainter extends StiPainter {
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawBorderSides: boolean): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiContainerPainter extends StiComponentPainter {
        paintComponents(container: StiContainer, g: Graphics): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiViewPainter extends StiComponentPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
declare module Stimulsoft.Report.Painters {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImagePainter extends StiViewPainter {
        getImage(component: Stimulsoft.Report.Components.StiComponent, REFzoom: any, format: StiExportFormat): Image;
    }
}
declare module Stimulsoft.Report.Painters {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiPagePainter extends StiContainerPainter implements IStiPagePainter {
        implements(): string[];
        paint(comp: StiComponent, g: Graphics): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextinCellsPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
    }
}
declare module Stimulsoft.Report.Painters {
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiText = Stimulsoft.Report.Components.StiText;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTextPainter extends StiComponentPainter {
        paintText(textComp: StiText, g: Graphics, rect: RectangleD): void;
        paintBackground(text: StiText, g: Graphics, rect: RectangleD): void;
        paintBorder(component: StiComponent, g: Graphics, rect: RectangleD, zoom: number, drawBorderFormatting: boolean, drawTopmostBorderSides: boolean): void;
        paint(component: StiComponent, g: Graphics): void;
    }
}
declare module Stimulsoft.Base.Context.Animation {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiPointAnimation extends StiAnimation {
        constructor(pointFrom: Point, duration: TimeSpan, beginTime: TimeSpan);
        pointFrom: Point;
        readonly type: StiAnimationType;
    }
}
declare module Stimulsoft.Base.Context {
    enum StiGeomType {
        None = 0,
        Border = 1,
        CachedShadow = 2,
        Curve = 3,
        Ellipse = 4,
        Font = 5,
        Line = 6,
        Lines = 7,
        Path = 8,
        Pen = 9,
        PopSmothingMode = 10,
        PopTextRenderingHint = 11,
        PopTransform = 12,
        PopClip = 13,
        PushClip = 14,
        PushRotateTransform = 15,
        PushSmothingMode = 16,
        PushSmothingModeToAntiAlias = 17,
        PushTextRenderingHint = 18,
        PushTextRenderingHintToAntiAlias = 19,
        PushTranslateTransform = 20,
        Segment = 21,
        Shadow = 22,
        Text = 23,
        StringFormat = 24,
        AnimationBar = 25,
        AnimationBorder = 26,
        AnimationColumn = 27,
        AnimationEllipse = 28,
        AnimationPath = 29,
        AnimationPathElement = 30,
        AnimationLines = 31,
        AnimationCurve = 32,
        AnimationLabel = 33,
        AnimationShadow = 34
    }
    enum StiPenAlignment {
        Center = 0,
        Inset = 1,
        Outset = 2,
        Left = 3,
        Right = 4
    }
    enum StiPenLineCap {
        Flat = 0,
        Square = 1,
        Round = 2,
        Triangle = 3,
        NoAnchor = 4,
        SquareAnchor = 5,
        RoundAnchor = 6,
        DiamondAnchor = 7,
        ArrowAnchor = 8
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import GraphicsUnit = Stimulsoft.System.Drawing.GraphicsUnit;
    import FontStyle = Stimulsoft.System.Drawing.FontStyle;
    class StiFontGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        static changeFontSize(font: Font, newFontSize: number): StiFontGeom;
        fontName: string;
        fontSize: number;
        fontStyle: FontStyle;
        unit: GraphicsUnit;
        readonly type: StiGeomType;
        static create(font: Font): StiFontGeom;
        constructor(fontName: string, fontSize: number, style: FontStyle, unit: GraphicsUnit);
    }
}
declare module Stimulsoft.Base.Context {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import HotkeyPrefix = Stimulsoft.System.Drawing.Text.HotkeyPrefix;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
    import StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
    class StiStringFormatGeom extends StiGeom implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        isGeneric: boolean;
        alignment: StringAlignment;
        formatFlags: StringFormatFlags;
        hotkeyPrefix: HotkeyPrefix;
        lineAlignment: StringAlignment;
        trimming: StringTrimming;
        readonly type: StiGeomType;
        constructor(sf: StringFormat);
    }
}
declare module Stimulsoft.Base.Context {
    class StiContextOptions {
        readonly isPrinting: boolean;
        private _isWpf;
        readonly isWpf: boolean;
        private _isGdi;
        readonly isGdi: boolean;
        private _zoom;
        readonly zoom: number;
        constructor(isGdi: boolean, isWpf: boolean, isPrinting: boolean, zoom: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    class StiGraphicsPathCloseFigureGaugeGeom extends StiGaugeGeom {
        readonly type: StiGaugeGeomType;
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGraphicsPathGaugeGeom extends StiGaugeGeom {
        readonly rect: Rectangle;
        readonly background: StiBrush;
        readonly borderBrush: StiBrush;
        readonly borderWidth: number;
        readonly startPoint: Point;
        readonly type: StiGaugeGeomType;
        private _geoms;
        readonly geoms: StiGaugeGeom[];
        addGraphicsPathArcGaugeGeom(x: number, y: number, width: number, height: number, startAngle: number, sweepAngle: number): void;
        addGraphicsPathCloseFigureGaugeGeom(): void;
        addGraphicsPathLinesGaugeGeom(points: Point[]): void;
        addGraphicsPathLineGaugeGeom(p1: Point, p2: Point): void;
        constructor(rect: Rectangle, startPoint: Point, background: StiBrush, borderBrush: StiBrush, borderWidth: number);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLineGaugeGeom extends StiGaugeGeom {
        readonly p1: Point;
        readonly p2: Point;
        readonly type: StiGaugeGeomType;
        constructor(p1: Point, p2: Point);
    }
}
declare module Stimulsoft.Report.Gauge.GaugeGeoms {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGraphicsPathLinesGaugeGeom extends StiGaugeGeom {
        readonly points: Point[];
        readonly type: StiGaugeGeomType;
        constructor(points: Point[]);
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    var IStiGaugeMarker: string;
    interface IStiGaugeMarker {
        showValue: boolean;
        textBrush: StiBrush;
        font: Font;
        format: string;
    }
}
declare module Stimulsoft.Base.Maps.Geoms {
    enum StiMapGeomType {
        MoveTo = 0,
        Line = 1,
        Bezier = 2,
        Beziers = 3,
        Close = 4
    }
}
declare module Stimulsoft.Report.Painters {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Image = Stimulsoft.System.Drawing.Image;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    var IStiBarCodePainter: string;
    interface IStiBarCodePainter {
        baseTransform(context: any, x: number, y: number, angle: number, dx: number, dy: number): any;
        baseRollbackTransform(context: any): any;
        baseFillRectangle(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillRectangle2D(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseFillPolygon(context: any, brush: StiBrush, points: PointD[]): any;
        baseFillEllipse(context: any, brush: StiBrush, x: number, y: number, width: number, height: number): any;
        baseDrawRectangle(context: any, penColor: Color, penSize: number, x: number, y: number, width: number, height: number): any;
        baseDrawImage(context: any, image: Image, report: StiReport, x: number, y: number, width: number, height: number): any;
        baseDrawString(context: any, st: string, font: Font, brush: StiBrush, rect: RectangleD, sf: StringFormat): any;
        baseMeasureString(context: any, st: string, font: Font): SizeD;
    }
}
declare module Stimulsoft.Report.Painters {
    var IStiPagePainter: string;
    interface IStiPagePainter {
    }
}
declare module Stimulsoft.Report.Painters {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SolidBrush = Stimulsoft.System.Drawing.SolidBrush;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import Brush = Stimulsoft.System.Drawing.Brush;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMapStyle = Stimulsoft.Report.Styles.StiMapStyle;
    import List = Stimulsoft.System.Collections.List;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiStyleColorsContainer {
        private stackColors;
        private index;
        private painter;
        getColor(): Brush;
        getColor1(): StiSolidBrush;
        init(map: StiMap, painter: StiGdiMapContextPainter): void;
    }
    class HeatmapInfo {
        private painter;
        private min;
        private max;
        private colors;
        getBrush(data: StiMapData): Brush;
        getBrush1(data: StiMapData): StiBrush;
        constructor(painter: StiGdiMapContextPainter, map: StiMap, mapData: StiMapData[]);
    }
    class HeatmapWithGroupInfo {
        private painter;
        private hash;
        private hashColors;
        getBrush(data: StiMapData): Brush;
        getBrush1(data: StiMapData): Brush;
        constructor(painter: StiGdiMapContextPainter, map: StiMap, mapData: StiMapData[]);
    }
    class NoneInfo {
        constructor();
        private colors;
        private index;
        getBrush(): StiSolidBrush;
    }
    class StiGdiMapContextPainter {
        individualStep: number;
        map: StiMap;
        defaultBrush: SolidBrush;
        defaultBrush1: StiSolidBrush;
        heatmapInfo: HeatmapInfo;
        heatmapWithGroupInfo: HeatmapWithGroupInfo;
        noneInfo: NoneInfo;
        hashGroup: any;
        colorsContainer: StiStyleColorsContainer;
        private _mapData;
        mapData: List<StiMapData>;
        private _mapStyle;
        mapStyle: StiMapStyle;
        private _dataTable;
        dataTable: StiDataTable;
        getValues(meter: IStiMeter): List<any>;
        prepareDataColumns(): void;
        getGeomBrush(data: StiMapData): Brush;
        updateHeatmapWithGroup(): void;
        updateGroupedData(): void;
        private fillGroupColors;
        parseHexColor(color: string): Brush;
        constructor(map: StiMap);
    }
}
declare module Stimulsoft.Base.Context {
    class StiInteractionDataGeom {
        componentName: String;
        pageGuid: String;
        componentIndex: String;
        pageIndex: String;
        elementIndex: String;
        seriesInteractionData: Stimulsoft.Report.Chart.IStiSeriesInteractionData;
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionElement {
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentNameElement extends StiStyleConditionElement {
        private _operationComponentName;
        /** Gets or sets type of operation which will be used for comparison of component names. */
        operationComponentName: StiStyleConditionOperation;
        private _componentName;
        /** Gets or sets component name or part of component name. */
        componentName: string;
        constructor(componentName: string, operationComponentName?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionComponentTypeElement extends StiStyleConditionElement {
        private _componentType;
        /** Gets or sets component type which can be detected by style condition. */
        componentType: StiStyleComponentType;
        private _operationComponentType;
        /** Gets or sets type of operation which will be used for comparison of component types. */
        operationComponentType: StiStyleConditionOperation;
        constructor(componentType: StiStyleComponentType, operationComponentType?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionLocationElement extends StiStyleConditionElement {
        private _operationLocation;
        /** Gets or sets type of operation which will be used for comparison of component locations. */
        operationLocation: StiStyleConditionOperation;
        private _location;
        /** Gets or sets variant of component location on parent component area. */
        location: StiStyleLocation;
        constructor(location: StiStyleLocation, operationLocation?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementElement extends StiStyleConditionElement {
        private _placement;
        /** Gets or sets type of bands on which component can be placed. */
        placement: StiStyleComponentPlacement;
        private _operationPlacement;
        /** Gets or sets type of operation which will be used for comparison of component placements. */
        operationPlacement: StiStyleConditionOperation;
        constructor(placement: StiStyleComponentPlacement, operationPlacement?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions.Elements {
    class StiStyleConditionPlacementNestedLevelElement extends StiStyleConditionElement {
        private _placementNestedLevel;
        /** Gets or sets value which indicates nested level of specified component. */
        placementNestedLevel: number;
        private _operationPlacementNestedLevel;
        /** Gets or sets type of operation which will be used for comparison of component nested level. */
        operationPlacementNestedLevel: StiStyleConditionOperation;
        constructor(placementNestedLevel: number, operationPlacementNestedLevel?: StiStyleConditionOperation);
    }
}
declare module Stimulsoft.Report.Styles.Conditions {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStyleConditionElement = Stimulsoft.Report.Styles.Conditions.Elements.StiStyleConditionElement;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyleCondition implements ICloneable, IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStyleCondition;
        private _type;
        /** Gets or sets type of this style condition. */
        type: StiStyleConditionType;
        private _operationPlacement;
        /** Gets or sets type of operation which will be used for comparison of component placements. */
        operationPlacement: StiStyleConditionOperation;
        private _operationPlacementNestedLevel;
        /** Gets or sets type of operation which will be used for comparison of component nested level. */
        operationPlacementNestedLevel: StiStyleConditionOperation;
        private _operationComponentType;
        /** Gets or sets type of operation which will be used for comparison of component types. */
        operationComponentType: StiStyleConditionOperation;
        private _operationLocation;
        /** Gets or sets type of operation which will be used for comparison of component locations. */
        operationLocation: StiStyleConditionOperation;
        private _operationComponentName;
        /** Gets or sets type of operation which will be used for comparison of component names. */
        operationComponentName: StiStyleConditionOperation;
        private _placement;
        /** Gets or sets type of bands on which component can be placed. */
        placement: StiStyleComponentPlacement;
        private _placementNestedLevel;
        /** Gets or sets value which indicates nested level of specified component. */
        placementNestedLevel: number;
        private _componentType;
        /** Gets or sets component type which can be detected by style condition. */
        componentType: StiStyleComponentType;
        private _location;
        /** Gets or sets variant of component location on parent component area. */
        location: StiStyleLocation;
        private _componentName;
        /** Gets or sets component name or part of component name. */
        componentName: string;
        fromElements(elements: StiStyleConditionElement[]): void;
        constructor();
        constructor(type: StiStyleConditionElement[]);
        constructor(type: StiStyleConditionType, operationPlacement: StiStyleConditionOperation, operationPlacementNestedLevel: StiStyleConditionOperation, operationComponentType: StiStyleConditionOperation, operationLocation: StiStyleConditionOperation, operationComponentName: StiStyleConditionOperation, placement: StiStyleComponentPlacement, placementNestedLevel: number, componentType: StiStyleComponentType, location: StiStyleLocation, componentName: string);
    }
}
declare module Stimulsoft.Report.Styles {
    /** Enum provide types of style condition. */
    enum StiStyleConditionType {
        ComponentType = 1,
        Placement = 2,
        PlacementNestedLevel = 4,
        ComponentName = 8,
        Location = 16
    }
    /** Enum provide type of bands on which component can be placed. */
    enum StiStyleComponentPlacement {
        None = 0,
        ReportTitle = 1,
        ReportSummary = 2,
        PageHeader = 4,
        PageFooter = 8,
        GroupHeader = 16,
        GroupFooter = 32,
        Header = 64,
        Footer = 128,
        ColumnHeader = 256,
        ColumnFooter = 512,
        Data = 1024,
        DataEvenStyle = 2048,
        DataOddStyle = 4096,
        Table = 8192,
        Hierarchical = 16384,
        Child = 32768,
        Empty = 65536,
        Overlay = 131072,
        Panel = 262144,
        Page = 524288,
        AllExeptStyles = 1042431
    }
    /** Enum provide component type which can be detected by style condition. */
    enum StiStyleComponentType {
        Text = 1,
        Primitive = 2,
        Image = 4,
        CrossTab = 8,
        Chart = 16,
        CheckBox = 32
    }
    /** Enum provide all variants of location component on parent component area. */
    enum StiStyleLocation {
        None = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 4,
        MiddleLeft = 8,
        MiddleCenter = 16,
        MiddleRight = 32,
        BottomLeft = 64,
        BottomCenter = 128,
        BottomRight = 256,
        Left = 512,
        Right = 1024,
        Top = 2048,
        Bottom = 4096,
        CenterHorizontal = 8192,
        CenterVertical = 16384
    }
    enum StiStyleConditionOperation {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Containing = 6,
        NotContaining = 7,
        BeginningWith = 8,
        EndingWith = 9
    }
}
declare module Stimulsoft.Report {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiStyleConditionHelper {
        static isAllowStyle(component: StiComponent, style: StiBaseStyle): boolean;
    }
}
declare module Stimulsoft.Report.Styles {
    var IStiBaseStyle: string;
    interface IStiBaseStyle {
        name: string;
    }
}
declare module Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGaugeStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        brush: StiBrush;
        borderColor: Color;
        borderWidth: number;
        foreColor: Color;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        /**
         *  Gets a style from the component.
         *  @param component Component.
         */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /**
         *  Sets style to a component.
         *  @param component Component
         */
        setStyleToComponent(component: StiComponent): void;
        /**
         *  Creates a new object of the type StiGaugeStyle.
         *  @param name Style name.
         *  @param description Style description.
         */
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    /**
     *  Describes the class that contains a style for Indicator components.
     */
    class StiIndicatorStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        backColor: Color;
        glyphColor: Color;
        foreColor: Color;
        hotBackColor: Color;
        hotForeColor: Color;
        positiveColor: Color;
        negativeColor: Color;
        /**
         *  Gets a style from the component.
         *  @param component Component.
         */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /**
         *  Sets style to a component.
         *  @param component Component.
         */
        setStyleToComponent(component: StiComponent): void;
        /**
         *  Creates a new object of the type StiIndicatorStyle.
         *  @param name Style name.
         *  @param description Style description.
         */
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare namespace Stimulsoft.Report {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    /**
     *  Describes the class that contains a style for Progress components.
     */
    class StiProgressStyle extends StiBaseStyle {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        trackColor: Color;
        bandColor: Color;
        seriesColors: Color[];
        foreColor: Color;
        backColor: Color;
        /**
         *  Gets a style from the component.
         *  @param component Component.
         */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        /**
         *  Sets style to a component.
         *  @param component Component.
         */
        setStyleToComponent(component: StiComponent): void;
        /**
         *  Creates a new object of the type StiProgressStyle.
         *  @param name Style name.
         *  @param description Style description.
         */
        constructor(name?: string, description?: string, report?: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStyle extends StiBaseStyle implements IStiJsonReportObject, IStiTextFormat {
        private static ImplementsStiStyle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): Object;
        private _horAlignment;
        /** Gets or sets a horizontal alignment of the style. */
        horAlignment: StiTextHorAlignment;
        private _vertAlignment;
        /** Gets or sets a vertical alignment of the style. */
        vertAlignment: StiVertAlignment;
        private _font;
        /** Gets or sets a font for drawing this style. */
        font: Font;
        private _border;
        /** Gets or sets a border of the component. */
        border: StiBorder;
        private _brush;
        /** Gets or sets a brush to fill the style. */
        brush: StiBrush;
        private _textBrush;
        /** Gets or sets a brush to draw the text. */
        textBrush: StiBrush;
        /**
         *  Gets or sets the format of the component.
         */
        textFormat: StiFormatService;
        private _allowUseHorAlignment;
        /** Gets or sets a value which indicates whether a report engine can use HorAlignment formatting or not. */
        allowUseHorAlignment: boolean;
        private _allowUseVertAlignment;
        /** Gets or sets a value which indicates whether a report engine can use VertAlignment formatting or not. */
        allowUseVertAlignment: boolean;
        private _allowUseImage;
        /** Gets or sets a value which indicates whether a report engine can use Image formatting or not. */
        allowUseImage: boolean;
        private _allowUseFont;
        /** Gets or sets a value which indicates whether a report engine can use Font formatting or not. */
        allowUseFont: boolean;
        /** Gets or sets a value which indicates whether a report engine can use Border formatting or not. */
        allowUseBorder: boolean;
        private _allowUseBorderFormatting;
        /** Gets or sets a value which indicates whether a report engine can use Border formatting or not. */
        allowUseBorderFormatting: boolean;
        private _allowUseBorderSides;
        /** Gets or sets a value which indicates whether a report engine can use Border Sides or not. */
        allowUseBorderSides: boolean;
        private _allowUseBorderSidesFromLocation;
        /** Gets or sets a value which indicates whether a report engine can set border sides of a component depending on the component location. */
        allowUseBorderSidesFromLocation: boolean;
        private _allowUseBrush;
        /** Gets or sets a value which indicates whether a report engine can use Brush formatting or not. */
        allowUseBrush: boolean;
        private _allowUseTextBrush;
        /** Gets or sets a value which indicates whether a report engine can use TextBrush formatting or not. */
        allowUseTextBrush: boolean;
        allowUseNegativeTextBrush: boolean;
        allowUseTextFormat: boolean;
        private _allowUseTextOptions;
        /** Gets or sets a value which indicates whether a report engine can use TextOptions formatting or not. */
        allowUseTextOptions: boolean;
        /** Gets a style from the component. */
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements, componentStyle?: StiBaseStyle): void;
        /** Sets style to a component. */
        setStyleToComponent(component: StiComponent): void;
        private _image;
        /** Gets or sets an image to fill the Image property of the Image component. */
        image: Image;
        /**
         *  Gets or sets a brush to draw the negative values.
         */
        negativeTextBrush: StiBrush;
    }
}
declare module Stimulsoft.Report.Styles {
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import IStiCustomStyle = Stimulsoft.Report.Chart.IStiCustomStyle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiStylesCollection extends CollectionBase<StiBaseStyle> implements IStiJsonReportObject {
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        add(style: StiBaseStyle): void;
        /** Removes all objects from the CollectionBase instance. */
        clear(): void;
        addRange(styles: StiBaseStyle[]): any;
        addRange(styles: StiStylesCollection): any;
        contains(style: StiBaseStyle): boolean;
        contains(styleName: string): boolean;
        indexOf(style: StiBaseStyle): number;
        insert(index: number, style: StiBaseStyle): void;
        remove(style: StiBaseStyle): void;
        getByIndex(index: number): StiBaseStyle;
        setByIndex(index: number, style: StiBaseStyle): void;
        getByName(name: string): StiBaseStyle;
        setByName(name: string, value: StiBaseStyle): void;
        private updateHash;
        toList(): StiBaseStyle[];
        getCustomChartStyle(customStyleName: string): IStiCustomStyle;
        getCustomGaugeStyle(customStyleName: string): IStiGaugeStyle;
        private report;
        private hash;
        private needUpdateHash;
        private lastCount;
        constructor(report?: StiReport);
    }
}
declare module Stimulsoft.Report {
    import StiNestedFactor = Stimulsoft.Report.StiNestedFactor;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStylesCreator {
        private report;
        private _showReportTitles;
        showReportTitles: boolean;
        private _showReportSummaries;
        showReportSummaries: boolean;
        private _showPageHeaders;
        showPageHeaders: boolean;
        private _showPageFooters;
        showPageFooters: boolean;
        private _showGroupHeaders;
        showGroupHeaders: boolean;
        private _showGroupFooters;
        showGroupFooters: boolean;
        private _showHeaders;
        showHeaders: boolean;
        private _showDatas;
        showDatas: boolean;
        private _showFooters;
        showFooters: boolean;
        private _showBorders;
        showBorders: boolean;
        private readonly colorFactor;
        private _maxNestedLevel;
        maxNestedLevel: number;
        private _nestedFactor;
        nestedFactor: StiNestedFactor;
        createStyles(collectionName: string, baseColor: Color): StiBaseStyle[];
        private createStyles1;
        private createStyles2;
        private createStyle;
        private getStyleName;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report.Styles {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
    /** This class contains method which helps convert component location to its border sides. */
    class StiStylesHelper {
        static getBorderSidesFromLocation(component: StiComponent): StiBorderSides;
        static changeComponentStyleName(comp: StiComponent, oldName: string, newName: string): void;
        private static changeDataBandStyleName;
        private static changeElementStyleName;
        private static changeChartStyleName;
        private static changeGaugeStyleName;
    }
}
declare module Stimulsoft.Report.Units {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiInchesUnit extends StiUnit {
        readonly rulerStep: number;
        readonly factor: number;
        readonly shortName: string;
        readonly name: string;
        convertToHInches(rect: RectangleD): RectangleD;
        convertToHInches(size: SizeD): SizeD;
        convertToHInches(value: number): number;
        convertFromHInches(rect: RectangleD): RectangleD;
        convertFromHInches(size: SizeD): SizeD;
        convertFromHInches(value: number): number;
    }
}
declare module Stimulsoft.Report.Viewer {
    enum StiPreviewSettings {
        All = 268435455,
        None = 0,
        Default = 268435455,
        PageViewMode = 1,
        VertScrollBar = 2,
        HorScrollBar = 4,
        StatusBar = 8,
        Print = 16,
        Open = 32,
        Save = 64,
        Parameters = 128,
        SendEMail = 256,
        PageNew = 512,
        PageDelete = 1024,
        PageDesign = 2048,
        PageSize = 4096,
        Resources = 8192,
        Editor = 65536,
        Find = 131072,
        Zoom = 262144,
        PageControl = 524288,
        Bookmarks = 1048576,
        Thumbs = 2097152,
        ContextMenu = 4194304,
        Close = 8388608,
        Toolbar = 16777216
    }
}
declare module Stimulsoft.Report {
    var IStiIgnoryStyle: string;
    interface IStiIgnoryStyle {
    }
}
declare module Stimulsoft.Report {
    var IStiInherited: string;
    interface IStiInherited {
        inherited: boolean;
    }
}
declare module Stimulsoft.Report {
    var IStiName: string;
    interface IStiName {
        name: string;
    }
}
declare module Stimulsoft.Report {
    var IStiStateSaveRestore: string;
    interface IStiStateSaveRestore {
        saveState(stateName: string): any;
        restoreState(stateName: string): any;
        clearAllStates(): any;
    }
}
declare module Stimulsoft.Report {
    class StiCells {
        clear(): void;
        private getRow;
        private rows;
        gett(x: number, y: number): number;
        distX: number;
        distY: number;
        setCell(x: number, y: number, value: number): void;
        private report;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report {
    import StiConditionsCollection = Stimulsoft.Report.Components.StiConditionsCollection;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiConditionsHelper {
        static getConditions(comps: StiComponentsCollection, REFglobalConditions?: any): StiConditionsCollection;
        static setConditions(comps: StiComponentsCollection, conditions: StiConditionsCollection, globalConditions: Hashtable): void;
        private static setConditionAllComponents;
    }
}
declare module Stimulsoft.Report {
    class StiDpiHelper {
        private static LOGPIXELSX;
        private static LOGPIXELSY;
        private static _deviceCapsDpi;
        private static _graphicsDpi;
        private static _graphicsRichTextDpi;
        static readonly deviceCapsDpi: number;
        static readonly graphicsDpi: number;
        static readonly graphicsRichTextDpi: number;
        private static getDpi;
        private static getRegistryValue;
        static readonly deviceCapsScale: number;
        static readonly graphicsScale: number;
        static readonly graphicsRichTextScale: number;
        static readonly needDeviceCapsScale: boolean;
        static readonly needGraphicsScale: boolean;
        static readonly needGraphicsRichTextScale: boolean;
    }
}
declare module Stimulsoft.Report {
    class StiEditableItem {
        private _pageIndex;
        pageIndex: number;
        private _position;
        position: number;
        private _componentName;
        componentName: string;
        private _textValue;
        textValue: string;
        constructor(pageIndex: number, position: number, componentName: string, textValue: string);
    }
    class StiEditableItemsContainer {
        private _items;
        readonly items: Array<any>;
    }
}
declare module Stimulsoft.Report {
    import Image = Stimulsoft.System.Drawing.Image;
    class StiImageCache {
        imageStore: Array<Image>;
        imagePackedStore: Array<number[]>;
        imageMaskStore: Array<number[]>;
        imageIndex: Array<number>;
        imageFormatStore: Array<ImageFormat>;
        private imageHashTable;
        private _useImageComparer;
        private _useImageCompression;
        private _useImageTransparency;
        private _imageSaveFormat;
        private _imageQuality;
        private static crcSeed;
        private static crcTable;
        clear(): void;
        addImageIntRaw(image: Image, imageFormat: Stimulsoft.System.Drawing.Imaging.ImageFormat): number;
        addImageInt(image: Image, imageFormat?: ImageFormat): number;
        constructor(useImageComparer: boolean, useImageCompression?: boolean, imageFormat?: ImageFormat, imageQuality?: number, useImageTransparency?: boolean);
    }
}
declare module Stimulsoft.Report {
    import CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
    class StiNullGlobalizationManager implements IStiGlobalizationManager {
        private _culture;
        culture: CultureInfo;
        getString(name: string): string;
        getObject(name: string): any;
        constructor();
    }
}
declare module Stimulsoft.Report {
    class StiNullValuesHelper {
        static isNull(report: StiReport, dataColumn: string): boolean;
    }
}
declare module Stimulsoft.Report {
    import IStiAppCell = Stimulsoft.Base.IStiAppCell;
    import IStiApp = Stimulsoft.Base.IStiApp;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    import StiExportService = Stimulsoft.Report.Export.StiExportService;
    import StiExportEventArgs = Stimulsoft.Report.Events.StiExportEventArgs;
    import StiPrintedEvent = Stimulsoft.Report.Events.StiPrintedEvent;
    import StiPrintingEvent = Stimulsoft.Report.Events.StiPrintingEvent;
    import StiExportedEvent = Stimulsoft.Report.Events.StiExportedEvent;
    import StiEndRenderEvent = Stimulsoft.Report.Events.StiEndRenderEvent;
    import StiRenderingEvent = Stimulsoft.Report.Events.StiRenderingEvent;
    import StiBeginRenderEvent = Stimulsoft.Report.Events.StiBeginRenderEvent;
    import StiExportingEvent = Stimulsoft.Report.Events.StiExportingEvent;
    import StiReportCacheProcessingEvent = Stimulsoft.Report.Events.StiReportCacheProcessingEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import StiGetSubReportEventArgs = Stimulsoft.Report.Events.StiGetSubReportEventArgs;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiDialogInfo = Stimulsoft.Report.Dictionary.StiDialogInfo;
    import StiDataCollection = Stimulsoft.Report.Dictionary.StiDataCollection;
    import StiDataSourcesCollection = Stimulsoft.Report.Dictionary.StiDataSourcesCollection;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiPagesCollection = Stimulsoft.Report.Components.StiPagesCollection;
    import IStiUnitConvert = Stimulsoft.Report.Components.IStiUnitConvert;
    import StiEngine = Stimulsoft.Report.Engine.StiEngine;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiBookmark = Stimulsoft.Report.Components.StiBookmark;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    import StiAggregateFunctionService = Stimulsoft.Report.Dictionary.StiAggregateFunctionService;
    import Type = Stimulsoft.System.Type;
    import DateTime = Stimulsoft.System.DateTime;
    import StiBusinessObjectData = Stimulsoft.Report.Dictionary.StiBusinessObjectData;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiMasterComponent = Stimulsoft.Report.Components.IStiMasterComponent;
    import IStiReport = Stimulsoft.Base.IStiReport;
    import List = Stimulsoft.System.Collections.List;
    import IStiReportPage = Stimulsoft.Base.IStiReportPage;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import JsonRelationDirection = Stimulsoft.System.Data.JsonRelationDirection;
    import StiClone = Stimulsoft.Report.Components.StiClone;
    class StiJsonLoaderHelper {
        masterComponents: IStiMasterComponent[];
        clones: StiClone[];
        dialogInfo: StiDialogInfo[];
        barcodeTypes: Stimulsoft.Report.BarCodes.StiBarCodeTypeService[];
        textFormatTypes: string[];
        refNames: string[];
        clean(): void;
    }
    class StiReport implements IStiUnitConvert, IStiReport, IStiApp, IStiAppCell {
        implements(): string[];
        jsonLoaderHelper: StiJsonLoaderHelper;
        private static assignSignature;
        private saveToJsonInternal;
        private loadFromJsonInternal;
        private loadFromXmlInternal;
        private isPackedFile;
        load(str: string): any;
        load(data: number[]): any;
        load(xml: XmlNode): any;
        load(json: Object): any;
        loadFile(filePath: string): void;
        loadPacked(str: string): any;
        loadPacked(data: number[]): any;
        loadPackedFile(filePath: string): void;
        loadEncryptedReport(reportStr: string, key: string): any;
        loadEncryptedReport(data: number[], key: string): any;
        loadEncryptedReportFile(filePath: string, key: string): void;
        loadDocument(str: string): any;
        loadDocument(data: number[]): any;
        loadDocument(obj: Object): any;
        loadDocumentFile(filePath: string): void;
        loadPackedDocument(str: string): any;
        loadPackedDocument(data: number[]): any;
        loadPackedDocumentFile(filePath: string): void;
        loadEncryptedDocument(reportStr: string, key: string): any;
        loadEncryptedDocument(data: number[], key: string): any;
        loadEncryptedDocumentFile(filePath: string, key: string): void;
        saveEncryptedReportToByteArray(key: string): number[];
        saveEncryptedReportToString(key: string): string;
        saveEncryptedReportFile(path: string, key: string): void;
        saveToJsonString(): string;
        saveFile(path: string): void;
        saveDocumentToJsonString(): string;
        saveDocumentFile(path: string): void;
        saveEncryptedDocumentToByteArray(key: string): number[];
        /**
         *  Returns reference to the data dictionary of the report.
         *  @returns Data dictioanary from the report.
         */
        getDictionary(): IStiAppDictionary;
        /**
         *  Returns unique key to this application.
        */
        getKey(): string;
        setKey(key: string): void;
        /**
         *  Returns an enumeration of the pages from this report.
         *  @returns The enumeration of the pages.
         */
        fetchPages(): List<IStiReportPage>;
        private _pageNumber;
        pageNumber: number;
        readonly pageNumberThrough: number;
        _totalPageCountValue: number;
        totalPageCount: number;
        readonly totalPageCountThrough: number;
        readonly pageNofM: string;
        readonly pageNofMThrough: string;
        private _pageNofMLocalizationString;
        pageNofMLocalizationString: string;
        private _line;
        line: number;
        private _groupLine;
        groupLine: number;
        readonly lineRoman: string;
        readonly lineABC: string;
        private _column;
        column: number;
        private _lineThrough;
        lineThrough: number;
        readonly date: DateTime;
        readonly today: DateTime;
        readonly time: DateTime;
        private _cacheAllData;
        cacheAllData: boolean;
        private _retrieveOnlyUsedData;
        retrieveOnlyUsedData: boolean;
        private _reportCacheMode;
        reportCacheMode: StiReportCacheMode;
        readonly isFirstPage: boolean;
        readonly isLastPage: boolean;
        readonly isFirstPageThrough: boolean;
        readonly isLastPageThrough: boolean;
        readonly isFirstPass: boolean;
        readonly isSecondPass: boolean;
        private _currentPage;
        currentPage: number;
        private _currentPrintPage;
        currentPrintPage: number;
        private _pageCopyNumber;
        pageCopyNumber: number;
        private _businessObjectsStore;
        readonly businessObjectsStore: Array<StiBusinessObjectData>;
        private _variables;
        variables: Hashtable;
        getVariable(name: string, onlyVariable?: boolean): any;
        setVariable(name: string, value: Object, onlyVariable?: boolean): void;
        private _aggregateFunctions;
        aggregateFunctions: StiAggregateFunctionService[];
        private _dictionary;
        dictionary: Stimulsoft.Report.Dictionary.StiDictionary;
        readonly dataSources: StiDataSourcesCollection;
        readonly dataStore: StiDataCollection;
        regData(name: string, alias: string, data: any, jsonRelationDirection?: JsonRelationDirection): void;
        regBusinessObject2(category: string, name: string, alias: string, value: Object): void;
        regBusinessObject(businessObjects: StiBusinessObjectData[]): void;
        private storeBusinessObjectWithCheckExistingData;
        private _script;
        script: string;
        scriptNew(): void;
        onBeginProcessData: Function;
        invokeBeginProcessData(args: any, callback: Function): any;
        onEndProcessData: Function;
        invokeEndProcessData(args: any): any;
        events: Hashtable;
        invokeRefreshPreview(): void;
        invokeRefreshViewer(): void;
        invokeClick(sender: Object, e: EventArgs): void;
        invokeDoubleClick(sender: Object, e: EventArgs): void;
        invokeGotoComp(e: StiGotoCompEventArgs): void;
        invokePaint(sender: Object, e: EventArgs): void;
        private static eventBeginRender;
        invokeBeginRender(): void;
        private beginRenderEventScript;
        beginRenderEvent: StiBeginRenderEvent;
        invokeRendering(): void;
        renderingEvent: StiRenderingEvent;
        private static eventEndRender;
        invokeEndRender(): void;
        private endRenderEventScript;
        endRenderEvent: StiEndRenderEvent;
        invokeStatusChanged(): void;
        protected onExporting(e: StiExportEventArgs): void;
        exportingEvent: StiExportingEvent;
        invokeExporting(exportFormat: StiExportFormat): void;
        protected onExported(e: StiExportEventArgs): void;
        exportedEvent: StiExportedEvent;
        invokeExported(exportFormat: StiExportFormat): void;
        protected onPrinting(e: EventArgs): void;
        printingEvent: StiPrintingEvent;
        invokePrinting(): void;
        protected onPrinted(e: EventArgs): void;
        printedEvent: StiPrintedEvent;
        invokePrinted(): void;
        onGetSubReport: Function;
        invokeGetSubReport(args: StiGetSubReportEventArgs): void;
        invokeReportCacheProcessing(): void;
        reportCacheProcessingEvent: StiReportCacheProcessingEvent;
        unit: StiUnit;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        static changeType(value: Object, conversionType: Type, convertNulls?: boolean): Object;
        applyStyleCollection(collectionName: string): void;
        applyStyles(): void;
        getCurrentPage(): StiPage;
        static getReportVersion(): string;
        private updateReportVersion;
        writeToReportRenderingMessages(str: string): void;
        getComponentByName(componentName: string): StiComponent;
        toString2(obj: Object): string;
        checkExcelValue(sender: any, value: Object): Object;
        toString3(sender: any, obj: Object, allowExcelCheck?: boolean): string;
        private generateReportGuid;
        addAnchor(value: any, component?: any): void;
        getAnchorPageNumber(value: any): number;
        getAnchorPageNumberThrough(value: any): number;
        private getAnchor;
        /** Returns a list of all components, including pages in the report. */
        getComponents(): StiComponentsCollection;
        getRenderedComponents(): StiComponentsCollection;
        getComponentsCount(): number;
        /** Renames a style with the specified name to a new name. */
        renameStyle(oldStylename: string, newStyleName: string): void;
        localizeReport(cultureName: string): void;
        private anchors;
        /** The master report for subreports. Do not use this field.**/
        subReportsMasterReport: StiReport;
        subReportsResetPageNumber: boolean;
        subReportsPrintOnPreviousPage: boolean;
        /** Internal use only. */
        indexName: number;
        containsTables: boolean;
        cachedTotals: Hashtable;
        cachedTotalsLocked: boolean;
        modifiedVariables: Hashtable;
        private _reportVersion;
        reportVersion: string;
        private _engine;
        engine: StiEngine;
        private _reportRenderingMessages;
        reportRenderingMessages: string[];
        private _interactionCollapsingStates;
        interactionCollapsingStates: any;
        private _subReports;
        subReports: StiReportsCollection;
        /**
         * Gets or sets the report key.
         */
        key: string;
        private _reportGuid;
        reportGuid: string;
        private _imageCachePath;
        /** Gets path to the report image cache path. Path can't be changed. */
        imageCachePath: string;
        private _parentReport;
        parentReport: StiReport;
        private _globalizationManager;
        globalizationManager: IStiGlobalizationManager;
        private _pages;
        readonly pages: StiPagesCollection;
        private _renderedPages;
        renderedPages: StiPagesCollection;
        private _info;
        info: Stimulsoft.Report.Design.StiDesignerInfo;
        bookmarkValue: StiBookmark;
        bookmark: StiBookmark;
        private _manualBookmark;
        manualBookmark: StiBookmark;
        private _totals;
        totals: Hashtable;
        private _cells;
        readonly cells: StiCells;
        private _password;
        password: string;
        private _dataBandsUsedInPageTotals;
        dataBandsUsedInPageTotals: string[];
        private _listOfUsedData;
        listOfUsedData: string[];
        private _reportPass;
        reportPass: StiReportPass;
        private _isRendered;
        isRendered: boolean;
        private _isRendering;
        isRendering: boolean;
        private _isModified;
        isModified: boolean;
        private _isStopped;
        isStopped: boolean;
        private _isExporting;
        isExporting: boolean;
        private _isSerializing;
        isSerializing: boolean;
        private _isPageDesigner;
        isPageDesigner: boolean;
        private isPrintingValue;
        isPrinting: boolean;
        /**
         *  Gets or sets value, which indicates that the report contains dashboard pages.
         */
        readonly containsDashboard: boolean;
        readonly isDesigning: boolean;
        private _isPreviewDialogs;
        isPreviewDialogs: boolean;
        private _isDocument;
        isDocument: boolean;
        private _isInteractionRendering;
        isInteractionRendering: boolean;
        private _reportName;
        reportName: string;
        private _reportAlias;
        reportAlias: string;
        private _reportAuthor;
        reportAuthor: string;
        private _reportDescription;
        reportDescription: string;
        private _reportCreated;
        reportCreated: DateTime;
        private _reportChanged;
        reportChanged: DateTime;
        private _styles;
        readonly styles: StiStylesCollection;
        private _numberOfPass;
        /** Gets or sets the number of passes which the report generator makes while report rendering.*/
        numberOfPass: StiNumberOfPass;
        private _calculationMode;
        calculationMode: StiCalculationMode;
        private _reportUnit;
        reportUnit: StiReportUnitType;
        private _stopBeforePage;
        stopBeforePage: number;
        private _previewSettings;
        previewSettings: number;
        private _dashboardViewerSettings;
        dashboardViewerSettings: number;
        private _collate;
        collate: number;
        private _globalizationStrings;
        readonly globalizationStrings: StiGlobalizationContainerCollection;
        private _autoLocalizeReportOnRun;
        autoLocalizeReportOnRun: boolean;
        private _requestParameters;
        requestParameters: boolean;
        private _cacheTotals;
        cacheTotals: boolean;
        private _culture;
        culture: string;
        private _refreshTime;
        refreshTime: number;
        private _compiledReport;
        compiledReport: StiReport;
        resetAggregateFunctions(): void;
        licenseKey: string;
        constructor();
        isAsyncMode: boolean;
        renderAsync(onRender: Function, showProgress?: boolean, fromPage?: number, toPage?: number): void;
        render(showProgress?: boolean, fromPage?: number, toPage?: number): void;
        processAutoLocalizeReportOnRun(): void;
        private storedCulture;
        private renderReport;
        print(pagesRange?: StiPagesRange, exportMode?: StiHtmlExportMode): void;
        printToPdf(pagesRange?: StiPagesRange, element?: HTMLElement): void;
        private _reportFile;
        reportFile: string;
        exportDocumentAsync(onExport: Function, exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings): void;
        exportDocument(exportFormat: StiExportFormat, exportService?: StiExportService, settings?: StiExportSettings, onExport?: Function): string | number[];
        static createNewReport(): StiReport;
        static createNewDashboard(): StiReport;
    }
}
declare namespace StiOptions {
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiColumnsSynchronizationMode = Stimulsoft.Report.Dictionary.StiColumnsSynchronizationMode;
    import StiWord2007RestrictEditing = Stimulsoft.Report.Export.StiWord2007RestrictEditing;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import PaperSizeCollection = Stimulsoft.System.Drawing.Printing.PrinterSettings.PaperSizeCollection;
    import StiTextQuality = Stimulsoft.Report.Components.StiTextQuality;
    import StiNamingRule = Stimulsoft.Report.StiNamingRule;
    import StiAutoSynchronizeMode = Stimulsoft.Report.Dictionary.StiAutoSynchronizeMode;
    import StiPropertiesProcessingType = Stimulsoft.Report.Dictionary.StiPropertiesProcessingType;
    import StiFieldsProcessingType = Stimulsoft.Report.Dictionary.StiFieldsProcessingType;
    import StiExcel2007RestrictEditing = Stimulsoft.Report.Export.StiExcel2007RestrictEditing;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import StiArabicDigitsType = Stimulsoft.Report.StiArabicDigitsType;
    import StiPdfAutoPrintMode = Stimulsoft.Report.Export.StiPdfAutoPrintMode;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import List = Stimulsoft.System.Collections.List;
    class CrossTab2 {
        styleColors: Color[];
    }
    class Designer {
        static useComponentPlacementOptimization: boolean;
        static autoCorrectDataSourceName: boolean;
        static autoCorrectDataRelationName: boolean;
        static autoCorrectDataColumnName: boolean;
        static autoCorrectComponentName: boolean;
        static autoCorrectReportName: boolean;
        static autoLargeHeight: boolean;
        static sortDictionaryByAliases: boolean;
        static runWizardAfterLoad: boolean;
        static runSpecificWizardAfterLoad: string;
        static Editors: {
            allowConnectToDataInGallery: boolean;
        };
        private static _styles;
        static readonly styles: Stimulsoft.Report.Styles.StiStylesCollection;
        static CrossTab: CrossTab2;
    }
    class Image {
        /** Gets or sets absolute path which will be used in combination with path from File property of image component. */
        absolutePathOfImages: string;
        /** Gets or sets a value forcing render RichText components in other application domain. */
        useImageCloning: boolean;
    }
    class Watemark {
        allowExpression: boolean;
    }
    class CrossTab {
        defaultWidth: number;
        defaultHeight: number;
    }
    class Globalization {
        allowUseText: boolean;
        allowUseTag: boolean;
        allowUseToolTip: boolean;
        allowUseHyperlink: boolean;
        allowUseVariableAlias: boolean;
    }
    class Engine {
        /** A class which controls of settings of the report engine. */
        static Image: Image;
        static Watermark: Watemark;
        static printIfDetailEmptyDefaultValue: boolean;
        /**
         *  Gets or sets the base type for the report creation in the designer.
         */
        static baseReportType: typeof Stimulsoft.Report.StiReport;
        static fullTrust: boolean;
        static allowUseResetMethodInBusinessObject: boolean;
        static allowResetValuesAtComponent: boolean;
        /**
         * If the property is set to true, the report generator will use the PrintOn property when rendering a report.
         * Using this mode is not recommended because of problems with page numbers.
         * If the property is set to false, then the property will be processed after rendering a report.
         */
        static useAdvancedPrint: boolean;
        /** The default value for the TextQuality property. */
        static defaultTextQualityMode: StiTextQuality;
        /** If the value is set to true, the names of the new components are generated as localized regardless the settings of the report designer. */
        static forceGenerationLocalizedName: boolean;
        /** If the property is set to true, the report generator will use the PrintOn property when rendering a report.
                Using this mode is not recommended because of problems with page numbers.
                If the property is set to false, then the property will be processed after rendering a report. */
        static useAdvancedPrintOnEngine: boolean;
        /** If the value is set to true, the names of the new components are generated as not localized regardless the settings of the report designer. */
        static forceGenerationNonLocalizedName: boolean;
        static forceNewPageForExtraColumns: boolean;
        static useRoundForToCurrencyWordsFunctions: boolean;
        static forceNewPageInSubReports: boolean;
        static useTemplateForPagePrintEvents: boolean;
        /** Gets or sets a value which controls of naming of new components in the report. */
        static namingRule: StiNamingRule;
        /** Gets or sets a value which indicates whether use the CheckSize method for Continued containers*/
        static useCheckSizeForContinuedContainers: boolean;
        /** Gets or sets a value, which indicates that if data are absent then controls of the data emulation. This value is used for report rendering in the designer without data. */
        static emulateData: boolean;
        static allowCacheForGetActualSize: boolean;
        static allowBreakContainerOptimization: boolean;
        static removeBottomBorderOfSplitContainer: boolean;
        static checkDockToContainerIfComponentDisabled: boolean;
        static usePrintOnAllPagesPropertyOfHeadersInSubreports: boolean;
        static useParentStylesOldMode: boolean;
        static useCollateOldMode: boolean;
        static dpiAware: boolean;
        static dockPageFooterToBottom: boolean;
        static defaultValueOfAllowApplyStyleProperty: boolean;
        static allowFixPieChartMarkerAlignment: boolean;
        static applyStylesInAutoSeries: boolean;
        static allowInvokeProcessChartEventForTemplateOfChart: boolean;
        static allowInteractionInChartWithComponents: boolean;
        static dontSaveDataSourceBeforeChartRendering: boolean;
        static measureTrailingSpaces: boolean;
        static renderExternalSubReportsWithHelpOfUnlimitedHeightPages: boolean;
        static escapeQueryParameters: boolean;
        static optimizeDetailDataFiltering: boolean;
        static CrossTab: CrossTab;
        static printIfDetailEmptyNesting: boolean;
        static allowForceCanBreakForCrossTabPrintOnAllPages: boolean;
        static Globalization: Globalization;
        static reportResources: any;
        static filterDataInDataSourceBeforeSorting: boolean;
        static allowConvertingInFormatting: boolean;
        /**
         *  Gets or sets a color which is used for coloring negative values in the text formatting.
         */
        static negativeColor: Color;
    }
    class Print {
        static customPaperSizes: PaperSizeCollection;
        static allowUsePaperSizesFromPrinterSettings: boolean;
    }
    class BusinessObjects {
        static allowUseDataColumn: boolean;
        static allowUseFields: boolean;
        static allowUseProperties: boolean;
        static propertiesProcessingType: StiPropertiesProcessingType;
        static fieldsProcessingType: StiFieldsProcessingType;
        columnsSynchronizationMode: StiColumnsSynchronizationMode;
    }
    class Dictionary {
        static BusinessObjects: BusinessObjects;
        /** Gets or sets a value indicating that instead of a database name an alias will be shown. */
        static showOnlyAliasForDatabase: boolean;
        /** Gets or sets a value indicating that instead of a data name an alias will be shown. */
        static showOnlyAliasForData: boolean;
        /** Gets or sets a value indicating that instead of a DataColumn name an alias will be shown. */
        static showOnlyAliasForDataColumn: boolean;
        /** Gets or sets a value indicating that instead of a DataRelation name an alias will be shown. */
        static showOnlyAliasForDataRelation: boolean;
        static hideRelationExceptions: boolean;
        static autoSynchronize: StiAutoSynchronizeMode;
        static useAdvancedDataSearch: boolean;
        static showOnlyAliasForComponents: boolean;
        static showOnlyAliasForDataSource: boolean;
        static allowRestConnections: boolean;
        static allowConnectToFirstTableForEmptyDataSource: boolean;
        static useNullableDateTime: boolean;
        static useNullableTimeSpan: boolean;
        static columnsSynchronizationMode: StiColumnsSynchronizationMode;
        static showOnlyAliasForResource: boolean;
    }
    class Dashboards {
        private _dashboardStyles;
        readonly dashboardStyles: List<Stimulsoft.Report.Dashboard.Styles.StiDashboardStyle>;
        private _controlStyles;
        readonly controlStyles: List<Stimulsoft.Report.Dashboard.Styles.StiControlElementStyle>;
        private _indicatorStyles;
        readonly indicatorStyles: List<Stimulsoft.Report.Dashboard.Styles.StiIndicatorElementStyle>;
        private _pivotStyles;
        readonly pivotStyles: List<Stimulsoft.Report.Dashboard.Styles.StiPivotElementStyle>;
        private _progressStyles;
        readonly progressStyles: List<Stimulsoft.Report.Dashboard.Styles.StiProgressElementStyle>;
        private _tableStyles;
        readonly tableStyles: List<Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle>;
    }
    class Services {
        private static _components;
        static readonly components: Stimulsoft.System.Type[];
        private static _databases;
        static readonly databases: Stimulsoft.Report.Dictionary.StiDatabase[];
        private static _dataAdapters;
        static readonly dataAdapters: Stimulsoft.Report.Dictionary.StiDataAdapterService[];
        private static _dataSource;
        static readonly dataSource: Stimulsoft.Report.Dictionary.StiDataSource[];
        private static _formats;
        static readonly formats: Stimulsoft.Report.Components.TextFormats.StiFormatService[];
        private static _styles;
        static readonly styles: Stimulsoft.Report.Styles.StiBaseStyle[];
        private static _chartAreas;
        static readonly chartAreas: Stimulsoft.Report.Chart.IStiArea[];
        private static _chartSeries;
        static readonly chartSeries: Stimulsoft.Report.Chart.IStiSeries[];
        private static _chartTrendLines;
        static readonly chartTrendLines: Stimulsoft.Report.Chart.IStiTrendLine[];
        private static _chartSerieLabels;
        static readonly chartSerieLabels: Stimulsoft.Report.Chart.IStiSeriesLabels[];
        private static _chartStyles;
        static readonly chartStyles: Stimulsoft.Report.Chart.IStiChartStyle[];
        private static _shapes;
        static readonly shapes: Stimulsoft.Report.Components.StiShapeTypeService[];
        private static _barCodes;
        static readonly barCodes: Stimulsoft.Report.BarCodes.StiBarCodeTypeService[];
        private static _indicatorRanges;
        static readonly indicatorRanges: IStiIndicatorRangeInfo[];
        private static _customValues;
        static readonly customValues: IStiCustomValueBase[];
        private static _gaugeElements;
        static readonly gaugeElements: IStiGaugeElement[];
        private static _ranges;
        static readonly ranges: IStiRangeBase[];
        private static _gaugeScales;
        static readonly gaugeScales: IStiScaleBase[];
        private static _gaugeStyles;
        static readonly gaugeStyles: IStiGaugeStyle[];
        private static _mapStyles;
        static readonly mapStyles: Stimulsoft.Report.Maps.StiMapStyleFX[];
        static Dashboards: Dashboards;
    }
    class ExportWord {
        divideSegmentPages: boolean;
        allowImageComparer: boolean;
        removeEmptySpaceAtBottom: boolean;
        spaceBetweenCharacters: number;
        lineHeightExactly: boolean;
        lineHeightExactlyForPHFMode: boolean;
        forceLineHeight: boolean;
        rightMarginCorrection: number;
        bottomMarginCorrection: number;
        renderRichTextAsImage: boolean;
        renderHtmlTagsAsImage: boolean;
        allowCorrectFontSize11Problem: boolean;
        normalStyleDefaultFontSize: number;
        lineSpacing: number;
        divideBigCells: boolean;
        restrictEditing: StiWord2007RestrictEditing;
    }
    class ExportHtml {
        convertDigitsToArabic: boolean;
        arabicDigitsType: Stimulsoft.Report.StiArabicDigitsType;
        allowImageComparer: boolean;
        forceWysiwygWordwrap: boolean;
        replaceSpecialCharacters: boolean;
        useImageResolution: boolean;
        useWordWrapBreakWordMode: boolean;
        useStrictTableCellSize: boolean;
        forceIE6Compatibility: boolean;
        allowStrippedImages: boolean;
        removeEmptySpaceAtBottom: boolean;
        useExtendedStyle: boolean;
        printLayoutOptimization: boolean;
        useComponentStyleName: boolean;
    }
    class ExportExcel {
        AllowExportDateTime: boolean;
        ColumnsRightToLeft: boolean;
        ShowGridLines: boolean;
        MaximumSheetHeight: number;
        RemoveEmptySpaceAtBottom: boolean;
        DivideBigCells: boolean;
        UseImageResolution: boolean;
        TrimTrailingSpaces: boolean;
        AllowExportFootersInDataOnlyMode: boolean;
        AllowImageComparer: boolean;
        AllowFreezePanes: boolean;
        RenderHtmlTagsAsImage: boolean;
        RestrictEditing: StiExcel2007RestrictEditing;
        FitToOnePageWide: boolean;
    }
    class ExportPdf {
        divideSegmentPages: boolean;
        convertDigitsToArabic: boolean;
        arabicDigitsType: StiArabicDigitsType;
        reduceFontFileSize: boolean;
        useEditableFieldName: boolean;
        useEditableFieldAlias: boolean;
        useEditableFieldTag: boolean;
        allowImageComparer: boolean;
        allowImageTransparency: boolean;
        allowInheritedPageResources: boolean;
        allowExtGState: boolean;
        private _creatorString;
        creatorString: string;
        keywordsString: string;
        defaultCoordinatesPrecision: Number;
        defaultAutoPrintMode: StiPdfAutoPrintMode;
        useAlternativeFontNames: boolean;
        private static _alternativeFontNames;
        alternativeFontNames: Hashtable;
    }
    class CheckBoxReplacementForExcelValue_ {
        Font: Font;
        HorAlignment: StiTextHorAlignment;
        VertAlignment: StiVertAlignment;
    }
    class Export {
        static Word: ExportWord;
        static Html: ExportHtml;
        static Excel: ExportExcel;
        static Pdf: ExportPdf;
        static CheckBoxReplacementForExcelValue: CheckBoxReplacementForExcelValue_;
        static optimizeDataOnlyMode: boolean;
        static checkBoxTextForTrue: string;
        static checkBoxTextForFalse: string;
    }
    class WebServer {
        static url: string;
        static timeout: number;
    }
}
declare module Stimulsoft.Report {
    class StiOptionsFontHelperAttribute {
        private _index;
        readonly index: number;
        constructor(index: number);
    }
}
declare module Stimulsoft.Report {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiReportsCollection extends CollectionBase<StiReport> {
        add(report: StiReport, resetPageNumber?: boolean, printOnPreviousPage?: boolean): void;
        getByIndex(index: number): StiReport;
        setByIndex(index: number, value: StiReport): void;
        private owner;
        constructor(owner: StiReport);
    }
}
declare module Stimulsoft.Report {
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiResizeReportOptions = Stimulsoft.Report.StiResizeReportOptions;
    class StiResizeReportHelper {
        private static setPageParameters;
        static resizeReport(report: StiReport, orientation: StiPageOrientation, paperSize: PaperKind, margins: StiMargins, pageWidth: number, pageHeight: number, options: StiResizeReportOptions, indexOfRenderedPage?: number): void;
    }
}
declare module Stimulsoft.Report {
    import StiSimpleText = Stimulsoft.Report.Components.StiSimpleText;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiRuntimeVariables {
        clone(): StiRuntimeVariables;
        page: StiPage;
        textBox: StiSimpleText;
        line: number;
        column: number;
        lineThrough: number;
        dataSourcesPosition: Hashtable;
        private _pageIndex;
        pageIndex: number;
        private _currentPrintPage;
        currentPrintPage: number;
        setVariables(report: StiReport): void;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Report {
    class StiStatesManager {
        private static ValueBoolFalse;
        private static ValueBoolTrue;
        private states;
        push(stateName: string, obj: Object, property: string, value: any): void;
        pushBool(stateName: string, obj: Object, property: string, value: boolean): void;
        pushInt(stateName: string, obj: Object, property: string, value: number): void;
        pushInt64(stateName: string, obj: Object, property: string, value: number): void;
        pushFloat(stateName: string, obj: Object, property: string, value: number): void;
        pushDouble(stateName: string, obj: Object, property: string, value: number): void;
        pushDecimal(stateName: string, obj: Object, property: string, value: number): void;
        pushRange(stateName: string, obj: Object, property: string, value: Range): void;
        pop(stateName: string, obj: Object, property: string): any;
        popBool(stateName: string, obj: Object, property: string): boolean;
        popInt(stateName: string, obj: Object, property: string): number;
        popInt64(stateName: string, obj: Object, property: string): number;
        popDouble(stateName: string, obj: Object, property: string): number;
        popFloat(stateName: string, obj: Object, property: string): number;
        popDecimal(stateName: string, obj: Object, property: string): number;
        popRange(stateName: string, obj: Object, property: string): Range;
        isExist(stateName: string, obj: Object): boolean;
        clearState(stateName: string): void;
        clear(): void;
    }
}
declare module Stimulsoft.Report {
    class StiSystemVariableLocHelper {
        static getPageNofM(report: StiReport): string;
        static getPageNofMThrough(report: StiReport): string;
        static getPageNofMIdent(report: StiReport): string;
        private static getIdent;
        private static locs;
    }
}
declare module Stimulsoft.Report {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiText = Stimulsoft.Report.Components.StiText;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiFitTextInfo {
        hashText: Hashtable;
        hashComponent: Hashtable;
        private hashFontString;
        getFontString(font: Font): string;
        getFontSizeObject(textBox: StiText, rect: RectangleD, text: string, REFfontSize?: any, REFhashSt?: any): Object;
        clear(): void;
    }
    class StiViewerFitTextHelper {
        private static hashes;
        private static _enabled;
        static enabled: boolean;
        static addReport(report: StiReport): void;
        static removeReport(report: StiReport): void;
        static clearReportInfo(report: StiReport): void;
        static getReportInfo(report: StiReport): StiFitTextInfo;
        static clear(): void;
    }
}
declare module Stimulsoft.Report {
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import DateTime = Stimulsoft.System.DateTime;
    class Totals {
        static getMethod(report: StiReport, name: string): any;
        private static calculate;
        private static calculate1;
        private static calcItem;
        private static calculateByCondition;
        private static compareValue;
        private static calculateNullable;
        private static calculateRunning;
        static sum(data: Object, report: StiReport, name: string): number;
        static sumNullable(data: Object, report: StiReport, name: string): number;
        static sumDistinct(data: Object, report: StiReport, name: string, name2?: string): number;
        static cSum(data: Object, report: StiReport, name: string): number;
        static cSumRunning(data: Object, report: StiReport, name: string): number;
        static sumAllLevels(data: Object, report: StiReport, name: string): number;
        static sumAllLevelsByCondition(data: Object, report: StiReport, name: string, filterCondition: StiFilterCondition, value1: number, value2: number): number;
        static sumAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static sumOnlyChilds(data: Object, report: StiReport, name: string): number;
        static sumTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cSumTime(data: Object, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static sumTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static sumTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static avg(data: Object, report: StiReport, name: string): number;
        static cAvg(data: Object, report: StiReport, name: string): number;
        static cAvgRunning(data: Object, report: StiReport, name: string): number;
        static avgAllLevels(data: Object, report: StiReport, name: string): number;
        static avgAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static avgOnlyChilds(data: Object, report: StiReport, name: string): number;
        static avgDate(data: Object, report: StiReport, name: string): DateTime;
        static cAvgDate(data: Object, report: StiReport, name: string): DateTime;
        static avgDateAllLevels(data: Object, report: StiReport, name: string): DateTime;
        static avgDateAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static avgDateOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static avgTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cAvgTime(data: Object, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static avgTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static avgTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static max(data: Object, report: StiReport, name: string): number;
        static cMax(data: Object, report: StiReport, name: string): number;
        static cMaxRunning(data: Object, report: StiReport, name: string): number;
        static maxAllLevels(data: Object, report: StiReport, name: string): number;
        static maxAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static maxOnlyChilds(data: Object, report: StiReport, name: string): number;
        static min(data: Object, report: StiReport, name: string): number;
        static cMin(data: Object, report: StiReport, name: string): number;
        static cMinRunning(data: Object, report: StiReport, name: string): number;
        static minAllLevels(data: Object, report: StiReport, name: string): number;
        static minAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static minOnlyChilds(data: Object, report: StiReport, name: string): number;
        static median(data: Object, report: StiReport, name: string): number;
        static cMedian(data: Object, report: StiReport, name: string): number;
        static cMedianRunning(data: Object, report: StiReport, name: string): number;
        static medianAllLevels(data: Object, report: StiReport, name: string): number;
        static medianAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static medianOnlyChilds(data: Object, report: StiReport, name: string): number;
        static mode(data: Object, report: StiReport, name: string): number;
        static cMode(data: Object, report: StiReport, name: string): number;
        static cModeRunning(data: Object, report: StiReport, name: string): number;
        static modeAllLevels(data: Object, report: StiReport, name: string): number;
        static modeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static modeOnlyChilds(data: Object, report: StiReport, name: string): number;
        static first(data: Object, report: StiReport, name: string): Object;
        static cFirst(data: Object, report: StiReport, name: string): Object;
        static cFirstRunning(data: Object, report: StiReport, name: string): Object;
        static firstAllLevels(data: Object, report: StiReport, name: string): Object;
        static firstAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static firstOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static last(data: Object, report: StiReport, name: string): Object;
        static cLast(data: Object, report: StiReport, name: string): Object;
        static cLastRunning(data: Object, report: StiReport, name: string): Object;
        static lastAllLevels(data: Object, report: StiReport, name: string): Object;
        static lastAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static lastOnlyChilds(data: Object, report: StiReport, name: string): Object;
        static count(data: Object, report?: StiReport, name?: string): number;
        static cCount(data: Object, report?: StiReport, name?: string): number;
        static cCountRunning(data: Object, report?: StiReport, name?: string): number;
        static countAllLevels(data: Object): number;
        static countAllLevelsOnlyChilds(data: Object): number;
        static countOnlyChilds(data: Object): number;
        static countDistinct(data: Object, report: StiReport, name: string): number;
        static cCountDistinct(data: Object, report: StiReport, name: string): number;
        static cCountDistinctRunning(data: Object, report: StiReport, name: string): number;
        static countDistinctAllLevels(data: Object, report: StiReport, name: string): number;
        static countDistinctAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): number;
        static countDistinctOnlyChilds(data: Object, report: StiReport, name: string): number;
        static minDate(data: Object, report: StiReport, name: string): DateTime;
        static cMinDate(data: Object, report: StiReport, name: string): DateTime;
        static minDateAllLevels(data: Object, report: StiReport, name: string): DateTime;
        static minDateAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static minDateOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static minTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cMinTime(data: Object, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static minTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static minTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static minStr(data: Object, report: StiReport, name: string): string;
        static cMinStr(data: Object, report: StiReport, name: string): string;
        static minStrAllLevels(data: Object, report: StiReport, name: string): string;
        static minStrAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): string;
        static minStrOnlyChilds(data: Object, report: StiReport, name: string): string;
        static maxDate(data: Object, report: StiReport, name: string): DateTime;
        static cMaxDate(data: Object, report: StiReport, name: string): DateTime;
        static maxDateAllLevels(data: Object, report: StiReport, name: string): DateTime;
        static maxDateAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static maxDateOnlyChilds(data: Object, report: StiReport, name: string): DateTime;
        static maxTime(data: Object, report: StiReport, name: string): TimeSpan;
        static cMaxTime(data: Object, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevels(data: Object, report: StiReport, name: string): TimeSpan;
        static maxTimeAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static maxTimeOnlyChilds(data: Object, report: StiReport, name: string): TimeSpan;
        static maxStr(data: Object, report: StiReport, name: string): string;
        static cMaxStr(data: Object, report: StiReport, name: string): string;
        static maxStrAllLevels(data: Object, report: StiReport, name: string): string;
        static maxStrAllLevelsOnlyChilds(data: Object, report: StiReport, name: string): string;
        static maxStrOnlyChilds(data: Object, report: StiReport, name: string): string;
        static rank(data: Object, report: StiReport, name: string, dense?: boolean, sortOrder?: StiRankOrder): number;
        private static saveState;
        private static restoreState;
        private static storeCachedValue;
        private static getCachedValue;
    }
}

declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    class StiChartFilter implements IStiJsonReportObject, IStiChartFilter, ICloneable {
        private static implementsStiChartFilter;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartFilter;
        readonly index: number;
        private _condition;
        condition: StiFilterCondition;
        private _dataType;
        dataType: StiFilterDataType;
        private _item;
        item: StiFilterItem;
        private _valueObj;
        value: string;
        toString(): string;
        filters: StiChartFiltersCollection;
        constructor(item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
    import StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
    import StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartCondition extends StiChartFilter implements IStiChartCondition, IStiChartFilter, IStiJsonReportObject {
        private static implementsStiChartCondition;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        clone(): StiChartCondition;
        private _color;
        color: Color;
        conditions: StiChartConditionsCollection;
        constructor(color?: Color, item?: StiFilterItem, dataType?: StiFilterDataType, condition?: StiFilterCondition, value?: string);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartConditionsCollection extends CollectionBase<StiChartCondition> implements IStiJsonReportObject, ICloneable, IStiChartConditionsCollection {
        private static implementsStiChartConditionsCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartConditionsCollection;
        add(condition: StiChartCondition): void;
        addRange(conditions: StiChartConditionsCollection): void;
        addRange2(conditions: StiChartCondition[]): void;
        contains(condition: StiChartCondition): boolean;
        indexOf(condition: StiChartCondition): number;
        insert(index: number, condition: StiChartCondition): void;
        remove(condition: StiChartCondition): void;
        getByIndex(index: number): StiChartCondition;
        setByIndex(index: number, value: StiChartCondition): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiNewAutoSeriesEventArgs = Stimulsoft.Report.Events.StiNewAutoSeriesEventArgs;
    import StiGetTitleEventArgs = Stimulsoft.Report.Events.StiGetTitleEventArgs;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiSeries extends StiService implements IStiJsonReportObject, ICloneable, IStiSeries, IStiJsonReportObject {
        private static implementsStiSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiSeries;
        baseTransform(context: Object, x: number, y: number, angle: number, dx: number, dy: number): void;
        readonly parent: StiComponent;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _core;
        core: StiSeriesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _format;
        format: string;
        private _sortBy;
        sortBy: StiSeriesSortType;
        private _sortDirection;
        sortDirection: StiSeriesSortDirection;
        private _showInLegend;
        showInLegend: boolean;
        showLabels: boolean;
        private _showSeriesLabels;
        showSeriesLabels: StiShowSeriesLabels;
        private _showShadow;
        showShadow: boolean;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: StiChartFiltersCollection;
        private _conditions;
        conditions: StiChartConditionsCollection;
        private _topN;
        topN: IStiSeriesTopN;
        private _yAxis;
        yAxis: StiSeriesYAxis;
        private _seriesLabels;
        seriesLabels: IStiSeriesLabels;
        private _trendLine;
        trendLine: IStiTrendLine;
        private _chart;
        chart: IStiChart;
        private valuesOld;
        valuesStart: number[];
        private _values;
        values: number[];
        private _valueDataColumn;
        valueDataColumn: string;
        valuesString: string;
        private _arguments;
        arguments: Object[];
        protected getArguments(): Object[];
        protected setArguments(value: Object[]): void;
        private _argumentDataColumn;
        argumentDataColumn: string;
        argumentsString: string;
        private _autoSeriesTitleDataColumn;
        autoSeriesTitleDataColumn: string;
        private _autoSeriesKeyDataColumn;
        autoSeriesKeyDataColumn: string;
        private _autoSeriesColorDataColumn;
        autoSeriesColorDataColumn: string;
        private _toolTips;
        toolTips: string[];
        private _toolTipDataColumn;
        toolTipDataColumn: string;
        toolTipsString: string;
        private _tags;
        tags: Object[];
        private _tagDataColumn;
        tagDataColumn: string;
        tagString: string;
        private _hyperlinks;
        hyperlinks: string[];
        private _hyperlinkDataColumn;
        hyperlinkDataColumn: string;
        hyperlinkString: string;
        private _drillDownEnabled;
        drillDownEnabled: boolean;
        private _drillDownReport;
        drillDownReport: string;
        drillDownPage: StiPage;
        private _drillDownPageGuid;
        drillDownPageGuid: string;
        private _allowSeries;
        allowSeries: boolean;
        private _allowSeriesElements;
        allowSeriesElements: boolean;
        coreTitle: string;
        /**
         *  Gets or sets value which indicates that this series is used in dashboards mode and IsDesign property will ingore.
         */
        isDashboard: boolean;
        private _interaction;
        interaction: IStiSeriesInteraction;
        processSeriesColors(pointIndex: number, seriesColor: Color): Color;
        processSeriesBrushes(pointIndex: number, seriesBrush: StiBrush): StiBrush;
        private getConditionResult;
        toString(): string;
        static getNullableValuesFromString(series: StiSeries, list: string): number[];
        static getValuesFromString(list: string): number[];
        static getStringsFromString(list: string): string[];
        static getArgumentsFromString(list: string): Object[];
        createNew(): StiSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        newAutoSeries: Function;
        invokeNewAutoSeries(e: StiNewAutoSeriesEventArgs): void;
        getValue: Function;
        protected onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValues: Function;
        protected onGetListOfValues(e: StiGetValueEventArgs): void;
        invokeGetListOfValues(sender: StiComponent, e: StiGetValueEventArgs, series: StiSeries): void;
        getArgument: Function;
        protected onGetArgument(e: StiValueEventArgs): void;
        invokeGetArgument(sender: StiComponent, e: StiValueEventArgs): void;
        getListOfArguments: Function;
        protected onGetListOfArguments(e: StiGetValueEventArgs): void;
        invokeGetListOfArguments(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTitle: Function;
        protected onGetTitle(e: StiGetTitleEventArgs): void;
        invokeGetTitle(sender: StiComponent, e: StiGetTitleEventArgs): void;
        getToolTip: Function;
        protected onGetToolTip(e: StiValueEventArgs): void;
        invokeGetToolTip(sender: Object, e: StiValueEventArgs): void;
        getListOfToolTips: Function;
        protected onGetListOfToolTips(e: StiGetValueEventArgs): void;
        invokeGetListOfToolTips(sender: StiComponent, e: StiGetValueEventArgs): void;
        getTag: Function;
        protected onGetTag(e: StiValueEventArgs): void;
        invokeGetTag(sender: Object, e: StiValueEventArgs): void;
        getListOfTags: Function;
        protected onGetListOfTags(e: StiGetValueEventArgs): void;
        invokeGetListOfTags(sender: StiComponent, e: StiGetValueEventArgs): void;
        getHyperlink: Function;
        protected onGetHyperlink(e: StiValueEventArgs): void;
        invokeGetHyperlink(sender: Object, e: StiValueEventArgs): void;
        getListOfHyperlinks: Function;
        protected onGetListOfHyperlinks(e: StiGetValueEventArgs): void;
        invokeGetListOfHyperlinks(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObj;
        value: string;
        private _listOfValues;
        listOfValues: string;
        private _argument;
        argument: string;
        private _listOfArguments;
        listOfArguments: string;
        private _titleValue;
        titleValue: string;
        private _title;
        title: string;
        private _toolTip;
        toolTip: string;
        private _listOfToolTips;
        listOfToolTips: string;
        private _tag;
        tag: string;
        private _listOfTags;
        listOfTags: string;
        private _hyperlink;
        hyperlink: string;
        private _listOfHyperlinks;
        listOfHyperlinks: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiBaseLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiBaseLineSeries;
        private _showNulls;
        showNulls: boolean;
        private _showZeros;
        showZeros: boolean;
        showMarker: boolean;
        markerColor: Color;
        markerSize: number;
        markerType: StiMarkerType;
        private _marker;
        marker: IStiMarker;
        private _lineMarker;
        lineMarker: IStiLineMarker;
        private _lineColor;
        lineColor: Color;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        private _labelsOffset;
        labelsOffset: number;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiScatterSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiScatterSeries, IStiAllowApplyColorNegative {
        private static implementsStiScatterSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        clone(): StiScatterSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterLineSeries extends StiScatterSeries implements IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiScatterLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        clone(): StiScatterLineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaCoreXF implements ICloneable, IStiApplyStyle, IStiAreaCoreXF {
        private static implementsStiAreaCoreXF;
        implements(): string[];
        clone(): StiAreaCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        protected prepareInfo(rect: RectangleD): void;
        checkInLabelsTypes(typeForCheck: Stimulsoft.System.Type): boolean;
        getSeries(): IStiSeries[];
        isAcceptableSeries(seriesType: Stimulsoft.System.Type): boolean;
        isAcceptableSeriesLabels(seriesLabelsType: Stimulsoft.System.Type): boolean;
        private _area;
        area: IStiArea;
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaCoreXF extends StiAreaCoreXF implements IStiAxisAreaCoreXF {
        private static implementsStiAxisAreaCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private calculateScrollValuesX;
        private calculateScrollValuesY;
        protected prepareInfo(rect: RectangleD): void;
        private renderSeries;
        isAutoRangeXAxis(axis: IStiAxis): boolean;
        isAutoRangeYAxis(axis: IStiAxis): boolean;
        calculateMinimumAndMaximumXAxis(axis: IStiAxis): void;
        calculateMinimumAndMaximumYAxis(axis: IStiAxis): void;
        getArgumentLabel(line: StiStripLineXF, series: IStiSeries): string;
        switchOff(): void;
        private swap;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumYAxis(axis: IStiAxis): void;
        private calculateStepX;
        private calculateStepY;
        private checkStartFromZeroYAxis;
        calculatePositions(axis: IStiAxis, REFcollection: any, step: number): void;
        private calculateDivider;
        private static rotateStripLines;
        getDividerX(): number;
        getDividerY(): number;
        getDividerRightY(): number;
        valuesCount: number;
        readonly scrollDistanceX: number;
        readonly scrollDistanceY: number;
        private _scrollRangeX;
        readonly scrollRangeX: number;
        private _scrollRangeY;
        readonly scrollRangeY: number;
        private _scrollViewX;
        readonly scrollViewX: number;
        private _scrollViewY;
        readonly scrollViewY: number;
        private _blockScrollValueX;
        blockScrollValueX: boolean;
        private _blockScrollValueY;
        blockScrollValueY: boolean;
        private _scrollValueX;
        scrollValueX: number;
        private _scrollValueY;
        scrollValueY: number;
        private _scrollDpiX;
        readonly scrollDpiX: number;
        private _scrollDpiY;
        readonly scrollDpiY: number;
        private _scrollDragStartValue;
        scrollDragStartValue: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiClusteredColumnAreaCoreXF extends StiAxisAreaCoreXF {
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiScatterAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        private isArgumentDateTime;
        private isXAxisAutoRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        protected checkStripLinesAndMaximumMinimumXAxis(axis: IStiAxis): void;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected createStripLinesYAxis(axis: IStiAxis, isDateTimeValues: boolean): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    class StiBubbleAreaCoreXF extends StiScatterAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiCandlestickAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiClusteredBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiParetoAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSplineAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSplineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSteppedAreaAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSteppedLineAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaCoreXF extends StiAreaCoreXF {
        valuesCount: number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaCoreXF extends StiPieAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedBarAreaCoreXF extends StiClusteredBarAreaCoreXF {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedBarAreaCoreXF extends StiStackedBarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedColumnAreaCoreXF extends StiAxisAreaCoreXF {
        private prepareSeriesRange;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedColumnAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedLineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaCoreXF extends StiFullStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelAreaCoreXF extends StiAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiGanttAreaCoreXF extends StiClusteredBarAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly seriesOrientation: StiChartSeriesOrientation;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaCoreXF extends StiAreaCoreXF {
        applyStyle(style: IStiChartStyle): void;
        valuesCount: number;
        points: PointD[];
        arguments: Object[];
        centerPoint: PointD;
        render(context: StiContext, areaRect: RectangleD): StiCellGeom;
        private static centerArea;
        measureLabels(context: StiContext, rect: RectangleD): RectangleD;
        renderArguments(context: StiContext, geom: StiRadarAreaGeom, series: IStiSeries): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        protected prepareInfo(rect: RectangleD): void;
        protected createStripLinesAxis(axis: IStiYRadarAxis, minimum: number, maximum: number): void;
        private calculateStep;
        calculatePositions(axis: IStiYRadarAxis, REFcollection: any, step: number): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRadarAreaAreaCoreXF extends StiRadarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRadarLineAreaCoreXF extends StiRadarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRadarPointAreaCoreXF extends StiRadarAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiRangeBarAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        protected createStripLinesXAxis(axis: IStiAxis): void;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSplineRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiSteppedRangeAreaCoreXF extends StiClusteredColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        protected prepareRange(specXAxis: IStiAxis, specXTopAxis: IStiAxis, specYAxis: IStiAxis, specYRightAxis: IStiAxis): void;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedLineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedSplineAreaAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStackedSplineAreaCoreXF extends StiStackedColumnAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStockAreaCoreXF extends StiCandlestickAreaCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaCoreXF extends StiAreaCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderSeries(context: StiContext, boxes: RectangleD[], boxRoot: RectangleD, geom: StiAreaGeom, seriesCollection: IStiSeries[]): void;
        private cutArea;
        squarify(data: number[], currentrow: number[], container: RectangleD, stack: RectangleD[]): RectangleD[];
        private improvesRatio;
        private calculateRatio;
        normalizeDataForArea(data: number[], area: number): number[];
        private getCoordinates;
        prepareInfo(rect: RectangleD): void;
        readonly localizedName: string;
        readonly position: number;
        constructor(area: IStiArea);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStripLineCalculatorXF {
        private static getInterval1;
        static getInterval(minValue: number, maxValue: number, num: number): number;
        static getStripLines(minValue: number, maxValue: number, step: number, asDateTimeValue: boolean): StiStripLinesXF;
        private static getCountAfterComma;
        static getStripLinesLogScale(minValue: number, maxValue: number): StiStripLinesXF;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStripLineXF implements IStiStripLineXF {
        private static implementsStiStripLineXF;
        implements(): string[];
        private _valueObject;
        valueObject: Object;
        private valueObj;
        value: number;
        constructor(valueObject: Object, value: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripLinesXF extends CollectionBase<StiStripLineXF> implements IStiStripLinesXF {
        private static implementsStiStripLinesXF;
        implements(): string[];
        add(valueObject: Object, value: number): void;
        add2(line: StiStripLineXF): void;
        addRange(lines: StiStripLineXF[]): void;
        contains(value: StiStripLineXF): boolean;
        indexOf(value: StiStripLineXF): number;
        insert(index: number, value: StiStripLineXF): void;
        remove(value: StiStripLineXF): void;
        getByindex(index: number): StiStripLineXF;
        setByIndex(index: number, value: StiStripLineXF): void;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStripPositionXF implements IStiStripPositionXF {
        private static implementsStiStripPositionXF;
        implements(): string[];
        position: number;
        stripLine: StiStripLineXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisCoreXF implements ICloneable, IStiApplyStyle, IStiAxisCoreXF {
        private static implementsStiAxisCoreXF;
        implements(): string[];
        clone(): StiAxisCoreXF;
        private _isMouseOverDecreaseButton;
        isMouseOverDecreaseButton: boolean;
        private _isMouseOverIncreaseButton;
        isMouseOverIncreaseButton: boolean;
        private _isMouseOverTrackBar;
        isMouseOverTrackBar: boolean;
        applyStyle(style: IStiChartStyle): void;
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getTicksMaxLength(context: StiContext): number;
        getArrowHeight(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getFontGeom(context: StiContext): StiFontGeom;
        getTextAlignment(): StiHorAlignment;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        protected getAxisTitleSize(context: StiContext): SizeD;
        protected getAngleTitle(): number;
        protected getCorrectionFontSize(axisRect: Rectangle, titleRect: Rectangle, currentFontSize: number): number;
        protected checkUseMaxWidth(axisRect: Rectangle, titleRect: Rectangle, RefMaxWidth: any): boolean;
        static defaultScrollBarSize: number;
        static defaultScrollBarSmallFactor: number;
        static defaultScrollBarFirstRecallTime: number;
        static defaultScrollBarOtherRecallTime: number;
        readonly ticksMaxLength: number;
        readonly arrowWidth: number;
        readonly arrowHeight: number;
        private _axis;
        axis: IStiAxis;
        info: StiAxisInfoXF;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInfoXF implements ICloneable, IStiAxisInfoXF {
        private static implementsStiAxisInfoXF;
        implements(): string[];
        clone(): StiAxisInfoXF;
        dpi: number;
        step: number;
        readonly range: number;
        stripLines: StiStripLinesXF;
        stripPositions: number[];
        ticksCollection: StiStripPositionXF[];
        labelsCollection: StiStripPositionXF[];
        minimum: number;
        _maximum: number;
        maximum: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAxisLabelInfoXF {
        clientRectangle: RectangleD;
        textPoint: PointD;
        angle: number;
        rotationMode: StiRotationMode;
        text: string;
        stripLine: StiStripLineXF;
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiAxisLabelsCoreXF {
        private static implementsStiAxisLabelsCoreXF;
        implements(): string[];
        clone(): StiAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _labels;
        labels: IStiAxisLabels;
        constructor(labels: IStiAxisLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTitleCoreXF implements IStiApplyStyle, ICloneable, IStiAxisTitleCoreXF {
        private static implementsStiAxisTitleCoreXF;
        implements(): string[];
        clone(): StiAxisTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _title;
        title: IStiAxisTitle;
        constructor(title: IStiAxisTitle);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisCoreXF extends StiAxisCoreXF {
        getStartFromZero(): boolean;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiXAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        private readonly isLabelsAngleByWidth;
        private checkAutoAngleLabels;
        private measureStripLines;
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsWidth: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels;
        private renderTitle;
        private isArgumentDateTime1;
        private isArgumentDateTime2;
        readonly dock: StiXAxisDock;
        readonly isTopSide: boolean;
        readonly isBottomSide: boolean;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiXBottomAxisCoreXF extends StiXAxisCoreXF {
        readonly dock: StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiXTopAxisCoreXF extends StiXAxisCoreXF {
        readonly dock: StiXAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Events {
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import EventArgs = Stimulsoft.System.EventArgs;
    class StiGetTitleEventArgs extends EventArgs {
        private valueObject;
        value: string;
        private _index;
        index: number;
        private _series;
        series: IStiSeries;
    }
}
declare module Stimulsoft.Report.Events {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    class StiNewAutoSeriesEventArgs extends EventArgs {
        private _seriesIndex;
        seriesIndex: number;
        private _color;
        color: Object;
        private _series;
        series: IStiSeries;
        constructor(seriesIndex: number, series: IStiSeries, color: Object);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiChartHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static fillSeriesData(series: StiSeries, items: StiDataItem[]): void;
        static getFilterData(report: StiReport, filter: StiChartFilter, filterMethodName: string): Object;
        static getFilterResult(filter: StiChartFilter, itemArgument: Object, itemValue: Object, itemValueEnd: Object, itemValueOpen: Object, itemValueClose: Object, itemValueLow: Object, itemValueHigh: Object, data: Object): boolean;
        static convertStringToColor(colorStr: string): Object;
        static createChart(masterChart: StiChart, chartComp: StiChart): void;
        static getShorterListPoints(series: StiSeries): PointD[];
        private static checkParetoValues;
        private static checkValueNaN;
        private static checkArgumentsDateTimeStep;
        private static createValuesTopN;
        private static getNextDate;
        private static getKey;
        private static sortArray;
        private static findIndex;
        private static getValueForDate;
        private static getTotalTimeSpans;
        private static isArgumentsDateTime;
        private static maximumDate;
        private static minimumDate;
        private static getAutoSeriesColorFromautoSeriesColorDataColumn;
        private static getAutoSeriesTitleFromAutoSeriesTitleDataColumn;
        private static getAutoSeriesKeysFromAutoSeriesKeyDataColumn;
        private static setTitle;
        private static setCutPieList;
        private static getArguments;
        private static getArgumentsFromArgumentExpression;
        private static getArgumentsFromArgumentDataColumn;
        private static getArgumentsFromListOfArguments;
        private static getValues;
        private static getValuesFromValueExpression;
        private static getValuesFromValueDataColumn;
        private static getValuesFromListOfValues;
        private static getValuesEnd;
        private static getValuesEndFromValueEndExpression;
        private static getValuesEndFromValueDataColumnEnd;
        private static getValuesEndFromListOfValuesEnd;
        private static getValuesOpen;
        private static getValuesOpenFromValuesOpenExpression;
        private static getValuesOpenFromValueDataColumnOpen;
        private static getValuesOpenFromListOfValuesOpen;
        private static getValuesClose;
        private static getValuesCloseFromValuesCloseExpression;
        private static getValuesCloseFromValueDataColumnClose;
        private static getValuesCloseFromListOfValuesClose;
        private static getValuesHigh;
        private static getValuesHighFromValuesHighExpression;
        private static getValuesHighFromValueDataColumnHigh;
        private static getValuesHighFromListOfValuesHigh;
        private static getValuesLow;
        private static getValuesLowFromValuesLowExpression;
        private static getValuesLowFromValueDataColumnLow;
        private static getValuesLowFromListOfValuesLow;
        private static getWeights;
        private static getWeightsWeightExpression;
        private static getWeightsFromWeightDataColumn;
        private static getWeightsFromListOfWeights;
        private static getHyperlinks;
        private static getHyperlinksFromHyperlinkExpression;
        private static getHyperlinksFromHyperlinkDataColumn;
        private static getHyperlinksFromListOfHyperlinks;
        private static getTags;
        private static getTagsFromTagExpression;
        private static getTagsFromTagDataColumn;
        private static getTagsFromListOfTags;
        private static getToolTips;
        private static getToolTipsFromToolTipExpression;
        private static getToolTipsFromToolTipDataColumn;
        private static getToolTipsFromListOfToolTips;
    }
}
declare module Stimulsoft.Report.Events {
    class StiProcessChartEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    class StiArea extends StiService implements IStiJsonReportObject, IStiArea, ICloneable {
        private static implementsStiArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiArea;
        static loadAreaFromXml(xmlNode: XmlNode, chart: Stimulsoft.Report.Components.StiChart): StiArea;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiArea;
        createNew(): StiArea;
        toString(): string;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        readonly isDefaultSeriesTypeFullStackedColumnSeries: boolean;
        readonly isDefaultSeriesTypeFullStackedBarSeries: boolean;
        private _core;
        core: StiAreaCoreXF;
        private _chart;
        chart: IStiChart;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _colorEach;
        colorEach: boolean;
        private _showShadow;
        showShadow: boolean;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarArea extends StiArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable {
        private static implementsStiRadarArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarArea;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        private _interlacingHor;
        interlacingHor: IStiInterlacingHor;
        private _interlacingVert;
        interlacingVert: IStiInterlacingVert;
        private _gridLinesHor;
        gridLinesHor: IStiRadarGridLinesHor;
        private _gridLinesVert;
        gridLinesVert: IStiRadarGridLinesVert;
        private _radarStyle;
        radarStyle: StiRadarStyle;
        private _xAxis;
        xAxis: IStiXRadarAxis;
        private _yAxis;
        yAxis: IStiYRadarAxis;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartCoreXF implements ICloneable, IStiApplyStyle, IStiChartCoreXF {
        private static implementsStiChartCoreXF;
        implements(): string[];
        clone(): Object;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD, useMargins: boolean): StiCellGeom;
        private setLegendRect;
        private _chart;
        chart: IStiChart;
        constructor(chart: IStiChart);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTable implements IStiJsonReportObject, IStiChartTable, ICloneable {
        private static implementsStiChartTable;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiChartTable;
        font: Font;
        private _visible;
        visible: boolean;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _markerVisible;
        markerVisible: boolean;
        private _gridLineColor;
        gridLineColor: Color;
        textColor: Color;
        private _gridLinesHor;
        gridLinesHor: boolean;
        private _gridLinesVert;
        gridLinesVert: boolean;
        private _gridOutline;
        gridOutline: boolean;
        private _format;
        format: string;
        private _header;
        header: IStiChartTableHeader;
        private _core;
        core: StiChartTableCoreXF;
        private _dataCells;
        dataCells: StiChartTableDataCells;
        private _chart;
        chart: IStiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTitle implements IStiChartTitle, ICloneable, IStiJsonReportObject {
        private static implementsStiChartTitle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiChartTitle;
        private _core;
        core: StiChartTitleCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _brush;
        brush: StiBrush;
        private _antialiasing;
        antialiasing: boolean;
        private _alignment;
        alignment: StringAlignment;
        private _dock;
        dock: StiChartTitleDock;
        private _spacing;
        spacing: number;
        private _visible;
        visible: boolean;
        private _chart;
        chart: IStiChart;
        constructor(font?: Font, text?: string, brush?: StiBrush, antialiasing?: boolean, alignment?: StringAlignment, dock?: StiChartTitleDock, spacing?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiStripsCollection extends CollectionBase<IStiStrips> implements IStiJsonReportObject, IStiApplyStyle, IStiStripsCollection {
        private static implementsStiStripsCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getStripsTitle;
        private addCore;
        add(value: IStiStrips): void;
        addRange(values: IStiStrips[]): void;
        addRange2(values: StiStripsCollection): void;
        contains(value: IStiStrips): boolean;
        indexOf(value: IStiStrips): number;
        insert(index: number, value: IStiStrips): void;
        onClear(): void;
        remove(value: IStiStrips): void;
        getByIndex(index: number): IStiStrips;
        setByIndex(index: number, value: IStiStrips): void;
        stripsAdded: Function;
        onStripsAdded(e: EventArgs): void;
        private invokeStripsAdded;
        stripsRemoved: Function;
        onStripsRemoved(e: EventArgs): void;
        private invokeStripsRemoved;
        private _chart;
        chart: StiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiConstantLinesCollection extends CollectionBase<IStiConstantLines> implements IStiJsonReportObject, IStiApplyStyle, IStiConstantLinesCollection {
        private static implementsStiConstantLinesCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        applyStyle(style: IStiChartStyle): void;
        private getConstantLineTitle;
        private addCore;
        add(value: IStiConstantLines): void;
        addRange(values: IStiConstantLines[]): void;
        addRange2(values: StiConstantLinesCollection): void;
        contains(value: IStiConstantLines): boolean;
        indexOf(value: IStiConstantLines): number;
        insert(index: number, value: IStiConstantLines): void;
        onClear(): void;
        remove(value: IStiConstantLines): void;
        getByIndex(index: number): IStiConstantLines;
        setByIndex(index: number, value: IStiConstantLines): void;
        constantLinesAdded: Function;
        onConstantLinesAdded(e: EventArgs): void;
        private invokeConstantLinesAdded;
        constantLinesRemoved: Function;
        onConstantLinesRemoved(e: EventArgs): void;
        private invokeConstantLinesRemoved;
        private _chart;
        chart: StiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiSeriesLabels extends StiService implements IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiSeriesLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static loadFromJsonObjectInternal(jObject: StiJson, chart: StiChart): IStiSeriesLabels;
        static loadLabelsFromXml(xmlNode: XmlNode, chart: StiChart): StiSeriesLabels;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiSeriesLabels;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _preventIntersection;
        preventIntersection: boolean;
        private _core;
        core: StiSeriesLabelsCoreXF;
        readonly axisCore: StiAxisSeriesLabelsCoreXF;
        readonly pieCore: StiPieSeriesLabelsCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        conditions: StiChartConditionsCollection;
        showOnZeroValues: boolean;
        private _showZeros;
        showZeros: boolean;
        private _showNulls;
        showNulls: boolean;
        private _markerVisible;
        markerVisible: boolean;
        private _markerSize;
        markerSize: SizeD;
        private _markerAlignment;
        markerAlignment: StiMarkerAlignment;
        private _step;
        step: number;
        private _valueType;
        valueType: StiSeriesLabelsValueType;
        private _valueTypeSeparator;
        valueTypeSeparator: string;
        private _legendValueType;
        legendValueType: StiSeriesLabelsValueType;
        private _textBefore;
        textBefore: string;
        private _textAfter;
        textAfter: string;
        private _angle;
        angle: number;
        private _format;
        format: string;
        private _antialiasing;
        antialiasing: boolean;
        private _visible;
        visible: boolean;
        private _drawBorder;
        drawBorder: boolean;
        private _useSeriesColor;
        useSeriesColor: boolean;
        private _labelColor;
        labelColor: Color;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _font;
        font: Font;
        private _chart;
        chart: IStiChart;
        private _wordWrap;
        wordWrap: boolean;
        private _width;
        width: number;
        toString(): string;
        createNew(): StiSeriesLabels;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels {
        private static implementsStiAxisSeriesLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _showInPercent;
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterAxisLabels extends StiAxisSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, ICloneable {
        private static implementsStiCenterAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiAxis implements IStiAxis, IStiJsonReportObject {
        private static implementsStiAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxis;
        private _logarithmicScale;
        logarithmicScale: boolean;
        private _core;
        core: StiAxisCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _startFromZero;
        startFromZero: boolean;
        step: number;
        private _interaction;
        interaction: IStiAxisInteraction;
        private _labels;
        labels: IStiAxisLabels;
        private _range;
        range: IStiAxisRange;
        private _title;
        title: IStiAxisTitle;
        private _ticks;
        ticks: IStiAxisTicks;
        private _arrowStyle;
        arrowStyle: StiArrowStyle;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _visible;
        visible: boolean;
        titleDirection: StiLegendDirection;
        private _area;
        area: IStiAxisArea;
        private _info;
        info: StiAxisInfoXF;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYAxis extends StiAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis {
        private static implementsStiYAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        private _showYAxis;
        showYAxis: StiShowYAxis;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYRightAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYRightAxis {
        private static implementsStiYRightAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXAxis extends StiAxis implements IStiJsonReportObject, IStiAxis, IStiXAxis, ICloneable {
        private static implementsStiXAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        private _showEdgeValues;
        showEdgeValues: boolean;
        private _showXAxis;
        showXAxis: StiShowXAxis;
        private _dateTimeStep;
        dateTimeStep: IStiAxisDateTimeStep;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXTopAxis extends StiXAxis implements IStiXTopAxis, ICloneable, IStiAxis, IStiXAxis, IStiJsonReportObject {
        private static implementsStiXTopAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiYLeftAxis extends StiYAxis implements IStiJsonReportObject, IStiYAxis, ICloneable, IStiAxis, IStiYLeftAxis {
        private static implementsStiYLeftAxis;
        implements(): string[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showYAxis?: StiShowYAxis, allowApplyStyle?: boolean, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisLabels implements IStiJsonReportObject, IStiAxisLabels, ICloneable {
        private static implementsStiAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisLabels;
        private _core;
        core: StiAxisLabelsCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _format;
        format: string;
        private _angle;
        angle: number;
        private _width;
        width: number;
        private _textBefore;
        textBefore: string;
        private _textAfter;
        textAfter: string;
        private _font;
        font: Font;
        private _antialiasing;
        antialiasing: boolean;
        private _placement;
        placement: StiLabelsPlacement;
        private _color;
        color: Color;
        private _textAlignment;
        textAlignment: StiHorAlignment;
        private _step;
        step: number;
        private _wordWrap;
        wordWrap: boolean;
        /**
         *  DBS use only!
         */
        formatService: StiFormatService;
        constructor(format?: string, textBefore?: string, textAfter?: string, angle?: number, font?: Font, antialiasing?: boolean, placement?: StiLabelsPlacement, color?: Color, width?: number, textAlignment?: StiHorAlignment, step?: number, allowApplyStyle?: boolean, wordWrap?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisRange implements IStiJsonReportObject, ICloneable, IStiAxisRange {
        private static implementsStiAxisRange;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisRange;
        private _minimum;
        minimum: number;
        private _maximum;
        maximum: number;
        private _auto;
        auto: boolean;
        constructor(auto?: boolean, minimum?: number, maximum?: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisTicks implements IStiJsonReportObject, IStiAxisTicks, ICloneable {
        private static implementsStiAxisTicks;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisTicks;
        private _lengthUnderLabels;
        lengthUnderLabels: number;
        private _length;
        length: number;
        private _minorLength;
        minorLength: number;
        private _minorCount;
        minorCount: number;
        private _step;
        step: number;
        private _minorVisible;
        minorVisible: boolean;
        private _visible;
        visible: boolean;
        constructor(visible?: boolean, length?: number, minorVisible?: boolean, minorLength?: number, minorCount?: number, step?: number, lengthUnderLabels?: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisInteraction implements IStiJsonReportObject, IStiAxisInteraction, ICloneable {
        private static implementsStiAxisInteraction;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisInteraction;
        private _showScrollBar;
        showScrollBar: boolean;
        private _rangeScrollEnabled;
        rangeScrollEnabled: boolean;
        constructor(showScrollBar?: boolean, rangeScrollEnabled?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    class StiAxisDateTimeStep implements IStiAxisDateTimeStep, IStiJsonReportObject {
        private static implementsStiAxisDateTimeStep;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisDateTimeStep;
        private _step;
        step: StiTimeDateStep;
        private _numberOfValues;
        numberOfValues: number;
        private _interpolation;
        interpolation: boolean;
        constructor(step?: StiTimeDateStep, numberOfValues?: number, interpolation?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiXBottomAxis extends StiXAxis implements IStiJsonReportObject, IStiXAxis, ICloneable, IStiXBottomAxis, IStiAxis {
        private static implementsStiXBottomAxis;
        implements(): string[];
        constructor(labels?: IStiAxisLabels, range?: IStiAxisRange, title?: IStiAxisTitle, ticks?: IStiAxisTicks, interaction?: IStiAxisInteraction, arrowStyle?: StiArrowStyle, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, startFromZero?: boolean, showXAxis?: StiShowXAxis, showEdgeValues?: boolean, allowApplyStyle?: boolean, dateTimeStep?: IStiAxisDateTimeStep, logarithmicScale?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable {
        private static implementsStiGridLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiGridLines;
        private _core;
        core: StiGridLinesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _color;
        color: Color;
        private _minorColor;
        minorColor: Color;
        private _style;
        style: StiPenStyle;
        private _minorStyle;
        minorStyle: StiPenStyle;
        private _visible;
        visible: boolean;
        private _minorVisible;
        minorVisible: boolean;
        private _minorCount;
        minorCount: number;
        private _area;
        area: IStiArea;
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesVert extends StiGridLines implements IStiJsonReportObject, IStiGridLines, ICloneable, IStiGridLinesVert {
        private static implementsStiGridLinesVert;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiGridLinesHor extends StiGridLines implements IStiJsonReportObject, IStiGridLines, IStiGridLinesHor, ICloneable {
        private static implementsStiGridLinesHor;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, minorColor?: Color, minorStyle?: StiPenStyle, minorVisible?: boolean, minorCount?: number, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacing implements IStiInterlacing, ICloneable, IStiJsonReportObject {
        private static implementsStiInterlacing;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiInterlacing;
        private _core;
        core: StiInterlacingCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _interlacedBrush;
        interlacedBrush: StiBrush;
        private _visible;
        visible: boolean;
        private _area;
        area: IStiArea;
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingVert extends StiInterlacing implements IStiInterlacingVert {
        private static implementsStiInterlacingVert;
        implements(): string[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiInterlacingHor extends StiInterlacing implements IStiInterlacing, IStiInterlacingHor, IStiJsonReportObject, ICloneable {
        private static implementsStiInterlacingHor;
        implements(): string[];
        constructor(interlacedBrush?: StiBrush, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAxisArea extends StiArea implements IStiJsonReportObject, IStiAxisArea, IStiArea, ICloneable {
        private static implementsStiAxisArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisArea;
        readonly axisCore: StiAxisAreaCoreXF;
        private _interlacingHor;
        interlacingHor: IStiInterlacingHor;
        private _interlacingVert;
        interlacingVert: IStiInterlacingVert;
        private _gridLinesHor;
        gridLinesHor: IStiGridLinesHor;
        private _gridLinesHorRight;
        gridLinesHorRight: IStiGridLinesHor;
        private _gridLinesVert;
        gridLinesVert: IStiGridLinesVert;
        private _yAxis;
        yAxis: IStiYAxis;
        private _yRightAxis;
        yRightAxis: IStiYAxis;
        private _xAxis;
        xAxis: IStiXAxis;
        private _xTopAxis;
        xTopAxis: IStiXAxis;
        private _reverseHor;
        reverseHor: boolean;
        private _reverseVert;
        reverseVert: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiClusteredColumnArea, IStiAxisArea, ICloneable, IStiArea {
        private static implementsStiClusteredColumnArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiSeriesCollection extends CollectionBase<IStiSeries> implements IStiJsonReportObject, IStiApplyStyle, IStiSeriesCollection {
        private static implementsStiSeriesCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, chart: StiChart): void;
        applyStyle(style: IStiChartStyle): void;
        private getSeriesTitle;
        private addCore;
        add(value: IStiSeries): void;
        addRange(values: IStiSeries[]): void;
        addRange2(values: StiSeriesCollection): void;
        contains(value: IStiSeries): boolean;
        indexOf(value: IStiSeries): number;
        insert(index: number, value: IStiSeries): void;
        onClear(): void;
        remove(value: IStiSeries): void;
        getByIndex(index: number): IStiSeries;
        setByIndex(index: number, value: IStiSeries): void;
        getByName(name: string): IStiSeries;
        setByName(index: number, value: IStiSeries): void;
        seriesAdded: Function;
        onSeriesAdded(e: EventArgs): void;
        private invokeSeriesAdded;
        onRemove(index: number, value: Object): void;
        seriesRemoved: Function;
        onSeriesRemoved(e: EventArgs): void;
        private invokeSeriesRemoved;
        private _chart;
        chart: StiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
    import StiText = Stimulsoft.Report.Components.StiText;
    class StiChartInfo extends StiComponentInfo implements IStiChartInfo {
        private static implementsStiChartInfo;
        implements(): string[];
        storedForProcessAtEndChart: StiChart;
        interactiveComps: StiText[];
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartStyle extends StiBaseStyle implements IStiJsonReportObject, IStiChartStyle, ICloneable {
        private static implementsStiChartStyle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromXml(xmlNode: XmlNode): StiChartStyle;
        static loadFromJsonObjectInternal(jObject: StiJson): StiChartStyle;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        readonly isOffice2015Style: boolean;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        private _core;
        core: StiStyleCoreXF;
        toString(): string;
        compareChartStyle(style: StiChartStyle): boolean;
        createNew(): StiChartStyle;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle25 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle29 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiLegend implements IStiJsonReportObject, ICloneable, IStiLegend {
        private static implementsStiLegend;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiLegend;
        private _core;
        core: StiLegendCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _chart;
        chart: IStiChart;
        private _hideSeriesWithEmptyTitle;
        hideSeriesWithEmptyTitle: boolean;
        private _showShadow;
        showShadow: boolean;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _titleColor;
        titleColor: Color;
        private _labelsColor;
        labelsColor: Color;
        private _direction;
        direction: StiLegendDirection;
        private _horAlignment;
        horAlignment: StiLegendHorAlignment;
        private _vertAlignment;
        vertAlignment: StiLegendVertAlignment;
        private _titleFont;
        titleFont: Font;
        private _font;
        font: Font;
        private _visible;
        visible: boolean;
        private _markerVisible;
        markerVisible: boolean;
        private _markerBorder;
        markerBorder: boolean;
        private _markerSize;
        markerSize: SizeD;
        private _markerAlignment;
        markerAlignment: StiMarkerAlignment;
        private _columns;
        columns: number;
        private _horSpacing;
        horSpacing: number;
        private _vertSpacing;
        vertSpacing: number;
        private _size;
        size: SizeD;
        private _title;
        title: string;
        constructor();
    }
}
declare module Stimulsoft.Report.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiProcessChartEvent = Stimulsoft.Report.Events.StiProcessChartEvent;
    import EventArgs = Stimulsoft.System.EventArgs;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiChartConditionsCollection = Stimulsoft.Report.Chart.StiChartConditionsCollection;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiChartTable = Stimulsoft.Report.Chart.IStiChartTable;
    import IStiChartTitle = Stimulsoft.Report.Chart.IStiChartTitle;
    import IStiLegend = Stimulsoft.Report.Chart.IStiLegend;
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiChartCoreXF = Stimulsoft.Report.Chart.StiChartCoreXF;
    import StiChartInfo = Stimulsoft.Report.Chart.StiChartInfo;
    import StiConstantLinesCollection = Stimulsoft.Report.Chart.StiConstantLinesCollection;
    import IStiChartStyle = Stimulsoft.Report.Chart.IStiChartStyle;
    import StiStripsCollection = Stimulsoft.Report.Chart.StiStripsCollection;
    import StiSeriesCollection = Stimulsoft.Report.Chart.StiSeriesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
    import StiComponentType = Stimulsoft.Report.Components.StiComponentType;
    import StiDataRelation = Stimulsoft.Report.Dictionary.StiDataRelation;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Image = Stimulsoft.System.Drawing.Image;
    class StiChart extends StiComponent implements IStiBorder, IStiBusinessObject, IStiBrush, IStiDataSource, IStiDataRelation, IStiMasterComponent, IStiSort, IStiFilter, IStiExportImage, IStiExportImageExtended, IStiIgnoryStyle, IStiGlobalizationProvider, IStiChart, IStiJsonReportObject {
        private static implementsStiChart;
        implements(): string[];
        jsonMasterComponentTemp: string;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        convertToHInches(value: number): number;
        setString(propertyName: string, value: string): void;
        getString(propertyName: string): string;
        getAllStrings(): string[];
        clone(): StiChart;
        saveState(stateName: string): void;
        restoreState(stateName: string): void;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _filterMethodHandler;
        filterMethodHandler: Function;
        private _filterMode;
        filterMode: StiFilterMode;
        private _filters;
        filters: StiFiltersCollection;
        filter: string;
        private _filterOn;
        filterOn: boolean;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        private _sort;
        sort: string[];
        readonly dataSource: StiDataSource;
        private _dataSourceName;
        dataSourceName: string;
        readonly isDataSourceEmpty: boolean;
        readonly isBusinessObjectEmpty: boolean;
        readonly businessObject: StiBusinessObject;
        private _businessObjectGuid;
        businessObjectGuid: string;
        private _masterComponent;
        masterComponent: StiComponent;
        private _countData;
        countData: number;
        first(): void;
        prior(): void;
        next(): void;
        last(): void;
        isEofValue: boolean;
        isEof: boolean;
        isBofValue: boolean;
        isBof: boolean;
        readonly isEmpty: boolean;
        positionValue: number;
        position: number;
        readonly count: number;
        private isCacheValues;
        private cachedCount;
        private cachedIsBusinessObjectEmpty;
        private cachedIsDataSourceEmpty;
        private cachedDataSource;
        private cachedBusinessObject;
        cacheValues(cache: boolean): void;
        readonly dataRelation: StiDataRelation;
        private _dataRelationName;
        dataRelationName: string;
        private _processAtEnd;
        processAtEnd: boolean;
        readonly priority: number;
        readonly localizedCategory: string;
        defaultClientRectangle: Rectangle;
        readonly componentType: StiComponentType;
        readonly localizedName: string;
        invokeEvents(): void;
        protected onProcessChart(e: EventArgs): void;
        invokeProcessChart(sender: Object, e: EventArgs): void;
        processChartEvent: StiProcessChartEvent;
        private series_SeriesAdded;
        private series_SeriesRemoved;
        private _seriesLabelsConditions;
        seriesLabelsConditions: StiChartConditionsCollection;
        chartType: IStiArea;
        private _isDashboard;
        isDashboard: boolean;
        createNew(): StiComponent;
        applyStyle(): void;
        simplifyValues(): void;
        private _core;
        core: StiChartCoreXF;
        private _rotation;
        rotation: StiImageRotation;
        private _series;
        series: StiSeriesCollection;
        private _area;
        area: IStiArea;
        private _table;
        table: IStiChartTable;
        private _style;
        style: IStiChartStyle;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _customStyleName;
        customStyleName: string;
        private _horSpacing;
        horSpacing: number;
        private _vertSpacing;
        vertSpacing: number;
        private _seriesLabels;
        seriesLabels: IStiSeriesLabels;
        private _legend;
        legend: IStiLegend;
        private _title;
        title: IStiChartTitle;
        private _strips;
        strips: StiStripsCollection;
        private _constantLines;
        constantLines: StiConstantLinesCollection;
        private _isAnimation;
        isAnimation: boolean;
        private _chartInfo;
        readonly chartInfo: StiChartInfo;
        constructor(rect?: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisCoreXF extends StiAxisCoreXF {
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        renderView(context: StiContext, rect: RectangleD): StiCellGeom;
        renderScrollBar(context: StiContext, axisRect: RectangleD, axisGeom: StiYAxisViewGeom): void;
        renderCenter(context: StiContext, rect: RectangleD): StiCellGeom;
        renderCenterView(context: StiContext, rect: RectangleD): StiCellGeom;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        private measureStripLines;
        getCenterAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean, includeScrollBar: boolean): RectangleD;
        private renderLabels;
        private renderTitle;
        readonly dock: StiYAxisDock;
        readonly isLeftSide: boolean;
        readonly isRightSide: boolean;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiYLeftAxisCoreXF extends StiYAxisCoreXF {
        readonly dock: StiYAxisDock;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiYRightAxisCoreXF extends StiYAxisCoreXF {
        readonly dock: StiYAxisDock;
        getStartFromZero(): boolean;
        constructor(axis: IStiAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleCoreXF implements ICloneable, IStiApplyStyle, IStiChartTitleCoreXF {
        private static implementsStiChartTitleCoreXF;
        implements(): string[];
        clone(): StiChartTitleCoreXF;
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, chartTitle: IStiChartTitle, rect: RectangleD): StiCellGeom;
        private _chartTitle;
        chartTitle: IStiChartTitle;
        constructor(chartTitle: IStiChartTitle);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiConstantLinesCoreXF implements IStiApplyStyle, ICloneable, IStiConstantLinesCoreXF {
        private static implementsStiConstantLinesCoreXF;
        implements(): string[];
        clone(): Object;
        applyStyle(style: IStiChartStyle): void;
        renderXConstantLines(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        renderYConstantLines(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private _constantLines;
        constantLines: IStiConstantLines;
        constructor(constantLines: IStiConstantLines);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiGridLinesCoreXF {
        private static implementsStiGridLinesCoreXF;
        implements(): string[];
        clone(): StiGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _gridLines;
        gridLines: IStiGridLines;
        constructor(gridLines: IStiGridLines);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarGridLinesCoreXF implements IStiApplyStyle, ICloneable, IStiRadarGridLinesCoreXF {
        private static implementsStiRadarGridLinesCoreXF;
        implements(): string[];
        clone(): StiRadarGridLinesCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _gridLines;
        gridLines: IStiRadarGridLines;
        constructor(gridLines: IStiRadarGridLines);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInterlacingCoreXF implements IStiApplyStyle, ICloneable, IStiInterlacingCoreXF {
        private static implementsStiInterlacingCoreXF;
        implements(): string[];
        clone(): StiInterlacingCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _interlacing;
        interlacing: IStiInterlacing;
        constructor(interlacing: IStiInterlacing);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import RectangleF = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLegendCoreXF implements ICloneable, IStiApplyStyle, IStiLegendCoreXF {
        private static implementsStiLegendCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiLegendCoreXF;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        getMatrixIndexItem(countColumns: number, countRows: number, countItems: number): number[][];
        getArgumentText(series: IStiSeries, index: number): string;
        getLegendItemColumn(seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): number;
        getTitleSize(context: StiContext): SizeD;
        getItemSize1(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesIndex: number): SizeD;
        getItemSize2(context: StiContext, seriesItems: StiLegendItemCoreXF[], seriesItem: StiLegendItemCoreXF): SizeD;
        getItemRealSize(context: StiContext, seriesItem: StiLegendItemCoreXF): SizeD;
        getItemsSize(context: StiContext, seriesItems: StiLegendItemCoreXF[]): SizeD;
        getItemsAutoSize(context: StiContext, seriesItems: StiLegendItemCoreXF[], rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getSeriesSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendSize(context: StiContext, rect: RectangleF, countColumns: any, countRows: any): SizeD;
        getLegendItems(REFcount: any): StiLegendItemCoreXF[];
        private _legend;
        legend: IStiLegend;
        constructor(legend: IStiLegend);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiLegendItemCoreXF {
        private _text;
        readonly text: string;
        private _series;
        readonly series: IStiSeries;
        private _index;
        readonly index: number;
        private _colorIndex;
        readonly colorIndex: number;
        constructor(text: string, series: IStiSeries, index: number, colorIndex: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiMarkerCoreXF implements ICloneable, IStiMarkerCoreXF {
        private static implementsStiMarkerCoreXF;
        implements(): string[];
        clone(): StiMarkerCoreXF;
        drawMarkers(context: StiContext, points: PointD[], showShadow: boolean): void;
        static getMarkerRect(position: PointD, markerSize: number, zoom: number): RectangleD;
        draw(context: StiContext, marker: IStiMarker, position: PointD, zoom: number, showShadow: boolean, isMouseOver: boolean, isTooltipMode: boolean, isAnimation: boolean, toolTip: String, tag: Object, interaction: StiInteractionDataGeom): void;
        drawLine(context: StiContext, x1: number, y1: number, x2: number, y2: number, scale: number, brushMarker: StiBrush, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawLines(context: StiContext, points: PointD[], scale: number, brushMarker: Object, penMarker: StiPenGeom, markerType: StiMarkerType, markerStep: number, markerSize: number, angle: number): void;
        drawPoint(context: StiContext, x: number, y: number, scale: number, brush: Object, pen: StiPenGeom, markerType: StiMarkerType, markerSize: number, angle: number, isMouseOver: boolean, isAnimation: boolean, toolTip: String, tag: Object, interaction: StiInteractionDataGeom): void;
        private drawPolygon;
        private _marker;
        marker: IStiMarker;
        constructor(marker: IStiMarker);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisCoreXF implements ICloneable, IStiApplyStyle, IStiRadarAxisCoreXF {
        private static implementsStiRadarAxisCoreXF;
        implements(): string[];
        clone(): StiRadarAxisCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _axis;
        axis: IStiRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxisLabelsCoreXF implements IStiApplyStyle, ICloneable, IStiRadarAxisLabelsCoreXF {
        private static implementsStiRadarAxisLabelsCoreXF;
        implements(): string[];
        clone(): StiRadarAxisLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        private _labels;
        labels: IStiRadarAxisLabels;
        constructor(labels: IStiRadarAxisLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiXRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiXRadarAxisCoreXF {
        private static implementsStiXRadarAxisCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        renderLabel(context: StiContext, series: IStiSeries, point: PointD, argument: Object, angle: number, colorIndex: number, colorCount: number): StiXRadarAxisLabelGeom;
        getLabelText(value: Object): string;
        getLabelRect(context: StiContext, point: PointD, text: string, angle: number): RectangleD;
        readonly xAxis: IStiXRadarAxis;
        constructor(axis: IStiRadarAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisCoreXF extends StiRadarAxisCoreXF implements IStiYRadarAxisCoreXF {
        private static implementsStiYRadarAxisCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private measureStripLines;
        private renderLabels;
        calculateStripPositions(topPosition: number, bottomPosition: number): void;
        getAxisRect(context: StiContext, rect: RectangleD, includeAxisArrow: boolean, includeLabelsHeight: boolean, isDrawing: boolean): RectangleD;
        getTicksMaxLength(context: StiContext): number;
        getLabelsSpaceAxis(context: StiContext): number;
        getLabelsTwoLinesDestination(context: StiContext): number;
        getTextAlignment(): StiHorAlignment;
        getLabelText(line: StiStripLineXF, series: IStiSeries): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        getFontGeom(context: StiContext): StiFontGeom;
        readonly yAxis: IStiYRadarAxis;
        info: StiAxisInfoXF;
        readonly ticksMaxLength: number;
        constructor(axis: IStiRadarAxis);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesLabelsCoreXF implements ICloneable, IStiApplyStyle, IStiSeriesLabelsCoreXF {
        private static implementsStiSeriesLabelsCoreXF;
        implements(): string[];
        clone(): StiSeriesLabelsCoreXF;
        applyStyle(style: IStiChartStyle): void;
        readonly position: number;
        readonly seriesLabelsType: StiSeriesLabelsType;
        private _seriesLabels;
        seriesLabels: IStiSeriesLabels;
        readonly localizedName: string;
        processSeriesColors(pointIndex: number, brush: StiBrush, series: IStiSeries): StiBrush;
        getSeriesLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getBorderColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        getLabelColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        recalcValue(value: number, signs: number): number;
        getLabelText(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, useLegendValueType?: boolean): string;
        getLabelText2(series: IStiSeries, value: number, argument: string, tag: string, seriesName: string, weight: number, useLegendValueType: boolean): string;
        private getArgument;
        private getFormatted;
        getFormattedValue(series: IStiSeries, value: number): string;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiAxisSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        readonly seriesLabelsType: StiSeriesLabelsType;
        currentIndex: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        renderLabel2(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, weight: number, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiInsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly position: number;
        readonly localizedName: string;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLeftAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideAxisLabelsCoreXF extends StiAxisSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, endPoint: PointD, startPoint: PointD, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD): StiSeriesLabelsGeom;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideBaseAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiOutsideEndAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRightAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiValueAxisLabelsCoreXF extends StiCenterAxisLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        getLabelRect(context: StiContext, endPoint: PointD, startPoint: PointD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        private getSumLastValues;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideLeftFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideRightFunnelLabelsCoreXF extends StiFunnelSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, valueNext: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, singleValueHeight: number, singleValueWidth: number, centerAxis: number, REFmeasureRect: any): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPieSeriesLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        recalcValue(value: number, signs: number): number;
        readonly seriesLabelsType: StiSeriesLabelsType;
        percentPerValue: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiCenterPieLabelsCoreXF extends StiPieSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        getLabelPoint(centerPie: PointD, radius: number, angleRad: number): PointD;
        getLabelRect(context: StiContext, labelPoint: PointD, labelText: string, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiInsideEndPieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        readonly localizedName: string;
        readonly position: number;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabelsCoreXF extends StiCenterPieLabelsCoreXF {
        applyStyle(style: IStiChartStyle): void;
        readonly position: number;
        readonly localizedName: string;
        getLineColor(series: IStiSeries, colorIndex: number, colorCount: number): Color;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTwoColumnsPieLabelsCoreXF extends StiOutsidePieLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, centerPie: PointD, radius: number, radius2: number, pieAngle: number, pointIndex: number, value: number, labelValue: number, argumentText: string, tag: string, measure: boolean, colorIndex: number, colorCount: number, percentPerValue: number, REFmeasureRect: any, drawValue: boolean, deltaY: number): StiSeriesLabelsGeom;
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsCoreXF extends StiSeriesLabelsCoreXF {
        renderLabel(series: IStiSeries, context: StiContext, pointIndex: number, value: number, argumentText: string, tag: string, colorIndex: number, colorCount: number, rect: RectangleD, animation?: StiAnimation): StiSeriesLabelsGeom;
        getLabelRect(context: StiContext, rect: RectangleD, value: number, labelText: string, checkHeight: boolean, font: StiFontGeom, sf: StiStringFormatGeom): RectangleD;
        readonly position: number;
        readonly localizedName: string;
        readonly seriesLabelsType: StiSeriesLabelsType;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiNoneLabelsCoreXF extends StiSeriesLabelsCoreXF {
        readonly seriesLabelsType: StiSeriesLabelsType;
        readonly position: number;
        readonly localizedName: string;
        constructor(seriesLabels: IStiSeriesLabels);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesCoreXF implements ICloneable, IStiApplyStyleSeries, IStiSeriesCoreXF {
        private static implementsStiSeriesCoreXF;
        implements(): string[];
        clone(): StiSeriesCoreXF;
        applyStyle(style: IStiChartStyle, color: Color): void;
        checkLabelsRect(labels: IStiSeriesLabels, geom: StiAreaGeom, labelsRect: RectangleD): RectangleD;
        private getRectangle;
        private rotatePoint;
        checkIntersectionLabels(geom: StiAreaGeom): void;
        private getLabelRectangle;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        getSeriesLabels(): IStiAxisSeriesLabels;
        getTag(tagIndex: number): string;
        private static falseObject;
        private static trueObject;
        private isMouseOverSeriesElementHashtable;
        getIsMouseOverSeriesElement(seriesIndex: number): boolean;
        setIsMouseOverSeriesElement(seriesIndex: number, value: boolean): void;
        private _isMouseOver;
        isMouseOver: boolean;
        readonly localizedName: string;
        seriesColors: Color[];
        private _isDateTimeValues;
        isDateTimeValues: boolean;
        private _isDateTimeArguments;
        isDateTimeArguments: boolean;
        private _series;
        series: IStiSeries;
        interaction: IStiSeriesInteraction;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiBaseLineSeriesCoreXF extends StiSeriesCoreXF implements IStiApplyStyleSeries {
        private static implementsStiBaseLineSeriesCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        protected clipLinePoints(context: StiContext, geom: StiAreaGeom, points: PointD[], REFstartIndex: any, REFendIndex: any): PointD[];
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getInteractions(context: StiContext, geom: StiAreaGeom, points: PointD[]): StiSeriesInteractionData[];
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private isTopmostLine;
        correctPoint(point: PointD, rect: RectangleD, correctY: number): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiScatterSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBubbleSeriesCoreXF extends StiScatterSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderBubbles(context: StiContext, geom: StiAreaGeom, series: IStiBubbleSeries, points: PointD[], weights: number[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiClusteredColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF implements IStiApplyStyleSeries {
        private static implementsStiClusteredBarSeriesCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiParetoSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private getParetoValues;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        renderColumns(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLinePareto;
        renderLines(geom: StiAreaGeom, points: PointD[], series: IStiSeries): void;
        private getPointValue;
        protected correctPoint(point: PointD, rect: RectangleD): PointD;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedLineSeriesCoreXF extends StiBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        private correctBrush;
        private renderPieElement;
        private renderPieElementShadow;
        private measurePieElement;
        private measurePieElementCore;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        private checkIntersectionTwoColumnsLabels;
        private checkLabelPosition;
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        getPointCenter(rect: RectangleD): PointD;
        getRadius(context: StiContext, rect: RectangleD): number;
        getPoint(centerPie: PointD, radius: number, angle: number): PointD;
        protected getArgumentText(series: IStiSeries, index: number): string;
        getPieDistance(pieIndex: number): number;
        getPieDistance2(series: IStiPieSeries, pieIndex: number): number;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesCoreXF extends StiPieSeriesCoreXF {
        private renderDoughnutElement;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        protected getGradPerValue(series: IStiSeries[]): number;
        getPercentPerValue(series: IStiSeries[]): number;
        protected getArgumentText(series: IStiSeries, index: number): string;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedBarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalWidth;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedBarSeriesCoreXF extends StiStackedBarSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedBaseLineSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        clipLinePoints(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], REFnewStartPoints: any, REFnewEndPoints: any, REFstartIndex: any, REFendIndex: any): void;
        renderMarkers(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight;
        private correctPoint;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly isFullStacked: boolean;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedLineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedAreaSeriesCoreXF extends StiStackedAreaSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedColumnSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private calculateTotalHeight;
        private correctRect;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedColumnSeriesCoreXF extends StiStackedColumnSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedLineSeriesCoreXF extends StiStackedLineSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedSplineSeriesCoreXF extends StiStackedBaseLineSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderAreas(context: StiContext, geom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineAreaSeriesCoreXF extends StiStackedSplineAreaSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFullStackedSplineSeriesCoreXF extends StiStackedSplineSeriesCoreXF {
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiFunnelSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getCurrentValue(funnelSeries: IStiFunnelSeries, index: number, values: number[]): number;
        getNextCurrentValue(funnelSeries: IStiFunnelSeries, index: number, values: number[]): number;
        getAllValues(funnelSeries: IStiFunnelSeries[]): number[];
        getAllTrueValues(funnelSeries: IStiFunnelSeries[]): number[];
        private getValues;
        private getArgumentText;
        private renderFunnelElement;
        private getSingleValueHeight;
        private getSingleValueWidth;
        private measureFunnelElementCore;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiFunnelWeightedSlicesSeriesCoreXF extends StiSeriesCoreXF {
        private labels;
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getAllValues(funnelSeries: IStiFunnelSeries[]): number[];
        getAllTrueValues(funnelSeries: IStiFunnelSeries[]): number[];
        private getValues;
        private getArgumentText;
        private renderFunnelElement;
        private getSumValues;
        private getSumLastValues;
        private measureFunnelElementCore;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesCoreXF extends StiClusteredBarSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import SizeD = Stimulsoft.System.Drawing.Size;
    import StiFontIcons = Stimulsoft.Report.StiFontIcons;
    class DataPictorial {
        private _value;
        value: number;
        private _icon;
        icon: StiFontIcons;
        constructor(value: number, icon: StiFontIcons);
    }
    class StiPictorialSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        private singleSizeConst;
        getSingleSize(context: StiContext): SizeD;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRadarSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderPoints(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        private getArgument;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): Object;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        renderAreas(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        renderLines(context: StiContext, series: IStiRadarSeries, points: PointD[], geom: StiAreaGeom): void;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarPointSeriesCoreXF extends StiRadarSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBarSeriesCoreXF extends StiClusteredColumnSeriesCoreXF {
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRangeSeriesCoreXF extends StiLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        private renderAreas2;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSplineRangeSeriesCoreXF extends StiSplineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        private renderAreas2;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiSteppedRangeSeriesCoreXF extends StiSteppedLineSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, series: IStiSeries[]): void;
        private renderAreas2;
        private renderLines2;
        private renderMarkers2;
        private getYPoint;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterLineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterSplineSeriesCoreXF extends StiScatterSeriesCoreXF {
        renderLines(context: StiContext, geom: StiAreaGeom, points: PointD[]): void;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiTreemapSeriesCoreXF extends StiSeriesCoreXF {
        applyStyle(style: IStiChartStyle, color: Color): void;
        renderSeries(context: StiContext, rect: RectangleD, geom: StiAreaGeom, seriesArray: IStiSeries[]): void;
        getArgumentText(series: IStiSeries, index: number): string;
        getSeriesBrush(colorIndex: number, colorCount: number): StiBrush;
        getSeriesBorderColor(colorIndex: number, colorCount: number): any;
        readonly localizedName: string;
        constructor(series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStripsCoreXF implements IStiApplyStyle, ICloneable, IStiStripsCoreXF {
        private static implementsStiStripsCoreXF;
        implements(): string[];
        clone(): Object;
        applyStyle(style: IStiChartStyle): void;
        renderXStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        renderYStrips(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        render(context: StiContext, geom: StiAxisAreaGeom, rect: RectangleD): void;
        private _strips;
        strips: IStiStrips;
        constructor(strips: IStiStrips);
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF implements IStiStyleCoreXF {
        private static implementsStiStyleCoreXF;
        implements(): string[];
        readonly localizedName: string;
        readonly styleId: StiChartStyleId;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        private _chart;
        chart: IStiChart;
        readonly chartAreaShowShadow: boolean;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsLineColor: Color;
        readonly seriesLabelsFont: Font;
        readonly trendLineColor: Color;
        readonly trendLineShowShadow: boolean;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly interlacingHorBrush: StiBrush;
        readonly interlacingVertBrush: StiBrush;
        readonly gridLinesHorColor: Color;
        readonly gridLinesVertColor: Color;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
        readonly markerVisible: boolean;
        readonly firstStyleColor: Color;
        readonly lastStyleColor: Color;
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getAreaBrush(color: Color): StiBrush;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
        getColors(seriesCount: number, seriesColors: Color[]): Color[];
        getColorByIndex(index: number, count: number, seriesColors: Color[]): Color;
        getColorBySeries(series: IStiSeries, seriesColors: Color[]): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF01 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCustomStyleCoreXF extends StiStyleCoreXF01 {
        private _base;
        readonly localizedName: string;
        reportChartStyle: Stimulsoft.Report.Styles.StiChartStyle;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        readonly chartAreaShowShadow: boolean;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsLineColor: Color;
        readonly trendLineColor: Color;
        readonly trendLineShowShadow: boolean;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly markerVisible: boolean;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly interlacingHorBrush: StiBrush;
        readonly interlacingVertBrush: StiBrush;
        readonly gridLinesHorColor: Color;
        readonly gridLinesVertColor: Color;
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        private _reportStyleName;
        reportStyleName: string;
        readonly reportStyle: Stimulsoft.Report.Styles.StiChartStyle;
        private _customStyle;
        readonly customStyle: StiCustomStyle;
        getColumnBrush(color: Color): StiBrush;
        constructor(customStyle: StiCustomStyle);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF02 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly basicStyleColor: Color;
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF03 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF04 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly basicStyleColor: Color;
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF05 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF06 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF07 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF08 extends StiStyleCoreXF03 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF09 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF10 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF11 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF12 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF13 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF14 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF15 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF16 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF17 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    class StiStyleCoreXF18 extends StiStyleCoreXF {
        readonly localizedName: string;
        fillColumn(context: StiContext, rect: RectangleD, brush: StiBrush, interaction: StiInteractionDataGeom): void;
        getColumnBrush(color: Color): StiBrush;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF19 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly interlacingHorBrush: StiBrush;
        readonly interlacingVertBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartBrush: StiBrush;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF20 extends StiStyleCoreXF {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly axisLineColor: Color;
        readonly chartAreaBorderColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF21 extends StiStyleCoreXF {
        readonly localizedName: string;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF22 extends StiStyleCoreXF {
        readonly localizedName: string;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly chartAreaBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly styleId: StiChartStyleId;
        getColumnBrush(color: Color): StiBrush;
        getColumnBorder(color: Color): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF23 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF24 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF25 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF26 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly chartAreaBrush: StiBrush;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly seriesLighting: boolean;
        readonly seriesShowShadow: boolean;
        readonly markerVisible: boolean;
        readonly styleId: StiChartStyleId;
        getColumnBorder(color: Color): Color;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF27 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly styleColors: Color[];
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly seriesLighting: boolean;
        getColumnBorder(color: Color): Color;
        readonly styleId: StiChartStyleId;
    }
}
declare module Stimulsoft.Report.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStyleCoreXF28 extends StiStyleCoreXF26 {
        readonly localizedName: string;
        protected _styleColor: Color[];
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly seriesLabelsColor: Color;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly styleId: StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStyleCoreXF29 extends StiStyleCoreXF26 {
        readonly localizedName: string;
        _styleColor: Color[];
        readonly styleColors: Color[];
        readonly styleId: StiChartStyleId;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly seriesLabelsColor: Color;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF30 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        _styleColor: Color[];
        readonly styleColors: Color[];
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly legendFont: Font;
        readonly seriesLighting: boolean;
        getColumnBorder(color: Color): Color;
        readonly styleId: StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF31 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        _styleColor: Color[];
        readonly styleColors: Color[];
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsFont: Font;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendBorderColor: Color;
        readonly legendFont: Font;
        readonly seriesLighting: boolean;
        getColumnBorder(color: Color): Color;
        readonly styleId: StiChartStyleId;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF32 extends StiStyleCoreXF22 {
        readonly localizedName: string;
        _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsLineColor: Color;
        readonly seriesLabelsFont: Font;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly gridLinesHorColor: Color;
        readonly gridLinesVertColor: Color;
        readonly seriesLighting: boolean;
        readonly styleId: StiChartStyleId;
        getColumnBorder(color: Color): Color;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare namespace Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStyleCoreXF33 extends StiStyleCoreXF {
        readonly localizedName: string;
        _styleColor: Color[];
        readonly styleColors: Color[];
        readonly basicStyleColor: Color;
        readonly chartBrush: StiBrush;
        readonly chartAreaBrush: StiBrush;
        readonly legendBrush: StiBrush;
        readonly legendLabelsColor: Color;
        readonly legendBorderColor: Color;
        readonly legendTitleColor: Color;
        readonly legendShowShadow: boolean;
        readonly legendFont: Font;
        readonly seriesLabelsBrush: StiBrush;
        readonly seriesLabelsColor: Color;
        readonly seriesLabelsBorderColor: Color;
        readonly seriesLabelsLineColor: Color;
        readonly seriesLabelsFont: Font;
        readonly axisTitleColor: Color;
        readonly axisLineColor: Color;
        readonly axisLabelsColor: Color;
        readonly gridLinesHorColor: Color;
        readonly gridLinesVertColor: Color;
        readonly seriesLighting: boolean;
        readonly styleId: StiChartStyleId;
        getColumnBorder(color: Color): Color;
        getColumnBrush(color: Color): StiBrush;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiChartTableCoreXF implements ICloneable, IStiApplyStyle, IStiChartTableCoreXF {
        private static implementsStiChartTableCoreXF;
        implements(): string[];
        applyStyle(style: IStiChartStyle): void;
        clone(): StiChartTableCoreXF;
        private _chartTable;
        chartTable: IStiChartTable;
        showTable(): boolean;
        getHeightTable(context: StiContext, widthTable: number): number;
        getHeightHeaderTable(context: StiContext, widthTable: number): number;
        getWidthCellLegend(context: StiContext): number;
        render(context: StiContext, rect: RectangleD): StiCellGeom;
        private getMaxCountValues;
        private getArguments;
        private getTableValues;
        constructor(table: IStiChartTable);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineCoreXF implements ICloneable, IStiTrendLineCoreXF {
        private static implementsStiTrendLineCoreXF;
        implements(): string[];
        clone(): StiTrendLineCoreXF;
        readonly localizedName: string;
        private _trendLine;
        trendLine: IStiTrendLine;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        sum(values: number[]): number;
        sumSqr(values: number[]): number;
        sumProductions(valuesX: number[], valuesY: number[]): number;
        sumProductionsXLogY(valuesX: number[], valuesY: number[]): number;
        sumLn(values: number[]): number;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineExponentialCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLinearCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineLogarithmicCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        renderTrendLine(geom: StiAreaGeom, points: PointD[], posY: number): void;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiTrendLineNoneCoreXF extends StiTrendLineCoreXF {
        readonly localizedName: string;
        constructor(trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiGeom = Stimulsoft.Base.Context.StiGeom;
    import StiGeomType = Stimulsoft.Base.Context.StiGeomType;
    class StiCellGeom extends StiGeom implements IStiGeomInteraction, IStiCellGeom {
        private static implementsStiCellGeom;
        implements(): string[];
        invokeClick(options: StiInteractionOptions): void;
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeMouseUp(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        readonly invisible: boolean;
        readonly type: StiGeomType;
        private _childGeoms;
        readonly childGeoms: StiCellGeom[];
        private _clientRectangle;
        clientRectangle: RectangleD;
        dispose(): void;
        contains(x: number, y: number): boolean;
        getGeomAt(parent: StiCellGeom, x: number, y: number): StiCellGeom;
        getSeriesGeoms(): StiCellGeom[];
        getSeriesElementGeoms(): StiCellGeom[];
        getRect(geom: StiGeom): RectangleD;
        createChildGeoms(): void;
        draw(context: StiContext): void;
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        constructor(clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAreaGeom extends StiCellGeom {
        private _area;
        readonly area: IStiArea;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaGeom extends StiAreaGeom {
        private _view;
        readonly view: StiAxisAreaViewGeom;
        private minWidth;
        private drawInterlacingHor;
        private drawInterlacingVer;
        private drawGridLinesHor;
        private drawGridLinesVer;
        protected allowChildDrawing(cellGeom: StiCellGeom): boolean;
        isChildVisibleInView(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(view: StiAxisAreaViewGeom, area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisAreaViewGeom extends StiAreaGeom {
        drawGeom(context: StiContext): void;
        drawChildGeoms(context: StiContext): void;
        private drawBorder;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutAreaGeom extends StiPieAreaGeom {
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPictorialAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAreaGeom extends StiAreaGeom {
        private _valuesCount;
        readonly valuesCount: number;
        private drawHor;
        private drawVert;
        private drawBackground;
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD, valuesCount: number);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTreemapAreaGeom extends StiAreaGeom {
        draw(context: StiContext): void;
        constructor(area: IStiArea, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDownButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveDown;
        private _axis;
        readonly axis: IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzScrollBarGeom extends StiCellGeom {
        invokeMouseDown(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiXAxis;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiHorzTrackBarGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiXAxis;
        private _scrollBar;
        readonly scrollBar: StiHorzScrollBarGeom;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, scrollBar: StiHorzScrollBarGeom);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLeftButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveLeft;
        private _axis;
        readonly axis: IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRightButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveRight;
        private _axis;
        readonly axis: IStiXAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiUpButtonGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        private moveUp;
        private _axis;
        readonly axis: IStiYAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertScrollBarGeom extends StiCellGeom {
        invokeMouseDown(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiYAxis;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiVertTrackBarGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeMouseDown(options: StiInteractionOptions): void;
        invokeDrag(options: StiInteractionOptions): void;
        draw(context: StiContext): void;
        private _axis;
        readonly axis: IStiYAxis;
        private _scrollBar;
        readonly scrollBar: StiVertScrollBarGeom;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, scrollBar: StiVertScrollBarGeom);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisLabelGeom extends StiCellGeom {
        private _rotationMode;
        readonly rotationMode: StiRotationMode;
        private _textPoint;
        readonly textPoint: PointD;
        private _angle;
        readonly angle: number;
        private _axis;
        readonly axis: IStiAxis;
        private _text;
        readonly text: string;
        private _stripLine;
        readonly stripLine: StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiAxisTitleGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiAxis;
        private _angle;
        readonly angle: number;
        private _font;
        readonly font: StiFontGeom;
        draw(context: StiContext): void;
        constructor(axis: IStiAxis, clientRectangle: RectangleD, angle: number, stringAlignment: StringAlignment, font: StiFontGeom);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiXAxis;
        private _isCenterAxis;
        readonly isCenterAxis: boolean;
        private _view;
        view: StiXAxisViewGeom;
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private isArgumentDateTime;
        private drawAxis;
        private getViewclipRect;
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXAxisViewGeom extends StiXAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiXAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiYAxis;
        private _isCenterAxis;
        readonly isCenterAxis: boolean;
        private _view;
        view: StiYAxisViewGeom;
        drawArrow(context: StiContext, rect: RectangleD): void;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private drawAxis;
        private getViewclipRect;
        allowChildDrawing(cellGeom: StiCellGeom): boolean;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYAxisViewGeom extends StiYAxisGeom {
        drawChildGeoms(context: StiContext): void;
        draw(context: StiContext): void;
        constructor(axis: IStiYAxis, clientRectangle: RectangleD, isCenterAxis: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTitleGeom extends StiCellGeom {
        private _title;
        readonly title: IStiChartTitle;
        draw(context: StiContext): void;
        constructor(title: IStiChartTitle, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesVerticalGeom extends StiCellGeom {
        private _line;
        readonly line: IStiConstantLines;
        private _point;
        readonly point: PointD;
        private _mode;
        readonly mode: StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiConstantLinesYGeom extends StiCellGeom {
        private _line;
        readonly line: IStiConstantLines;
        private _point;
        readonly point: PointD;
        private _mode;
        readonly mode: StiRotationMode;
        draw(context: StiContext): void;
        constructor(line: IStiConstantLines, clientRectangle: RectangleD, point: PointD, mode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendCandelstickMarker implements IStiLegendMarker {
        private static implementsStiLegendCandelstickMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendColumnMarker implements IStiLegendMarker {
        private static implementsStiLegendColumnMarker;
        implements(): string[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendDoughnutMarker implements IStiLegendMarker {
        private static implementsStiLegendDoughnutMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendFunnelMarker implements IStiLegendMarker {
        private static implementsStiLegendFunnelMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendLineMarker implements IStiLegendMarker {
        private static implementsStiLegendLineMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLegendMarkerHelper {
        static getSteppedMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getAreaMarkerLinePoints(rect: RectangleD): PointD[];
        static getSplineAreaMarkerPath(rect: RectangleD): StiSegmentGeom[];
        static getSplineAreaMarkerLinePoints(rect: RectangleD): PointD[];
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPictorialMarker implements IStiLegendMarker {
        private static implementsStiLegendPictorialMarker;
        implements(): string[];
        draw(context: StiContext, series: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendPieMarker implements IStiLegendMarker {
        private static implementsStiLegendPieMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendRangeMarker implements IStiLegendMarker {
        private static implementsStiLegendRangeMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendSplineAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSplineRangeMarker implements IStiLegendMarker {
        private static implementsStiLegendSplineRangeMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendStackedAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStackedSplineAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendStackedSplineAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedAreaMarker implements IStiLegendMarker {
        private static implementsStiLegendSteppedAreaMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendSteppedRangeMarker implements IStiLegendMarker {
        private static implementsStiSteppedRangeSeries;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendStockMarker implements IStiLegendMarker {
        private static implementsStiLegendStockMarker;
        implements(): string[];
        draw(context: StiContext, serie: IStiSeries, rect: RectangleD, colorIndex: number, colorCount: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    class StiMarkerLegendFactory {
        static createMarker(series: IStiSeries): IStiLegendMarker;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendGeom extends StiCellGeom {
        private _legend;
        readonly legend: IStiLegend;
        private _seriesItems;
        readonly seriesItems: StiLegendItemCoreXF[];
        private _legendTitleGeom;
        legendTitleGeom: StiLegendTitleGeom;
        dispose(): void;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD, seriesItems: StiLegendItemCoreXF[]);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendItemGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        private readonly isColorEach;
        isMouseOver: boolean;
        private _legend;
        readonly legend: IStiLegend;
        private _item;
        readonly item: StiLegendItemCoreXF;
        private _colorIndex;
        readonly colorIndex: number;
        private _legendItemsCount;
        readonly legendItemsCount: number;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, item: StiLegendItemCoreXF, clientRectangle: RectangleD, colorIndex: number, legendItemsCount: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiLegendTitleGeom extends StiCellGeom {
        private _legend;
        readonly legend: IStiLegend;
        draw(context: StiContext): void;
        constructor(legend: IStiLegend, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    class StiMarkerGeom extends StiCellGeom implements IStiSeriesElement {
        private static implementsStiMarkerGeom;
        implements(): string[];
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        private getValueIndex;
        getHyperlink(): string;
        private getHyperlink2;
        getToolTip(): string;
        private getToolTip2;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _interaction;
        interaction: StiSeriesInteractionData;
        private _index;
        readonly index: number;
        private _point;
        readonly point: PointD;
        private _marker;
        readonly marker: IStiMarker;
        private _value;
        readonly value: number;
        private _showShadow;
        readonly showShadow: boolean;
        private _series;
        readonly series: IStiSeries;
        private _elementIndex;
        elementIndex: String;
        private _isTooltipMode;
        readonly isTooltipMode: boolean;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, index: number, value: number, point: PointD, marker: IStiMarker, showShadow: boolean, zoom: number, isTooltipMode: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarAxisGeom extends StiCellGeom {
        private _axis;
        readonly axis: IStiYRadarAxis;
        private drawAxisLine;
        private drawMinorTicks;
        private drawTicks;
        private drawAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiXRadarAxisLabelGeom extends StiCellGeom {
        private _borderColor;
        readonly borderColor: Color;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _text;
        readonly text: string;
        private _angle;
        readonly angle: number;
        private _point;
        readonly point: PointD;
        private _labelRect;
        readonly labelRect: RectangleD;
        private _axis;
        readonly axis: IStiXRadarAxis;
        draw(context: StiContext): void;
        constructor(axis: IStiXRadarAxis, text: string, labelBrush: StiBrush, borderColor: Color, angle: number, clientRectangle: RectangleD, labelRect: RectangleD, point: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiYRadarAxisLabelGeom extends StiCellGeom {
        private _rotationMode;
        readonly rotationMode: StiRotationMode;
        private _textPoint;
        readonly textPoint: PointD;
        private _angle;
        readonly angle: number;
        private _axis;
        readonly axis: IStiYRadarAxis;
        private _text;
        readonly text: string;
        private _stripLine;
        readonly stripLine: StiStripLineXF;
        draw(context: StiContext): void;
        constructor(axis: IStiYRadarAxis, clientRectangle: RectangleD, textPoint: PointD, text: string, stripLine: StiStripLineXF, angle: number, rotationMode: StiRotationMode);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSeriesLabelsGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        private getValueIndex;
        private getHyperlink;
        private getToolTip;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _value;
        readonly value: number;
        private _index;
        readonly index: number;
        private _series;
        readonly series: IStiSeries;
        private _seriesLabels;
        readonly seriesLabels: IStiSeriesLabels;
        private _beginTime;
        beginTime: TimeSpan;
        private _duration;
        duration: TimeSpan;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: Object, markerBrush: StiBrush): void;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterAxisLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        readonly labelColor: Color;
        private _labelBorderColor;
        readonly labelBorderColor: Color;
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _font;
        readonly font: StiFontGeom;
        private _text;
        readonly text: string;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideAxisLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        readonly labelColor: Color;
        private _labelBorderColor;
        readonly labelBorderColor: Color;
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _font;
        readonly font: StiFontGeom;
        private _text;
        readonly text: string;
        private _startPoint;
        readonly startPoint: PointD;
        private _endPoint;
        readonly endPoint: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, startPoint: PointD, endPoint: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCenterFunnelLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _text;
        readonly text: string;
        private _labelRect;
        readonly labelRect: RectangleD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsideFunnelLabelsGeom extends StiCenterFunnelLabelsGeom {
        private _startPointLine;
        readonly startPointLine: PointD;
        private _endPointLine;
        readonly endPointLine: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, startPointLine: PointD, endPointLine: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterPieLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _text;
        readonly text: string;
        private _rotationMode;
        readonly rotationMode: StiRotationMode;
        private _labelRect;
        readonly labelRect: RectangleD;
        private _angleToUse;
        readonly angleToUse: number;
        private _animation;
        animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiOutsidePieLabelsGeom extends StiCenterPieLabelsGeom {
        private _lineColor;
        readonly lineColor: Color;
        private _labelPoint;
        readonly labelPoint: PointD;
        private _startPoint;
        readonly startPoint: PointD;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, rotationMode: StiRotationMode, labelRect: RectangleD, angleToUse: number, lineColor: Color, labelPoint: PointD, startPoint: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiTwoColumnsPieLabelsGeom extends StiSeriesLabelsGeom {
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _labelBrush;
        readonly labelBrush: StiBrush;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _text;
        readonly text: string;
        private _labelRect;
        readonly labelRect: RectangleD;
        private _lineColor;
        readonly lineColor: Color;
        private _startPoint;
        readonly startPoint: PointD;
        private _endPoint;
        endPoint: PointD;
        private _arcPoint;
        readonly arcPoint: PointD;
        private _centerPie;
        readonly centerPie: PointD;
        draw(context: StiContext): void;
        drawMarker(context: StiContext, itemRect: Rectangle, markerColor: Object, markerBrush: StiBrush): void;
        constructor(seriesLabels: IStiSeriesLabels, series: IStiSeries, index: number, value: number, clientRectangle: RectangleD, text: string, seriesBrush: StiBrush, labelBrush: StiBrush, seriesLabelsBrush: StiBrush, borderColor: Color, seriesBorderColor: Color, labelRect: RectangleD, lineColor: Color, startPoint: PointD, endPoint: PointD, arcPoint: PointD, centerPie: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiCenterTreemapLabelsGeom extends StiSeriesLabelsGeom {
        private _labelColor;
        readonly labelColor: Color;
        private _labelBorderColor;
        readonly labelBorderColor: Color;
        private _seriesBrush;
        readonly seriesBrush: StiBrush;
        private _seriesLabelsBrush;
        readonly seriesLabelsBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _font;
        readonly font: StiFontGeom;
        private _text;
        readonly text: string;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(seriesLabels: IStiSeriesLabels, series: any, index: number, value: number, clientRectangle: RectangleD, text: string, labelColor: Color, labelBorderColor: Color, seriesBrush: StiBrush, seriesLabelsBrush: StiBrush, seriesBorderColor: Color, font: StiFontGeom, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
    import IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSeriesElementGeom extends StiCellGeom implements IStiSeriesElement {
        private static implementsStiSeriesElementGeom;
        implements(): string[];
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        protected getValueIndex(): number;
        getHyperlink(): string;
        private getHyperlink2;
        getToolTip(): string;
        private getToolTip2;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _value;
        readonly value: number;
        private _index;
        readonly index: number;
        private _series;
        readonly series: IStiSeries;
        private _interaction;
        interaction: StiSeriesInteractionData;
        private _areaGeom;
        areaGeom: StiAreaGeom;
        private _elementIndex;
        elementIndex: String;
        draw(context: StiContext): void;
        getInteractionData(): StiInteractionDataGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBubbleSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiClusteredBarSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _valueStart;
        readonly valueStart: number;
        private _columnRectStart;
        readonly columnRectStart: RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, valueStart: number, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRectStart: RectangleD, columnRect: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiSeriesGeom extends StiCellGeom {
        private _series;
        readonly series: IStiSeries;
        private _interactions;
        interactions: StiSeriesInteractionData[];
        private _areaGeom;
        areaGeom: StiAreaGeom;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiBaseLineSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _points;
        readonly points: PointD[];
        static getClientRectangle(points: PointD[], lineWidth: number): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiLineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross;
        private drawLine;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiAreaSeriesGeom extends StiLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiClusteredColumnSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, columnRect: RectangleD, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineAreaSeriesGeom extends StiSplineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedLineSeriesGeom extends StiBaseLineSeriesGeom {
        getConvertedPoints(points: PointD[]): PointD[];
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private intersectionAxis;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedAreaSeriesGeom extends StiSteppedLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiDoughnutSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        readonly path: StiSegmentGeom[];
        private _pathLight;
        readonly pathLight: StiSegmentGeom[];
        private _pathDark;
        readonly pathDark: StiSegmentGeom[];
        private _borderColor;
        readonly borderColor: Color;
        private _brush;
        readonly brush: StiBrush;
        private _brushLight;
        readonly brushLight: StiBrush;
        private _brushDark;
        readonly brushDark: StiBrush;
        private _startAngle;
        readonly startAngle: number;
        private _endAngle;
        readonly endAngle: number;
        private _radiusFrom;
        readonly radiusFrom: number;
        private _radiusTo;
        readonly radiusTo: number;
        private _beginTime;
        readonly beginTime: TimeSpan;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiDoughnutSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], pathDark: StiSegmentGeom[], borderColor: Color, brush: StiBrush, brushLight: StiBrush, brushDark: StiBrush, startAngle: number, endAngle: number, radiusFrom: number, radiusTo: number, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFinancialSeriesElementGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        private getValueIndex;
        private getHyperlink;
        private getToolTip;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _series;
        readonly series: IStiSeries;
        private _interaction;
        interaction: StiSeriesInteractionData;
        private _open;
        readonly open: number;
        private _close;
        readonly close: number;
        private _high;
        readonly high: number;
        private _low;
        readonly low: number;
        private _positionX;
        readonly positionX: number;
        private _areaGeom;
        readonly areaGeom: StiAreaGeom;
        private _index;
        readonly index: number;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiCandlestickSeriesElementGeom extends StiFinancialSeriesElementGeom {
        private _brush;
        readonly brush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, bodyStart: number, bodyEnd: number, high: number, low: number, positionX: number, index: number, brush: StiBrush, borderColor: Color, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStockSeriesElementGeom extends StiFinancialSeriesElementGeom {
        private _color;
        readonly color: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, series: IStiSeries, clientRectangle: RectangleD, open: number, close: number, high: number, low: number, positionX: number, index: number, color: Color, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiFunnelSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        readonly path: StiSegmentGeom[];
        private _borderColor;
        readonly borderColor: Color;
        private _brush;
        readonly brush: StiBrush;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color, path: StiSegmentGeom[], beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiGanttSeriesElementGeom extends StiSeriesElementGeom {
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiFontIcons = Stimulsoft.Report.StiFontIcons;
    class StiPictorialSeriesElementGeom extends StiSeriesElementGeom {
        private _icon;
        icon: StiFontIcons;
        private _drawRectangles;
        drawRectangles: RectangleD[];
        private _clipRectangles;
        clipRectangles: RectangleD[];
        _seriesBrush: StiBrush;
        seriesBrush: StiBrush;
        private _animation;
        animation: StiAnimation;
        draw(context: StiContext): void;
        getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, series: IStiSeries, icon: StiFontIcons, drawRectangles: RectangleD[], clipRectangles: RectangleD[], clientRectangle: RectangleD, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiSegmentGeom = Stimulsoft.Base.Context.StiSegmentGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiPieSeriesElementGeom extends StiSeriesElementGeom {
        private _path;
        readonly path: StiSegmentGeom[];
        private _pathLight;
        readonly pathLight: StiSegmentGeom[];
        private _borderColor;
        readonly borderColor: Color;
        private _brush;
        readonly brush: StiBrush;
        private _startAngle;
        startAngle: number;
        private _endAngle;
        endAngle: number;
        private _radius;
        radius: number;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _animation;
        animation: StiAnimation;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiPieSeries, clientRectangle: RectangleD, path: StiSegmentGeom[], pathLight: StiSegmentGeom[], borderColor: Color, brush: StiBrush, startAngle: number, endAngle: number, radius: number, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesFullElementGeom extends StiCellGeom {
        private _series;
        readonly series: IStiPieSeries;
        private _brush;
        readonly brush: StiBrush;
        private _borderColor;
        readonly borderColor: Color;
        draw(context: StiContext): void;
        constructor(series: IStiPieSeries, clientRectangle: RectangleD, brush: StiBrush, borderColor: Color);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiPieSeriesShadowElementGeom extends StiCellGeom {
        readonly invisible: boolean;
        private _series;
        readonly series: IStiPieSeries;
        private _shadowContext;
        readonly shadowContext: StiContext;
        private _radius;
        readonly radius: number;
        private _duration;
        readonly duration: TimeSpan;
        private _beginTime;
        readonly beginTime: TimeSpan;
        private _isAnimation;
        readonly isAnimation: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiPieSeries, clientRectangle: RectangleD, radius: number, shadowContext: StiContext, duration: TimeSpan, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRadarAreaSeriesGeom extends StiCellGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _series;
        readonly series: IStiSeries;
        private _points;
        readonly points: PointD[];
        private _centerPoint;
        readonly centerPoint: PointD;
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, points: PointD[], centerPoint: PointD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRadarPointSeriesElementGeom extends StiSeriesElementGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        invokeClick(options: StiInteractionOptions): void;
        protected getValueIndex(): number;
        private getHyperlink3;
        private getToolTip3;
        private _point;
        readonly point: PointD;
        contains(x: number, y: number): boolean;
        getMouseOverRect(): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiRadarSeries, point: PointD, zoom: number);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiRangeBarElementGeom extends StiSeriesElementGeom {
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiRangeSeriesGeom extends StiLineSeriesGeom {
        private _pointsEnd;
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private getBrush;
        private fillPath;
        private intersection;
        private getPointCross2;
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSplineRangeSeriesGeom extends StiSplineSeriesGeom {
        private _pointsEnd;
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private fillPath;
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSteppedRangeSeriesGeom extends StiSteppedLineSeriesGeom {
        private _pointsEnd;
        pointsEnd: PointD[];
        draw(context: StiContext): void;
        private getBrush;
        private fillPath;
        private intersection;
        constructor(areaGeom: StiAreaGeom, points: PointD[], pointsEnd: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiScatterSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBarSeriesShadowElementGeom extends StiCellGeom {
        readonly invisible: boolean;
        private _series;
        readonly series: IStiSeries;
        private _isLeftShadow;
        readonly isLeftShadow: boolean;
        private _isRightShadow;
        readonly isRightShadow: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isLeftShadow: boolean, isRightShadow: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedAreaSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _startPoints;
        readonly startPoints: PointD[];
        private _endPoints;
        readonly endPoints: PointD[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedBaseLineSeriesGeom extends StiSeriesGeom {
        private _points;
        readonly points: PointD[];
        static getClientRectangle(points: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _beginTime;
        readonly beginTime: TimeSpan;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, beginTime: TimeSpan);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedColumnSeriesShadowElementGeom extends StiCellGeom {
        readonly invisible: boolean;
        private _series;
        readonly series: IStiSeries;
        private _isTopShadow;
        readonly isTopShadow: boolean;
        private _isBottomShadow;
        readonly isBottomShadow: boolean;
        draw(context: StiContext): void;
        constructor(series: IStiSeries, clientRectangle: RectangleD, isTopShadow: boolean, isBottomShadow: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedLineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        private getPointCross;
        private drawLine;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStackedSplineAreaSeriesGeom extends StiSeriesGeom {
        invokeMouseEnter(options: StiInteractionOptions): void;
        invokeMouseLeave(options: StiInteractionOptions): void;
        readonly allowMouseOver: boolean;
        isMouseOver: boolean;
        private _startPoints;
        readonly startPoints: PointD[];
        private _endPoints;
        readonly endPoints: PointD[];
        contains(x: number, y: number): boolean;
        static getClientRectangle(startPoints: PointD[], endPoints: PointD[]): RectangleD;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, startPoints: PointD[], endPoints: PointD[], series: IStiSeries);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiStackedSplineSeriesGeom extends StiBaseLineSeriesGeom {
        contains(x: number, y: number): boolean;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, points: PointD[], series: IStiSeries);
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiTreemapSeriesElementGeom extends StiSeriesElementGeom {
        _seriesBrush: StiBrush;
        readonly seriesBrush: StiBrush;
        private _seriesBorderColor;
        readonly seriesBorderColor: Color;
        private _animation;
        readonly animation: StiAnimation;
        draw(context: StiContext): void;
        constructor(areaGeom: StiAreaGeom, value: number, index: number, seriesBrush: StiBrush, seriesBorderColor: Color, series: IStiSeries, clientRectangle: RectangleD, animation: StiAnimation);
    }
}
declare module Stimulsoft.Report.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMouseOverHelper {
        static getMouseOverColor(): Color;
        static getLineMouseOverColor(): Color;
        static mouseOverLineDistance: number;
        static mouseOverSplineDistance: number;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsXGeom extends StiCellGeom {
        private _strip;
        readonly strip: IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiStripsYGeom extends StiCellGeom {
        private _strip;
        readonly strip: IStiStrips;
        draw(context: StiContext): void;
        constructor(strip: IStiStrips, clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartTableGeom extends StiCellGeom {
        constructor(clientRectangle: RectangleD, table: string[][], widthCellLegendTableChart: number, heightCellHeader: number, chartTable: IStiChartTable);
        private table;
        private widthCellLegendTableChart;
        private heightCellHeader;
        private chartTable;
        private pen;
        private font;
        private fontHeader;
        private labelBrush;
        private sf;
        private sfHeader;
        private labelHeaderBrush;
        draw(context: StiContext): void;
        private drawHeaderArgument;
        private drawTitleLegend;
        private drawRootTable;
        private checkFontSize;
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendCurveGeom extends StiCellGeom {
        private _points;
        readonly points: PointD[];
        private _trendLine;
        readonly trendLine: IStiTrendLine;
        draw(context: StiContext): void;
        constructor(points: PointD[], trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiTrendLineGeom extends StiCellGeom {
        private trendLine;
        private pointStart;
        private pointEnd;
        draw(context: StiContext): void;
        private static getArray;
        constructor(pointStart: PointD, pointEnd: PointD, trendLine: IStiTrendLine);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    class StiChartGeom extends StiCellGeom {
        draw(context: StiContext): void;
        constructor(clientRectangle: RectangleD);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiNullableDrawing {
        static drawLines(context: StiContext, penGeom: StiPenGeom, points: PointD[], isAnimation?: boolean): void;
        static drawCurve(context: StiContext, penGeom: StiPenGeom, points: PointD[], tension: number, isAnimation?: boolean): void;
        static getPointsList(points: PointD[]): PointD[][];
        static getNullablePointsList(points: PointD[]): PointD[][];
        static getPointsList2(points1: PointD[], points2: PointD[], REFlist1: any, REFlist2: any): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterArea extends StiClusteredColumnArea implements IStiScatterArea, IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiScatterArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiBubbleArea extends StiScatterArea implements IStiScatterArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable, IStiBubbleArea {
        private static implementsStiBubbleArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCandlestickArea extends StiClusteredColumnArea implements IStiCandlestickArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, IStiArea, ICloneable {
        private static implementsStiCandlestickArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiClusteredBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiAreaArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineArea extends StiClusteredColumnArea implements IStiArea, IStiLineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiParetoArea extends StiClusteredColumnArea implements IStiArea, IStiParetoArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiParetoArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiParetoArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineArea extends StiClusteredColumnArea implements IStiArea, IStiSplineArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSplineAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedAreaArea extends StiClusteredColumnArea implements IStiArea, IStiSteppedAreaArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiAxisArea, IStiSteppedLineArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieArea extends StiArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable {
        private static implementsStiPieArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDoughnutArea extends StiPieArea implements IStiJsonReportObject, IStiPieArea, IStiArea, ICloneable, IStiDoughnutArea {
        private static implementsStiDoughnutArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedBarArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiStackedBarArea, ICloneable {
        private static implementsStiStackedBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarArea extends StiStackedBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiFullStackedBarArea, IStiStackedBarArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedColumnArea extends StiAxisArea implements IStiJsonReportObject, IStiStackedColumnArea, IStiAxisArea, ICloneable, IStiArea {
        private static implementsStiStackedColumnArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedColumnArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedAreaArea {
        private static implementsStiFullStackedAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable, IStiFullStackedLineArea {
        private static implementsStiFullStackedLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineArea extends StiFullStackedColumnArea implements IStiFullStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedSplineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaArea extends StiFullStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiFullStackedColumnArea, IStiFullStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiFullStackedSplineAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelArea extends StiArea implements IStiJsonReportObject, IStiArea, ICloneable, IStiFunnelArea {
        private static implementsStiFunnelArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiFunnelWeightedSlicesArea extends StiFunnelArea {
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGanttArea extends StiClusteredBarArea implements IStiClusteredBarArea, IStiClusteredColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, IStiGanttArea, ICloneable {
        private static implementsStiGanttArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPictorialArea extends StiArea implements IStiJsonReportObject, IStiPictorialArea, IStiArea, ICloneable {
        private static implementsStiPictorialArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        private _roundValues;
        roundValues: boolean;
        private _actual;
        actual: boolean;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAreaArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, IStiRadarAreaArea, ICloneable {
        private static implementsStiRadarAreaArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarLineArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarArea, IStiArea, ICloneable, IStiRadarLineArea {
        private static implementsStiRadarLineArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointArea extends StiRadarArea implements IStiJsonReportObject, IStiRadarPointArea, IStiRadarArea, IStiArea, ICloneable {
        private static implementsStiRadarPointArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeArea extends StiClusteredColumnArea implements IStiArea, IStiRangeArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiRangeArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRangeBarArea extends StiClusteredColumnArea implements IStiArea, IStiRangeBarArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiRangeBarArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineRangeArea extends StiClusteredColumnArea implements IStiArea, IStiAxisArea, IStiClusteredColumnArea, IStiSplineRangeArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSplineRangeArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedRangeArea extends StiClusteredColumnArea implements IStiArea, IStiClusteredColumnArea, IStiSteppedRangeArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiSteppedRangeArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedAreaArea extends StiStackedColumnArea implements IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiStackedAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineArea extends StiStackedColumnArea implements IStiStackedLineArea, IStiArea, IStiAxisArea, IStiStackedColumnArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedLineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineArea extends StiStackedColumnArea implements IStiStackedSplineArea, IStiStackedColumnArea, IStiArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedSplineArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineAreaArea extends StiStackedColumnArea implements IStiAxisArea, IStiStackedColumnArea, IStiArea, IStiStackedSplineAreaArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStackedSplineAreaArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStockArea extends StiClusteredColumnArea implements IStiArea, IStiStockArea, IStiClusteredColumnArea, IStiAxisArea, IStiJsonReportObject, ICloneable {
        private static implementsStiStockArea;
        implements(): string[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        readonly componentId: StiComponentId;
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTreemapArea extends StiArea implements IStiJsonReportObject, IStiTreemapArea, ICloneable {
        private static implementsStiTreemapArea;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultSeriesLabelsType(): Stimulsoft.System.Type;
        getSeriesLabelsTypes(): Stimulsoft.System.Type[];
        getDefaultSeriesType(): Stimulsoft.System.Type;
        getSeriesTypes(): Stimulsoft.System.Type[];
        createNew(): StiArea;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiAxisTitle implements IStiAxisTitle, ICloneable, IStiJsonReportObject {
        private static implementsStiAxisTitle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiAxisTitle;
        private _core;
        core: StiAxisTitleCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _color;
        color: Color;
        private _antialiasing;
        antialiasing: boolean;
        private _alignment;
        alignment: StringAlignment;
        private _position;
        position: StiTitlePosition;
        private _direction;
        direction: StiDirection;
        constructor(font?: Font, text?: string, color?: Color, antialiasing?: boolean, alignment?: StringAlignment, direction?: StiDirection, allowApplyStyle?: boolean, position?: StiTitlePosition);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiConstantLines extends StiService implements IStiConstantLines, ICloneable, IStiJsonReportObject {
        private static implementsStiConstantLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiConstantLines;
        readonly serviceCategory: string;
        readonly ServiceType: Stimulsoft.System.Type;
        private _core;
        core: StiConstantLinesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _antialiasing;
        antialiasing: boolean;
        private _position;
        position: StiConstantLines_StiTextPosition;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _titleVisible;
        titleVisible: boolean;
        private _orientation;
        orientation: StiConstantLines_StiOrientation;
        private _lineWidth;
        lineWidth: number;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColor;
        lineColor: Color;
        private _showInLegend;
        showInLegend: boolean;
        private _showBehind;
        showBehind: boolean;
        private _axisValue;
        axisValue: string;
        private _visible;
        visible: boolean;
        private _chart;
        chart: IStiChart;
        toString(): string;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    class StiChartFiltersCollection extends CollectionBase<IStiChartFilter> implements IStiJsonReportObject, ICloneable {
        private static implementsStiChartFiltersCollection;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartFiltersCollection;
        add(filter: StiChartFilter): void;
        addRange(filters: StiChartFiltersCollection): void;
        addRange2(filters: StiChartFilter[]): void;
        contains(filter: StiChartFilter): boolean;
        indexOf(filter: StiChartFilter): number;
        insert(index: number, filter: StiChartFilter): void;
        remove(filter: StiChartFilter): void;
        getByIndex(index: number): StiChartFilter;
        setByIndex(index: number, value: StiChartFilter): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import IComparer = Stimulsoft.System.Collections.IComparer;
    class StiDataItem {
        argument: Object;
        value: Object;
        valueEnd: Object;
        weight: Object;
        valueOpen: Object;
        valueClose: Object;
        valueLow: Object;
        valueHigh: Object;
        title: Object;
        key: Object;
        color: Object;
        toolTip: any;
        tag: Object;
        constructor(argument: Object, value: Object, valueEnd: Object, weight: Object, valueOpen: Object, valueClose: Object, valueLow: Object, valueHight: Object, title: Object, key: Object, color: Object, toolTip: Object, tag: Object);
    }
    class StiDataItemComparer implements IComparer<StiDataItem> {
        compare(x: StiDataItem, y: StiDataItem): number;
        private directionFactor;
        private sortType;
        constructor(sortType: StiSeriesSortType, sortDirection: StiSeriesSortDirection);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, ICloneable {
        private static implementsStiRadarGridLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        needSetAreaJsonPropertyInternal: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiRadarGridLines;
        private _core;
        core: StiRadarGridLinesCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _color;
        color: Color;
        private _style;
        style: StiPenStyle;
        private _visible;
        visible: boolean;
        private _area;
        area: IStiArea;
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesHor extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesHor, ICloneable {
        private static implementsStiRadarGridLinesHor;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarGridLinesVert extends StiRadarGridLines implements IStiJsonReportObject, IStiRadarGridLines, IStiRadarGridLinesVert, ICloneable {
        private static implementsStiRadarGridLinesVert;
        implements(): string[];
        constructor(color?: Color, style?: StiPenStyle, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMarker implements IStiJsonReportObject, IStiMarker, ICloneable {
        private static implementsStiMarker;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiMarker;
        private _core;
        core: StiMarkerCoreXF;
        private _showInLegend;
        showInLegend: boolean;
        private _visible;
        visible: boolean;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        private _size;
        size: number;
        private _angle;
        angle: number;
        private _type;
        type: StiMarkerType;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineMarker extends StiMarker implements IStiJsonReportObject, IStiLineMarker, IStiMarker, ICloneable {
        private static implementsStiLineMarker;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _step;
        step: number;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarAxis implements IStiJsonReportObject, IStiRadarAxis, ICloneable {
        private static implementsStiRadarAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        jsonLoadFromJsonObjectArea: boolean;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarAxis;
        private _core;
        core: StiRadarAxisCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _visible;
        visible: boolean;
        private _area;
        area: IStiRadarArea;
        constructor(visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiRadarAxisLabels implements IStiJsonReportObject, IStiRadarAxisLabels, ICloneable {
        private static implementsStiRadarAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarAxisLabels;
        private _core;
        core: StiRadarAxisLabelsCoreXF;
        private _rotationLabels;
        rotationLabels: boolean;
        private _textBefore;
        textBefore: string;
        private _textAfter;
        textAfter: string;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _drawBorder;
        drawBorder: boolean;
        private _format;
        format: string;
        private _font;
        font: Font;
        private _antialiasing;
        antialiasing: boolean;
        private _color;
        color: Color;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _width;
        width: number;
        private _wordWrap;
        wordWrap: boolean;
        constructor(format?: string, font?: Font, antialiasing?: boolean, drawBorder?: boolean, color?: Color, borderColor?: Color, brush?: StiBrush, allowApplyStyle?: boolean, rotationLabels?: boolean, width?: number, wordWrap?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiXRadarAxis extends StiRadarAxis implements IStiXRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        private static implementsStiXRadarAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiXRadarAxis;
        readonly xCore: StiXRadarAxisCoreXF;
        private _labels;
        labels: IStiRadarAxisLabels;
        constructor(labels?: IStiRadarAxisLabels, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYRadarAxis extends StiRadarAxis implements IStiYRadarAxis, IStiRadarAxis, ICloneable, IStiJsonReportObject {
        private static implementsStiYRadarAxis;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiYRadarAxis;
        readonly yCore: StiYRadarAxisCoreXF;
        private _labels;
        labels: IStiAxisLabels;
        private _ticks;
        ticks: IStiAxisTicks;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _info;
        info: StiAxisInfoXF;
        constructor(labels?: IStiAxisLabels, ticks?: IStiAxisTicks, lineStyle?: StiPenStyle, lineColor?: Color, lineWidth?: number, visible?: boolean, allowApplyStyle?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideBaseAxisLabels extends StiCenterAxisLabels implements IStiInsideBaseAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        private static implementsStiInsideBaseAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, IStiInsideEndAxisLabels, ICloneable {
        private static implementsStiInsideEndAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLeftAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiLeftAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiLeftAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideAxisLabels extends StiAxisSeriesLabels implements IStiOutsideAxisLabels, IStiSeriesLabels, ICloneable, IStiAxisSeriesLabels, IStiJsonReportObject {
        private static implementsStiOutsideAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _lineLength;
        lineLength: number;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideBaseAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiOutsideBaseAxisLabels, IStiSeriesLabels, ICloneable {
        private static implementsStiOutsideBaseAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideEndAxisLabels extends StiCenterAxisLabels implements IStiOutsideEndAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiOutsideEndAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRightAxisLabels extends StiCenterAxisLabels implements IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiRightAxisLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiRightAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiValueAxisLabels extends StiCenterAxisLabels implements IStiValueAxisLabels, IStiCenterAxisLabels, IStiAxisSeriesLabels, IStiJsonReportObject, IStiSeriesLabels, ICloneable {
        private static implementsStiValueAxisLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiFunnelSeriesLabels, ICloneable, IStiSeriesLabels {
        private static implementsStiFunnelSeriesLabels;
        implements(): string[];
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterFunnelLabels extends StiFunnelSeriesLabels implements IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable, IStiCenterFunnelLabels {
        private static implementsStiCenterFunnelLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideLeftFunnelLabels extends StiFunnelSeriesLabels implements IStiCenterFunnelLabels, IStiOutsideLeftFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        private static implementsStiOutsideLeftFunnelLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiOutsideRightFunnelLabels extends StiFunnelSeriesLabels implements IStiOutsideRightFunnelLabels, IStiCenterFunnelLabels, IStiJsonReportObject, IStiSeriesLabels, IStiFunnelSeriesLabels, ICloneable {
        private static implementsStiOutsideRightFunnelLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiPieSeriesLabels extends StiSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, ICloneable {
        private static implementsStiPieSeriesLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _showInPercent;
        showInPercent: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiCenterPieLabels extends StiPieSeriesLabels implements IStiJsonReportObject, IStiPieSeriesLabels, IStiSeriesLabels, IStiCenterPieLabels, ICloneable {
        private static implementsStiCenterPieLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _autoRotate;
        autoRotate: boolean;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiInsideEndPieLabels extends StiCenterPieLabels implements IStiCenterPieLabels, IStiSeriesLabels, IStiPieSeriesLabels, IStiInsideEndPieLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiInsideEndPieLabels;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiOutsidePieLabels extends StiCenterPieLabels implements IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiOutsidePieLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _showValue;
        showValue: boolean;
        private _lineLength;
        lineLength: number;
        private _lineColor;
        lineColor: Color;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTwoColumnsPieLabels extends StiOutsidePieLabels implements IStiTwoColumnsPieLabels, IStiOutsidePieLabels, IStiCenterPieLabels, IStiPieSeriesLabels, IStiSeriesLabels, IStiJsonReportObject, ICloneable {
        private static implementsStiTwoColumnsPieLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiCenterTreemapLabels extends StiAxisSeriesLabels implements IStiCenterAxisLabels {
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiNoneLabels extends StiSeriesLabels implements IStiNoneLabels, IStiSeriesLabels, ICloneable, IStiJsonReportObject {
        private static implementsStiNoneLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        createNew(): StiSeriesLabels;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiBubbleSeries extends StiScatterSeries implements IStiBaseLineSeries, IStiBubbleSeries, IStiScatterSeries, IStiJsonReportObject, IStiSeries, ICloneable {
        private static implementsStiBubbleSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiBubbleSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _weights;
        weights: number[];
        weightsString: string;
        private _weightDataColumn;
        weightDataColumn: string;
        getWeight: Function;
        onGetWeight(e: StiGetValueEventArgs): void;
        invokeGetWeight(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfWeights: Function;
        onGetListOfWeights(e: StiGetValueEventArgs): void;
        invokeGetListOfWeights(sender: StiComponent, e: StiGetValueEventArgs): void;
        private _weight;
        weight: string;
        private _listOfWeights;
        listOfWeights: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiClusteredColumnSeries extends StiSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiClusteredColumnSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiClusteredColumnSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiClusteredBarSeries extends StiClusteredColumnSeries implements IStiJsonReportObject, IStiClusteredColumnSeries, IStiSeries, ICloneable, IStiClusteredBarSeries, IStiAllowApplyBrushNegative {
        private static implementsStiClusteredBarSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiLineSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiAreaSeries extends StiLineSeries implements IStiLineSeries, IStiBaseLineSeries, IStiAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiAreaSeries;
        private _topmostLine;
        topmostLine: boolean;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    class StiParetoSeries extends StiSeries implements IStiJsonReportObject, IStiParetoSeries, IStiBaseLineSeries, IStiClusteredColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiParetoSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiParetoSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        private _showNulls;
        showNulls: boolean;
        showMarker: boolean;
        markerColor: Color;
        markerSize: number;
        markerType: StiMarkerType;
        private _marker;
        marker: IStiMarker;
        private _lineMarker;
        lineMarker: IStiLineMarker;
        private _lineColor;
        lineColor: Color;
        getLineColor(): Color;
        setLineColor(value: Color): void;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        private _labelsOffset;
        labelsOffset: number;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSplineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, ICloneable, IStiSeries, IStiSplineSeries, IStiAllowApplyColorNegative {
        private static implementsStiSplineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _tension;
        tension: number;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineAreaSeries extends StiSplineSeries implements IStiSplineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiSplineAreaSeries, IStiAllowApplyColorNegative {
        private static implementsStiSplineAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSplineAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _topmostLine;
        topmostLine: boolean;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSteppedLineSeries extends StiBaseLineSeries implements IStiJsonReportObject, IStiBaseLineSeries, IStiSeries, ICloneable, IStiSteppedLineSeries, IStiAllowApplyColorNegative {
        private static implementsStiSteppedLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _pointAtCenter;
        pointAtCenter: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedAreaSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiJsonReportObject, IStiSteppedAreaSeries, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSteppedAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSteppedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _topmostLine;
        topmostLine: boolean;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Design {
    class StiSeriesInteractionConverter {
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiPieSeries extends StiSeries implements IStiPieSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        private static implementsStiPieSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiPieSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _allowApplyBrush;
        allowApplyBrush: boolean;
        private _allowApplyBorderColor;
        allowApplyBorderColor: boolean;
        getArguments(): Object[];
        setArguments(value: Object[]): void;
        private _startAngle;
        startAngle: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _lighting;
        lighting: boolean;
        private _diameter;
        diameter: number;
        private _distance;
        distance: number;
        private _cutPieListValues;
        cutPieListValues: number[];
        cuttedPieList: string;
        private _cutPieList;
        cutPieList: string;
        getCutPieList: Function;
        onGetCutPieList(e: StiGetValueEventArgs): void;
        invokeGetCutPieList(sender: StiComponent, e: StiGetValueEventArgs): void;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiDoughnutSeries extends StiPieSeries implements IStiPieSeries, IStiSeries, ICloneable, IStiDoughnutSeries, IStiJsonReportObject, IStiAllowApplyBorderColor, IStiAllowApplyBrush {
        private static implementsStiDoughnutSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiCandlestickSeries extends StiSeries implements IStiJsonReportObject, IStiSeries, IStiFinancialSeries, ICloneable, IStiCandlestickSeries {
        private static implementsStiCandlestickSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiCandlestickSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesOpen;
        valuesOpen: number[];
        private _valuesClose;
        valuesClose: number[];
        valuesStringOpen: string;
        valuesStringClose: string;
        valuesStringHigh: string;
        valuesStringLow: string;
        private _valuesHigh;
        valuesHigh: number[];
        private _valuesLow;
        valuesLow: number[];
        private _valueDataColumnOpen;
        valueDataColumnOpen: string;
        private _valueDataColumnClose;
        valueDataColumnClose: string;
        private _valueDataColumnHigh;
        valueDataColumnHigh: string;
        private _valueDataColumnLow;
        valueDataColumnLow: string;
        private _borderColor;
        borderColor: Color;
        private _borderColorNegative;
        borderColorNegative: Color;
        private _borderWidth;
        borderWidth: number;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        getValueOpen: Function;
        protected onGetValueOpen(e: StiGetValueEventArgs): void;
        invokeGetValueOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesOpen: Function;
        protected onGetListOfValuesOpen(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesOpen(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueClose: Function;
        protected onGetValueClose(e: StiGetValueEventArgs): void;
        invokeGetValueClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesClose: Function;
        protected onGetListOfValuesClose(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesClose(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueHigh: Function;
        protected onGetValueHigh(e: StiGetValueEventArgs): void;
        invokeGetValueHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesHigh: Function;
        protected onGetListOfValuesHigh(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesHigh(sender: StiComponent, e: StiGetValueEventArgs): void;
        getValueLow: Function;
        protected onGetValueLow(e: StiGetValueEventArgs): void;
        invokeGetValueLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesLow: Function;
        protected onGetListOfValuesLow(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesLow(sender: StiComponent, e: StiGetValueEventArgs): void;
        private valueObjOpen;
        valueOpen: string;
        private _listOfValuesOpen;
        listOfValuesOpen: string;
        private valueObjClose;
        valueClose: string;
        private _listOfValuesClose;
        listOfValuesClose: string;
        private valueObjHigh;
        valueHigh: string;
        private _listOfValuesHigh;
        listOfValuesHigh: string;
        private valueObjLow;
        valueLow: string;
        private _listOfValuesLow;
        listOfValuesLow: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStockSeries extends StiCandlestickSeries implements IStiJsonReportObject, IStiStockSeries, IStiFinancialSeries, ICloneable, IStiSeries, IStiAllowApplyColorNegative {
        private static implementsStiStockSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStockSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _lineColor;
        lineColor: Color;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineWidth;
        lineWidth: number;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedBarSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBarSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedBarSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedBarSeries extends StiStackedBarSeries implements IStiJsonReportObject, IStiStackedBarSeries, ICloneable, IStiSeries, IStiFullStackedBarSeries {
        private static implementsStiFullStackedBarSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedBaseLineSeries extends StiSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries {
        private static implementsStiStackedBaseLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiStackedBaseLineSeries;
        private _showNulls;
        showNulls: boolean;
        showMarker: boolean;
        markerColor: Color;
        markerSize: number;
        markerType: StiMarkerType;
        private _marker;
        marker: IStiMarker;
        private _lineMarker;
        lineMarker: IStiLineMarker;
        private _lighting;
        lighting: boolean;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lineColorNegative;
        lineColorNegative: Color;
        private _allowApplyColorNegative;
        allowApplyColorNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedLineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable {
        private static implementsStiStackedLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedAreaSeries extends StiStackedLineSeries implements ICloneable, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiJsonReportObject, IStiSeries, IStiStackedAreaSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedAreaSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        coreBrush: StiBrush;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedAreaSeries extends StiStackedAreaSeries implements IStiStackedAreaSeries, IStiStackedBaseLineSeries, IStiSeries, IStiJsonReportObject, IStiFullStackedAreaSeries, IStiStackedLineSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedAreaSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiStackedColumnSeries extends StiSeries implements IStiJsonReportObject, IStiStackedColumnSeries, ICloneable, IStiSeries, IStiAllowApplyBrushNegative {
        private static implementsStiStackedColumnSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedColumnSeries;
        private _showZeros;
        showZeros: boolean;
        private _width;
        width: number;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedColumnSeries extends StiStackedColumnSeries implements IStiFullStackedColumnSeries, IStiStackedColumnSeries, ICloneable, IStiSeries, IStiJsonReportObject, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedColumnSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedLineSeries extends StiStackedLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, IStiStackedLineSeries, IStiSeries, ICloneable {
        private static implementsStiFullStackedLineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStackedSplineSeries extends StiStackedBaseLineSeries implements IStiJsonReportObject, IStiStackedBaseLineSeries, ICloneable, IStiSeries, IStiStackedSplineSeries, IStiAllowApplyColorNegative {
        private static implementsStiStackedSplineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _tension;
        tension: number;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiStackedSplineAreaSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiStackedSplineAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiStackedSplineAreaSeries;
        private _brush;
        brush: StiBrush;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineAreaSeries extends StiStackedSplineAreaSeries implements IStiStackedSplineSeries, IStiFullStackedSplineAreaSeries, IStiStackedBaseLineSeries, IStiStackedSplineAreaSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiFullStackedSplineAreaSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFullStackedSplineSeries extends StiStackedSplineSeries implements IStiStackedSplineSeries, IStiStackedBaseLineSeries, IStiFullStackedSplineSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiFullStackedSplineSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiFunnelSeries extends StiSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiSeries, ICloneable {
        private static implementsStiFunnelSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiFunnelSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _showZeros;
        showZeros: boolean;
        private _allowApplyBrush;
        allowApplyBrush: boolean;
        private _allowApplyBorderColor;
        allowApplyBorderColor: boolean;
        private _brush;
        brush: StiBrush;
        private _borderColor;
        borderColor: Color;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiFunnelWeightedSlicesSeries extends StiFunnelSeries implements IStiJsonReportObject, IStiFunnelSeries, IStiFunnelWeightedSlicesSeries, IStiSeries, ICloneable {
        private static implementsStiFunnelWeightedSlicesSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        clone(): StiFunnelWeightedSlicesSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiGanttSeries extends StiClusteredBarSeries implements IStiClusteredColumnSeries, IStiClusteredBarSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, IStiGanttSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiGanttSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiGanttSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiGanttSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiPictorialSeries extends StiSeries implements IStiPictorialSeries, ICloneable, IStiSeries, IStiJsonReportObject {
        private static implementsStiPictorialSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        private _brush;
        brush: StiBrush;
        private _icon;
        icon: StiFontIcons;
        readonly componentId: StiComponentId;
        clone(): StiPictorialSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarSeries extends StiSeries implements IStiJsonReportObject, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiRadarSeries;
        private _showNulls;
        showNulls: boolean;
        private _marker;
        marker: IStiMarker;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarAreaSeries extends StiRadarSeries implements IStiRadarSeries, IStiRadarLineSeries, IStiJsonReportObject, IStiSeries, IStiRadarAreaSeries, ICloneable {
        private static implementsStiRadarAreaSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _lineColor;
        lineColor: Color;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        private _brush;
        brush: StiBrush;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiRadarLineSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarLineSeries, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarLineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        private _lineColor;
        lineColor: Color;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _lighting;
        lighting: boolean;
        private _lineWidth;
        lineWidth: number;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiRadarPointSeries extends StiRadarSeries implements IStiJsonReportObject, IStiRadarPointSeries, ICloneable, IStiSeries, IStiRadarSeries {
        private static implementsStiRadarPointSeries;
        implements(): string[];
        readonly componentId: StiComponentId;
        getDefaultAreaType(): Stimulsoft.System.Type;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiRangeBarSeries extends StiClusteredColumnSeries implements IStiRangeBarSeries, IStiClusteredColumnSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyBrushNegative {
        private static implementsStiRangeBarSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiRangeBarSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        getValueEnd: Function;
        protected onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        protected onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeBarSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiRangeSeries extends StiLineSeries implements IStiLineSeries, IStiLineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiRangeSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        brush: StiBrush;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiRangeSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSplineRangeSeries extends StiSplineSeries implements IStiSplineSeries, IStiSplineRangeSeries, IStiBaseLineSeries, IStiRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSplineRangeSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSplineRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        brush: StiBrush;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSplineRangeSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiSteppedRangeSeries extends StiSteppedLineSeries implements IStiSteppedLineSeries, IStiBaseLineSeries, IStiRangeSeries, IStiSteppedRangeSeries, IStiJsonReportObject, IStiSeries, ICloneable, IStiAllowApplyColorNegative {
        private static implementsStiSteppedRangeSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiSteppedRangeSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _brush;
        brush: StiBrush;
        private _valuesEnd;
        valuesEnd: number[];
        valuesStringEnd: string;
        private _valueDataColumnEnd;
        valueDataColumnEnd: string;
        private _brushNegative;
        brushNegative: StiBrush;
        private _allowApplyBrushNegative;
        allowApplyBrushNegative: boolean;
        getValueEnd: Function;
        onGetValueEnd(e: StiGetValueEventArgs): void;
        invokeGetValueEnd(sender: StiComponent, e: StiGetValueEventArgs): void;
        getListOfValuesEnd: Function;
        onGetListOfValuesEnd(e: StiGetValueEventArgs): void;
        invokeGetListOfValuesEnd(sender: StiComponent, e: StiGetValueEventArgs, series: StiSteppedRangeSeries): void;
        private valueObjEnd;
        valueEnd: string;
        private _listOfValuesEnd;
        listOfValuesEnd: string;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiScatterSplineSeries extends StiScatterSeries implements ICloneable, IStiScatterLineSeries, IStiBaseLineSeries, IStiScatterSplineSeries, IStiJsonReportObject, IStiSeries, IStiScatterSeries, IStiAllowApplyColorNegative {
        private static implementsStiScatterSplineSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        clone(): StiScatterSplineSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        private _tension;
        tension: number;
        createNew(): StiSeries;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTreemapSeries extends StiSeries implements IStiJsonReportObject, IStiTreemapSeries, ICloneable, IStiSeries {
        private static implementsStiTreemapSeries;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiTreemapSeries;
        getDefaultAreaType(): Stimulsoft.System.Type;
        readonly componentId: StiComponentId;
        createNew(): StiSeries;
        private _borderColor;
        borderColor: Color;
        private _brush;
        brush: StiBrush;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiSeriesInteraction implements /*IStiDefault,*/ IStiSeriesInteraction, IStiJsonReportObject, ICloneable {
        private static implementsStiSeriesInteraction;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        getReport(): any;
        clone(): StiSeriesInteraction;
        readonly isDefault: boolean;
        hyperlink: string;
        tag: string;
        toolTip: string;
        hyperlinkDataColumn: string;
        tagDataColumn: string;
        toolTipDataColumn: string;
        listOfHyperlinks: string;
        listOfTags: string;
        listOfToolTips: string;
        allowSeries: boolean;
        allowSeriesElements: boolean;
        drillDownEnabled: boolean;
        drillDownReport: string;
        drillDownPage: StiPage;
        drillDownPageGuid: string;
        readonly parentComponent: StiComponent;
        parentSeries: StiSeries;
    }
}
declare module Stimulsoft.Report.Chart {
    import Point = Stimulsoft.System.Drawing.Point;
    class StiSeriesInteractionData implements IStiSeriesInteractionData {
        isElements: boolean;
        tag: Object;
        tooltip: string;
        hyperlink: string;
        argument: Object;
        value: number;
        series: IStiSeries;
        pointIndex: number;
        point: Point;
        fill(area: IStiArea, series: IStiSeries, pointIndex: number): void;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiStrips extends StiService implements IStiJsonReportObject, IStiStrips, ICloneable {
        private static implementsStiStrips;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiStrips;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _core;
        core: StiStripsCoreXF;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _showBehind;
        showBehind: boolean;
        private _stripBrush;
        stripBrush: StiBrush;
        private _antialiasing;
        antialiasing: boolean;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _titleVisible;
        titleVisible: boolean;
        private _titleColor;
        titleColor: Color;
        private _orientation;
        orientation: StiStrips_StiOrientation;
        private _showInLegend;
        showInLegend: boolean;
        private _maxValue;
        maxValue: string;
        private _minValue;
        minValue: string;
        private _visible;
        visible: boolean;
        private _chart;
        chart: IStiChart;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle01 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiCustomStyle extends StiStyle01 implements IStiCustomStyle {
        private static implementsStiCustomStyle;
        implements(): string[];
        readonly serviceName: string;
        readonly customCore: StiCustomStyleCoreXF;
        constructor(reportStyleName?: string);
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle02 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle03 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle04 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle05 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle06 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle07 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle08 extends StiStyle03 {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle09 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle10 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle11 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle12 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle13 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle14 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle15 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle16 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle17 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle18 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle19 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle20 extends StiChartStyle {
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle21 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle22 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiStyle23 extends StiChartStyle {
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle24 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        readonly isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle26 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle27 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle28 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle30 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle31 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle32 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Chart {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiStyle33 extends StiChartStyle {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        isOffice2015Style: boolean;
        createNew(): StiChartStyle;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTableDataCells implements IStiChartTableDataCells, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTableDataCells;
        private _font;
        font: Font;
        private _textColor;
        textColor: Color;
        private _shrinkFontToFit;
        shrinkFontToFit: boolean;
        private _shrinkFontToFitMinimumSize;
        shrinkFontToFitMinimumSize: number;
        constructor(shrinkFontToFit?: boolean, shrinkFontToFitMinimumSize?: number, font?: Font, textColor?: Color);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiChartTableHeader implements IStiJsonReportObject, IStiChartTableHeader, ICloneable {
        private static implementsStiChartTableHeader;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        clone(): StiChartTableHeader;
        private _brush;
        brush: StiBrush;
        private _font;
        font: Font;
        private _textColor;
        textColor: Color;
        private _wordWrap;
        wordWrap: boolean;
        constructor(brush?: StiBrush, font?: Font, textColor?: Color, wordWrap?: boolean);
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiSeriesTopN implements IStiJsonReportObject, IStiSeriesTopN, ICloneable {
        private static implementsStiSeriesTopN;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiSeriesTopN;
        private _mode;
        mode: StiTopNMode;
        private _count;
        count: number;
        private _showOthers;
        showOthers: boolean;
        private _othersText;
        othersText: string;
    }
}
declare module Stimulsoft.Report.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiService = Stimulsoft.Base.Services.StiService;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTrendLine extends StiService implements IStiTrendLine, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLine;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static loadFromJsonObjectInternal(jObject: StiJson): IStiTrendLine;
        loadFromXml(xmlNode: XmlNode): void;
        static loadTrendLineFromXml(xmlNode: XmlNode): StiTrendLine;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiTrendLine;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Stimulsoft.System.Type;
        private _core;
        core: StiTrendLineCoreXF;
        private _lineColor;
        lineColor: Color;
        private _lineWidth;
        lineWidth: number;
        private _lineStyle;
        lineStyle: StiPenStyle;
        private _showShadow;
        showShadow: boolean;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        private _position;
        position: StiTrendLine_StiTextPosition;
        private _font;
        font: Font;
        private _text;
        text: string;
        private _titleVisible;
        titleVisible: boolean;
        createNew(): StiTrendLine;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineExponential extends StiTrendLine implements IStiTrendLine, ICloneable, IStiJsonReportObject, IStiTrendLineExponential {
        private static implementsStiTrendLineExponential;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLinear extends StiTrendLine implements IStiTrendLine, IStiTrendLineLinear, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLineLinear;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineLogarithmic extends StiTrendLine implements IStiTrendLine, IStiTrendLineLogarithmic, ICloneable, IStiJsonReportObject {
        private static implementsStiTrendLineLogarithmic;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiTrendLineNone extends StiTrendLine implements IStiTrendLine, IStiTrendLineNone, IStiJsonReportObject, ICloneable {
        private static implementsStiTrendLineNone;
        implements(): string[];
        readonly componentId: StiComponentId;
        createNew(): StiTrendLine;
        constructor();
    }
}
declare module Stimulsoft.Report.Chart {
    class StiChartOptions {
        private static _oldChartPercentMode;
        static oldChartPercentMode: boolean;
    }
}
declare module Stimulsoft.Report.Chart {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import PointD = Stimulsoft.System.Drawing.Point;
    import SizeD = Stimulsoft.System.Drawing.Size;
    class StiInteractionOptions {
        private _updateContext;
        updateContext: boolean;
        private _recallEvent;
        recallEvent: boolean;
        private _recallTime;
        recallTime: TimeSpan;
        private _isRecalled;
        isRecalled: boolean;
        private _mousePoint;
        mousePoint: PointD;
        private _dragEnabled;
        dragEnabled: boolean;
        private _dragDelta;
        dragDelta: SizeD;
        private _interactionToolTip;
        interactionToolTip: string;
        private _interactionHyperlink;
        interactionHyperlink: string;
        private _seriesInteractionData;
        seriesInteractionData: StiSeriesInteractionData;
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiPointHelper {
        private static getPointClassify;
        static isPointInTriangle(p: PointD, a: PointD, b: PointD, c: PointD): boolean;
        static isPointInPolygon(p: PointD, points: PointD[]): boolean;
        static getLineOffsetRectangle(point1: PointD, point2: PointD, offset: number): PointD[];
        static isLineContainsPoint(startPoint: PointD, endPoint: PointD, offset: number, point: PointD): boolean;
        static optimizePoints(points: PointD[]): PointD[];
    }
}
declare module Stimulsoft.Report.Chart {
    import PointD = Stimulsoft.System.Drawing.Point;
    class StiSimplifyHelper {
        private static getSquareDistance;
        private static getSquareSegmentDistance;
        private static simplifyRadialDistance;
        private static simplifyDouglasPeucker;
        static simplify(points: PointD[], tolerance: number, highestQuality: boolean): PointD[];
    }
}

declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.StiIndicatorRangeInfo;
    class StiBarRangeListCollection extends CollectionBase<StiIndicatorRangeInfo> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private barType;
        clone(): StiBarRangeListCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiIndicatorRangeInfo;
        setByIndex(index: number, value: StiIndicatorRangeInfo): void;
        add(element: StiIndicatorRangeInfo): void;
        addRange(elements: StiIndicatorRangeInfo[]): void;
        private addCore;
        insert(index: number, element: StiIndicatorRangeInfo): void;
        remove(element: StiIndicatorRangeInfo): boolean;
        contains(element: StiIndicatorRangeInfo): boolean;
        copyTo(elements: StiIndicatorRangeInfo[], arrayIndex: number): void;
        indexOf(element: StiIndicatorRangeInfo): number;
        private setItemInternal;
        moveUp(element: StiIndicatorRangeInfo): boolean;
        moveDown(element: StiIndicatorRangeInfo): boolean;
        constructor(barType: StiBarRangeListType);
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    class StiCustomValuesCollection extends CollectionBase<StiCustomValueBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiCustomValuesCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiCustomValueBase;
        setByIndex(index: number, value: StiCustomValueBase): void;
        add(element: StiCustomValueBase): void;
        addRange(elements: StiCustomValueBase[]): void;
        insert(index: number, element: StiCustomValueBase): void;
        remove(element: StiCustomValueBase): boolean;
        contains(element: StiCustomValueBase): boolean;
        copyTo(elements: StiCustomValueBase[], arrayIndex: number): void;
        indexOf(element: StiCustomValueBase): number;
        private setItemInternal;
        moveUp(element: StiCustomValueBase): boolean;
        moveDown(element: StiCustomValueBase): boolean;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiStateIndicatorFilter implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): any;
        private _startValue;
        startValue: number;
        private _endValue;
        endValue: number;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiStateIndicatorFilter = Stimulsoft.Report.Components.Gauge.StiStateIndicatorFilter;
    class StiFilterCollection extends CollectionBase<StiStateIndicatorFilter> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiFilterCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiStateIndicatorFilter;
        setByIndex(index: number, value: StiStateIndicatorFilter): void;
        add(element: StiStateIndicatorFilter): void;
        addRange(elements: StiStateIndicatorFilter[]): void;
        insert(index: number, element: StiStateIndicatorFilter): void;
        remove(element: StiStateIndicatorFilter): boolean;
        contains(element: StiStateIndicatorFilter): boolean;
        copyTo(elements: StiStateIndicatorFilter[], arrayIndex: number): void;
        indexOf(element: StiStateIndicatorFilter): number;
        private setItemInternal;
        moveUp(element: StiStateIndicatorFilter): boolean;
        moveDown(element: StiStateIndicatorFilter): boolean;
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiGaugeElementCollection extends CollectionBase<StiGaugeElement> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private scale;
        private scaleType;
        clone(): StiGaugeElementCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiGaugeElement;
        setByIndex(index: number, value: StiGaugeElement): void;
        toArray(): StiGaugeElement[];
        private addCore;
        add(element: StiGaugeElement): void;
        addRange(elements: StiGaugeElement[]): void;
        insert(index: number, element: StiGaugeElement): void;
        remove(element: StiGaugeElement): boolean;
        contains(element: StiGaugeElement): boolean;
        copyTo(elements: StiGaugeElement[], arrayIndex: number): void;
        indexOf(element: StiGaugeElement): number;
        private setItemInternal;
        moveUp(element: StiGaugeElement): boolean;
        moveDown(element: StiGaugeElement): boolean;
        constructor(scale: StiScaleBase);
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    class StiRangeCollection extends CollectionBase<StiRangeBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private parent;
        clone(): StiRangeCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiRangeBase;
        setByIndex(index: number, value: StiRangeBase): void;
        setParent(element: StiRangeBase): void;
        clearParent(element: StiRangeBase): void;
        add(element: StiRangeBase): void;
        addRange(elements: StiRangeBase[]): void;
        insert(index: number, element: StiRangeBase): void;
        remove(element: StiRangeBase): boolean;
        contains(element: StiRangeBase): boolean;
        copyTo(elements: StiRangeBase[], arrayIndex: number): void;
        indexOf(element: StiRangeBase): number;
        private setItemInternal;
        private addInternal;
        moveUp(element: StiRangeBase): boolean;
        moveDown(element: StiRangeBase): boolean;
        constructor(parent: StiScaleRangeList);
    }
}
declare module Stimulsoft.Report.Gauge.Collections {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import CollectionBase = Stimulsoft.System.Collections.CollectionBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiScaleCollection extends CollectionBase<StiScaleBase> implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): any;
        private parent;
        clone(): StiScaleCollection;
        readonly isReadOnly: boolean;
        getByIndex(index: number): StiScaleBase;
        setByIndex(index: number, value: StiScaleBase): void;
        private setParent;
        private clearParent;
        add(element: StiScaleBase): void;
        addRange(elements: StiScaleBase[]): void;
        private addRangeInternal;
        insert(index: number, element: StiScaleBase): void;
        remove(element: StiScaleBase): boolean;
        onRemoveComplete(index: number, value: any): void;
        onClearComplete(): void;
        contains(element: StiScaleBase): boolean;
        copyTo(elements: StiScaleBase[], arrayIndex: number): void;
        indexOf(element: StiScaleBase): number;
        private setItemInternal;
        private addInternal;
        moveUp(element: StiScaleBase): boolean;
        moveDown(element: StiScaleBase): boolean;
        private invokeElementsChanged;
        constructor(parent: StiGauge);
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetSkipIndicesEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetSkipValuesEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetTextEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetTextEventHandler: EventHandler;
    class StiGetTextEventArgs extends EventArgs {
        private _value;
        value: string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import StiEvent = Stimulsoft.Report.Events.StiEvent;
    class StiGetValueEvent extends StiEvent {
        toString(): string;
    }
}
declare module Stimulsoft.Report.Gauge.Events {
    import EventHandler = Stimulsoft.System.EventHandler;
    import EventArgs = Stimulsoft.System.EventArgs;
    var StiGetValueEventHandler: EventHandler;
    class StiGetValueEventArgs extends EventArgs {
        private _value;
        value: any;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiDrawingHelper {
        static getRoundedPath(rect: Rectangle, offset: number, leftTop: number, rightTop: number, rightBottom: number, leftBottom: number): void;
        private static PiDiv180;
        private static FourDivThree;
        static getArcGeometry(rect: Rectangle, startAngle: number, sweepAngle: number, startWidth: number, endWidth: number): void;
        static getRadialRangeGeometry(centerPoint: Point, startAngle: number, sweepAngle: number, radius1: number, radius2: number, radius3: number, radius4: number): void;
        private static round;
        private static convertArcToCubicBezier;
        private static convertArcToCubicBezier2;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiApplyStyleGauge = Stimulsoft.Report.Gauge.IStiApplyStyleGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiElementBase implements ICloneable, IStiApplyStyleGauge {
        applyStyle(style: IStiGaugeStyle): void;
        clone(): any;
        private _allowApplyStyle;
        allowApplyStyle: boolean;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeElement = Stimulsoft.Report.Components.Gauge.IStiGaugeElement;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiGaugeElement extends StiElementBase implements IStiJsonReportObject, IStiGaugeElement {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly PropName: string;
        animation: StiAnimation;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        private _scale;
        scale: StiScaleBase;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetSkipValuesEvent = Stimulsoft.Report.Gauge.Events.StiGetSkipValuesEvent;
    import StiGetSkipIndicesEvent = Stimulsoft.Report.Gauge.Events.StiGetSkipIndicesEvent;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiTickBase extends StiGaugeElement implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiTickBase;
        onGetSkipValues(e: StiGetValueEventArgs): void;
        invokeGetSkipValues(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getSkipValuesEvent;
        getSkipValuesEvent: StiGetSkipValuesEvent;
        onGetSkipIndices(e: StiGetValueEventArgs): void;
        invokeGetSkipIndices(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getSkipIndicesEvent;
        getSkipIndicesEvent: StiGetSkipIndicesEvent;
        private _skipValues;
        skipValues: string;
        private _skipIndices;
        skipIndices: string;
        private _placement;
        placement: Stimulsoft.Report.Gauge.StiPlacement;
        private _skipValuesObj;
        skipValuesObj: number[];
        private _skipIndicesObj;
        skipIndicesObj: number[];
        private _offset;
        offset: number;
        private _minimumValue;
        minimumValue: number;
        private _maximumValue;
        maximumValue: number;
        readonly isSkipMajorValues: boolean;
        getPointCollection(): Hashtable;
        getMinorCollections(): Hashtable;
        getMajorCollections(): Hashtable;
        checkTickValue(skipValues: number[], skipIndices: number[], key: number, value: number): boolean;
        prepareGaugeElement(): void;
        getOffset(value: number): number;
        getPlacement(value: Stimulsoft.Report.Gauge.StiPlacement): Stimulsoft.Report.Gauge.StiPlacement;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiTickLabelBase extends StiTickBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiTickLabelBase;
        private _textFormat;
        textFormat: string;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        getTextForRender(value: number, format: string): string;
        getTextForRender2(value: string, format?: string): string;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiRectangleHelper {
        static centerX(rect: Rectangle): number;
        static centerY(rect: Rectangle): number;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class CacheInfo {
        valueKey: number;
        valueStr: string;
        count: number;
        toString(): string;
        constructor(valueKey: number, valueStr: string, count: number);
    }
    class StiTickLabelHelper {
        static getLabels(collection: Hashtable): Dictionary<number, string>;
        private static prepare;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickLabelBase extends StiTickLabelBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMajor extends StiLinearTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle?: number, centerPoint?: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import StringFormat = Stimulsoft.System.Drawing.StringFormat;
    import StiAnimation = Stimulsoft.Base.Context.Animation.StiAnimation;
    class StiMarkerBaseSkin extends StiGaugeElementSkin {
        addLines(context: StiGaugeContextPainter, indicator: StiIndicatorBase, points: Point[], rect: Rectangle, angle: number, centerPoint: Point, sf: StringFormat, animation: StiAnimation): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker10Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker11Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker12Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker13Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker14Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker15Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker1Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker2Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker4Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker5Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker6Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker7Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker8Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMarker9Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiNeedleIndicator3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiNeedleIndicator4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    class StiState2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiState3Skin extends StiMarkerBaseSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark1Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark2Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark3Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark4Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark5Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark6Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Skins {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiMark7Skin extends StiGaugeElementSkin {
        draw(context: StiGaugeContextPainter, element: StiGaugeElement, rect: Rectangle, angle: number, centerPoint: Point): void;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    class StiGaugeSkinHelper {
        static getMarkerSkin(skin: StiMarkerSkin): StiGaugeElementSkin;
        static getTickMarkSkin(skin: StiTickMarkSkin): StiGaugeElementSkin;
        static getStateIndicatorSkin(skin: StiStateSkin): StiGaugeElementSkin;
        static getNeedleIndicatorSkin(skin: StiNeedleSkin): StiGaugeElementSkin;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiTickBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickBase;
    class StiTickMarkBase extends StiTickBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiTickMarkBase;
        private _relativeHeight;
        relativeHeight: number;
        private _relativeWidth;
        relativeWidth: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiTickMarkSkin;
        private _customSkin;
        customSkin: StiGaugeElementSkin;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        getActualSkin(): StiGaugeElementSkin;
        getRelativeWidth(value: number): number;
        getRelativeHeight(value: number): number;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickMarkBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialTickMarkBase extends StiTickMarkBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _offsetAngle;
        offsetAngle: number;
        readonly elementType: StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialTickMarkCustom extends StiRadialTickMarkBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialTickMarkCustom;
        private _valueObj;
        valueObj: number;
        private _values;
        values: StiCustomValuesCollection;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        private _value;
        value: string;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    class StiMathHelper {
        static length1(value1: number, value2: number): number;
        static maxMinusMin(value1: number, value2: number): number;
        static getMax(...list: number[]): number;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiLinearBarGeometry implements IStiScaleBarGeometry {
        private scale;
        private _size;
        readonly size: Size;
        private _rectGeometry;
        readonly rectGeometry: Rectangle;
        readonly radius: number;
        readonly diameter: number;
        private _center;
        readonly center: Point;
        checkRectGeometry(rect: Rectangle): void;
        private getRectGeometry;
        getRestToLenght(): number;
        private checkMinMaxWidth;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        drawGeometry(context: StiGaugeContextPainter, startValue1: number, endValue1: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        drawPrimitiveGeometry(context: StiGaugeContextPainter, rect: Rectangle, minAscent: number, maxAscent: number, startWidth: number, endWidth: number, placement: StiPlacement, restOffset: number, isStartGreaterEnd: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiLinearScale);
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import EventArgs = Stimulsoft.System.EventArgs;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGaugeElementCollection = Stimulsoft.Report.Gauge.Collections.StiGaugeElementCollection;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiScaleBase = Stimulsoft.Report.Components.Gauge.IStiScaleBase;
    class StiScaleHelper {
        actualMinimum: number;
        actualMaximum: number;
        minWidth: number;
        maxWidth: number;
        private _totalLength;
        totalLength: number;
    }
    class StiScaleBase extends StiElementBase implements IStiJsonReportObject, IStiScaleBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiScaleBase;
        barGeometry: IStiScaleBarGeometry;
        scaleHelper: StiScaleHelper;
        readonly isUp: boolean;
        private _gauge;
        gauge: StiGauge;
        private _left;
        left: number;
        private _top;
        top: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _majorInterval;
        majorInterval: number;
        private _minorInterval;
        minorInterval: number;
        private _minimum;
        minimum: number;
        private _maximum;
        maximum: number;
        private _isReversed;
        isReversed: boolean;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        _items: StiGaugeElementCollection;
        readonly items: StiGaugeElementCollection;
        set(value: StiGaugeElementCollection): void;
        readonly scaleType: StiGaugeElemenType;
        prepare(gauge: StiGauge): void;
        private calculateMinMaxScaleHelper;
        private calculateWidthScaleHelper;
        getPosition(value: number): number;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        drawElement(context: StiGaugeContextPainter): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Orientation = Stimulsoft.System.Windows.Forms.Orientation;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearScale extends StiScaleBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _orientation;
        orientation: Orientation;
        private _relativeHeight;
        relativeHeight: number;
        readonly scaleType: Stimulsoft.Report.Gauge.StiGaugeElemenType;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import IStiCustomValueBase = Stimulsoft.Report.Components.Gauge.IStiCustomValueBase;
    class StiCustomValueBase implements ICloneable, IStiCustomValueBase, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): any;
        private _value;
        value: number;
        private _placement;
        placement: StiPlacement;
        private _offset;
        offset: number;
        readonly localizedName: string;
        createNew(): StiCustomValueBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiCustomValueBase = Stimulsoft.Report.Components.Gauge.StiCustomValueBase;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickMarkCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialTickMarkCustomValue;
        useBrush: boolean;
        useBorderBrush: boolean;
        useBorderWidth: boolean;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        relativeHeight: number;
        private _offsetAngle;
        offsetAngle: number;
        private _skin;
        skin: StiGaugeElementSkin;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, offsetAngle?: number, placement?: StiPlacement, brush?: StiBrush, borderBrush?: StiBrush, borderWidth?: number, skin?: StiGaugeElementSkin);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMajor extends StiRadialTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiRadialTickMarkMinor extends StiRadialTickMarkBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiIndicatorRangeInfo = Stimulsoft.Report.Components.Gauge.IStiIndicatorRangeInfo;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiIndicatorRangeInfo implements ICloneable, IStiIndicatorRangeInfo, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): any;
        private _value;
        value: number;
        readonly rangeListType: StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiMixedColorHelper {
        static colorMixed(colors: Color[]): Color;
        private static colorMixer;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiIndicatorBase extends StiGaugeElement implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiIndicatorBase;
        private _valueObj;
        valueObj: number;
        private _placement;
        placement: Stimulsoft.Report.Gauge.StiPlacement;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        private _value;
        value: string;
        prepareGaugeElement(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        onValueChanged(): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBarRangeListCollection = Stimulsoft.Report.Gauge.Collections.StiBarRangeListCollection;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiBarBase extends StiIndicatorBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiBarBase;
        private _emptyBrush;
        emptyBrush: StiBrush;
        private _emptyBorderBrush;
        emptyBorderBrush: StiBrush;
        private _emptyBorderWidth;
        emptyBorderWidth: number;
        private _offset;
        offset: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _useRangeColor;
        useRangeColor: boolean;
        private _rangeList;
        rangeList: StiBarRangeListCollection;
        readonly barType: StiBarRangeListType;
        onRangeColorChanged(): void;
        checkActualBrushForTopGeometry(): void;
        onValueChanged(): void;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiLinearBar extends StiBarBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private colorModeHelper;
        private actualBackground;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiLinearBarSkin;
        private _rangeColorMode;
        rangeColorMode: Stimulsoft.Report.Gauge.StiLinearRangeColorMode;
        onRangeColorChanged(): void;
        readonly barType: Stimulsoft.Report.Gauge.StiBarRangeListType;
        readonly localizeName: string;
        checkActualBrushForTopGeometry(): void;
        private getRangeBrush;
        createNew(): StiGaugeElement;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        private drawHorizontalThermometer;
        private drawVerticalThermometer;
        private getGeometryHelperForTopIndicator;
        private getTopGeometry;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiLinearIndicatorRangeInfo extends StiIndicatorRangeInfo implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, report: StiReport): void;
        readonly componentId: StiComponentId;
        private _color;
        color: Color;
        private _brush;
        brush: StiBrush;
        readonly rangeListType: StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiMarkerBase extends StiIndicatorBase implements IStiGaugeMarker, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        clone(): StiMarkerBase;
        private _offset;
        offset: number;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        relativeHeight: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiMarkerSkin;
        private _customSkin;
        customSkin: StiGaugeElementSkin;
        private _format;
        format: string;
        private _showValue;
        showValue: boolean;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        getActualSkin(): StiGaugeElementSkin;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiLinearMarker extends StiMarkerBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        private getRectangle;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getBarPosition;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import Point = Stimulsoft.System.Drawing.Point;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    class StiNeedle extends StiIndicatorBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _format;
        format: string;
        private _showValue;
        showValue: boolean;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        private _capBrush;
        capBrush: StiBrush;
        private _capBorderBrush;
        capBorderBrush: StiBrush;
        private _capBorderWidth;
        capBorderWidth: number;
        private _offsetNeedle;
        offsetNeedle: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _autoCalculateCenterPoint;
        autoCalculateCenterPoint: boolean;
        private _centerPoint;
        centerPoint: Point;
        private _relativeHeight;
        relativeHeight: number;
        private _relativeWidth;
        relativeWidth: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiNeedleSkin;
        private _customSkin;
        customSkin: StiGaugeElementSkin;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getActualCenterPoint;
        private getActualSkin;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBarBase = Stimulsoft.Report.Components.Gauge.Primitives.StiBarBase;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import Point = Stimulsoft.System.Drawing.Point;
    class StiRadialBar extends StiBarBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private actualBush;
        private colorModeHelper;
        readonly elementType: StiGaugeElemenType;
        readonly barType: Stimulsoft.Report.Gauge.StiBarRangeListType;
        readonly localizeName: string;
        checkActualBrushForTopGeometry(): void;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        onRangeColorChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        private getRangeGeometry;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiBarRangeListType = Stimulsoft.Report.Gauge.StiBarRangeListType;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialIndicatorRangeInfo extends StiIndicatorRangeInfo implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _brush;
        brush: StiBrush;
        readonly rangeListType: StiBarRangeListType;
        createNew(): StiIndicatorRangeInfo;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiMarkerBase = Stimulsoft.Report.Components.Gauge.Primitives.StiMarkerBase;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiRadialMarker extends StiMarkerBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
        interactiveClick(rect: Rectangle, p: Point): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiFilterCollection = Stimulsoft.Report.Gauge.Collections.StiFilterCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiIndicatorBase = Stimulsoft.Report.Components.Gauge.Primitives.StiIndicatorBase;
    import IStiGaugeMarker = Stimulsoft.Report.Gauge.IStiGaugeMarker;
    class StiStateIndicator extends StiIndicatorBase implements IStiGaugeMarker, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private lastFilter;
        private _format;
        format: string;
        private _showValue;
        showValue: boolean;
        private _textBrush;
        textBrush: StiBrush;
        private _font;
        font: Font;
        readonly elementType: Stimulsoft.Report.Gauge.StiGaugeElemenType;
        readonly localizeName: string;
        private _filters;
        filters: StiFilterCollection;
        private _left;
        left: number;
        private _top;
        top: number;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        relativeHeight: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiStateSkin;
        private _customSkin;
        customSkin: Stimulsoft.Report.Gauge.StiGaugeElementSkin;
        createNew(): StiGaugeElement;
        onValueChanged(): void;
        interactiveClick(rect: Rectangle, p: Point): void;
        drawElement(context: StiGaugeContextPainter): void;
        getActualSkin(): Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiScaleBarGeometry = Stimulsoft.Report.Gauge.Primitives.IStiScaleBarGeometry;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialBarGeometry implements IStiScaleBarGeometry {
        private scale;
        private _size;
        readonly size: Size;
        private _rectGeometry;
        readonly rectGeometry: Rectangle;
        private _radius;
        readonly radius: number;
        private _diameter;
        readonly diameter: number;
        private _center;
        readonly center: Point;
        checkRectGeometry(rect: Rectangle): void;
        drawScaleGeometry(context: StiGaugeContextPainter): void;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
        constructor(scale: StiRadialScale);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import EventArgs = Stimulsoft.System.EventArgs;
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiRadialScale extends StiScaleBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialScale;
        applyStyle(style: IStiGaugeStyle): void;
        private _radius;
        radius: number;
        private _radiusMode;
        radiusMode: Stimulsoft.Report.Gauge.StiRadiusMode;
        private _center;
        center: Point;
        private _startAngle;
        startAngle: number;
        private _sweepAngle;
        sweepAngle: number;
        private _skin;
        skin: Stimulsoft.Report.Gauge.StiRadialScaleSkin;
        readonly scaleType: Stimulsoft.Report.Gauge.StiGaugeElemenType;
        getRadius(): number;
        getStartWidth(): number;
        getEndWidth(): number;
        getSweepAngle(): number;
        getCurrentAngle(angle: number): number;
        interactiveClick(e: EventArgs): void;
        createNew(): StiScaleBase;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import IStiRangeBase = Stimulsoft.Report.Components.Gauge.IStiRangeBase;
    class StiRangeBase implements ICloneable, IStiRangeBase, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly propName: string;
        clone(): StiRangeBase;
        private _brush;
        brush: StiBrush;
        private _borderBrush;
        borderBrush: StiBrush;
        private _borderWidth;
        borderWidth: number;
        private _startValue;
        startValue: number;
        private _endValue;
        endValue: number;
        private _startWidth;
        startWidth: number;
        private _endWidth;
        endWidth: number;
        private _placement;
        placement: StiPlacement;
        private _offset;
        offset: number;
        private _rangeList;
        rangeList: StiScaleRangeList;
        readonly localizeName: string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        createNew(): StiRangeBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    class StiLinearRange extends StiRangeBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        readonly localizeName: string;
        createNew(): StiRangeBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeCollection = Stimulsoft.Report.Gauge.Collections.StiRangeCollection;
    class StiScaleRangeList extends StiGaugeElement implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiScaleRangeList;
        private _ranges;
        ranges: StiRangeCollection;
        constructor();
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearRangeList extends StiScaleRangeList implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRangeBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRangeBase;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiRadialRange extends StiRangeBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _useValuesFromTheSpecifiedRange;
        useValuesFromTheSpecifiedRange: boolean;
        readonly localizeName: string;
        drawRange(context: StiGaugeContextPainter, scale: StiScaleBase): void;
        createNew(): StiRangeBase;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiScaleRangeList = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleRangeList;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    class StiRadialRangeList extends StiScaleRangeList implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        readonly elementType: StiGaugeElemenType;
        createNew(): StiGaugeElement;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    class StiLinearTickMarkBase extends StiTickMarkBase {
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    class StiLinearTickMarkCustom extends StiLinearTickMarkBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiLinearTickMarkCustom;
        private _valueObj;
        valueObj: number;
        private _values;
        values: StiCustomValuesCollection;
        readonly localizeName: string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        private _value;
        value: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElementSkin = Stimulsoft.Report.Gauge.StiGaugeElementSkin;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickMarkCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _relativeWidth;
        relativeWidth: number;
        private _relativeHeight;
        get(): number;
        relativeHeight: number;
        private _skin;
        skin: StiGaugeElementSkin;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, offset?: number, relativeWidth?: number, relativeHeight?: number, placement?: StiPlacement, skin?: StiGaugeElementSkin);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMajor extends StiLinearTickMarkBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickMarkBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickMarkBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickMarkMinor extends StiLinearTickMarkBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge.Primitives {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiTickLabelBase;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import Point = Stimulsoft.System.Drawing.Point;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiRadialTickLabelBase extends StiTickLabelBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        private _labelRotationMode;
        labelRotationMode: Stimulsoft.Report.Gauge.StiLabelRotationMode;
        private _offsetAngle;
        offsetAngle: number;
        readonly elementType: StiGaugeElemenType;
        drawElement(context: StiGaugeContextPainter): void;
        getMatrixRotation(context: StiGaugeContextPainter, centerPoint: Point, textSize: Size, rotateMode: Stimulsoft.Report.Gauge.StiLabelRotationMode, radius: number, angle: number, REFposition: any): number;
        private getRadialPosition;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGetTextEvent = Stimulsoft.Report.Gauge.Events.StiGetTextEvent;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    class StiRadialTickLabelCustom extends StiRadialTickLabelBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiRadialTickLabelCustom;
        private _valueObj;
        valueObj: number;
        private _textObj;
        textObj: string;
        private _values;
        values: StiCustomValuesCollection;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _getTextEvent;
        getTextEvent: StiGetTextEvent;
        private _value;
        value: string;
        private _text;
        text: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
        private getOffsetAngle;
        private getLabelRotationMode;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiLabelRotationMode = Stimulsoft.Report.Gauge.StiLabelRotationMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiRadialTickLabelCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _text;
        text: string;
        private _offsetAngle;
        offsetAngle: number;
        private _labelRotationMode;
        labelRotationMode: StiLabelRotationMode;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, text?: string, offset?: number, offsetAngle?: number, labelRotationMode?: StiLabelRotationMode, placement?: StiPlacement);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMajor extends StiRadialTickLabelBase {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiGaugeElemenType = Stimulsoft.Report.Gauge.StiGaugeElemenType;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiRadialTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiRadialTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiRadialTickLabelMinor extends StiRadialTickLabelBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly elementType: StiGaugeElemenType;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Gauge.Helpers {
    import TimeSpan = Stimulsoft.System.TimeSpan;
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeHelper {
        static globalDurationElement: TimeSpan;
        static globalBeginTimeElement: TimeSpan;
        static getFloatValueFromObject(valueObj: any, scale: StiScaleBase): number;
        static getFloatValueFromObject2(valueObj: any, defaultValue: number): number;
        static getFloatArrayValueFromString(value: any): number[];
        private static initializeGauge;
        private static initializeName;
        static checkGaugeName(gauge: StiGauge): void;
        static simpleRadialGauge(gauge: StiGauge, report: StiReport): void;
        static radialTwoScalesGauge(gauge: StiGauge, report: StiReport): void;
        static radialBarGauge(gauge: StiGauge, report: StiReport): void;
        static simpleTwoBarGauge(gauge: StiGauge, report: StiReport): void;
        static defaultRadialGauge(gauge: StiGauge, report: StiReport): void;
        static defaultLinearGauge(gauge: StiGauge, report: StiReport): void;
        static linearGaugeRangeList(gauge: StiGauge, report: StiReport): void;
        static bulletGraphsGreen(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge(gauge: StiGauge, report: StiReport): void;
        static halfDonutsGauge2(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleN(gauge: StiGauge, report: StiReport): void;
        static radialGaugeHalfCircleS(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleNE(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSW(gauge: StiGauge, report: StiReport): void;
        static radialGaugeQuarterCircleSE(gauge: StiGauge, report: StiReport): void;
        private static radialGaugeQuarterCircle;
        static horizontalThermometer(gauge: StiGauge, report: StiReport): void;
        static verticalThermometer(gauge: StiGauge, report: StiReport): void;
        static lightSpeedometer(gauge: StiGauge, report: StiReport): void;
        static darkSpeedometer(gauge: StiGauge, report: StiReport): void;
    }
}
declare module Stimulsoft.Report.Gauge.Primitives {
    import StiGraphicsPathLinesGaugeGeom = Stimulsoft.Report.Gauge.GaugeGeoms.StiGraphicsPathLinesGaugeGeom;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    var IStiScaleBarGeometry: string;
    interface IStiScaleBarGeometry {
        size: Size;
        rectGeometry: Rectangle;
        center: Point;
        radius: number;
        diameter: number;
        checkRectGeometry(rect: Rectangle): any;
        drawScaleGeometry(context: StiGaugeContextPainter): any;
        getRestToLenght(): number;
        drawGeometry(context: StiGaugeContextPainter, startValue: number, endValue: number, startWidth: number, endWidth: number, offset: number, placement: StiPlacement, REFrect: any, returnOnlyRect: boolean): StiGraphicsPathLinesGaugeGeom;
    }
}
declare module Stimulsoft.Report.Gauge.Primitives {
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    var IStiTickCustom: string;
    interface IStiTickCustom {
        valueObj: number;
        values: StiCustomValuesCollection;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeStyleCoreXF implements IStiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMajorBorderWidth: number;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickMarkMinorBorderWidth: number;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
        markerSkin: StiMarkerSkin;
        markerBrush: StiBrush;
        markerBorderBrush: StiBrush;
        markerBorderWidth: number;
        styleId: StiGaugeStyleId;
        gauge: StiGauge;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF25 extends StiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: any;
        linearBarEmptyBorderBrush: any;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiGaugeStyle = Stimulsoft.Report.StiGaugeStyle;
    class StiCustomGaugeStyleCoreXF extends StiGaugeStyleCoreXF25 {
        private readonly _super;
        readonly localizedName: string;
        private _reportGaugeStyle;
        reportGaugeStyle: StiGaugeStyle;
        readonly reportStyleName: string;
        readonly brush: StiBrush;
        readonly borderColor: Color;
        readonly foreColor: Color;
        readonly borderWidth: number;
        readonly tickMarkMajorBrush: StiBrush;
        readonly tickMarkMajorBorder: StiBrush;
        readonly tickMarkMajorBorderWidth: number;
        readonly tickMarkMinorBrush: StiBrush;
        readonly tickMarkMinorBorder: StiBrush;
        readonly tickMarkMinorBorderWidth: number;
        readonly tickLabelMajorTextBrush: StiBrush;
        readonly tickLabelMajorFont: Font;
        readonly tickLabelMinorTextBrush: StiBrush;
        readonly tickLabelMinorFont: Font;
        readonly markerBrush: StiBrush;
        readonly linearBarBrush: StiBrush;
        readonly linearBarBorderBrush: StiBrush;
        readonly linearBarEmptyBrush: any;
        readonly linearBarEmptyBorderBrush: any;
        readonly linearBarStartWidth: number;
        readonly linearBarEndWidth: number;
        readonly radialBarBrush: StiBrush;
        readonly radialBarBorderBrush: StiBrush;
        readonly radialBarEmptyBrush: StiBrush;
        readonly radialBarEmptyBorderBrush: StiBrush;
        readonly radialBarStartWidth: number;
        readonly radialBarEndWidth: number;
        readonly needleBrush: StiBrush;
        readonly needleBorderBrush: StiBrush;
        readonly needleCapBrush: StiBrush;
        readonly needleCapBorderBrush: StiBrush;
        readonly needleBorderWidth: number;
        readonly needleCapBorderWidth: number;
        readonly needleStartWidth: number;
        readonly needleEndWidth: number;
        readonly needleRelativeHeight: number;
        readonly needleRelativeWith: number;
        constructor(style: StiGaugeStyle);
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF24 extends StiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF26 extends StiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF27 extends StiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiEmptyBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare module Stimulsoft.Report.Gauge {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Font = Stimulsoft.System.Drawing.Font;
    class StiGaugeStyleCoreXF28 extends StiGaugeStyleCoreXF {
        localizedName: string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiEmptyBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiEmptyBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
    class StiGaugeStyleCoreXF29 extends StiGaugeStyleCoreXF {
        /**
         *  Gets a localized name of style.
         */
        localizedName: string;
        brush: StiSolidBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiSolidBrush;
        tickMarkMajorBorder: StiEmptyBrush;
        tickMarkMinorBrush: StiSolidBrush;
        tickMarkMinorBorder: StiEmptyBrush;
        tickLabelMajorTextBrush: StiSolidBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiSolidBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiSolidBrush;
        linearMarkerBorder: StiSolidBrush;
        linearScaleBrush: StiSolidBrush;
        linearBarBrush: StiSolidBrush;
        linearBarBorderBrush: StiEmptyBrush;
        linearBarEmptyBrush: StiEmptyBrush;
        linearBarEmptyBorderBrush: StiEmptyBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiSolidBrush;
        radialBarBorderBrush: StiEmptyBrush;
        radialBarEmptyBrush: StiSolidBrush;
        radialBarEmptyBorderBrush: StiEmptyBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiSolidBrush;
        needleBorderBrush: StiEmptyBrush;
        needleCapBrush: StiSolidBrush;
        needleCapBorderBrush: StiSolidBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiGaugeStyleCoreXF = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF30 extends StiGaugeStyleCoreXF {
        /**
         *  Gets a localized name of style.
         */
        localizedName: string;
        brush: StiBrush;
        foreColor: Color;
        borderColor: Color;
        borderWidth: number;
        tickMarkMajorBrush: StiBrush;
        tickMarkMajorBorder: StiBrush;
        tickMarkMinorBrush: StiBrush;
        tickMarkMinorBorder: StiBrush;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        linearBarBorderBrush: StiBrush;
        linearBarEmptyBrush: StiBrush;
        linearBarEmptyBorderBrush: StiBrush;
        linearBarStartWidth: number;
        linearBarEndWidth: number;
        radialBarBrush: StiBrush;
        radialBarBorderBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
        radialBarEmptyBorderBrush: StiBrush;
        radialBarStartWidth: number;
        radialBarEndWidth: number;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleBorderWidth: number;
        needleCapBorderWidth: number;
        needleStartWidth: number;
        needleEndWidth: number;
        needleRelativeHeight: number;
        needleRelativeWith: number;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF31 extends StiGaugeStyleCoreXF30 {
        /**
         *  Gets a localized name of style.
         */
        localizedName: string;
        brush: StiBrush;
        foreColor: System.Drawing.Color;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    class StiGaugeStyleCoreXF32 extends StiGaugeStyleCoreXF30 {
        /**
         *  Gets a localized name of style.
         */
        localizedName: string;
        brush: StiBrush;
        foreColor: System.Drawing.Color;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleCapBorderWidth: number;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiGaugeStyleCoreXF30 = Stimulsoft.Report.Gauge.StiGaugeStyleCoreXF30;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Font = System.Drawing.Font;
    import Color = System.Drawing.Color;
    class StiGaugeStyleCoreXF33 extends StiGaugeStyleCoreXF30 {
        /**
         *  Gets a localized name of style.
         */
        localizedName: string;
        brush: StiBrush;
        foreColor: Color;
        tickLabelMajorTextBrush: StiBrush;
        tickLabelMajorFont: Font;
        tickLabelMinorTextBrush: StiBrush;
        tickLabelMinorFont: Font;
        markerBrush: StiBrush;
        linearMarkerBorder: StiBrush;
        needleBrush: StiBrush;
        needleBorderBrush: StiBrush;
        needleCapBrush: StiBrush;
        needleCapBorderBrush: StiBrush;
        needleCapBorderWidth: number;
        linearScaleBrush: StiBrush;
        linearBarBrush: StiBrush;
        radialBarBrush: StiBrush;
        radialBarEmptyBrush: StiBrush;
    }
}
declare module Stimulsoft.Report.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Type = Stimulsoft.System.Type;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    class StiGaugeStyleXF extends StiBaseStyle implements IStiGaugeStyle, IStiJsonReportObject {
        private static implementsStiGaugeStyleXF;
        implements(): string[];
        readonly componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        static createFromJsonObject(jObject: StiJson): StiGaugeStyleXF;
        static createFromXml(xmlNode: XmlNode): StiGaugeStyleXF;
        readonly serviceName: string;
        readonly serviceCategory: string;
        readonly serviceType: Type;
        private _core;
        core: StiGaugeStyleCoreXF;
        allowDashboard: boolean;
        styleIdent: StiElementStyleIdent;
        toString(): string;
        compareGaugeStyle(style: StiGaugeStyleXF): boolean;
        drawStyle(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        drawBox(g: Graphics, rect: Rectangle, paintValue: boolean, paintImage: boolean): void;
        getStyleFromComponent(component: StiComponent, styleElements: StiStyleElements): void;
        setStyleToComponent(component: StiComponent): void;
        createNew(): StiGaugeStyleXF;
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF27 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiCustomGaugeStyleCoreXF = Stimulsoft.Report.Gauge.StiCustomGaugeStyleCoreXF;
    class StiCustomGaugeStyle extends StiGaugeStyleXF27 {
        readonly serviceName: string;
        readonly customCore: StiCustomGaugeStyleCoreXF;
        constructor(style?: StiGaugeStyle);
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF24 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF25 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF26 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF28 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF29 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF30 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF31 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF32 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare namespace Stimulsoft.Report.Gauge {
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    class StiGaugeStyleXF33 extends StiGaugeStyleXF {
        allowDashboard: boolean;
        dashboardName: string;
        styleIdent: StiElementStyleIdent;
        createNew(): StiGaugeStyleXF;
        constructor();
    }
}
declare module Stimulsoft.Report.Gauge {
    var IStiApplyStyleGauge: string;
    interface IStiApplyStyleGauge {
        applyStyle(style: IStiGaugeStyle): any;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGetTextEventArgs = Stimulsoft.Report.Gauge.Events.StiGetTextEventArgs;
    import StiGetTextEvent = Stimulsoft.Report.Gauge.Events.StiGetTextEvent;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
    import StiCustomValuesCollection = Stimulsoft.Report.Gauge.Collections.StiCustomValuesCollection;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import StiGetValueEvent = Stimulsoft.Report.Events.StiGetValueEvent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiTickCustom = Stimulsoft.Report.Gauge.Primitives.IStiTickCustom;
    class StiLinearTickLabelCustom extends StiLinearTickLabelBase implements IStiTickCustom, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        clone(): StiLinearTickLabelCustom;
        private _valueObj;
        valueObj: number;
        private _textObj;
        textObj: string;
        private _values;
        values: StiCustomValuesCollection;
        readonly localizeName: string;
        onGetValue(e: StiGetValueEventArgs): void;
        invokeGetValue(sender: StiGaugeElement, e: StiGetValueEventArgs): void;
        private _getValueEvent;
        getValueEvent: StiGetValueEvent;
        onGetText(e: StiGetTextEventArgs): void;
        invokeGetText(sender: StiGaugeElement, e: StiGetTextEventArgs): void;
        private _getTextEvent;
        getTextEvent: StiGetTextEvent;
        private _value;
        value: string;
        private _text;
        text: string;
        createNew(): StiGaugeElement;
        prepareGaugeElement(): void;
        drawElement(context: StiGaugeContextPainter): void;
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiPlacement = Stimulsoft.Report.Gauge.StiPlacement;
    class StiLinearTickLabelCustomValue extends StiCustomValueBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        private _text;
        text: string;
        readonly localizedName: string;
        toString(): string;
        createNew(): StiCustomValueBase;
        constructor(value?: number, text?: string, offset?: number, placement?: StiPlacement);
    }
}
declare module Stimulsoft.Report.Components.Gauge {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiGaugeElement = Stimulsoft.Report.Components.Gauge.Primitives.StiGaugeElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLinearTickLabelBase = Stimulsoft.Report.Components.Gauge.Primitives.StiLinearTickLabelBase;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    class StiLinearTickLabelMinor extends StiLinearTickLabelBase implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        readonly componentId: StiComponentId;
        applyStyle(style: IStiGaugeStyle): void;
        private _skipMajorValues;
        skipMajorValues: boolean;
        readonly isSkipMajorValues: boolean;
        readonly localizeName: string;
        createNew(): StiGaugeElement;
        getPointCollection(): Hashtable;
    }
}
declare module Stimulsoft.Report.Components {
    import StiGaugeCalculationMode = Stimulsoft.Report.Gauge.StiGaugeCalculationMode;
    import StiGaugeType = Stimulsoft.Report.Gauge.StiGaugeType;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiGaugeContextPainter = Stimulsoft.Report.Painters.StiGaugeContextPainter;
    import StiScaleCollection = Stimulsoft.Report.Gauge.Collections.StiScaleCollection;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiExportImageExtended = Stimulsoft.Report.Components.IStiExportImageExtended;
    import IStiBorder = Stimulsoft.Report.Components.IStiBorder;
    import IStiBrush = Stimulsoft.Report.Components.IStiBrush;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiGaugeStyle = Stimulsoft.Report.Gauge.IStiGaugeStyle;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiGauge extends StiComponent implements IStiExportImageExtended, IStiBorder, IStiBrush, IStiGauge, IStiJsonReportObject {
        private static implementsStiGauge;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly componentId: StiComponentId;
        clone(cloneProperties?: boolean, cloneComponents?: boolean): StiGauge;
        getImage(REFzoom: any, format?: StiExportFormat): Image;
        isExportAsImage(format: StiExportFormat): boolean;
        private _border;
        border: StiBorder;
        private _brush;
        brush: StiBrush;
        readonly localizedCategory: string;
        readonly localizedName: string;
        readonly defaultClientRectangle: Rectangle;
        shortValue: boolean;
        minimum: number;
        maximum: number;
        type: StiGaugeType;
        calculationMode: StiGaugeCalculationMode;
        painter: StiGaugeContextPainter;
        private _style;
        style: IStiGaugeStyle;
        private _allowApplyStyle;
        /**
         *N Gets or sets value which indicates that gauge style will be used.
         */
        allowApplyStyle: boolean;
        private _customStyleName;
        customStyleName: string;
        private _scales;
        scales: StiScaleCollection;
        private _isAnimation;
        isAnimation: boolean;
        private changeSkin;
        drawGauge(context: StiGaugeContextPainter): void;
        createNew(): StiComponent;
        applyStyle(style: IStiGaugeStyle): void;
        /**
         *  Creates a new StiGauge.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}

/**
 * @hidden
 */
declare module Stimulsoft.Reflection {
    class StiTypesHelper {
        static run(type?: Stimulsoft.System.Type, namespace?: string): void;
    }
}
/**
 * @hidden
 */
declare var _module: any;

declare module Stimulsoft.Report.Maps {
    class StiMapResourcesAlbania {
        static Albania: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesAndorra {
        static Andorra: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesArgentina {
        static Argentina: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesArgentinaFD {
        static ArgentinaFD: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesArmenia {
        static Armenia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesAustralia {
        static Australia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesAustria {
        static Austria: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesAzerbaijan {
        static Azerbaijan: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesBelarus {
        static Belarus: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesBelgium {
        static Belgium: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesBolivia {
        static Bolivia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesBosniaAndHerzegovina {
        static BosniaAndHerzegovina: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesBrazil {
        static Brazil: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesBulgaria {
        static Bulgaria: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesCanada {
        static Canada: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesChile {
        static Chile: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesChina {
        static China: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesColombia {
        static Colombia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesCroatia {
        static Croatia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesCyprus {
        static Cyprus: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesCzechRepublic {
        static CzechRepublic: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesDenmark {
        static Denmark: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesEU {
        static EU: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesEcuador {
        static Ecuador: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesEstonia {
        static Estonia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesEurope {
        static Europe: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesFalklandIslands {
        static FalklandIslands: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesFinland {
        static Finland: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesFrance {
        static France: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesGeorgia {
        static Georgia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesGermany {
        static Germany: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesGreece {
        static Greece: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesGuyana {
        static Guyana: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesHungary {
        static Hungary: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesIceland {
        static Iceland: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesIndia {
        static India: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesIndonesia {
        static Indonesia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesIreland {
        static Ireland: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesIsrael {
        static Israel: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesItaly {
        static Italy: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesJapan {
        static Japan: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesKazakhstan {
        static Kazakhstan: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesLatvia {
        static Latvia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesLiechtenstein {
        static Liechtenstein: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesLithuania {
        static Lithuania: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesLuxembourg {
        static Luxembourg: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMacedonia {
        static Macedonia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMalaysia {
        static Malaysia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMalta {
        static Malta: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMexico {
        static Mexico: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMiddleEast {
        static MiddleEast: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMoldova {
        static Moldova: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMonaco {
        static Monaco: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesMontenegro {
        static Montenegro: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesNetherlands {
        static Netherlands: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesNewZealand {
        static NewZealand: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesNorthAmerica {
        static NorthAmerica: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesNorway {
        static Norway: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesOman {
        static Oman: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesParaguay {
        static Paraguay: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesPeru {
        static Peru: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesPhilippines {
        static Philippines: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesPoland {
        static Poland: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesPortugal {
        static Portugal: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesQatar {
        static Qatar: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesRomania {
        static Romania: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesRussia {
        static Russia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSanMarino {
        static SanMarino: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSaudiArabia {
        static SaudiArabia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSerbia {
        static Serbia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSlovakia {
        static Slovakia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSlovenia {
        static Slovenia: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSouthAfrica {
        static SouthAfrica: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSouthAmerica {
        static SouthAmerica: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSouthKorea {
        static SouthKorea: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSpain {
        static Spain: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSuriname {
        static Suriname: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSweden {
        static Sweden: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesSwitzerland {
        static Switzerland: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesTaiwan {
        static Taiwan: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesThailand {
        static Thailand: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesTurkey {
        static Turkey: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesUK {
        static UK: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesUKCountries {
        static UKCountries: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesUSA {
        static USA: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesUSAAndCanada {
        static USAAndCanada: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesUkraine {
        static Ukraine: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesUruguay {
        static Uruguay: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesVatican {
        static Vatican: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesVenezuela {
        static Venezuela: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesVietnam {
        static Vietnam: string;
    }
}
declare module Stimulsoft.Report.Maps {
    class StiMapResourcesWorld {
        static World: string;
    }
}

declare namespace Stimulsoft.Dashboard.Components.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts a StiMeter object from one data type to another.
     */
    class StiMeterConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiValueChartMeter object from one data type to another.
     */
    class StiValueChartMeterConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts a StiXChartAxis object from one data type to another.
     */
    class StiXChartAxisConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts a StiYChartAxis object from one data type to another.
     */
    class StiYChartAxisConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Helpers {
    import List = Stimulsoft.System.Collections.List;
    class StiChartGroups {
        private static hash;
        private static isInit;
        static sameGroup(type1: StiChartSeriesType, type2: StiChartSeriesType): boolean;
        static getGroup(type: StiChartSeriesType): List<StiChartSeriesType>;
        static init(): void;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart.Helpers {
    import StiSeries = Stimulsoft.Report.Chart.StiSeries;
    /**
     *  This class helps in creation of new  chart series object based on specified Ident of series type.
     */
    class StiChartSeriesCreator {
        /**
         *  Creates new  chart series object with help of its identification type name.
         *  @param typeName A name of the identification type which is used for the series creation.
         *  @returns Created series object.
         */
        static neww(typeName: string): StiSeries;
        /**
         *  Creates new  chart series object with help of it type.
         *  @param type An idendification type of the series.
         *  @returns Created series object.
         */
        static neww2(type: StiChartSeriesType): StiSeries;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    enum StiChartSeriesType {
        ClusteredColumn = 1,
        StackedColumn = 2,
        FullStackedColumn = 3,
        Pareto = 4,
        Line = 5,
        StackedLine = 6,
        FullStackedLine = 7,
        Spline = 8,
        StackedSpline = 9,
        FullStackedSpline = 10,
        SteppedLine = 11,
        Area = 12,
        StackedArea = 13,
        FullStackedArea = 14,
        SplineArea = 15,
        StackedSplineArea = 16,
        FullStackedSplineArea = 17,
        SteppedArea = 18,
        Range = 19,
        SplineRange = 20,
        SteppedRange = 21,
        RangeBar = 22,
        ClusteredBar = 23,
        StackedBar = 24,
        FullStackedBar = 25,
        Scatter = 26,
        ScatterLine = 27,
        ScatterSpline = 28,
        Pie = 29,
        RadarPoint = 30,
        RadarLine = 31,
        RadarArea = 32,
        Funnel = 33,
        FunnelWeightedSlices = 34,
        Candlestick = 35,
        Stock = 36,
        Treemap = 37,
        Gantt = 38,
        Doughnut = 39,
        Bubble = 40,
        Pictorial = 41
    }
    enum StiChartLabelsStyle {
        Value = 0,
        PercentOfTotal = 1,
        Category = 2,
        CategoryValue = 3,
        CategoryPercentOfTotal = 4
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiLocalizedMeter = Stimulsoft.Base.Meters.IStiLocalizedMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMeter/* extends StiObject*/  implements IStiMeter, IStiLocalizedMeter, IStiJsonReportObject {
        private static ImplementsStiMeter;
        implements(): string[];
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        saveToString(): string;
        loadFromString(str: string): void;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        getUniqueCode(): number;
        expression: string;
        label: string;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Gets or sets unically object identificator.
         */
        key: string;
        readonly isDefault: boolean;
        toString(): string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionMeter extends StiMeter implements IStiDimensionMeter {
        private static ImplementsStiDimensionMeter;
        implements(): string[];
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiArgumentChartMeter extends StiDimensionMeter implements IStiArgumentMeter {
        private static ImplementsStiArgumentChartMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiChartArea = Stimulsoft.Report.Dashboard.IStiChartArea;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    class StiChartArea implements IStiJsonReportObject, IStiChartArea {
        private static ImplementsStiChartArea;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): StiChartArea;
        colorEach: boolean;
        /**
         *  Gets or sets value which indicate that all values on horizontal axis is reverse.
         */
        reverseHor: boolean;
        /**
         *  Gets or sets value which indicate that all values on vertical axis is reverse.
         */
        reverseVert: boolean;
        /**
         *  Gets or sets interlacing settings on horizontal axis.
         */
        interlacingHor: StiHorChartInterlacing;
        /**
         *  Gets or sets interlacing settings on vertical axis.
         */
        interlacingVert: StiVertChartInterlacing;
        /**
         *  Gets or sets horizontal grid lines on left axis.
         */
        gridLinesHor: StiHorChartGridLines;
        /**
         *  Gets or sets grid lines on vertical axis.
         */
        gridLinesVert: StiVertChartGridLines;
        constructor(colorEach?: boolean, reverseHor?: boolean, reverseVert?: boolean, gridLinesHor?: StiHorChartGridLines, gridLinesVert?: StiVertChartGridLines, interlacingHor?: StiHorChartInterlacing, interlacingVert?: StiVertChartInterlacing);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiLabelsPlacement = Stimulsoft.Report.Chart.StiLabelsPlacement;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxisLabels implements ICloneable, IStiFont, IStiJsonReportObject {
        private static ImplementsStiChartAxisLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets angle of label rotation.
         */
        angle: number;
        /**
         *  Gets or sets color of labels drawing.
         */
        color: Color;
        private shouldSerializeColor;
        /**
         *  Gets or sets font which will be used for axis label drawing.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or set mode of labels placement on axis.
         */
        placement: StiLabelsPlacement;
        /**
         *  Gets or sets label text alignment.
         */
        textAlignment: StiHorAlignment;
        /**
         *  Gets or sets string which will be output after argument string representation.
         */
        textAfter: string;
        /**
         *  Gets or sets string which will be output before argument string representation.
         */
        textBefore: string;
        readonly isDefault: boolean;
        constructor(textBefore?: string, textAfter?: string, angle?: number, font?: Font, placement?: StiLabelsPlacement, color?: Color, textAlignment?: StiHorAlignment);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    import StiChartAxisLabels = Stimulsoft.Dashboard.Components.Chart.StiChartAxisLabels;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartAxis implements IStiJsonReportObject, IStiDefault, ICloneable {
        private static ImplementsStiChartAxis;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or sets axis labels settings.
         */
        labels: StiChartAxisLabels;
        private shouldSerializeLabels;
        readonly isDefault: boolean;
        constructor(labels?: StiChartAxisLabels);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import Color = Stimulsoft.System.Drawing.Color;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    enum Order {
        Alignment = 1,
        Color = 2,
        Direction = 3,
        Font = 4,
        Placement = 5,
        Position = 6,
        Text = 7,
        Visible = 8
    }
    class StiChartAxisTitle implements IStiJsonReportObject, IStiDefault {
        private static ImplementsStiChartAxisTitle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets visibility of axis.
         */
        visible: boolean;
        /**
         *  Gets or sets title text alignment.
         */
        alignment: StringAlignment;
        /**
         *  Gets or sets color which will be used for title drawing.
         */
        color: Color;
        private shouldSerializeColor;
        /**
         *  Gets or set font which will be used for axis title drawing.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets title text position.
         */
        position: StiTitlePosition;
        /**
         *  Gets or sets title text.
         */
        text: string;
        readonly isDefault: boolean;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, position?: StiTitlePosition, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyTreeViewBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyTreeViewBoxMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyTreeViewMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyTreeViewMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiDashboardInteractionLoader {
        static loadInteractionFromJsonObject(jObject: StiJson): StiDashboardInteraction;
        static loadInteractionFromXml(xmlNode: XmlNode, isDocument: boolean): StiDashboardInteraction;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiDashboardDrillDownParameter = Stimulsoft.Report.Dashboard.IStiDashboardDrillDownParameter;
    import List = Stimulsoft.System.Collections.List;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiDashboardInteraction implements IStiDashboardInteraction, IStiJsonReportObject {
        private static ImplementsStiDashboardInteraction;
        implements(): string[];
        clone(cloneProperties?: boolean, cloneComponents?: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly isDefault: boolean;
        getDrillDownParameters(): List<IStiDashboardDrillDownParameter>;
        setDrillDownParameters(drillDownParameters: any[]): void;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        hyperlinkDestination: StiInteractionOpenHyperlinkDestination;
        toolTip: string;
        hyperlink: string;
        /**
         *  Describes a key of the dashboard page which should be opened.
         */
        drillDownPageKey: string;
        /**
         *  Describes a list of drillDownParameters.
         */
        drillDownParameters: List<StiDashboardDrillDownParameter>;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiTableColumnDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        onHover: StiInteractionOnHover;
        onClick: StiInteractionOnClick;
        readonly isDefault: boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, dashboardKey?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import StiTableColumnDashboardInteraction = Stimulsoft.Dashboard.Interactions.StiTableColumnDashboardInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTableColumn = Stimulsoft.Base.Meters.IStiTableColumn;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    class StiTableColumn extends StiMeter implements IStiHorAlignment, IStiTextFormat, IStiTableColumn, IStiForeColor, IStiJsonReportObject, IStiElementInteraction {
        private static ImplementsStiTableColumn;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets a text horizontal alignment.
         */
        horAlignment: StiHorAlignment;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        dashboardInteraction: IStiDashboardInteraction;
        private shouldSerializeDashboardInteraction;
        readonly isDefault: boolean;
        getUniqueCode(): number;
        /**
         *  Gets or sets a visibility of the column.
         */
        visible: boolean;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visible?: boolean, foreColor?: Color, interaction?: StiTableColumnDashboardInteraction);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    import IStiMeasureColumn = Stimulsoft.Base.Meters.IStiMeasureColumn;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiMeasureColumn extends StiTableColumn implements IStiMeasureMeter, IStiMeasureColumn {
        private static ImplementsStiMeasureColumn;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visible?: boolean, foreColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiIndicatorColumn = Stimulsoft.Base.Meters.IStiIndicatorColumn;
    class StiIndicatorColumn extends StiMeasureColumn implements IStiIndicatorColumn {
        private static ImplementsStiIndicatorColumn;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visible?: boolean, foreColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiColorScaleColumn = Stimulsoft.Base.Meters.IStiColorScaleColumn;
    class StiColorScaleColumn extends StiMeasureColumn implements IStiColorScaleColumn {
        private static ImplementsStiColorScaleColumn;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visible?: boolean, foreColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDataBarsColumn = Stimulsoft.Base.Meters.IStiDataBarsColumn;
    class StiDataBarsColumn extends StiMeasureColumn implements IStiDataBarsColumn, IStiJsonReportObject {
        private static ImplementsStiDataBarsColumn;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        getUniqueCode(): number;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visible?: boolean, foreColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiReport = Stimulsoft.Report.StiReport;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiSparklinesColumn = Stimulsoft.Base.Meters.IStiSparklinesColumn;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    class StiSparklinesColumn extends StiMeasureColumn implements IStiSparklinesColumn, IStiJsonReportObject {
        private static ImplementsStiSparklinesColumn;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        /**
         *  Gets or sets the type of the sparklines.
         */
        type: StiSparklinesType;
        /**
         *  Gets or sets the value which indicates that high and low points should be show.
         */
        showHighLowPoints: boolean;
        /**
         *  Gets or sets the value which indicates that first and last points should be show.
         */
        showFirstLastPoints: boolean;
        getUniqueCode(): number;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, type?: StiSparklinesType, showHighLowPoints?: boolean, showFirstLastPoints?: boolean, visible?: boolean, foreColor?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    class StiTextFormatHelper {
        private static _defaultGeneralFormat;
        static readonly defaultGeneralFormat: StiGeneralFormatService;
        private static _defaultCurrencyFormat;
        static readonly defaultCurrencyFormat: StiCurrencyFormatService;
        private static _defaultPercentageFormat;
        static readonly defaultPercentageFormat: StiPercentageFormatService;
        private static _defaultNumberFormat;
        static readonly defaultNumberFormat: StiNumberFormatService;
        private static _defaultIntegerFormat;
        static readonly defaultIntegerFormat: StiNumberFormatService;
        private static _defaultDateFormat;
        static readonly defaultDateFormat: StiDateFormatService;
        private static _defaultBooleanFormat;
        static readonly defaultBooleanFormat: StiBooleanFormatService;
        static formatBasedOnColumnType(table: StiTableElement, column: StiTableColumn, value: any): string;
        static format(format: StiFormatService, value: any): string;
        static formatAsPercentage(value: any): string;
        static formatAsPercentage2(format: StiFormatService, value: any): string;
        static getDefaultFormatForColumn(dataColumn: StiDataColumn): StiFormatService;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiDimensionColumn = Stimulsoft.Base.Meters.IStiDimensionColumn;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    class StiDimensionColumn extends StiTableColumn implements IStiDimensionMeter, IStiDimensionColumn {
        private static ImplementsStiDimensionColumn;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): void;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        /**
         *  Shows or not hyperlink.
         */
        showHyperlink: boolean;
        /**
         *  A hyperlink pattern.
         */
        hyperlinkPattern: string;
        readonly isDefault: boolean;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, visible?: boolean, foreColor?: Color, showHyperlink?: boolean, hyperlinkPattern?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiColorMapMeter = Stimulsoft.Base.Meters.IStiColorMapMeter;
    /**
     *  Describes a column with data.
     */
    class StiColorMapMeter extends StiDimensionMeter implements IStiColorMapMeter {
        private static ImplementsStiColorMapMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiValueMapMeter = Stimulsoft.Base.Meters.IStiValueMapMeter;
    /**
     *  Describes a column with data.
     */
    class StiValueMapMeter extends StiDimensionMeter implements IStiValueMapMeter {
        private static ImplementsStiValueMapMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiGroupMapMeter = Stimulsoft.Base.Meters.IStiGroupMapMeter;
    /**
     *  Describes a column with data.
     */
    class StiGroupMapMeter extends StiDimensionMeter implements IStiGroupMapMeter {
        private static ImplementsStiGroupMapMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiNameMapMeter = Stimulsoft.Base.Meters.IStiNameMapMeter;
    /**
     *  Describes a column with data.
     */
    class StiNameMapMeter extends StiDimensionMeter implements IStiNameMapMeter {
        private static ImplementsStiNameMapMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import IStiKeyMapMeter = Stimulsoft.Base.Meters.IStiKeyMapMeter;
    /**
     *  Describes a column with data.
     */
    class StiKeyMapMeter extends StiDimensionMeter implements IStiKeyMapMeter {
        private static ImplementsStiKeyMapMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiMeasureMeter = Stimulsoft.Base.Meters.IStiMeasureMeter;
    class StiMeasureMeter extends StiMeter implements IStiMeasureMeter {
        private static ImplementsStiMeasureMeter;
        implements(): string[];
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueProgressMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueProgressMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiTargetProgressMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueProgressMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiSeriesProgressMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiSeriesProgressMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiPivotColumn = Stimulsoft.Base.Meters.IStiPivotColumn;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiPivotColumn extends StiMeter implements IStiDimensionMeter, IStiHorAlignment, IStiTextFormat, IStiPivotColumn, IStiDataTopN, IStiJsonReportObject {
        private static ImplementsStiPivotColumn;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or sets the text horizontal alignment.
         */
        horAlignment: StiHorAlignment;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         * Gets or sets the TopN
         */
        topN: StiDataTopN;
        getUniqueCode(): number;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, topN?: StiDataTopN);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiPivotRow = Stimulsoft.Base.Meters.IStiPivotRow;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    import IStiDimensionMeter = Stimulsoft.Base.Meters.IStiDimensionMeter;
    import IStiDataTopN = Stimulsoft.Data.Engine.IStiDataTopN;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    class StiPivotRow extends StiMeter implements IStiDimensionMeter, IStiHorAlignment, IStiTextFormat, IStiPivotRow, IStiDataTopN, IStiJsonReportObject {
        private static ImplementsStiPivotRow;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or sets the text horizontal alignment.
         */
        horAlignment: StiHorAlignment;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         * Gets or sets the TopN
         */
        topN: StiDataTopN;
        getUniqueCode(): number;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService, topN?: StiDataTopN);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiPivotSummary = Stimulsoft.Base.Meters.IStiPivotSummary;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    class StiPivotSummary extends StiMeasureMeter implements IStiHorAlignment, IStiTextFormat, IStiPivotSummary, IStiJsonReportObject {
        private static ImplementsStiPivotSummary;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or sets the text horizontal alignment.
         */
        horAlignment: StiHorAlignment;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        getUniqueCode(): number;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, horAlignment?: StiHorAlignment, textFormat?: StiFormatService);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    /**
     *  Describes a column with data.
     */
    class StiLatitudeMapMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    /**
     *  Describes a column with data.
     */
    class StiLongitudeMapMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyListBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyListBoxMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiNameListBoxMeter extends StiDimensionMeter implements IStiArgumentMeter {
        private static ImplementsStiNameListBoxMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.DatePicker {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueDatePickerMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiValueDatePickerMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiEndValueChartMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiArgumentMeter = Stimulsoft.Base.Meters.IStiArgumentMeter;
    class StiNameComboBoxMeter extends StiDimensionMeter implements IStiArgumentMeter {
        private static ImplementsStiNameComboBoxMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiKeyComboBoxMeter extends StiDimensionMeter implements IStiValueMeter {
        private static ImplementsStiKeyComboBoxMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesGaugeMeter extends StiDimensionMeter implements IStiSeriesMeter {
        private static ImplementsStiSeriesGaugeMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueGaugeMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueGaugeMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesIndicatorMeter extends StiDimensionMeter implements IStiSeriesMeter {
        private static ImplementsStiSeriesIndicatorMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    class StiValueIndicatorMeter extends StiMeasureMeter implements IStiValueMeter {
        private static ImplementsStiValueIndicatorMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiTargetMeter = Stimulsoft.Base.Meters.IStiTargetMeter;
    class StiTargetIndicatorMeter extends StiMeasureMeter implements IStiTargetMeter {
        private static ImplementsStiTargetIndicatorMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiWeightChartMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiValueMeter = Stimulsoft.Base.Meters.IStiValueMeter;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiValueChartMeter extends StiMeasureMeter implements IStiJsonReportObject, IStiValueMeter {
        private static ImplementsStiValueChartMeter;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        seriesType: StiChartSeriesType;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        getUniqueCode(): number;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiOpenValueChartMeter extends StiValueChartMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        seriesType: StiChartSeriesType;
        constructor(key?: string, expression?: string, label?: string, seriesType?: StiChartSeriesType);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiCloseValueChartMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiLowValueChartMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiHighValueChartMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiSeriesMeter = Stimulsoft.Base.Meters.IStiSeriesMeter;
    class StiSeriesChartMeter extends StiDimensionMeter implements IStiSeriesMeter {
        private static ImplementsStiSeriesChartMeter;
        implements(): string[];
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    /**
     *  Describes a column with data.
     */
    class StiLocationMapMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    /**
     *  Describes a column with data.
     */
    class StiLocationColorMapMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    /**
     *  Describes a column with data.
     */
    class StiLocationValueMapMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiLocationMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationMapMeter;
    import StiLocationColorMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationColorMapMeter;
    import StiLocationValueMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLocationValueMapMeter;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiKeyTreeViewBoxMeter = Stimulsoft.Dashboard.Components.TreeViewBox.StiKeyTreeViewBoxMeter;
    import StiKeyTreeViewMeter = Stimulsoft.Dashboard.Components.TreeView.StiKeyTreeViewMeter;
    import StiIndicatorColumn = Stimulsoft.Dashboard.Components.Table.StiIndicatorColumn;
    import StiColorScaleColumn = Stimulsoft.Dashboard.Components.Table.StiColorScaleColumn;
    import StiDataBarsColumn = Stimulsoft.Dashboard.Components.Table.StiDataBarsColumn;
    import StiSparklinesColumn = Stimulsoft.Dashboard.Components.Table.StiSparklinesColumn;
    import StiDimensionColumn = Stimulsoft.Dashboard.Components.Table.StiDimensionColumn;
    import StiMeasureColumn = Stimulsoft.Dashboard.Components.Table.StiMeasureColumn;
    import StiColorMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiColorMapMeter;
    import StiValueMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiValueMapMeter;
    import StiGroupMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiGroupMapMeter;
    import StiNameMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiNameMapMeter;
    import StiKeyMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiKeyMapMeter;
    import StiValueProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiValueProgressMeter;
    import StiTargetProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiTargetProgressMeter;
    import StiSeriesProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiSeriesProgressMeter;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiPivotColumn = Stimulsoft.Dashboard.Components.PivotTable.StiPivotColumn;
    import StiPivotRow = Stimulsoft.Dashboard.Components.PivotTable.StiPivotRow;
    import StiPivotSummary = Stimulsoft.Dashboard.Components.PivotTable.StiPivotSummary;
    import StiLatitudeMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLatitudeMapMeter;
    import StiLongitudeMapMeter = Stimulsoft.Dashboard.Components.OnlineMap.StiLongitudeMapMeter;
    import StiKeyListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiKeyListBoxMeter;
    import StiNameListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiNameListBoxMeter;
    import StiValueDatePickerMeter = Stimulsoft.Dashboard.Components.DatePicker.StiValueDatePickerMeter;
    import StiElement = Stimulsoft.Dashboard.Components.StiElement;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNameComboBoxMeter = Stimulsoft.Dashboard.Components.ComboBox.StiNameComboBoxMeter;
    import StiKeyComboBoxMeter = Stimulsoft.Dashboard.Components.ComboBox.StiKeyComboBoxMeter;
    import StiSeriesGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiSeriesGaugeMeter;
    import StiValueGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiValueGaugeMeter;
    import StiSeriesIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiSeriesIndicatorMeter;
    import StiValueIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiValueIndicatorMeter;
    import StiTargetIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiTargetIndicatorMeter;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiOpenValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiOpenValueChartMeter;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import StiArgumentChartMeter = Stimulsoft.Dashboard.Components.Chart.StiArgumentChartMeter;
    import StiValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiValueChartMeter;
    import StiSeriesChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSeriesChartMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    class Chart {
        static getValue(meter: StiMeter): StiValueChartMeter;
        static getEndValue(meter: StiMeter): StiEndValueChartMeter;
        static getOpenValue(meter: StiMeter): StiOpenValueChartMeter;
        static getCloseValue(meter: StiMeter): StiCloseValueChartMeter;
        static getLowValue(meter: StiMeter): StiLowValueChartMeter;
        static getHighValue(meter: StiMeter): StiHighValueChartMeter;
        static getValue2(dataColumn: StiDataColumn, element: StiChartElement): StiValueChartMeter;
        static getEndValue2(dataColumn: StiDataColumn): StiEndValueChartMeter;
        static getCloseValue2(dataColumn: StiDataColumn): StiCloseValueChartMeter;
        static getLowValue2(dataColumn: StiDataColumn): StiLowValueChartMeter;
        static getHighValue2(dataColumn: StiDataColumn): StiHighValueChartMeter;
        static getWeight(meter: StiMeter): StiWeightChartMeter;
        static getWeight2(dataColumn: StiDataColumn): StiWeightChartMeter;
        static getArgument(meter: StiMeter): StiArgumentChartMeter;
        static getArgument2(dataColumn: StiDataColumn): StiArgumentChartMeter;
        static getX2(dataColumn: StiDataColumn): StiArgumentChartMeter;
        static getX(meter: StiMeter): StiArgumentChartMeter;
        static getY2(dataColumn: StiDataColumn): StiValueChartMeter;
        static getY(meter: StiMeter): StiValueChartMeter;
        static getSeries(meter: StiMeter): StiSeriesChartMeter;
        static getSeries2(dataColumn: StiDataColumn): StiSeriesChartMeter;
    }
    class ComboBox {
        static getName(meter: StiMeter): StiNameComboBoxMeter;
        static getName2(dataColumn: StiDataColumn): StiNameComboBoxMeter;
        static getKey(meter: StiMeter): StiKeyComboBoxMeter;
        static getKey2(dataColumn: StiDataColumn): StiKeyComboBoxMeter;
    }
    class DataFilter {
        static getFilter2(dataColumn: StiDataColumn): StiDataFilterRule;
        static getFilter(column: StiTableColumn, element: StiElement): StiDataFilterRule;
    }
    class DatePicker {
        static getValue(meter: StiMeter): StiValueDatePickerMeter;
        static getValue2(dataColumn: StiDataColumn): StiValueDatePickerMeter;
    }
    class Gauge {
        static getSeries(meter: StiMeter): StiSeriesGaugeMeter;
        static getSeries2(dataColumn: StiDataColumn): StiSeriesGaugeMeter;
        static getValue(meter: StiMeter): StiValueGaugeMeter;
        static getValue2(dataColumn: StiDataColumn): StiValueGaugeMeter;
    }
    class Indicator {
        static getSeries(meter: StiMeter): StiSeriesIndicatorMeter;
        static getSeries2(dataColumn: StiDataColumn): StiSeriesIndicatorMeter;
        static getValue(meter: StiMeter): StiValueIndicatorMeter;
        static getValue2(dataColumn: StiDataColumn): StiValueIndicatorMeter;
        static getTarget(meter: StiMeter): StiTargetIndicatorMeter;
        static getTarget2(dataColumn: StiDataColumn): StiTargetIndicatorMeter;
    }
    class ListBox {
        static getName(meter: StiMeter): StiNameListBoxMeter;
        static getName2(dataColumn: StiDataColumn): StiNameListBoxMeter;
        static getKey(meter: StiMeter): StiKeyListBoxMeter;
        static getKey2(dataColumn: StiDataColumn): StiKeyListBoxMeter;
    }
    class OnlineMap {
        static getLatitude(meter: StiMeter): StiLatitudeMapMeter;
        static getLongitude(meter: StiMeter): StiLongitudeMapMeter;
        static getLocation(meter: StiMeter): StiLocationMapMeter;
        static getLocationColor(meter: StiMeter): StiLocationColorMapMeter;
        static getLocationValue(meter: StiMeter): StiLocationValueMapMeter;
        static getLatitude2(dataColumn: StiDataColumn): StiLatitudeMapMeter;
        static getLongitude2(dataColumn: StiDataColumn): StiLongitudeMapMeter;
        static getLocation2(dataColumn: StiDataColumn): StiLocationMapMeter;
        static getLocationColor2(dataColumn: StiDataColumn): StiLocationColorMapMeter;
        static getLocationValue2(dataColumn: StiDataColumn): StiLocationValueMapMeter;
    }
    class Pivot {
        static getColumn(meter: StiMeter): StiPivotColumn;
        static getRow(meter: StiMeter): StiPivotRow;
        static getSummary(meter: StiMeter): StiPivotSummary;
        static getSummary3(meter: StiMeter, dashboard?: IStiDashboard): StiPivotSummary;
        static getColumn2(dataColumn: StiDataColumn): StiPivotColumn;
        static getRow2(dataColumn: StiDataColumn): StiPivotRow;
        static getSummary2(dataColumn: StiDataColumn): StiPivotSummary;
        static getFormat(meter: StiMeter): StiFormatService;
        static getTopN(meter: StiMeter): StiDataTopN;
    }
    class Progress {
        static getSeries(meter: StiMeter): StiSeriesProgressMeter;
        static getSeries2(dataColumn: StiDataColumn): StiSeriesProgressMeter;
        static getValue(meter: StiMeter): StiValueProgressMeter;
        static getValue2(dataColumn: StiDataColumn): StiValueProgressMeter;
        static getTarget(meter: StiMeter): StiTargetProgressMeter;
        static getTarget2(dataColumn: StiDataColumn): StiTargetProgressMeter;
    }
    class RegionMap {
        static getKey(meter: StiMeter): StiKeyMapMeter;
        static getName(meter: StiMeter): StiNameMapMeter;
        static getGroup(meter: StiMeter): StiGroupMapMeter;
        static getValue(meter: StiMeter, dashboard: IStiDashboard): StiValueMapMeter;
        static getColor(meter: StiMeter): StiColorMapMeter;
        static getKey2(dataColumn: StiDataColumn): StiKeyMapMeter;
        static getName2(dataColumn: StiDataColumn): StiNameMapMeter;
        static getValue2(dataColumn: StiDataColumn): StiValueMapMeter;
        static getGroup2(dataColumn: StiDataColumn): StiGroupMapMeter;
        static getColor2(dataColumn: StiDataColumn): StiColorMapMeter;
    }
    class Table {
        static getColumn(meter: StiMeter): StiTableColumn;
        static getDimension(tableColumn: StiTableColumn): StiDimensionColumn;
        static getDimension2(dataColumn: StiDataColumn): StiDimensionColumn;
        static getMeasure(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiMeasureColumn;
        static getMeasure2(dataColumn: StiDataColumn): StiMeasureColumn;
        static getDataBars(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiDataBarsColumn;
        static getColorScale(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiColorScaleColumn;
        static getSparklines(tableColumn: StiTableColumn): StiSparklinesColumn;
        static getIndicator(tableColumn: StiTableColumn, dashboard: IStiDashboard): StiIndicatorColumn;
    }
    class TreeView {
        static getKey(meter: StiMeter): StiKeyTreeViewMeter;
        static getKey2(dataColumn: StiDataColumn): StiKeyTreeViewMeter;
    }
    class TreeViewBox {
        static getKey(meter: StiMeter): StiKeyTreeViewBoxMeter;
        static getKey2(dataColumn: StiDataColumn): StiKeyTreeViewBoxMeter;
    }
    class StiMeterHelper {
        static Chart: typeof Chart;
        static ComboBox: typeof ComboBox;
        static DataFilter: typeof DataFilter;
        static DatePicker: typeof DatePicker;
        static Gauge: typeof Gauge;
        static Indicator: typeof Indicator;
        static ListBox: typeof ListBox;
        static OnlineMap: typeof OnlineMap;
        static Pivot: typeof Pivot;
        static Progress: typeof Progress;
        static RegionMap: typeof RegionMap;
        static Table: typeof Table;
        static TreeView: typeof TreeView;
        static TreeViewBox: typeof TreeViewBox;
        static toTotalExpression2(dataColumn: StiDataColumn): string;
        static toTotalExpression(meter: StiMeter): string;
        static toTotalExpression3(meter: StiMeter, dashboard: IStiDashboard): string;
        static toSumExpression2(dataColumn: StiDataColumn): string;
        static toSumExpression(expression: string): string;
        static toCountExpression2(dataColumn: StiDataColumn): string;
        static toCountExpression(expression: string): string;
        static toExpression(dataColumn: StiDataColumn): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiMeterLoader {
        static loadFromJson2(jsons: List<StiJson>): List<StiMeter>;
        static loadFromJson(json: StiJson): StiMeter;
        static loadFromXml(xmlNode: XmlNode, isDocument: boolean, report?: StiReport): StiMeter;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartLegendTitle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets color which will be used for title drawing.
         */
        color: Color;
        private shouldSerializeColor;
        /**
         *  Gets or set font which will be used for axis title drawing.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets title text.
         */
        text: string;
        readonly isDefault: boolean;
        constructor(font?: Font, text?: string, color?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiChartLegendLabels implements ICloneable, IStiFont, IStiJsonReportObject {
        private static ImplementsStiChartLegendLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets color of legend labels drawing.
         */
        color: Color;
        private shouldSerializeColor;
        /**
         *  Gets or sets font which will be used for legend label drawing.
         */
        font: Font;
        private shouldSerializeFont;
        readonly isDefault: boolean;
        constructor(font?: Font, color?: Color);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiChartLegendTitle = Stimulsoft.Dashboard.Components.Chart.StiChartLegendTitle;
    import StiChartLegendLabels = Stimulsoft.Dashboard.Components.Chart.StiChartLegendLabels;
    import StiLegendVertAlignment = Stimulsoft.Report.Chart.StiLegendVertAlignment;
    import StiLegendHorAlignment = Stimulsoft.Report.Chart.StiLegendHorAlignment;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    enum Order {
        HorAlignment = 1,
        Labels = 2,
        Title = 3,
        VertAlignment = 4
    }
    class StiChartLegend implements IStiJsonReportObject {
        private static ImplementsStiChartLegend;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets horizontal alignment of legend placement.
         */
        horAlignment: StiLegendHorAlignment;
        /**
         *  Gets or sets vertical alignment of legend placement.
         */
        vertAlignment: StiLegendVertAlignment;
        /**
         *  Gets or sets legend labels settings.
         */
        labels: StiChartLegendLabels;
        /**
         *  Gets or sets legend title settings.
         */
        title: StiChartLegendTitle;
        readonly isDefault: boolean;
        constructor(title?: StiChartLegendTitle, labels?: StiChartLegendLabels, horAlignment?: StiLegendHorAlignment, vertAlignment?: StiLegendVertAlignment);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYChartAxisTitle extends StiChartAxisTitle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or set text direction for axis title drawing.
         */
        direction: StiDirection;
        readonly isDefault: boolean;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, direction?: StiDirection, position?: StiTitlePosition, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiYChartAxisTitle = Stimulsoft.Dashboard.Components.Chart.StiYChartAxisTitle;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiYChartAxis extends StiChartAxis implements IStiJsonReportObject {
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or sets axis title settings.
         */
        title: StiYChartAxisTitle;
        private shouldSerializeTitle;
        readonly isDefault: boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiYChartAxisTitle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiXChartAxis extends StiChartAxis implements IStiJsonReportObject {
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or sets axis title settings.
         */
        title: StiXChartAxisTitle;
        private shouldSerializeTitle;
        readonly isDefault: boolean;
        constructor(labels?: StiChartAxisLabels, title?: StiXChartAxisTitle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiYChartMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiTitle = Stimulsoft.Report.Dashboard.IStiTitle;
    import ICloneable = Stimulsoft.System.ICloneable;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiJson = Stimulsoft.Base.StiJson;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTitle implements ICloneable, IStiJsonReportObject, IStiTitle {
        private static ImplementsStiTitle;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        static createFromJsonObject(jObject: StiJson): StiTitle;
        static createFromXml(xmlNode: XmlNode): StiTitle;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): any;
        /**
         *  Gets or sets title text alignment.
         */
        horAlignment: StiHorAlignment;
        /**
         *  Gets or set font which will be used for title drawing.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets a back color.
         */
        backColor: Color;
        private shouldSerializeBackColor;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        /**
         *  Gets or sets title text.
         */
        text: string;
        /**
         *  Gets or sets visibility of title.
         */
        visible: boolean;
        constructor(text?: string, foreColor?: Color, backColor?: Color, font?: Font, alignment?: StiHorAlignment, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Panel {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiToolboxCategory = Stimulsoft.Report.Components.StiToolboxCategory;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiMargin = Stimulsoft.Report.Dashboard.IStiMargin;
    import IStiPadding = Stimulsoft.Report.Dashboard.IStiPadding;
    import IStiPanel = Stimulsoft.Report.Dashboard.IStiPanel;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    /**
     *  Panel component of the dashboards.
     */
    class StiPanelElement extends StiPanel implements IStiSimpleBorder, IStiPanel, IStiPadding, IStiMargin, IStiJsonReportObject {
        private static ImplementsStiPanelElement;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
        getElements(nested?: boolean, group?: string): List<IStiElement>;
        fetchAllMeters(): List<IStiMeter>;
        getMeters2(): List<IStiMeter>;
        getFilterRules(): List<StiDataFilterRule>;
        getNestedPages(): List<StiPage>;
        readonly dashboard: IStiDashboard;
        isDefined: boolean;
        isQuerable: boolean;
        isEnabled: boolean;
        /**
         *  Gets zoom of a report.
         */
        readonly zoom: number;
        retrieveUsedDataNames(group: string): List<string>;
        getDictionary(): IStiAppDictionary;
        /**
         *  Gets or sets element margin.
         */
        margin: StiMargin;
        private shouldSerializeMargin;
        /**
         *  Gets or sets element padding.
         */
        padding: StiPadding;
        shouldSerializePadding(): boolean;
        /**
         *  Gets or sets border of the element.
         */
        border2: StiSimpleBorder;
        private shouldSerializeBorder;
        /**
         *  Gets or sets a back color.
         */
        backColor: Color;
        private shouldSerializeBackColor;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        brush: StiBrush;
        /**
         *  Gets a service category.
         */
        serviceCategory: string;
        /**
         *  Gets a localized name of the component category.
         */
        localizedCategory: string;
        toolboxCategory: StiToolboxCategory;
        /**
         *  May this container be located in the specified component.
         *  @param component Component for checking.
         *  @returns true, if this container may is located in the specified component.
         */
        canContainIn(component: StiComponent): boolean;
        createNew(): StiComponent;
        key: string;
        /**
         *  Creates a new  component of the type StiPanelElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiToolboxCategory = Stimulsoft.Report.Components.StiToolboxCategory;
    import StiMargin = Stimulsoft.Report.Dashboard.StiMargin;
    import StiPadding = Stimulsoft.Report.Dashboard.StiPadding;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiMargin = Stimulsoft.Report.Dashboard.IStiMargin;
    import IStiPadding = Stimulsoft.Report.Dashboard.IStiPadding;
    import IStiBackColor = Stimulsoft.Report.Components.IStiBackColor;
    import IStiSimpleBorder = Stimulsoft.Report.Components.IStiSimpleBorder;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    /**
     *  Describes the base class for all dashboards elements.
     */
    class StiElement extends StiComponent implements IStiElement, IStiSimpleBorder, IStiBackColor, IStiPadding, IStiMargin, IStiJsonReportObject {
        private static ImplementsStiElement;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        readonly dashboard: IStiDashboard;
        isDefined: boolean;
        isQuerable: boolean;
        readonly iiEnabled: boolean;
        readonly zoom: number;
        retrieveUsedDataNames2(group: string): List<string>;
        retrieveUsedDataNames(): List<string>;
        getDictionary(): IStiAppDictionary;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        /**
         *  Gets or sets border of the element.
         */
        border2: StiSimpleBorder;
        private shouldSerializeBorder;
        /**
         *  Gets or sets a back color.
         */
        backColor: Color;
        private shouldSerializeBackColor;
        /**
         *  Gets or sets element margin.
         */
        margin: StiMargin;
        private shouldSerializeMargin;
        /**
         *  Gets or sets element padding.
         */
        padding: StiPadding;
        shouldSerializePadding(): boolean;
        /**
         *  Gets a service category.
         */
        serviceCategory: string;
        /**
         *  Return events collection of this component;
         */
        /**
         *  May this container be located in the specified component.
         *  @param component Component for checking.
         *  @returns true, if this container may is located in the specified component.
         */
        canContainIn(component: StiComponent): boolean;
        toolboxCategory: StiToolboxCategory;
        /**
         *  Gets a localized name of the component category.
         */
        localizedCategory: string;
        /**
         *  Gets a localized component name.
         */
        localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        key: string;
        /**
         *  Returns a list of the nested pages.
         */
        getNestedPages(): List<StiPage>;
        /**
         *  Gets default event for this report control.
         *  @returns Default event.
         */
        /**
         *  Creates a new  StiElement.
         *  @param rect The rectangle describes sizes and position of the control.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Export {
    import Dictionary = Stimulsoft.System.Collections.Dictionary;
    import Attribute = Stimulsoft.System.Attribute;
    class StiExportToolAttribute extends Attribute {
        exportToolTypeName: string;
        constructor(exportToolTypeName: string);
        static attributes: Dictionary<string, StiExportToolAttribute>;
        static add(typeName: string, exportToolTypeName: string): void;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    var IStiAllowUserDrillDownDashboardInteraction: string;
    interface IStiAllowUserDrillDownDashboardInteraction {
        allowUserDrillDown: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiDashboardDrillDownParameter = Stimulsoft.Dashboard.Interactions.StiDashboardDrillDownParameter;
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import IStiAllowUserDrillDownDashboardInteraction = Stimulsoft.Dashboard.Interactions.IStiAllowUserDrillDownDashboardInteraction;
    import IStiChartDashboardInteraction = Stimulsoft.Report.Dashboard.IStiChartDashboardInteraction;
    class StiChartDashboardInteraction extends StiDashboardInteraction implements IStiChartDashboardInteraction, IStiAllowUserDrillDownDashboardInteraction, IStiJsonReportObject {
        private static ImplementsIStiChartDashboardInteraction;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        ident: StiInteractionIdent;
        allowUserDrillDown: boolean;
        availableOnClick: StiAvailableInteractionOnClick;
        readonly isDefault: boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowUserDrillDown?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDrillDownHelper {
        static isDrillAvailable(element: IStiElement): boolean;
        static isDrillUpAvailable(element: IStiElement): boolean;
        static isDrillDownAvailable(element: IStiElement): boolean;
        static drillUp(element: IStiElement): void;
        static drillDown(element: IStiElement, drillDownFilters?: List<StiDataFilterRule>): void;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiNegativeSeriesColors = Stimulsoft.Report.Dashboard.IStiNegativeSeriesColors;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiChartLegend = Stimulsoft.Dashboard.Components.Chart.StiChartLegend;
    import StiYChartAxis = Stimulsoft.Dashboard.Components.Chart.StiYChartAxis;
    import StiXChartAxis = Stimulsoft.Dashboard.Components.Chart.StiXChartAxis;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import StiSeriesChartMeter = Stimulsoft.Dashboard.Components.Chart.StiSeriesChartMeter;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiArgumentChartMeter = Stimulsoft.Dashboard.Components.Chart.StiArgumentChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import List = Stimulsoft.System.Collections.List;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiDrillDownElement = Stimulsoft.Data.Engine.IStiDrillDownElement;
    class StiChartElement extends StiElement implements IStiChartElement, IStiSkipOwnFilter, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiSeriesColors, IStiNegativeSeriesColors, IStiElementInteraction, IStiDrillDownElement {
        private static ImplementsStiChartElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        convertToBubble(): void;
        convertFromBubble(): void;
        getChartSeriesTypes(seriesTypeStr: string): List<string>;
        addValue(dataColumn: StiDataColumn): void;
        getValue2(dataColumn: StiDataColumn): IStiMeter;
        getValue(meter: IStiMeter): IStiMeter;
        getValueByIndex(index: number): IStiMeter;
        insertValue(index: number, meter: IStiMeter): void;
        removeValue(index: number): void;
        removeAllValues(): void;
        createNewValue(): IStiMeter;
        addEndValue(dataColumn: StiDataColumn): void;
        getEndValue2(dataColumn: StiDataColumn): IStiMeter;
        getEndValue(meter: IStiMeter): IStiMeter;
        getEndValueByIndex(index: number): IStiMeter;
        insertEndValue(index: number, meter: IStiMeter): void;
        removeEndValue(index: number): void;
        removeAllEndValues(): void;
        createNewEndValue(): IStiMeter;
        addCloseValue(dataColumn: StiDataColumn): void;
        getCloseValue2(dataColumn: StiDataColumn): IStiMeter;
        getCloseValue(meter: IStiMeter): IStiMeter;
        getCloseValueByIndex(index: number): IStiMeter;
        insertCloseValue(index: number, meter: IStiMeter): void;
        removeCloseValue(index: number): void;
        removeAllCloseValues(): void;
        createNewCloseValue(): IStiMeter;
        addLowValue(dataColumn: StiDataColumn): void;
        getLowValue2(dataColumn: StiDataColumn): IStiMeter;
        getLowValue(meter: IStiMeter): IStiMeter;
        getLowValueByIndex(index: number): IStiMeter;
        insertLowValue(index: number, meter: IStiMeter): void;
        removeLowValue(index: number): void;
        removeAllLowValues(): void;
        createNewLowValue(): IStiMeter;
        addHighalue(dataColumn: StiDataColumn): void;
        getHighValue2(dataColumn: StiDataColumn): IStiMeter;
        getHighValue(meter: IStiMeter): IStiMeter;
        getHighValueByIndex(index: number): IStiMeter;
        insertHighValue(index: number, meter: IStiMeter): void;
        removeHighValue(index: number): void;
        removeAllHighValues(): void;
        createNewHighValue(): IStiMeter;
        addArgument(dataColumn: StiDataColumn): void;
        getArgument2(dataColumn: StiDataColumn): IStiMeter;
        getArgument(meter: IStiMeter): IStiMeter;
        getArgumentByIndex(index: number): IStiMeter;
        insertArgument(index: number, meter: IStiMeter): void;
        removeArgument(index: number): void;
        removeAllArguments(): void;
        createNewArgument(): void;
        addWeight(dataColumn: StiDataColumn): void;
        getWeight2(dataColumn: StiDataColumn): IStiMeter;
        getWeight(meter: IStiMeter): IStiMeter;
        getWeightByIndex(index: number): IStiMeter;
        insertWeight(index: number, meter: IStiMeter): void;
        removeWeight(index: number): void;
        removeAllWeights(): void;
        createNewWeight(): void;
        addSeries(dataColumn: StiDataColumn): void;
        getSeries2(dataColumn: StiDataColumn): IStiMeter;
        getSeries(meter: IStiMeter): IStiMeter;
        getSeries3(): IStiMeter;
        insertSeries(meter: IStiMeter): void;
        removeSeries(): void;
        createNewSeries(): void;
        convertFrom(element: IStiElement): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        group: string;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        private shouldSerializeDataTransformation;
        isDefaultDataTransformation(): boolean;
        dataFilters: List<StiDataFilterRule>;
        /**
         *  Gets or sets a list of colors which will be used for drawing series.
         */
        seriesColors: Color[];
        /**
         *  Gets or sets a list of colors which will be used for drawing series with negative values.
         */
        negativeSeriesColors: Color[];
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
     *  Gets localized string from specified property name.
     */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        readonly shouldSerializeDashboardInteraction: boolean;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        colorEach: boolean;
        values: List<StiValueChartMeter>;
        private shouldSerializeValues;
        endValues: List<StiEndValueChartMeter>;
        private shouldSerializeEndValues;
        closeValues: List<StiCloseValueChartMeter>;
        private shouldSerializeCloseValues;
        lowValues: List<StiLowValueChartMeter>;
        private shouldSerializeLowValues;
        highValues: List<StiHighValueChartMeter>;
        private shouldSerializeHighValues;
        arguments: List<StiArgumentChartMeter>;
        private shouldSerializeArguments;
        weights: List<StiWeightChartMeter>;
        private shouldSerializeWeights;
        series: StiSeriesChartMeter;
        private shouldSerializeSeries;
        /**
         *  Gets or sets settings of XAxis.
         */
        xAxis: StiXChartAxis;
        private shouldSerializeXAxis;
        /**
         *  Gets or sets settings of YAxis.
         */
        yAxis: StiYChartAxis;
        private shouldSerializeYAxis;
        /**
         *  Gets or sets settings of the legend.
         */
        legend: StiChartLegend;
        private shouldSerializeLegend;
        /**
             *  Gets or sets settings of the chart area.
             */
        area: StiChartArea;
        /**
         *  Gets or sets settings of the chart labels.
         */
        labels: StiChartLabels;
        /**
         *  Gets or sets the format of the arguments.
         */
        argumentFormat: StiFormatService;
        private shouldSerializeArgumentFormat;
        /**
         *  Gets or sets the format of the values.
         */
        valueFormat: StiFormatService;
        private shouldSerializeValueFormat;
        readonly isAxisAreaChart: boolean;
        readonly isBubbleChart: boolean;
        readonly isRange: boolean;
        readonly isFinancial: boolean;
        readonly isPieChart: boolean;
        readonly isDoughnutChart: boolean;
        readonly isFunnelChart: boolean;
        readonly isTreemapChart: boolean;
        readonly isParetoChart: boolean;
        /**
         *  Returns a list of the nested pages.
         */
        getNestedPages(): List<StiPage>;
        drillDownFiltersList: List<List<StiDataFilterRule>>;
        drillDownFilters: List<StiDataFilterRule>;
        drillDownCurrentLevel: number;
        readonly drillDownLevelCount: number;
        createNew(): StiComponent;
        checkBrowsableProperties(): void;
        private setBrowsableProperty;
        /**
         *  Creates a new  component of the type StiChartElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiChartGridLines implements ICloneable, IStiDefault, IStiJsonReportObject {
        private static ImplementsStiChartGridLines;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): StiChartGridLines;
        /**
         *  Gets or sets color which will be used for drawing major grid lines.
         */
        color: Color;
        visible: boolean;
        readonly isDefault: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import ICloneable = Stimulsoft.System.ICloneable;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    class StiChartInterlacing implements ICloneable, IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): StiChartInterlacing;
        /**
         * Gets or sets color which used for drawing interlaced bars.
         */
        color: Color;
        /**
         *  Gets or sets visibility of interlaced bars.
         */
        visible: boolean;
        readonly isDefault: boolean;
        StiChartInterlacing(): void;
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiChartLabels = Stimulsoft.Report.Dashboard.IStiChartLabels;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiChartLabelsPosition = Stimulsoft.Report.Dashboard.StiChartLabelsPosition;
    class StiChartLabels implements IStiJsonReportObject, IStiChartLabels {
        private static ImplementsStiChartLabels;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode): void;
        /**
         *  Creates a new object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(): StiChartLabels;
        /**
         *  Gets or sets a position of the labels.
         */
        position: StiChartLabelsPosition;
        /**
         *  Gets or sets a color which will be used for the labels drawing.
         */
        foreColor: Color;
        /**
         *  Gets or set a font which will be used for the labels drawing.
         */
        font: Font;
        /**
         *  Gets or sets value which enables or disables auto rotate mode drawing of the labels.
         */
        autoRotate: boolean;
        /**
         *  Gets or sets a style of the labels.
         */
        style: StiChartLabelsStyle;
        /**
         *  Gets or sets string which will be output after the labels string representation.
         */
        textAfter: string;
        /**
         *  Gets or sets string which will be output before the labels string representation.
         */
        textBefore: string;
        readonly isDefault: boolean;
        constructor(position?: StiChartLabelsPosition, style?: StiChartLabelsStyle, font?: Font, foreColor?: Color, textBefore?: string, textAfter?: string, autoRotate?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHorChartGridLines extends StiChartGridLines {
        /**
         *  Gets or sets visibility of major grid lines.
         */
        visible: boolean;
        readonly isDefault: boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHorChartInterlacing extends StiChartInterlacing {
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiVertChartGridLines extends StiChartGridLines {
        /**
         *  Gets or sets visibility of major grid lines.
         */
        visible: boolean;
        readonly isDefault: boolean;
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiVertChartInterlacing extends StiChartInterlacing {
        constructor(color?: Color, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiTitlePosition = Stimulsoft.Report.Chart.StiTitlePosition;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiDirection = Stimulsoft.Report.Chart.StiDirection;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiXChartAxisTitle extends StiChartAxisTitle implements IStiJsonReportObject {
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets or set text direction for axis title drawing.
         */
        direction: StiDirection;
        readonly isDefault: boolean;
        constructor(font?: Font, text?: string, color?: Color, alignment?: StringAlignment, direction?: StiDirection, position?: StiTitlePosition, visible?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Chart {
    class StiXChartMeter extends StiDimensionMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    class StiComboBoxElement extends StiElement implements IStiComboBoxElement, IStiFixedHeightElement, IStiJsonReportObject {
        private static ImplementsStiComboBoxElement;
        implements(): string[];
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFiltersAsync(): Promise<void>;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        showAllValue: boolean;
        selectionMode: StiItemSelectionMode;
        addKeyMeter2(dataColumn: StiDataColumn): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(dataColumn: StiDataColumn): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        createNextMeter(dataColumn: StiDataColumn): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        minSize: Size;
        maxSize: Size;
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        nameMeter: StiNameComboBoxMeter;
        keyMeter: StiKeyComboBoxMeter;
        /**
         *  Creates a new  element of the type StiComboBoxElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    import Promise = Stimulsoft.System.Promise;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import List = Stimulsoft.System.Collections.List;
    class StiComboBoxHelper {
        static fetchItems(comboBoxElement: StiComboBoxElement, dataTable: StiDataTable): StiComboBoxItem[];
        static fetchDefaultUserFiltersAsync(comboBoxElement: StiComboBoxElement): Promise<List<StiDataFilterRule>>;
        private static getNameMeterIndex;
        private static getKeyMeterIndex;
        static getKeyMeterExpression(comboBoxElement: StiComboBoxElement): string;
        private static format;
    }
}
declare namespace Stimulsoft.Dashboard.Components.ComboBox {
    class StiComboBoxItem {
        label: string;
        value: any;
        toString(): string;
        constructor(label: string, value?: any);
    }
}
declare namespace Stimulsoft.Dashboard.Components.DatePicker {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiInitialDateRangeSelection = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelection;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDateSelectionMode = Stimulsoft.Report.Dashboard.StiDateSelectionMode;
    import StiDateCondition = Stimulsoft.Report.Dashboard.StiDateCondition;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiValueDatePickerMeter = Stimulsoft.Dashboard.Components.DatePicker.StiValueDatePickerMeter;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiGroupElement = Stimulsoft.Report.Dashboard.IStiGroupElement;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElement extends StiElement implements IStiDatePickerElement, IStiFixedHeightElement, IStiGroupElement, IStiJsonReportObject {
        private static ImplementsStiDatePickerElement;
        implements(): string[];
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFiltersAsync(): Promise<void>;
        userFilters: List<StiDataFilterRule>;
        dataFilters: List<StiDataFilterRule>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        addValueMeter2(dataColumn: StiDataColumn): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiDateFormatService;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        minSize: Size;
        maxSize: Size;
        helpUrl: string;
        createNew(): StiComponent;
        condition: StiDateCondition;
        selectionMode: StiDateSelectionMode;
        valueMeter: StiValueDatePickerMeter;
        initialRangeSelection: StiInitialDateRangeSelection;
        /**
         *  Creates a new  element of the type StiDatePickerElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.DatePicker {
    import Promise = Stimulsoft.System.Promise;
    import StiDataFilterCondition = Stimulsoft.Data.Engine.StiDataFilterCondition;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiInitialDateRangeSelection = Stimulsoft.Report.Dashboard.StiInitialDateRangeSelection;
    import DateTime = Stimulsoft.System.DateTime;
    import List = Stimulsoft.System.Collections.List;
    class StiDatePickerHelper {
        static calculateRangeFromInitial(selection: StiInitialDateRangeSelection, start: {
            ref: DateTime;
        }, end: {
            ref: DateTime;
        }): void;
        static fetchDefaultUserFiltersAsync(datePickerElement: StiDatePickerElement): Promise<List<StiDataFilterRule>>;
        private static getSingleDefaultUserFilters;
        private static getRangeDefaultUserFilters;
        private static getAutoRangeDefaultUserFiltersAsync;
        static getValueMeterExpression(datePickerElement: StiDatePickerElement): string;
        static getCondition(datePickerElement: StiDatePickerElement): StiDataFilterCondition;
        static getFormatedDate(dateTime: DateTime): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    class StiElementEditorConsts {
        elementEditor: string;
        textFormatEditor: string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    class StiElementLayoutConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts a StiElementStyleIdent object from one data type to another.
     */
    class StiElementStyleConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts a List of StiMeter object from one data type to another.
     */
    class StiMeterListConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Design {
    /**
     *  Converts a StiTitle object from one data type to another.
     */
    class StiTitleConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts a StiGaugeRange object from one data type to another.
     */
    class StiGaugeRangeConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiElementBuilder {
        protected getSeries(table: StiDataTable, seriesIndex: number, seriesKey: string): string;
        protected getValue(table: StiDataTable, valueIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string): number;
        protected getNullableValue(table: StiDataTable, valueIndex: number, seriesIndex: number, seriesCount: number, seriesKey: string): number;
        protected getSeriesKeys(table: StiDataTable, seriesIndex: number): List<string>;
        private replaceDbNull;
        private toString;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    class StiMinGaugeMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    class StiMaxGaugeMeter extends StiMeasureMeter {
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        ident: StiMeterIdent;
        /**
         *  Localized name of this component type.
         */
        localizedName: string;
        constructor(key?: string, expression?: string, label?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Gauge {
    import StiGauge = Stimulsoft.Report.Components.StiGauge;
    class StiGaugeIteration {
        gauge: StiGauge;
        series: string;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiScaleBase = Stimulsoft.Report.Components.Gauge.Primitives.StiScaleBase;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Size = Stimulsoft.System.Drawing.Size;
    import StiGaugeElement = Stimulsoft.Dashboard.Components.Gauge.StiGaugeElement;
    import StiGaugeIteration = Stimulsoft.Dashboard.Visuals.Gauge.StiGaugeIteration;
    class StiGaugeElementBuilder extends StiElementBuilder {
        render(element: StiGaugeElement, size: Size, dataTable: StiDataTable): List<StiGaugeIteration>;
        render2(element: StiGaugeElement, size: Size, dataTable: StiDataTable): () => List<StiGaugeIteration>;
        private static setStyle;
        private createScale;
        private getSummary;
        private createFullCircularScale;
        createHalfCircularScale(element: StiGaugeElement, minValue: number, maxValue: number): StiScaleBase;
        createLinearScale(element: StiGaugeElement, minValue: number, maxValue: number): StiScaleBase;
        private static addRadialRanges;
        private static addLinearRanges;
        private getMinValue;
        private getMaxValue;
        private getValueMeterIndex;
        private getMinMeterIndex;
        private getMaxMeterIndex;
        private getSeriesMeterIndex;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiGaugeRange = Stimulsoft.Report.Dashboard.IStiGaugeRange;
    import ICloneable = Stimulsoft.System.ICloneable;
    class StiGaugeRange implements IStiJsonReportObject, IStiGaugeRange, ICloneable {
        private static ImplementsStiGaugeRange;
        implements(): string[];
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        color: Color;
        private shouldSerializeColor;
        start: number;
        end: number;
        static loadFromJson(json: StiJson): StiGaugeRange;
        static loadFromXml(xmlNode: XmlNode): StiGaugeRange;
        /**
         *  Saves element to String.
         *  @returns String representation which contains schema.
         */
        saveToString(): string;
        getStringRepresentation(): string;
        constructor(color?: Color, start?: number, end?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Gauge {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiGauge = Stimulsoft.Report.Components.Gauge.IStiGauge;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiGaugeRange = Stimulsoft.Dashboard.Components.Gauge.StiGaugeRange;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import Size = Stimulsoft.System.Drawing.Size;
    import IStiGaugeRange = Stimulsoft.Report.Dashboard.IStiGaugeRange;
    import StiSeriesGaugeMeter = Stimulsoft.Dashboard.Components.Gauge.StiSeriesGaugeMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiGaugeElement = Stimulsoft.Report.Dashboard.IStiGaugeElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiGaugeElement extends StiElement implements IStiGaugeElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiGaugeElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        addValue2(dataColumn: StiDataColumn): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addSeries2(dataColumn: StiDataColumn): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        getRanges(): List<IStiGaugeRange>;
        private getPreferedColor;
        addRange(): IStiGaugeRange;
        removeRange(index: number): void;
        createdDefaultRanges(): void;
        getGaugeComponentAsync(size?: Size): Promise<IStiGauge>;
        convertFrom(element: IStiElement): void;
        group: string;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        shortValue: boolean;
        value: StiValueGaugeMeter;
        series: StiSeriesGaugeMeter;
        minimum: number;
        maximum: number;
        calculationMode: Report.Gauge.StiGaugeCalculationMode;
        rangeMode: Report.Gauge.StiGaugeRangeMode;
        rangeType: Report.Gauge.StiGaugeRangeType;
        type: Report.Gauge.StiGaugeType;
        ranges: List<StiGaugeRange>;
        createNew(): StiComponent;
        /**
         *  Creates a new  component of the type StiGaugeElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Helpers {
    /**
     *  Class helps in creation new  object of the StiMeter type.
     */
    class StiMeterCreator {
        /**
         *  Creates new  meter object with help of its identification type name.
         *  @param identName A name of the identification type which is used for the meter creation.
         *  @returns Created meter object.
         */
        static neww(identName: string): StiMeter;
        /**
         *  Creates new  meter object with help of it identification type.
         *  @param ident An idendification type of the meter.
         *  @returns Created meter object.
         */
        static neww2(ident: StiMeterIdent): StiMeter;
    }
}
declare namespace Stimulsoft.Dashboard.Components.Helpers {
    class StiMeterJsonConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Image.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts image to string description.
     */
    class StiImageBytesConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Image {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import Image = Stimulsoft.System.Drawing.Image;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiHorAlignment = Stimulsoft.Report.Components.IStiHorAlignment;
    /**
     *  Image component of the dashboards.
     */
    class StiImageElement extends StiElement implements IStiHorAlignment, IStiVertAlignment, IStiImageElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiImageElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly isDefined: boolean;
        isQuerable: boolean;
        title: StiTitle;
        private _image;
        image: Image;
        imageHyperlink: string;
        aspectRatio: boolean;
        copyAllImageProperties(image: IStiImageElement): void;
        /**
         *  Gets or sets the image horizontal alignment.
         */
        horAlignment: StiHorAlignment;
        /**
         *  Gets or sets the vertical alignment of an image.
         */
        vertAlignment: StiVertAlignment;
        shouldSerializePadding(): boolean;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        createNew(): StiComponent;
        resetAllImageProperties(): void;
        readonly isImageDefined: boolean;
        readonly isImageHyperlinkDefined: boolean;
        /**
         *  Creates a new  component of the type StiImageElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Indicator {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiFontIconSet = Stimulsoft.Report.Helpers.StiFontIconSet;
    import StiFontIcons = Stimulsoft.Report.StiFontIcons;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiValueIndicatorMeter = Stimulsoft.Dashboard.Components.Indicator.StiValueIndicatorMeter;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    /**
     *  Indicator component of the dashboards.
     */
    class StiIndicatorElement extends StiElement implements IStiTextFormat, IStiIndicatorElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiIndicatorElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        group: string;
        addValue2(dataColumn: StiDataColumn): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addTarget2(dataColumn: StiDataColumn): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        addSeries2(dataColumn: StiDataColumn): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        private shouldSerializeDataTransformation;
        isDefaultDataTransformation(): boolean;
        dataFilters: List<StiDataFilterRule>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        /**
         *  Gets or sets glyph color for this element.
         */
        glyphColor: Color;
        private shouldSerializeGlyphColor;
        value: StiValueIndicatorMeter;
        target: StiTargetIndicatorMeter;
        series: StiSeriesIndicatorMeter;
        icon: StiFontIcons;
        iconSet: StiFontIconSet;
        isSampleForStyles: boolean;
        createNew(): StiComponent;
        /**
         *  Creates a new  component of the type StiIndicatorElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiNameListBoxMeter = Stimulsoft.Dashboard.Components.ListBox.StiNameListBoxMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiListBoxElement extends StiElement implements IStiListBoxElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiListBoxElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        group: string;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        showAllValue: boolean;
        selectionMode: StiItemSelectionMode;
        title: StiTitle;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFiltersAsync(): Promise<void>;
        addKeyMeter2(dataColumn: StiDataColumn): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(dataColumn: StiDataColumn): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        createNextMeter(dataColumn: StiDataColumn): void;
        convertFrom(element: IStiElement): void;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        nameMeter: StiNameListBoxMeter;
        keyMeter: StiKeyListBoxMeter;
        /**
         *  Creates a new  element of the type StiListBoxElement with specified location.
         * <param name="rect" > The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    import Promise = Stimulsoft.System.Promise;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiListBoxHelper {
        static fetchItems(listBoxElement: StiListBoxElement, dataTable: StiDataTable): StiListBoxItem[];
        static fetchDefaultUserFiltersAsync(listBoxElement: StiListBoxElement): Promise<List<StiDataFilterRule>>;
        static getNameMeterIndex(table: StiDataTable): number;
        static getKeyMeterIndex(table: StiDataTable): number;
        static getKeyMeterExpression(listBoxElement: StiListBoxElement): string;
        static format(listBoxElement: StiListBoxElement, value: any): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.ListBox {
    class StiListBoxItem {
        label: string;
        value: any;
        toString(): string;
        constructor(label: string, value?: any);
    }
}
declare namespace Stimulsoft.Dashboard.Components.OnlineMap {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiOnlineMapElement = Stimulsoft.Report.Dashboard.IStiOnlineMapElement;
    import StiOnlineMapLocationType = Stimulsoft.Report.Dashboard.StiOnlineMapLocationType;
    import StiOnlineMapCulture = Stimulsoft.Report.Dashboard.StiOnlineMapCulture;
    import StiOnlineMapLocationColorType = Stimulsoft.Report.Dashboard.StiOnlineMapLocationColorType;
    import StiOnlineMapValueViewMode = Stimulsoft.Report.Dashboard.StiOnlineMapValueViewMode;
    import Color = Stimulsoft.System.Drawing.Color;
    /**
     *  Map component of the dashboards.
     */
    class StiOnlineMapElement extends StiElement implements IStiOnlineMapElement, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiOnlineMapElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        group: string;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        createNextMeter(dataColumn: StiDataColumn): void;
        addLatitudeMeter2(dataColumn: StiDataColumn): void;
        addLatitudeMeter(meter: IStiMeter): void;
        getLatitudeMeter(): IStiMeter;
        removeLatitudeMeter(): void;
        createNewLatitudeMeter(): void;
        addLongitudeMeter2(dataColumn: StiDataColumn): void;
        addLongitudeMeter(meter: IStiMeter): void;
        getLongitudeMeter(): IStiMeter;
        removeLongitudeMeter(): void;
        createNewLongitudeMeter(): void;
        addLocationMeter2(dataColumn: StiDataColumn): void;
        addLocationMeter(meter: IStiMeter): void;
        getLocationMeter(): IStiMeter;
        removeLocationMeter(): void;
        createNewLocationMeter(): void;
        addLocationColorMeter2(dataColumn: StiDataColumn): void;
        addLocationColorMeter(meter: IStiMeter): void;
        getLocationColorMeter(): IStiMeter;
        removeLocationColorMeter(): void;
        createNewLocationColorMeter(): void;
        addLocationValueMeter2(dataColumn: StiDataColumn): void;
        addLocationValueMeter(meter: IStiMeter): void;
        getLocationValueMeter(): IStiMeter;
        removeLocationValueMeter(): void;
        createNewLocationValueMeter(): void;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        latitude: StiLatitudeMapMeter;
        longitude: StiLongitudeMapMeter;
        location: StiLocationMapMeter;
        locationColorMeter: StiLocationMapMeter;
        locationValue: StiLocationMapMeter;
        locationType: StiOnlineMapLocationType;
        culture: StiOnlineMapCulture;
        locationColorType: StiOnlineMapLocationColorType;
        valueViewMode: StiOnlineMapValueViewMode;
        locationColor: Color;
        createNew(): StiComponent;
        /**
         *  Creates a new  component of the type StiOnlineMapElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiPivotColumn object from one data type to another.
     */
    class StiPivotColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiPivotRow object from one data type to another.
     */
    class StiPivotRowConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiPivotSummary object from one data type to another.
     */
    class StiPivotSummaryConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiPivotTableElement = Stimulsoft.Dashboard.Components.PivotTable.StiPivotTableElement;
    class StiPivotTableElementSelection {
        private static hash;
        static getSelected(element: StiPivotTableElement): List<StiMeter>;
        static getSelectedObjects(element: StiPivotTableElement): List<any>;
        static isSelected(element: StiPivotTableElement, column: StiMeter): boolean;
        static select(element: StiPivotTableElement, column: StiMeter): void;
        static resetSelection(element: StiPivotTableElement): void;
    }
}
declare namespace Stimulsoft.Dashboard.Components.PivotTable {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiPivotSummary = Stimulsoft.Dashboard.Components.PivotTable.StiPivotSummary;
    import StiPivotColumn = Stimulsoft.Dashboard.Components.PivotTable.StiPivotColumn;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    class StiPivotTableElement extends StiElement implements IStiPivotTableElement, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiPivotTableElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        retrieveUsedDataNames(): List<string>;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        readonly isDefined: boolean;
        group: string;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        createNextMeter(dataColumn: StiDataColumn): void;
        createNewColumn(): void;
        getColumn2(dataColumn: StiDataColumn): IStiMeter;
        getColumn(meter: IStiMeter): IStiMeter;
        getColumnByIndex(index: number): IStiMeter;
        insertColumn(index: number, meter: IStiMeter): void;
        removeColumn(index: number): void;
        removeAllColumns(): void;
        createNewRow(): void;
        getRow2(dataColumn: StiDataColumn): IStiMeter;
        getRow(meter: IStiMeter): IStiMeter;
        getRowByIndex(index: number): IStiMeter;
        insertRow(index: number, meter: IStiMeter): void;
        removeRow(index: number): void;
        removeAllRows(): void;
        createNewSummary(): void;
        getSummary2(dataColumn: StiDataColumn): IStiMeter;
        getSummary(meter: IStiMeter): IStiMeter;
        getSummaryByIndex(index: number): IStiMeter;
        insertSummary(index: number, meter: IStiMeter): void;
        removeSummary(index: number): void;
        removeAllSummaries(): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         * Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         * Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        columns: List<StiPivotColumn>;
        private shouldSerializeColumns;
        rows: List<StiPivotRow>;
        private shouldSerializeRows;
        summaries: List<StiPivotSummary>;
        private shouldSerializeSummaries;
        totalLabel: string;
        createNew(): StiComponent;
        getFormatObjects(): List<any>;
        /**
         *  Creates a new  component of the type StiPivotTableElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Progress {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiSeriesColors = Stimulsoft.Report.Dashboard.IStiSeriesColors;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiProgressElementMode = Stimulsoft.Report.Dashboard.StiProgressElementMode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import List = Stimulsoft.System.Collections.List;
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiTargetProgressMeter = Stimulsoft.Dashboard.Components.Progress.StiTargetProgressMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiFont = Stimulsoft.Report.Components.IStiFont;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import IStiTextFormat = Stimulsoft.Report.Components.IStiTextFormat;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    /**
     *  Progress component of the dashboards.
     */
    class StiProgressElement extends StiElement implements IStiTextFormat, IStiProgressElement, IStiTitleElement, IStiFont, IStiForeColor, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiSeriesColors {
        private static ImplementsStiProgressElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        group: string;
        addValue2(dataColumn: StiDataColumn): void;
        addValue(meter: IStiMeter): void;
        removeValue(): void;
        getValue(): IStiMeter;
        getValue2(meter: IStiMeter): IStiMeter;
        createNewValue(): void;
        addTarget2(dataColumn: StiDataColumn): void;
        addTarget(meter: IStiMeter): void;
        removeTarget(): void;
        getTarget(): IStiMeter;
        getTarget2(meter: IStiMeter): IStiMeter;
        createNewTarget(): void;
        addSeries2(dataColumn: StiDataColumn): void;
        addSeries(meter: IStiMeter): void;
        removeSeries(): void;
        getSeries(): IStiMeter;
        getSeries2(meter: IStiMeter): IStiMeter;
        createNewSeries(): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        topN: StiDataTopN;
        dataTransformation: {};
        private shouldSerializeDataTransformation;
        isDefaultDataTransformation(): boolean;
        dataFilters: List<StiDataFilterRule>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets or sets a list of colors which will be used for drawing series.
         */
        seriesColors: Color[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        colorEach: boolean;
        value: StiValueProgressMeter;
        target: StiTargetProgressMeter;
        series: StiSeriesProgressMeter;
        mode: StiProgressElementMode;
        isSampleForStyles: boolean;
        createNew(): StiComponent;
        /**
         *  Creates a new  component of the type StiProgressElement with specified location.
         * <param name="rect" > The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    class StiRegionMapDashboardInteraction extends StiDashboardInteraction {
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        readonly isDefault: boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, dashboardKey?: string);
    }
}
declare namespace Stimulsoft.Dashboard.Components.RegionMap {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiKeyMapMeter = Stimulsoft.Dashboard.Components.RegionMap.StiKeyMapMeter;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiMapData = Stimulsoft.Report.Maps.StiMapData;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiDisplayNameType = Stimulsoft.Report.Maps.StiDisplayNameType;
    import StiMapType = Stimulsoft.Report.Maps.StiMapType;
    import StiMapID = Stimulsoft.Report.Maps.StiMapID;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiMapSource = Stimulsoft.Report.Maps.StiMapSource;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiSkipOwnFilter = Stimulsoft.Report.Dashboard.IStiSkipOwnFilter;
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    class StiRegionMapElement extends StiElement implements IStiRegionMapElement, IStiSkipOwnFilter, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        private static ImplementsStiRegionMapElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        group: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        readonly isQuerable: boolean;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        createNextMeter(dataColumn: StiDataColumn): void;
        addKeyMeter2(dataColumn: StiDataColumn): void;
        addKeyMeter(meter: IStiMeter): void;
        getKeyMeter(): IStiMeter;
        removeKeyMeter(): void;
        createNewKeyMeter(): void;
        addNameMeter2(dataColumn: StiDataColumn): void;
        addNameMeter(meter: IStiMeter): void;
        getNameMeter(): IStiMeter;
        removeNameMeter(): void;
        createNewNameMeter(): void;
        addValueMeter2(dataColumn: StiDataColumn): void;
        addValueMeter(meter: IStiMeter): void;
        getValueMeter(): IStiMeter;
        removeValueMeter(): void;
        createNewValueMeter(): void;
        addGroupMeter2(dataColumn: StiDataColumn): void;
        addGroupMeter(meter: IStiMeter): void;
        getGroupMeter(): IStiMeter;
        removeGroupMeter(): void;
        createNewGroupMeter(): void;
        addColorMeter2(dataColumn: StiDataColumn): void;
        addColorMeter(meter: IStiMeter): void;
        getColorMeter(): IStiMeter;
        removeColorMeter(): void;
        createNewColorMeter(): void;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        dashboardInteraction: IStiDashboardInteraction;
        readonly shouldSerializeDashboardInteraction: boolean;
        mapID: StiMapID;
        dataFrom: StiMapSource;
        mapData: string;
        mapType: StiMapType;
        showValue: boolean;
        shortValue: boolean;
        colorEach: boolean;
        showName: StiDisplayNameType;
        keyMeter: StiKeyMapMeter;
        nameMeter: StiNameMapMeter;
        valueMeter: StiValueMapMeter;
        groupMeter: StiGroupMapMeter;
        colorMeter: StiColorMapMeter;
        /**
         *  Returns a list of the nested pages.
         */
        getNestedPages(): List<StiPage>;
        getMapData(): List<StiMapData>;
        createNew(): StiComponent;
        /**
         *  Creates a new  component of the type StiRegionMapElement with specified location.
         * <param name="rect" > The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Shape {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiTitle = Stimulsoft.Dashboard.Components.StiTitle;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiJson = Stimulsoft.Base.StiJson;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiRectangleShapeType = Stimulsoft.Report.Components.StiRectangleShapeType;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiShapeElement = Stimulsoft.Report.Dashboard.IStiShapeElement;
    class StiShapeElement extends StiElement implements IStiShapeElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiShapeElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        isDefined: boolean;
        isQuerable: boolean;
        title: StiTitle;
        shouldSerializePadding(): boolean;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        createNew(): StiComponent;
        /**
         *  Gets or sets type of the shape.
         */
        shapeType: StiRectangleShapeType;
        private _size;
        /**
         *  Gets or sets size of the border.
         */
        size: number;
        /**
         *  Gets or sets a brush to fill a component.
         */
        fill: StiBrush;
        /**
         *  Gets or sets stroke shape.
         */
        stroke: Color;
        /**
         *  Creates a new  component of the type StiShapeElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiDataBarsColumn object from one data type to another.
     */
    class StiDataBarsColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiDimensionColumn object from one data type to another.
     */
    class StiDimensionColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiDataBarsColumn object from one data type to another.
     */
    class StiSparklinesColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table.Design {
    import StiMeterConverter = Stimulsoft.Dashboard.Components.Design.StiMeterConverter;
    /**
     *  Converts a StiTableColumn object from one data type to another.
     */
    class StiTableColumnConverter extends StiMeterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    /**
     *  In which direction data bar will be filled by brush, from left to right or from right to left.
     */
    enum StiDataBarsDirection {
        /**
         *  From left to right direction.
         */
        LeftToRight = 0,
        /**
         *  From right to left direction.
         */
        RighToLeft = 1
    }
    /**
     *  Styles of brush for drawing Data Bars Indicator
     */
    enum StiDataBarsBrushType {
        /**
         *  Solid brush.
         */
        Solid = 0,
        /**
         *  Gradient brush.
         */
        Gradient = 1
    }
    /**
     *  Types of the sparklines
     */
    enum StiSparklinesType {
        /**
         *  Line type.
         */
        Line = 0,
        /**
         *  Area type.
         */
        Area = 1,
        /**
         *  Column.
         */
        Column = 2,
        /**
         *  WinLoss
         */
        WinLoss = 3
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import List = Stimulsoft.System.Collections.List;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    class StiTableElementSelection {
        private static hash;
        static getSelected(element: StiTableElement): List<StiTableColumn>;
        static getSelectedObjects(element: StiTableElement): List<any>;
        static isSelected(element: StiTableElement, column: StiTableColumn): boolean;
        static select(element: StiTableElement, column: StiTableColumn): void;
        static resetSelection(element: StiTableElement): void;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    var IStiAllowUserFilteringDashboardInteraction: string;
    interface IStiAllowUserFilteringDashboardInteraction {
        allowUserFiltering: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    var IStiAllowUserSortingDashboardInteraction: string;
    interface IStiAllowUserSortingDashboardInteraction {
        allowUserSorting: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import List = Stimulsoft.System.Collections.List;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiInteractionOnHover = Stimulsoft.Report.Dashboard.StiInteractionOnHover;
    import StiInteractionOnClick = Stimulsoft.Report.Dashboard.StiInteractionOnClick;
    import StiInteractionOpenHyperlinkDestination = Stimulsoft.Report.Dashboard.StiInteractionOpenHyperlinkDestination;
    import StiInteractionIdent = Stimulsoft.Report.Dashboard.StiInteractionIdent;
    import StiAvailableInteractionOnClick = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnClick;
    import IStiTableDashboardInteraction = Stimulsoft.Report.Dashboard.IStiTableDashboardInteraction;
    import IStiAllowUserSortingDashboardInteraction = Stimulsoft.Dashboard.Interactions.IStiAllowUserSortingDashboardInteraction;
    import IStiAllowUserFilteringDashboardInteraction = Stimulsoft.Dashboard.Interactions.IStiAllowUserFilteringDashboardInteraction;
    import StiAvailableInteractionOnHover = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnHover;
    import StiAvailableInteractionOnDataManipulation = Stimulsoft.Report.Dashboard.StiAvailableInteractionOnDataManipulation;
    class StiTableDashboardInteraction extends StiDashboardInteraction implements IStiTableDashboardInteraction, IStiAllowUserSortingDashboardInteraction, IStiAllowUserFilteringDashboardInteraction, IStiJsonReportObject {
        private static ImplementsIStiTableDashboardInteraction;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        allowUserSorting: boolean;
        allowUserFiltering: boolean;
        ident: StiInteractionIdent;
        availableOnClick: StiAvailableInteractionOnClick;
        Filter: any;
        availableOnHover: StiAvailableInteractionOnHover;
        availableOnDataManipulation: StiAvailableInteractionOnDataManipulation;
        readonly isDefault: boolean;
        constructor(onHover?: StiInteractionOnHover, onClick?: StiInteractionOnClick, hyperlinkDestination?: StiInteractionOpenHyperlinkDestination, toolTip?: string, hyperlink?: string, drillDownPageKey?: string, drillDownParameters?: List<StiDashboardDrillDownParameter>, allowFiltering?: boolean, allowSorting?: boolean);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Table {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import IStiElementInteraction = Stimulsoft.Report.Dashboard.IStiElementInteraction;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiElementLayout = Stimulsoft.Report.Dashboard.IStiElementLayout;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiTableSizeMode = Stimulsoft.Report.Dashboard.StiTableSizeMode;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Font = Stimulsoft.System.Drawing.Font;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    class StiTableElement extends StiElement implements IStiTableElement, IStiTitleElement, IStiElementLayout, IStiJsonReportObject, IStiGlobalizationProvider, IStiElementInteraction {
        private static ImplementsStiTableElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        createMeters(source: IStiTableElement): void;
        createMeters2(dataSource: StiDataSource): void;
        createMeter3(dataColumn: StiDataColumn): void;
        removeMeter(index: number): void;
        removeAllMeters(): void;
        insertMeter(index: number, meter: IStiMeter): void;
        insertNewDimension(index: number): void;
        insertNewMeasure(index: number): void;
        getMeasure(dataColumn: StiDataColumn): IStiMeter;
        getDimension(dataColumn: StiDataColumn): IStiMeter;
        convertFrom(element: IStiElement): void;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        title: StiTitle;
        /**
         *  Gets layout of the element.
         */
        layout: StiElementLayout;
        private shouldSerializeLayout;
        group: string;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        userFilters: List<StiDataFilterRule>;
        userSorts: List<StiDataSortRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        /**
         *  Gets or sets value indicates is the component selected or not.
         */
        /**
        /// Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        dashboardInteraction: IStiDashboardInteraction;
        readonly shouldSerializeDashboardInteraction: boolean;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        helpUrl: string;
        columns: List<StiTableColumn>;
        private shouldSerializeColumns;
        /**
         *  Gets or sets the column size mode.
         */
        sizeMode: StiTableSizeMode;
        /**
         *  Gets or sets fore color for the table header.
         */
        headerForeColor: Color;
        private shouldSerializeHeaderForeColor;
        /**
         *  Gets or sets the font of the table header.
         */
        headerFont: Font;
        private shouldSerializeHeaderFont;
        /**
         *  Returns a list of the nested pages.
         */
        getNestedPages(): List<StiPage>;
        getFormatObjects(): List<any>;
        createNew(): StiComponent;
        /**
         *  Creates a new  component of the type StiTableElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.Text.Design {
    import TypeConverter = Stimulsoft.System.ComponentModel.TypeConverter;
    /**
     *  Converts text to string description.
     */
    class StiTextConverter extends TypeConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Components.Text {
    import StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import IStiHtmlTextHelper = Stimulsoft.Report.Dashboard.IStiHtmlTextHelper;
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import Font = Stimulsoft.System.Drawing.Font;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTextElement = Stimulsoft.Report.Dashboard.IStiTextElement;
    import IStiVertAlignment = Stimulsoft.Report.Components.IStiVertAlignment;
    import IStiTextHorAlignment = Stimulsoft.Report.Components.IStiTextHorAlignment;
    import IStiForeColor = Stimulsoft.Report.Components.IStiForeColor;
    import IStiTextFont = Stimulsoft.Report.Components.IStiTextFont;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    class StiTextElement extends StiElement implements IStiTextFont, IStiForeColor, IStiTextHorAlignment, IStiVertAlignment, IStiTextElement, IStiTitleElement, IStiJsonReportObject, IStiGlobalizationProvider {
        private static ImplementsStiTextElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        readonly isDefined: boolean;
        isQuerable: boolean;
        title: StiTitle;
        text: string;
        getSimpleText(): string;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        getFont(): Font;
        setFontName(fontName: string): void;
        setFontSize(fontSize: number): void;
        growFontSize(): void;
        shrinkFontSize(): void;
        setFontBoldStyle(isBold: boolean): void;
        setFontItalicStyle(isItalic: boolean): void;
        setFontUnderlineStyle(isUnderline: boolean): void;
        /**
         *  Gets or sets the text horizontal alignment.
         */
        horAlignment: StiTextHorAlignment;
        /**
         *  Gets or sets the vertical alignment of an object.
         */
        vertAlignment: StiVertAlignment;
        shouldSerializePadding(): boolean;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        createNew(): StiComponent;
        getHtmlTextHelper(): IStiHtmlTextHelper;
        /**
         *  Creates a new  component of the type StiTextElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeItem {
        key: any;
        meter: IStiMeter;
        items: List<StiTreeItem>;
        toString(): string;
        constructor(key?: any, meter?: IStiMeter);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import Promise = Stimulsoft.System.Promise;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiTreeViewBoxElement = Stimulsoft.Dashboard.Components.TreeViewBox.StiTreeViewBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import StiTreeItem = Stimulsoft.Dashboard.Components.TreeView.StiTreeItem;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiTreeViewHelper {
        static fetchItems(dataTable: StiDataTable, removeEmptyField?: boolean, fillLastTagOnly?: boolean): List<StiTreeItem>;
        static fetchDefaultUserFiltersAsync(treeViewBoxElement: StiTreeViewBoxElement): Promise<List<StiDataFilterRule>>;
        static fetchDefaultUserFilters2Async(treeViewElement: StiTreeViewElement): Promise<List<StiDataFilterRule>>;
        static format(treeViewBoxElement: StiTreeViewBoxElement, value: any): string;
        static format2(treeViewElement: StiTreeViewElement, value: any): string;
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeViewBox {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Promise = Stimulsoft.System.Promise;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import Size = Stimulsoft.System.Drawing.Size;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiFixedHeightElement = Stimulsoft.Report.Dashboard.IStiFixedHeightElement;
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    class StiTreeViewBoxElement extends StiElement implements IStiTreeViewBoxElement, IStiFixedHeightElement, IStiJsonReportObject {
        private static ImplementsStiTreeViewBoxElement;
        implements(): string[];
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFiltersAsync(): Promise<void>;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        showAllValue: boolean;
        selectionMode: StiItemSelectionMode;
        getKeyMeter(dataColumn: StiDataColumn): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): void;
        removeKeyMeter(index: number): void;
        removeAllKeyMeters(): void;
        addNewKeyMeter(): IStiMeter;
        addKey(dataColumn: StiDataColumn): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        minSize: Size;
        maxSize: Size;
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        keyMeters: List<StiKeyTreeViewBoxMeter>;
        /**
         *  Creates a new  element of the type StiTreeViewBoxElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components.TreeView {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiGlobalizationProvider = Stimulsoft.Report.IStiGlobalizationProvider;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiComponentToolboxPosition = Stimulsoft.Report.Components.StiComponentToolboxPosition;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiItemSelectionMode = Stimulsoft.Report.Dashboard.StiItemSelectionMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiJson = Stimulsoft.Base.StiJson;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiTitleElement = Stimulsoft.Report.Dashboard.IStiTitleElement;
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    class StiTreeViewElement extends StiElement implements IStiTreeViewElement, IStiTitleElement, IStiGlobalizationProvider, IStiJsonReportObject {
        private static ImplementsStiTreeViewElement;
        implements(): string[];
        /**
         *  Creates a new  object that is a copy of the current instance.
         *  @returns A new object that is a copy of this instance.
         */
        clone(cloneProperties: boolean): any;
        /**
         *  ID code of this component. Used in JSON saving.
         */
        componentId: StiComponentId;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        group: string;
        getParentKey(): string;
        setParentKey(key: string): void;
        applyDefaultFiltersAsync(): Promise<void>;
        title: StiTitle;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        fetchAllMeters(): List<IStiMeter>;
        getMeters(): List<IStiMeter>;
        retrieveUsedDataNames(): List<string>;
        readonly isDefined: boolean;
        userFilters: List<StiDataFilterRule>;
        transformActions: List<StiDataActionRule>;
        transformFilters: List<StiDataFilterRule>;
        transformSorts: List<StiDataSortRule>;
        dataTransformation: {};
        dataFilters: List<StiDataFilterRule>;
        /**
         *  Gets or sets the font of the text displayed by the control.
         */
        font: Font;
        private shouldSerializeFont;
        /**
         *  Gets or sets font color for this element.
         */
        foreColor: Color;
        private shouldSerializeForeColor;
        showAllValue: boolean;
        selectionMode: StiItemSelectionMode;
        getKeyMeter(dataColumn: StiDataColumn): IStiMeter;
        getKeyMeterByIndex(index: number): IStiMeter;
        insertKeyMeter(index: number, meter: IStiMeter): void;
        removeKeyMeter(index: number): void;
        removeAllKeyMeters(): void;
        addNewKeyMeter(): IStiMeter;
        addKey(dataColumn: StiDataColumn): void;
        convertFrom(element: IStiElement): void;
        /**
         *  Gets or sets the format of the text.
         */
        textFormat: StiFormatService;
        private shouldSerializeTextFormat;
        /**
         *  Sets localized string to specified property name.
         */
        setString(propertyName: string, value: string): void;
        /**
         *  Gets localized string from specified property name.
         */
        getString(propertyName: string): string;
        /**
         *  Returns array of the property names which can be localized.
         */
        getAllStrings(): string[];
        /**
         *  Gets value to sort a position in the toolbox.
         */
        toolboxPosition: StiComponentToolboxPosition;
        /**
         *  Gets a localized component name.
         */
        readonly localizedName: string;
        /**
         *  Gets or sets the default client area of a component.
         */
        defaultClientRectangle: Rectangle;
        helpUrl: string;
        createNew(): StiComponent;
        parentKey: string;
        keyMeters: List<StiKeyTreeViewMeter>;
        /**
         *  Creates a new  element of the type StiTreeViewElement with specified location.
         *  @param rect The rectangle describes size and position of the component.
         */
        constructor(rect?: Rectangle);
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    enum StiMeterIdent {
        ArgumentChartMeter = 1,
        SeriesChartMeter = 2,
        ValueChartMeter = 3,
        EndValueChartMeter = 4,
        OpenValueChartMeter = 5,
        CloseValueChartMeter = 6,
        LowValueChartMeter = 7,
        HighValueChartMeter = 8,
        WeightChartMeter = 9,
        XChartMeter = 10,
        YChartMeter = 11,
        MaxGaugeMeter = 12,
        MinGaugeMeter = 13,
        SeriesGaugeMeter = 14,
        ValueGaugeMeter = 15,
        SeriesIndicatorMeter = 16,
        TargetIndicatorMeter = 17,
        ValueIndicatorMeter = 18,
        SeriesProgressMeter = 19,
        TargetProgressMeter = 20,
        ValueProgressMeter = 21,
        LatitudeMapMeter = 22,
        LongitudeMapMeter = 23,
        LocationMapMeter = 24,
        LocationValueMapMeter = 25,
        LocationColorMapMeter = 26,
        KeyMapMeter = 27,
        NameMapMeter = 28,
        ValueMapMeter = 29,
        GroupMapMeter = 30,
        ColorMapMeter = 31,
        ColorScaleColumn = 32,
        DataBarsColumn = 33,
        DimensionColumn = 34,
        IndicatorColumn = 35,
        MeasureColumn = 36,
        SparklinesColumn = 37,
        PivotColumn = 38,
        PivotRow = 39,
        PivotSummary = 40,
        NameListBoxMeter = 41,
        KeyListBoxMeter = 42,
        KeyTreeViewMeter = 43,
        KeyTreeViewBoxMeter = 44,
        NameComboBoxMeter = 45,
        KeyComboBoxMeter = 46,
        ValueDatePickerMeter = 47
    }
}
declare namespace Stimulsoft.Dashboard.Components {
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiUnit = Stimulsoft.Report.Units.StiUnit;
    import StiMargins = Stimulsoft.Report.Components.StiMargins;
    import StiComponentId = Stimulsoft.Report.StiComponentId;
    import IStiAppDataSource = Stimulsoft.Base.IStiAppDataSource;
    import IStiAppDictionary = Stimulsoft.Base.IStiAppDictionary;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    /**
     *  Represents a dashboard panel.
     */
    class StiDashboard extends StiPage implements IStiDashboard, IStiJsonReportObject {
        private static ImplementsStiDashboard;
        implements(): string[];
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        getMeters(nested?: boolean, group?: string): List<IStiMeter>;
        getElements(nested?: boolean, group?: string): List<IStiElement>;
        getUserFilters(element: IStiElement): List<StiDataFilterRule>;
        private getUserFilters3;
        fetchAllMeters(): List<IStiMeter>;
        getNestedPages(): List<StiPage>;
        readonly isDefined: boolean;
        isQuerable: boolean;
        /**
         *  Gets or sets a back color.
         */
        backColor: Color;
        private shouldSerializeBackColor;
        retrieveUsedDataNames(group: string): List<string>;
        getDictionary(): IStiAppDictionary;
        getDataSources(dataNames: List<string>): List<IStiAppDataSource>;
        getKey(): string;
        isDataSource: boolean;
        /**
         *  Gets a service category.
         */
        serviceCategory: string;
        /**
         *  ID code of this meter. Used in JSON saving.
         */
        componentId: StiComponentId;
        /**
         *  Gets a localized component name.
         */
        localizedName: string;
        margins: StiMargins;
        readonly gridSize: number;
        readonly unit: StiUnit;
        brush: StiBrush;
        readonly skip: boolean;
        convert(oldUnit: StiUnit, newUnit: StiUnit, isReportSnapshot?: boolean): void;
        createNew(): StiComponent;
        key: string;
        private _style;
        style: StiElementStyleIdent;
        customStyleName: string;
        private _width2;
        /**
         *  Gets or sets the total width of the dashboard.
         */
        width: number;
        private _height2;
        /**
         *  Gets or sets the total height of the dashboard.
         */
        height: number;
        /**
         *  Creates a new  StiDashboard.
         */
        constructor(report?: StiReport);
    }
}
declare namespace Stimulsoft.Dashboard.Design.Helpers {
    enum StiRichTextAlignment {
        /**
         *  The text is aligned to the left.
         */
        Left = 1,
        /**
         *  The text is aligned to the right.
         */
        Right = 2,
        /**
         *  The text is aligned in the center.
         */
        Center = 3,
        /**
         *  The text is justified.
         */
        Justify = 4
    }
}
declare namespace Stimulsoft.Dashboard.Design.Helpers {
    import Color = Stimulsoft.System.Drawing.Color;
    import Font = Stimulsoft.System.Drawing.Font;
    /**
     *  Represents a Windows rich text box control, with some impovements.
     */
    class StiRichBoxControl {
        selectionFont: Font;
        selectionColor: Color;
        selectionAlignment: StiRichTextAlignment;
        font: Font;
        text: string;
        selectedText: string;
        selectAll(): void;
        select(start: number, end: number): void;
        beginUpdate(): void;
        endUpdate(): void;
        setSelectionFont(face: string): boolean;
        setSelectionSize(size: number): boolean;
        setSelectionBold(bold: boolean): boolean;
        setSelectionItalic(italic: boolean): boolean;
        setSelectionUnderlined(underlined: boolean): boolean;
        constructor();
    }
}
declare namespace Stimulsoft.Dashboard.Design.Helpers {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import IStiHtmlTextHelper = Stimulsoft.Report.Dashboard.IStiHtmlTextHelper;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiRichBoxControl = Stimulsoft.Dashboard.Design.Helpers.StiRichBoxControl;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiHtmlTextHelper implements IStiHtmlTextHelper {
        setFontName(textObj: any, text: string, fontName: string, defaultColor: Color): string;
        setFontSize(textObj: any, text: string, fontSize: number, defaultColor: Color): string;
        growFontSize(textObj: any, text: string, defaultColor: Color): string;
        shrinkFontSize(textObj: any, text: string, defaultColor: Color): string;
        setFontBoldStyle(textObj: any, text: string, isBold: boolean, defaultColor: Color): string;
        setFontItalicStyle(textObj: any, text: string, isItalic: boolean, defaultColor: Color): string;
        setFontUnderlineStyle(textObj: any, text: string, isUnderline: boolean, defaultColor: Color): string;
        setColor(textObj: any, text: string, color: Color, defaultColor: Color): string;
        setHorAlignment(textObj: any, text: string, alignment: StiTextHorAlignment, defaultColor: Color): string;
        getFont(textObj: any, text: string, defaultColor: Color): Font;
        getColor(textObj: any, text: string, defaultColor: Color): Color;
        getHorAlign(textObj: any, text: string, defaultColor: Color): StiTextHorAlignment;
        setHtmlText(htmlText: string, textObj: any, richTextBox: StiRichBoxControl, defaultColor: Color): void;
        getHtmlText(richTextBox: StiRichBoxControl, defaultColor: Color): string;
        private getAlignment;
        private getAlignment2;
        getSimpleText(htmlText: string, defaultColor: Color): string;
    }
}
declare namespace Stimulsoft.Dashboard.Design {
    class StiInplaceDesigner {
        static isEditorActivated: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiTextOptions = Stimulsoft.Base.Drawing.StiTextOptions;
    import Size = Stimulsoft.System.Drawing.Size;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiAutoSizeHtmlTextHelper {
        static measure(g: Graphics, rect: Rectangle, text: string, textObj: any, scale?: number): Size;
        static getDefaultTextOptions(): StiTextOptions;
        private static getHorAlignment;
        private static getVerAlignment;
        private static getTextScale;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Size = Stimulsoft.System.Drawing.Size;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    class StiAutoSizeTextHelper {
        static toAlignment(alignment: StiHorAlignment): StiTextHorAlignment;
        static measure(g: Graphics, text: string, font: Font): Size;
        static measureFontSize(g: Graphics, text: string, rect: Rectangle, font: Font): number;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import List = Stimulsoft.System.Collections.List;
    class StiElementLocationHelper {
        private static hashLocations;
        static IsWpfMode: boolean;
        static getSumRectangle(listLocationRectangles: List<Rectangle>): Rectangle;
        static getLocationRectangles(rect: Rectangle, countRect: number, element: IStiElement): List<Rectangle>;
        private static getMinRectangle;
        private static prepareColumnRow;
        private static getUsingRect;
        private static checkMinRect;
        private static getSimpleRect;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiElementLocationKey {
        rectKey: Rectangle;
        countKey: number;
        constructor(rectKey: Rectangle, countKey: number);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Promise = Stimulsoft.System.Promise;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiGaugeVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiGaugeVisualSvgHelper;
    class StiGaugeVisualSvgHelper implements IStiGaugeVisualSvgHelper {
        private static ImplementsStiGaugeVisualSvgHelper;
        implements(): string[];
        writeGaugeAsync(writer: XmlTextWriter, svgData: StiSvgData, needAnimation: boolean): Promise<void>;
        private paintTitle;
        private getTitleMinFontSize;
        private getTitleHeight;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Indicator {
    class StiIndicatorIteration {
        series: string;
        value: number;
        target: number;
        constructor(series?: string, value?: number, target?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiIndicatorIteration = Stimulsoft.Dashboard.Visuals.Indicator.StiIndicatorIteration;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiIndicatorElement = Stimulsoft.Dashboard.Components.Indicator.StiIndicatorElement;
    class StiIndicatorElementBuilder extends StiElementBuilder {
        render(element: StiIndicatorElement, dataTable: StiDataTable): List<StiIndicatorIteration>;
        static processTopNElements(element: StiIndicatorElement, iterations: List<StiIndicatorIteration>): List<StiIndicatorIteration>;
        private getValueMeterIndex;
        private getTargetMeterIndex;
        private getSeriesMeterIndex;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiVisual {
        draw(context: StiContext, rect: Rectangle): void;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Point = Stimulsoft.System.Drawing.Point;
    import StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiStringFormatGeom = Stimulsoft.Base.Context.StiStringFormatGeom;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiStringFormatHelper {
        static getStringFormatGeom(context: StiContext): StiStringFormatGeom;
        static measureAlignmentParameters(alignment: StiHorAlignment, elementRectText: Rectangle, rotationMode: {
            ref: StiRotationMode;
        }, point: {
            ref: Point;
        }): void;
        static getFontSize(context: StiContext, rect: Rectangle, text: string, font: Font): number;
        static getFontSize2(context: StiContext, font: Font, rect: Rectangle, text: string): number;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Indicator {
    import Size = Stimulsoft.System.Drawing.Size;
    import List = Stimulsoft.System.Collections.List;
    import StiIndicatorElement = Stimulsoft.Dashboard.Components.Indicator.StiIndicatorElement;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiIndicatorVisual extends StiVisual {
        private minSide;
        iterations: List<StiIndicatorIteration>;
        element: StiIndicatorElement;
        iconAlignment: StiIconAlignment;
        showDelta: boolean;
        draw(context: StiContext, rect: Rectangle): void;
        getContentRectangle(rect: Rectangle): Rectangle;
        private drawSingleMode;
        private drawMultiMode;
        private drawMultiModePresent;
        private drawMultiModeWithTarget;
        private getMaxValue;
        getTargetValues(): List<number>;
        private drawTextIcon;
        private getFontGeom;
        measureFontSize(context: StiContext, rect: Rectangle, text: string, font: {
            ref: number;
        }): void;
        protected getElementSide(isVerticalOrientation: boolean, size: Size): number;
        constructor(element: StiIndicatorElement, iterations: List<StiIndicatorIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Promise = Stimulsoft.System.Promise;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import IStiIndicatorVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiIndicatorVisualSvgHelper;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    class StiIndicatorVisualSvgHelper implements IStiIndicatorVisualSvgHelper {
        private static ImplementsStiIndicatorVisualSvgHelper;
        implements(): string[];
        writeIndicatorAsync(writer: XmlTextWriter, svgData: StiSvgData): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Promise = Stimulsoft.System.Promise;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiOnlineMapElement = Stimulsoft.Dashboard.Components.OnlineMap.StiOnlineMapElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    class StiOnlineMapHelper {
        private static ICON;
        private static EMPTY_ICON;
        private static MAX_LOCATIONS;
        private static MIN_RADIUS;
        private static MAX_RADIUS;
        private static DELTA_RADIUS;
        private static htmlNameToColor;
        private static lockHtmlNameToColor;
        static getBingMapScriptAsync(element: IStiElement, showTitle: boolean): Promise<string>;
        static calculateMapData(dataTable: StiDataTable, onlineMapElement: StiOnlineMapElement): Hashtable;
        static getColors(count: number): List<Color>;
        static getLongitudeMeterIndex(dataTable: StiDataTable): number;
        static getLatitudeMeterIndex(dataTable: StiDataTable): number;
        static getLocationMeterIndex(dataTable: StiDataTable): number;
        static getLocationColorMeterIndex(dataTable: StiDataTable): number;
        static getLocationValueMeterIndex(dataTable: StiDataTable): number;
        static parseColor(colorAttribute: string): Color;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Promise = Stimulsoft.System.Promise;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiPivotTableElement = Stimulsoft.Dashboard.Components.PivotTable.StiPivotTableElement;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableHelper {
        static summaryTypes: Hashtable;
        static getViewerDataAsync(pivotElement: IStiPivotTableElement): Promise<any>;
        private static cellItem;
        static applyStyle(pivot: StiPivotTableElement, crossTab: StiCrossTab, exportDataOnly: boolean): void;
        static buildCross(masterCrossTab: StiCrossTab, dataTable: StiDataTable, pivot: StiPivotTableElement): void;
        static convertToCrossTab(pivot: StiPivotTableElement, dataTable: StiDataTable): StiCrossTab;
        static updateCrossTab(crossTab: StiCrossTab, pivot: StiPivotTableElement, dataTable: StiDataTable, build?: boolean): void;
        private static setupTitle;
        private static setupField;
        private static createRowTotal;
        private static createColTotal;
        private static getLabel;
        private static getSummaryTypes;
        private static setTopN;
        private static setSummaryType;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    class StiProgressIteration {
        series: string;
        value: number;
        target: number;
        constructor(series?: string, value?: number, target?: number);
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import StiProgressIteration = Stimulsoft.Dashboard.Visuals.Progress.StiProgressIteration;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiProgressElementBuilder extends StiElementBuilder {
        render(element: StiProgressElement, dataTable: StiDataTable): List<StiProgressIteration>;
        static processTopNElements(element: StiProgressElement, iterations: List<StiProgressIteration>): List<StiProgressIteration>;
        private getValueMeterIndex;
        private getTargetMeterIndex;
        private getSeriesMeterIndex;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress.Helpers {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    class StiProgressVisualCreator {
        static createProgressVisual(element: StiProgressElement, iterations: List<StiProgressIteration>): StiProgressVisual;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Promise = Stimulsoft.System.Promise;
    import XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiProgressVisualSvgHelper = Stimulsoft.Report.Dashboard.Visuals.IStiProgressVisualSvgHelper;
    class StiProgressVisualSvgHelper implements IStiProgressVisualSvgHelper {
        private static ImplementsStiProgressVisualSvgHelper;
        implements(): string[];
        writeProgressAsync(writer: XmlTextWriter, svgData: StiSvgData): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    class StiTableAlignmentHelper {
        static getHorAlign(dataColumn: StiDataColumn): StiHorAlignment;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    class StiTableElementHelper {
        static minDataColumnValue(column: StiTableColumn, dataTable: StiDataTable, columnIndex: number): number;
        static maxDataColumnValue(column: StiTableColumn, dataTable: StiDataTable, columnIndex: number): number;
    }
}
declare namespace Stimulsoft.Dashboard.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiTitle = Stimulsoft.Report.Dashboard.IStiTitle;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import Size = Stimulsoft.System.Drawing.Size;
    class StiTitleMeasureHelper {
        static measureTitle(title: IStiTitle): Size;
        static measureTitle2(title: IStiTitle, titleText: string): Size;
        static measureTitle3(g: Graphics, rect: Rectangle, title: IStiTitle, titleText: string): Size;
        static measureTitle4(g: Graphics, rect: Rectangle, font: Font, titleText: string): Size;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardDashboardsHelper {
        static loadReport(report: StiReport, wizardName: String): void;
        private static financial;
        private static orders;
        private static salesOverview;
        private static ticketsStatistics;
        private static trafficAnalytics;
        private static vehicleProduction;
        private static websiteAnalytics;
    }
}
declare namespace Stimulsoft.Dashboard.Images {
    class StiDashboardImages {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    /**
     *  Converts StiDashboardDrillDownParameter from one data type to another.
     */
    class StiDashboardDrillDownParameterConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionCreator {
        static new2(identName: string): StiDashboardInteraction;
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiDashboardInteractionJsonConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions.Design {
    class StiTableDashboardInteractionConverter extends StiDashboardInteractionConverter {
    }
}
declare namespace Stimulsoft.Dashboard.Interactions {
    import IStiDashboardDrillDownParameter = Stimulsoft.Report.Dashboard.IStiDashboardDrillDownParameter;
    import XmlNode = Stimulsoft.System.Xml.XmlNode;
    import StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
    import StiJson = Stimulsoft.Base.StiJson;
    import IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
    import ICloneable = Stimulsoft.System.ICloneable;
    import IStiDefault = Stimulsoft.Base.Design.IStiDefault;
    class StiDashboardDrillDownParameter implements IStiDefault, ICloneable, IStiJsonReportObject, IStiDashboardDrillDownParameter {
        clone(): any;
        saveToJsonObject(mode: StiJsonSaveMode): StiJson;
        loadFromJsonObject(jObject: StiJson): void;
        loadFromXml(xmlNode: XmlNode, isDocument: boolean): void;
        static loadFromJson(json: StiJson): StiDashboardDrillDownParameter;
        static loadFromXml(xmlNode: XmlNode): StiDashboardDrillDownParameter;
        /**
         *  Saves element to string.
         *  @returns String representation which contains schema.
         */
        saveToString(): string;
        getStringRepresentation(): string;
        readonly isDefault: boolean;
        name: string;
        /**
         * Gets or sets expression to fill drill-down parameter.
         */
        expression: string;
        constructor();
    }
}
declare namespace Stimulsoft.Dashboard.Options {
    import Type = Stimulsoft.System.Type;
    /**
     *  Class for adjustment all aspects of Stimulsoft Dashboards.
     */
    class StiDashboardOptions {
    }
    class Services {
        private static _elements;
        static readonly elements: Type[];
    }
}
declare namespace Stimulsoft.Dashboard.Options {
    import Type = Stimulsoft.System.Type;
    class StiDashboardElementsLoader {
        static fetchAll(): Type[];
        static load(): void;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import Point = Stimulsoft.System.Drawing.Point;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import StiSeries = Stimulsoft.Report.Chart.StiSeries;
    import List = Stimulsoft.System.Collections.List;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiChartElementBuilder extends StiElementBuilder {
        render(element: StiChartElement, dataTable: StiDataTable): StiChart;
        protected renderElements(element: StiChartElement, chart: StiChart, dataTable: StiDataTable): void;
        static processTopNElements(element: StiChartElement, series: StiSeries): void;
        private static setStyle;
        private static getDetailRows;
        protected renderSeries(element: StiChartElement, value: StiMeter, seriesKey: string, chart: StiChart): StiSeries;
        private renderSeriesNegativeColor;
        protected renderArea(element: StiChartElement, chart: StiChart): void;
        private static getColorEach;
        private renderAxisAxes;
        private static renderInterlacingHor;
        private static renderInterlacingVert;
        private static renderGridLinesHor;
        private static renderGridLinesVert;
        private renderXAxis;
        private renderYAxis;
        private static renderYRightAxis;
        private static renderXAxisTitleText;
        private static renderYAxisTitleText;
        private static renderAxisLineColor;
        private static renderAxis;
        private static renderAxisLabelsTitleColor;
        private static renderAxisLabelsColor;
        private static getTitleAxisChart;
        private renderLegend;
        private static renderLegendLabelsColor;
        private renderSeriesLabels;
        private static renderPieLabelsAutoRotate;
        private static renderPieLabelsColor;
        private static renderLabelsTextFormat;
        private static renderFunnelLabelsPosition;
        private static renderTreemapLabelsPosition;
        private static renderPieLabelsPosition;
        private static renderDoughnutLabelsPosition;
        private static renderPieLabelsStyle;
        protected renderSeriesInteraction(series: StiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        private getToolTip;
        private getHyperlink;
        getTitle(meter: StiMeter): string;
        protected getSeriesTitle(element: StiChartElement, seriesKey: string, meter: StiMeter): string;
        protected getArgumentIndex(dataTable: StiDataTable, index: number): number;
        private simplifyValues;
        getShorterListPoints(series: StiSeries): List<Point>;
        protected getString(format: StiFormatService, value: any): string;
        private getFormatValue;
        static create(chart: StiChartElement): StiChartElementBuilder;
        protected getValueMeterIndexes(table: StiDataTable): number[];
        protected getArgumentMeterIndexes(table: StiDataTable): number[];
        protected getSeriesMeterIndex(table: StiDataTable): number;
        protected getArgumentKeys(element: IStiElement, table: StiDataTable): List<any>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getArgumentMeters(table: StiDataTable): List<StiMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import List = Stimulsoft.System.Collections.List;
    import StiWeightChartMeter = Stimulsoft.Dashboard.Components.Chart.StiWeightChartMeter;
    import StiSeries = Stimulsoft.Report.Chart.StiSeries;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiBubbleChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: StiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: StiChart): StiSeries;
        protected renderSeriesInteraction(series: StiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        protected getWeightIndex(table: StiDataTable, index: number): number;
        protected getWeightMeterIndexes(table: StiDataTable): number[];
        protected getWeightMeters(table: StiDataTable): List<StiWeightChartMeter>;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getArgumentMeters(table: StiDataTable): List<StiMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import StiSeries = Stimulsoft.Report.Chart.StiSeries;
    import StiCloseValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiCloseValueChartMeter;
    import StiLowValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiLowValueChartMeter;
    import StiHighValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiHighValueChartMeter;
    import List = Stimulsoft.System.Collections.List;
    class StiFinancialChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: StiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: StiChart): StiSeries;
        protected renderSeriesInteraction(series: StiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        protected renderArea(element: StiChartElement, chart: StiChart): void;
        protected getValueMeters(table: StiDataTable): List<StiMeter>;
        protected getCloseValueIndex(table: StiDataTable, index: number): number;
        protected getCloseMeterIndexes(table: StiDataTable): number[];
        protected getCloseMeters(table: StiDataTable): List<StiCloseValueChartMeter>;
        protected getLowValueIndex(table: StiDataTable, index: number): number;
        protected getLowMeterIndexes(table: StiDataTable): number[];
        protected getLowMeters(table: StiDataTable): List<StiLowValueChartMeter>;
        protected getHighValueIndex(table: StiDataTable, index: number): number;
        protected getHighMeterIndexes(table: StiDataTable): number[];
        protected getHighMeters(table: StiDataTable): List<StiHighValueChartMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiMeter = Stimulsoft.Dashboard.Components.StiMeter;
    import StiSeries = Stimulsoft.Report.Chart.StiSeries;
    import StiEndValueChartMeter = Stimulsoft.Dashboard.Components.Chart.StiEndValueChartMeter;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import StiChartElement = Stimulsoft.Dashboard.Components.Chart.StiChartElement;
    class StiRangeChartElementBuilder extends StiChartElementBuilder {
        protected renderElements(element: StiChartElement, chart: StiChart, dataTable: StiDataTable): void;
        protected renderSeries(element: StiChartElement, value: StiMeter, groupKey: string, chart: StiChart): StiSeries;
        protected renderSeriesInteraction(series: StiSeries, element: StiChartElement, count: number, seriesKey: string): void;
        protected getEndValueIndex(table: StiDataTable, index: number): number;
        protected getEndValueMeterIndexes(table: StiDataTable): number[];
        protected getEndValueMeters(table: StiDataTable): List<StiEndValueChartMeter>;
    }
}
declare namespace Stimulsoft.Dashboard.Render {
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiShapeElement = Stimulsoft.Dashboard.Components.Shape.StiShapeElement;
    class StiShapeElementBuilder {
        render(element: StiShapeElement): StiShape;
    }
}
declare namespace Stimulsoft.Dashboard.Visualizers {
    import Type = Stimulsoft.System.Type;
    class StiVisualizer {
        private static typeToGdiVisualizer;
        private static typeToWpfVisualizer;
        private static lockObject;
        static getVisualizer(type: Type): StiVisualizer;
    }
}
declare namespace Stimulsoft.Dashboard.Visualizers {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiGdiVisualizer extends StiVisualizer {
        render(element: IStiElement): any;
    }
}
declare namespace Stimulsoft.Dashboard.Visualizers {
    class StiGdiVisualizerAttribute {
        visualizerTypeName: string;
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElementStyle = Stimulsoft.Report.Dashboard.Styles.StiProgressElementStyle;
    class StiProgressVisual extends StiVisual {
        protected style: StiProgressElementStyle;
        protected minElementSide: number;
        protected minFontSize: number;
        iterations: List<StiProgressIteration>;
        element: StiProgressElement;
        private getMaxValue;
        getTargetValues(): List<number>;
        getTextValues(): List<string>;
        getColor(index: number): Color;
        getColors(seriesCount: number): Color[];
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiPieProgressVisual extends StiProgressVisual {
        draw(context: StiContext, rectMain: Rectangle): void;
        private drawPieProgress;
        drawArrowMore(context: StiContext, rect: Rectangle): void;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Point = Stimulsoft.System.Drawing.Point;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiCircleProgressVisual extends StiPieProgressVisual {
        draw(context: StiContext, rectMain: Rectangle): void;
        protected getPoint(centerPie: Point, radius: number, angle: number): Point;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard.Visuals.Progress {
    import List = Stimulsoft.System.Collections.List;
    import StiProgressElement = Stimulsoft.Dashboard.Components.Progress.StiProgressElement;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiContext = Stimulsoft.Base.Context.StiContext;
    class StiDataBarsProgressVisual extends StiProgressVisual {
        draw(context: StiContext, rect: Rectangle): void;
        constructor(element: StiProgressElement, iterations: List<StiProgressIteration>);
    }
}
declare namespace Stimulsoft.Dashboard {
    enum StiIconAlignment {
        None = 0,
        Left = 1,
        Right = 2,
        Top = 3,
        Bottom = 4
    }
    enum StiTextFormatState {
        None = 0,
        DecimalDigits = 1,
        DecimalSeparator = 2,
        GroupSeparator = 4,
        GroupSize = 8,
        PositivePattern = 16,
        NegativePattern = 32,
        CurrencySymbol = 64,
        PercentageSymbol = 128
    }
    enum StiFilterCondition {
        EqualTo = 0,
        NotEqualTo = 1,
        GreaterThan = 2,
        GreaterThanOrEqualTo = 3,
        LessThan = 4,
        LessThanOrEqualTo = 5,
        Between = 6,
        NotBetween = 7,
        Containing = 8,
        NotContaining = 9,
        BeginningWith = 10,
        EndingWith = 11,
        IsNull = 12,
        IsNotNull = 13
    }
    enum StiFilterItem {
        Argument = 0,
        Value = 1,
        ValueEnd = 2,
        Expression = 3,
        ValueOpen = 4,
        ValueClose = 5,
        ValueLow = 6,
        ValueHigh = 7
    }
    enum StiFilterDataType {
        String = 0,
        Numeric = 1,
        DateTime = 2,
        Boolean = 3,
        Expression = 4
    }
}

declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiBackColorExportHelper {
        static render(element: IStiElement, component: StiComponent): void;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiBorderExportHelper {
        static render(element: IStiElement, component: StiComponent, settings: StiDashboardExportSettings): void;
    }
}
declare namespace Stimulsoft.Dashboard.Drawing.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    class StiElementControlPainter {
        static getBorderContentRect(rect: Rectangle, border: StiBorder): Rectangle;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiExportFormatHelper {
        static convert(format: StiDashboardExportFormat): StiExportFormat;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiPageOrientation = Stimulsoft.Report.Components.StiPageOrientation;
    import PaperKind = Stimulsoft.System.Drawing.Printing.PaperKind;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    class StiDashboardExportSettings implements IStiDashboardExportSettings {
        private static ImplementsStiDashboardExportSettings;
        implements(): string[];
        format: StiDashboardExportFormat;
        /**
         *  Enables or disables rendering of the defined element borders.
         */
        renderBorders: boolean;
        /**
         *  Export a single dashboard element to the entire page.
         */
        renderSingleElement: boolean;
        /**
         *  Export only the first page if elements require multiple pages to be rendered.
         */
        renderSinglePage: boolean;
        /**
         *  Gets or sets page orientation.
         */
        orientation: StiPageOrientation;
        /**
         * Gets or sets the page size.
         */
        paperSize: PaperKind;
        openAfterExport: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    import IStiImageDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiImageDashboardExportSettings;
    class StiImageDashboardExportSettings extends StiDashboardExportSettings implements IStiSizeExportSettings, IStiImageDashboardExportSettings {
        private static ImplementsStiImageDashboardExportSettings;
        implements(): string[];
        format: StiDashboardExportFormat;
        imageType: StiImageType;
        private _width;
        width: number;
        private _height;
        height: number;
        /**
         *  Gets or sets image scale for exported images.
         */
        scale: number;
        constructor(imageType?: StiImageType);
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiImageType = Stimulsoft.Report.Export.StiImageType;
    class StiSvgDashboardExportSettings extends StiImageDashboardExportSettings {
        imageType: StiImageType;
        /**
         *  If false and the element has no data, render empty data 'Drag & Drop' message instead of element content
         */
        renderEmptyContent: boolean;
        /**
         *  Export the element for use on the web designer page.
         */
        designMode: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import IStiExcelDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiExcelDashboardExportSettings;
    class StiExcelDashboardExportSettings extends StiDashboardExportSettings implements IStiSizeExportSettings, IStiExcelDashboardExportSettings {
        private static ImplementsStiExcelDashboardExportSettings;
        implements(): string[];
        format: StiDashboardExportFormat;
        private _width;
        width: number;
        private _height;
        height: number;
        /**
         *  Gets or sets image quality of images which will be exported to Excel file.
         */
        imageQuality: number;
        exportDataOnly: boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import IStiPdfDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiPdfDashboardExportSettings;
    class StiPdfDashboardExportSettings extends StiDashboardExportSettings implements IStiPdfDashboardExportSettings {
        private static ImplementsStiPdfDashboardExportSettings;
        implements(): string[];
        format: StiDashboardExportFormat;
        autoPrint: boolean;
        /**
         *  Gets or sets image quality of images which will be exported to result PDF file.
         */
        imageQuality: number;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    import StiDataType = Stimulsoft.Report.Export.StiDataType;
    import IStiDataDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDataDashboardExportSettings;
    class StiDataDashboardExportSettings extends StiDashboardExportSettings implements IStiDataDashboardExportSettings {
        private static ImplementsStiDataDashboardExportSettings;
        implements(): string[];
        format: StiDashboardExportFormat;
        dataType: StiDataType;
        constructor(dataType?: StiDataType);
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    class StiHtmlDashboardExportSettings extends StiDashboardExportSettings {
        format: StiDashboardExportFormat;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import StiExportSettings = Stimulsoft.Report.Export.StiExportSettings;
    class StiExportSettingsHelper {
        static getExportSettings(settings: StiDashboardExportSettings): StiExportSettings;
        static getDashboardExportSettings(settings: StiExportSettings): StiDashboardExportSettings;
        static getDashboardExportSettings2(format: StiExportFormat): StiDashboardExportSettings;
        static isDataExport(settings: StiDashboardExportSettings): boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiLayoutExportHelper {
        static excludeMargin(element: IStiElement, rect: Rectangle): Rectangle;
        static excludePadding(element: IStiElement, rect: Rectangle): Rectangle;
    }
}
declare namespace Stimulsoft.Dashboard.Drawing.Helpers {
    class StiLocHelper {
        static locAll: string;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Helpers {
    import StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    class StiTitleExportHelper {
        static render(element: IStiElement, component: StiPanel): Rectangle;
        static convert(alignment: StiHorAlignment): StiTextHorAlignment;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    class StiColorScaleCellPainter {
        static getScaleColor(value: number, min: number, max: number, style: StiTableElementStyle): Color;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiColumnSparklinesCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, array: any[], style: StiTableElementStyle): void;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiDataBarsDirection = Stimulsoft.Dashboard.Components.Table.StiDataBarsDirection;
    import StiDataBarsBrushType = Stimulsoft.Dashboard.Components.Table.StiDataBarsBrushType;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiDataBarsCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiTableColumn, zoom: number, value: number, min: number, max: number, isInterlaced: boolean, isSelected: boolean, drawText?: boolean, direction?: StiDataBarsDirection, brushType?: StiDataBarsBrushType): void;
        static draw2(writer: StiSvgGeomWriter, rect: RectangleD, value: number, min: number, max: number, zoom: number, text: string, table: StiTableElement, column: StiTableColumn, isInterlaced: boolean, isSelected: boolean, drawText?: boolean, direction?: StiDataBarsDirection, brushType?: StiDataBarsBrushType): void;
        static getForeColor(table: StiTableElement, column: StiTableColumn, style: StiTableElementStyle, isInterlaced: boolean, isSelected: boolean): Color;
        static calculateDataBarsRect(rect: RectangleD, textObj: object): RectangleD;
        static calculateTextRect(rect: RectangleD, textObj: object): RectangleD;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiIndicatorColumn = Stimulsoft.Dashboard.Components.Table.StiIndicatorColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
    import Font = Stimulsoft.System.Drawing.Font;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiIndicatorCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiIndicatorColumn, zoom: number, value: number, style: StiTableElementStyle, drawText?: boolean): void;
        static draw2(writer: StiSvgGeomWriter, rect: RectangleD, table: StiTableElement, column: StiIndicatorColumn, zoom: number, value: number, style: StiTableElementStyle, str: string, drawText?: boolean): void;
        private static drawIndicator;
        private static drawText;
        static measureText(zoom: number, text: string, baseFont: Font): number;
        private static calculateIndicatorRect;
        static getCellText(table: StiTableElement, column: StiIndicatorColumn, value: number): string;
        static calculateTextRect(rect: Rectangle, textObj: any): Rectangle;
        static getColor(column: StiTableColumn, value: number, style: StiTableElementStyle): Color;
        private static toAlignment2;
        static toAlignment(value: StiHorAlignment): StringAlignment;
        private static getHorAlignment;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiLineSparklinesCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, array: any[], style: StiTableElementStyle, showArea: boolean, showFirstLastMarker?: boolean, showHighLowMarker?: boolean): void;
        private static drawArea;
        private static drawLines;
        private static drawFirstLastMarkers;
        private static drawHighLowMarkers;
        private static drawMarker;
        private static simplifyPoints;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    import StiSparklinesColumn = Stimulsoft.Dashboard.Components.Table.StiSparklinesColumn;
    class StiSparklinesCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, column: StiSparklinesColumn, value: any, style: StiTableElementStyle): void;
        private static castToArray;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Painters.Table {
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    import StiSvgGeomWriter = Stimulsoft.Report.Export.StiSvgGeomWriter;
    class StiWinLossSparklinesCellPainter {
        static draw(writer: StiSvgGeomWriter, rect: RectangleD, array: any[], style: StiTableElementStyle): void;
    }
}
declare namespace Stimulsoft.Dashboard.Drawing.Painters {
    import List = Stimulsoft.System.Collections.List;
    import Font = Stimulsoft.System.Drawing.Font;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiTableElementStyle = Stimulsoft.Report.Dashboard.Styles.StiTableElementStyle;
    class StiTableElementGdiPainter {
        static getBackgroundColor(style: StiTableElementStyle, isInterlaced: boolean): Color;
        private static measureColumn;
        private static getArrowSize;
        private static getRightImageRect;
        static measureSparklinesCell(table: StiTableElement, columnWidth: number, zoom: number): number;
        static measureIndicatorCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): number;
        static measureDataBarsCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, zoom: number): number;
        static measureCommonCell(g: Graphics, table: StiTableElement, column: StiTableColumn, rowValue: any, columnWidth: number, zoom: number): number;
        static measureHeader(table: StiTableElement, column: StiTableColumn): number;
        private static measureHeader2;
        static measureCell(caption: string, baseFont: Font): number;
        private static measureCell2;
        static measureHeaders(columns: List<StiTableColumn>, baseFont: Font): number;
        private static captionSizeCache;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Settings {
    var IStiSizeExportSettings: string;
    interface IStiSizeExportSettings {
        width: number;
        height: number;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import Type = Stimulsoft.System.Type;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiExportTool {
        private static typeToTool;
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        static getTool(type: Type): StiExportTool;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import Image = Stimulsoft.System.Drawing.Image;
    import Graphics = Stimulsoft.System.Drawing.Graphics;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiElementExportTool extends StiExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        protected renderContentAsync(element: IStiElement, destination: StiPanel, rect: Rectangle): Promise<void>;
        private drawElementAsync;
        protected drawAsync(element: IStiElement, rect: Rectangle): Promise<Image>;
        protected paintContentAsync(g: Graphics, rect: Rectangle, element: IStiElement): Promise<void>;
        paintAtomAsync(g: Graphics, rect: Rectangle, element: IStiElement): Promise<void>;
        protected renderEmptyDataMessage(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): boolean;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import List = Stimulsoft.System.Collections.List;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiChartElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings, chartStartValues?: List<number[]>): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiComboBoxElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        getValuesCount(dataTable: StiDataTable): number;
        private renderElement;
        private renderItem;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDatePickerElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiGaugeElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import List = Stimulsoft.System.Collections.List;
    import StiCheckStyle = Stimulsoft.Report.Components.StiCheckStyle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiListBoxElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        protected renderItemsAsync(destination: StiPanel, rect: Rectangle, element: IStiElement): Promise<void>;
        protected renderItems2(destination: StiPanel, rect: Rectangle, element: IStiElement, values: List<string>, checks: List<StiCheckStyle>): void;
        protected renderItem(destination: StiPanel, rect: Rectangle, element: IStiElement, value: string, checkStyle: StiCheckStyle, underline: boolean, drawCheckBox: boolean): void;
        private static renderCheckBox;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiPanelElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiPivotTableElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private static renderForWebDesigner;
        private static renderCells;
        private static convertSizes;
        private static convert;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiRegionMapElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    class StiShapeElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiTableColumn = Stimulsoft.Dashboard.Components.Table.StiTableColumn;
    import StiTableElement = Stimulsoft.Dashboard.Components.Table.StiTableElement;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    class StiTableElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        static renderCellsForViewerAsync(element: IStiTableElement): Promise<any[]>;
        private static renderCellsAsync;
        private static measureSparklinesCell;
        private static measureHeader;
        private static measureIndicatorCell;
        private static measureDataBarsCell;
        private static measureCommonCell;
        private static renderHeader;
        static renderCell(destination: StiPanel, rect: Rectangle, table: StiTableElement, column: StiTableColumn, zoom: number, value: any, min: number, max: number, isInterlaced: boolean, format: StiDashboardExportFormat, exportDataOnly: boolean): void;
        private static renderGraphicCell;
        private static drawColorScaleColumn;
        private static renderBoolCell2;
        private static renderTextCell;
        private static renderImageCell;
        private static renderBoolCell;
        private static getForeColor;
        private static getHeaderForeColor;
        private static getBorderSides;
        private static fitByWidth;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import Promise = Stimulsoft.System.Promise;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTextElementExportTool extends StiElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private changeFontSize;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTreeViewBoxElementExportTool extends StiComboBoxElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
    }
}
declare namespace Stimulsoft.Dashboard.Export.Tools {
    import Promise = Stimulsoft.System.Promise;
    import StiCheckStyle = Stimulsoft.Report.Components.StiCheckStyle;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import StiPanel = Stimulsoft.Report.Components.StiPanel;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiTreeViewElementExportTool extends StiListBoxElementExportTool {
        renderAsync(element: IStiElement, destination: StiPanel, rect: Rectangle, settings: StiDashboardExportSettings): Promise<void>;
        private getCheckStyle;
        protected renderItemsAsync(destination: StiPanel, rect: Rectangle, element: IStiElement): Promise<void>;
        protected renderItem(destination: StiPanel, rect: Rectangle, element: IStiElement, value: string, checkStyle: StiCheckStyle, underline: boolean, drawCheckBox: boolean): void;
        private static renderExpander;
    }
}
declare namespace Stimulsoft.Dashboard.Export {
    enum StiDashboardExportFormat {
        Pdf = 0,
        Excel = 1,
        Data = 2,
        Image = 3,
        Html = 4,
        Document = 5
    }
}
declare namespace Stimulsoft.Dashboard.Export {
    import Promise = Stimulsoft.System.Promise;
    import Rectangle = Stimulsoft.System.Drawing.Rectangle;
    import List = Stimulsoft.System.Collections.List;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDashboardExportSettings = Stimulsoft.Dashboard.Export.Settings.StiDashboardExportSettings;
    class StiDashboardExportTools {
        private static exportToStreamAsync;
        private static renderDashboardAsync;
        private static renderSingleElementAsync;
        static renderElementsAsync(parent: StiContainer, elements: List<IStiElement>, scaleX: number, scaleY: number, settings: StiDashboardExportSettings): Promise<void>;
        static renderElementAsync(parent: StiContainer, element: IStiElement, scaleX: number, scaleY: number, settings: StiDashboardExportSettings, chartStartValues?: List<number[]>, refTitleRect?: {
            ref: Rectangle;
        }): Promise<StiComponent>;
    }
}

declare namespace Stimulsoft.Viewer {
    class StiRequestParams {
        interaction: StiInteractionParams;
    }
    class StiInteractionParams {
        /**
         *  The the values of the request from user report variables after Submit.
         */
        variables: {};
        /**
         *  The the values of the sorting parameters after Sorting action.
         */
        sorting: {};
        /**
         *  The the values of the collapsing parameters after Collapsing action.
         */
        collapsing: {};
        /**
         *  The the values of the parameters for all levels for drill-down report after DrillDown action.
         */
        drillDown: any[];
        /**
         *  The the values of the edited report fields.
         */
        editable: {};
        /**
         *  The the values of the filtering parameters after DashboardFiltering action.
         */
        dashboardFiltering: {};
        /**
         *  The the values of the sorting  parameters after DashboardSorting action.
         */
        dashboardSorting: {};
        /**
         *  The the values of the drilldown  parameters after DashboardDrillDown action.
         */
        dashboardDrillDownParameters: {};
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import List = Stimulsoft.System.Collections.List;
    import StiChart = Stimulsoft.Report.Components.StiChart;
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    class StiChartElementViewHelper {
        static getColumnPath(chartElement: IStiChartElement): string;
        static getBubleXColumnPath(chartElement: IStiChartElement): string;
        static getBubleYColumnPath(chartElement: IStiChartElement): string;
        static getSeriesValues(chart: StiChart): List<number[]>;
        static getChartValuesFromCache(cacheGuid: string, requestParams: any): any;
        static saveChartValuesToCache(cacheGuid: string, page: StiPage, requestParams: any): void;
        static isBubble(chartElement: IStiChartElement): boolean;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiComboBoxElementViewHelper {
        static getElementItemsAsync(comboBoxElement: IStiComboBoxElement): Promise<List<any>>;
        static comboBoxItem(label: string, value: any): any;
        private static format;
        static getSettings(comboBoxElement: IStiComboBoxElement): any;
        protected static getNameMeterIndex(table: StiDataTable): number;
        protected static getKeyMeterIndex(table: StiDataTable): number;
        static getColumnPath(comboBoxElement: IStiComboBoxElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardElementDrillDownHelper {
        static applyDashboardElementDrillDown(report: StiReport, parameters: any): void;
        static applyDrillDownToElement(element: IStiElement, filters: any[]): void;
        static applyDashboardElementDrillUp(report: StiReport, parameters: any): void;
        static applyDrillUpToElement(element: IStiElement): void;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    class StiDashboardsSvgHelper {
        private static getSvgImageValue;
        private static saveElementToVectorStringAsync;
        static saveElementToStringAsync(element: IStiElement, scaleX?: number, scaleY?: number, designMode?: boolean, exportFormat?: StiExportFormat, requestParams?: any): Promise<string>;
        static saveElementToBase64Async(element: IStiElement, scaleX?: number, scaleY?: number, designMode?: boolean, exportFormat?: StiExportFormat, requestParams?: any): Promise<string>;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    class StiDashboardElementViewHelper {
        static getElementContentAttributesAsync(element: IStiElement, scaleX: number, scaleY: number, requestParams: any): Promise<any>;
        static getForeColor(element: IStiElement): string;
        static getBackColor(element: IStiElement): string;
        static getBorder(element: IStiElement): any;
        static getBorderJson(border: StiSimpleBorder): any;
        static getFont(element: IStiElement): any;
        static getFontJson(font: Font): any;
        static getTitle(element: IStiElement): any;
        static getControlElementSettings(element: IStiElement): any;
        static getLayout(element: IStiElement): any;
        private static fixColor;
        static getActionColors(element: IStiElement): any;
        static getBingMapScriptAsync(element: IStiElement, showTitle: boolean): Promise<string>;
        static getDashboardInteraction(object_: any): any;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiDrillDownElement = Stimulsoft.Data.Engine.IStiDrillDownElement;
    import Promise = Stimulsoft.System.Promise;
    import StiReport = Stimulsoft.Report.StiReport;
    import List = Stimulsoft.System.Collections.List;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import Type = Stimulsoft.System.Type;
    import IStiQueryObject = Stimulsoft.Data.Engine.IStiQueryObject;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiDataFiltersHelper {
        static applyFiltering(report: StiReport, parameters: any): void;
        static applyFiltersToElement(element: IStiElement, filters: any[]): void;
        static getElementFilters(element: IStiElement): any[];
        static getFilterItemsAsync(report: StiReport, requestParams: any): Promise<any>;
        static getDrillDownFilters(drillDownElement: IStiDrillDownElement): any[];
        static getDrillDownFiltersList(drillDownElement: IStiDrillDownElement): any[];
        static filterRuleItem(filterRule: StiDataFilterRule): any;
        private static sortFilterMenuItem;
        static getFilterItemsHelperAsync(query: IStiQueryObject, meters: List<IStiMeter>, columnIndex: number, sorts: List<StiDataSortRule>, filters: List<StiDataFilterRule>, element?: IStiElement): Promise<any>;
        static typeToString(type: Type): string;
        static toFilterString(value: any, type?: Type): string;
        static toDisplayString(value: any, type?: Type): string;
        private static distinct;
        private static isValueCanBeFiltered;
        private static getLevel;
        static applyDefaultFiltersForFilterElementsAsync(report: StiReport): Promise<any>;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDataSortsHelper {
        static applySorting(report: StiReport, parameters: any): void;
        static applySortsToElement(element: IStiElement, sorts: any[]): void;
        static getElementSorts(element: IStiElement): any[];
        static sortRuleItem(sortRule: StiDataSortRule): any;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElementViewHelper {
        static getAutoRangeValuesAsync(datePickerElement: IStiDatePickerElement): Promise<any>;
        static getColumnPath(datePickerElement: IStiDatePickerElement): string;
        static getSettings(datePickerElement: IStiDatePickerElement): any;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import StiDataTable = Stimulsoft.Data.Engine.StiDataTable;
    class StiListBoxElementViewHelper {
        static getElementItemsAsync(listBoxElement: IStiListBoxElement): Promise<List<any>>;
        static listBoxItem(label: string, value: any): any;
        private static format;
        static getSettings(listBoxElement: IStiListBoxElement): any;
        protected static getNameMeterIndex(table: StiDataTable): number;
        protected static getKeyMeterIndex(table: StiDataTable): number;
        static getColumnPath(listBoxElement: IStiListBoxElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableElementViewHelper {
        static getPivotTableDataAsync(pivotElement: IStiPivotTableElement): Promise<any>;
        static getPivotTableSettings(tableElement: IStiPivotTableElement): any;
        private static getCellAlignment;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    class StiRangeBand {
        top: number;
        bottom: number;
        readonly height: number;
        originalTop: number;
        originalBottom: number;
        readonly originalHeight: number;
        isFixed: boolean;
        toString(): string;
        intersect(rect: Rectangle): boolean;
        constructor(top: number, bottom: number);
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    class StiRegionMapElementViewHelper {
        static getColumnPath(regionMapElement: IStiRegionMapElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    class StiTableElementViewHelper {
        static getTableDataAsync(tableElement: IStiTableElement): Promise<any[]>;
        static getTableSettings(tableElement: IStiTableElement): any;
        private static getCellForeColor;
        private static getHeaderForeColor;
        private static getCellAlignment;
        private static getSortLabel;
        private static getFilterLabel;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeViewBoxElementViewHelper {
        static getElementItemsAsync(treeViewBoxElement: IStiTreeViewBoxElement): Promise<List<any>>;
        static treeViewBoxItem(treeViewBoxElement: IStiTreeViewBoxElement, key?: any, meter?: IStiMeter): any;
        private static format;
        static getSettings(treeViewBoxElement: IStiTreeViewBoxElement): any;
        static getColumnPath(treeViewBoxElement: IStiTreeViewBoxElement): string;
        static getMeterKey(treeViewBoxElement: IStiTreeViewBoxElement): string;
    }
}
declare namespace Stimulsoft.Viewer.Helpers.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    import List = Stimulsoft.System.Collections.List;
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    class StiTreeViewElementViewHelper {
        static getElementItemsAsync(treeViewElement: IStiTreeViewElement): Promise<List<any>>;
        static treeViewItem(treeViewElement: IStiTreeViewElement, key?: any, meter?: IStiMeter): any;
        private static format;
        static getSettings(treeViewElement: IStiTreeViewElement): any;
        static getColumnPath(treeViewElement: IStiTreeViewElement): string;
        static getMeterKey(treeViewElement: IStiTreeViewElement): string;
    }
}
declare module Stimulsoft.Viewer {
    class StiCollectionsHelper {
        static getLocalizationItems(): Object;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiEditableFieldsHelper {
        static checkEditableReport(report: StiReport): boolean;
        static applyEditableFieldsToReport(report: StiReport, parameters: Object): void;
    }
}
declare module Stimulsoft.Viewer {
    import Promise = Stimulsoft.System.Promise;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiExportFormat = Stimulsoft.Report.StiExportFormat;
    import IStiDashboardExportSettings = Stimulsoft.Report.Dashboard.Export.IStiDashboardExportSettings;
    class StiExportsHelper {
        static getReportFileName(report: StiReport): string;
        static applyExportSettings(exportFormat: StiExportFormat, settingsObject: any, settings: any): void;
        static getDashboardExportSettings(exportFormat: StiExportFormat, settingsObject: any): IStiDashboardExportSettings;
        private static getPdfDashboardExportSettings;
        private static getExcelDashboardExportSettings;
        private static getDataDashboardExportSettings;
        /**
         *  Exports dashboard page or element to the specified format
         */
        static exportDashboardAsync(requestParams: any, report: StiReport, exportSettings: IStiDashboardExportSettings): Promise<number[]>;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCopier {
        static cloneReport(report: StiReport): StiReport;
        static copyReportDictionary(reportFrom: StiReport, reportTo: StiReport): void;
    }
}
declare module Stimulsoft.Viewer {
    import Promise = Stimulsoft.System.Promise;
    import StiReport = Stimulsoft.Report.StiReport;
    import Color = Stimulsoft.System.Drawing.Color;
    class StiReportHelper {
        /**
         *  Get the color in HEX format.
         */
        static getHtmlColor(color: Color): string;
        private static round;
        private static round2;
        private static getNestedPages;
        static getDashboards(report: StiReport): any[];
        static isReportHasDashboards(report: StiReport): boolean;
        private static getElementsPositions;
        static getDashboardPageAsync(report: StiReport, pageIndex: number, requestParams: any): Promise<any>;
        private static calculateParentPanelPositions;
        static applySorting(report: StiReport, parameters: any): void;
        static applyCollapsing(report: StiReport, parameters: any): void;
        static applyDrillDown(report: StiReport, renderedReport: StiReport, parameters: any): StiReport;
        static applyDashboardDrillDown(report: StiReport, drillDownParameters: any): StiReport;
        private static addBookmarkNode;
        static getBookmarksContent(report: StiReport, viewerId: string, pageNumber: number): string;
        static getReportPreviewSettings(report: StiReport): any;
    }
    class StiBookmarkTreeNode {
        parent: number;
        title: string;
        url: string;
        used: boolean;
        componentGuid: string;
    }
}
declare module Stimulsoft.Viewer {
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportResourceHelper {
        static getResourcesItems(report: StiReport): any[];
        static isFontResourceType(resourceType: StiResourceType): boolean;
        static getFontResourcesArray(report: StiReport): any[];
        static getBase64DataFromFontResourceContent(resourceType: StiResourceType, content: number[]): string;
    }
}
declare module Stimulsoft.Viewer {
    import Promise = Stimulsoft.System.Promise;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiVariablesHelper {
        private en_us_culture;
        static fillDialogInfoItemsAsync(report: StiReport): Promise<void>;
        private static getVariableAlias;
        private static getItems;
        private static getDateTimeObject;
        private static getBasicType;
        private static getStiType;
        static applyReportParameters(report: StiReport, values: any): void;
        static applyReportBindingVariables(report: StiReport, values: any): void;
        private static setVariableValue;
        static getVariablesAsync(report: StiReport, values: any): Promise<any>;
    }
}
declare module Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    import StiHtmlExportMode = Stimulsoft.Report.Export.StiHtmlExportMode;
    class StiAppearanceOptions {
        /** Gets or sets the background color of the viewer. */
        backgroundColor: Color;
        /** Gets or sets a color of the report page border. */
        pageBorderColor: Color;
        /** Gets or sets a value which controls of output objects in the right to left mode. */
        rightToLeft: boolean;
        /** Gets or sets a value which indicates which indicates that the viewer is displayed in full screen mode. */
        fullScreenMode: boolean;
        /** Gets or sets a value which indicates that the viewer will show the report area with scrollbars. */
        scrollbarsMode: boolean;
        /** Gets or sets a browser window to open links from the report. */
        openLinksWindow: string;
        /** Gets or sets a browser window to open the exported report. */
        openExportedReportWindow: string;
        /** Gets or sets a value which indicates that show or hide tooltips. */
        showTooltips: boolean;
        /** Gets or sets a value which indicates that show or hide the help link in tooltips. */
        showTooltipsHelp: boolean;
        /** Gets or sets the alignment of the viewer page. */
        pageAlignment: StiContentAlignment;
        /** Gets or sets a value which indicates that the shadow of the page will be displayed in the viewer. */
        showPageShadow: boolean;
        /** Gets or sets a value which allows printing report bookmarks. */
        bookmarksPrint: boolean;
        /** Gets or sets a width of the bookmarks tree in the viewer. */
        bookmarksTreeWidth: number;
        parametersPanelPosition: StiParametersPanelPosition;
        /** Gets or sets a max height of parameters panel in the viewer. */
        parametersPanelMaxHeight: number;
        /** Gets or sets a count columns in parameters panel. */
        parametersPanelColumnsCount: number;
        /** Gets or sets a date format for datetime parameters in parameters panel. The default is the client browser date format. */
        parametersPanelDateFormat: string;
        /** Gets or sets the type of the viewer interface. */
        interfaceType: StiInterfaceType;
        /** Gets or sets the type of the chart in the viewer. */
        chartRenderType: StiChartRenderType;
        /** Gets or sets a method how the viewer will show a report. */
        reportDisplayMode: StiHtmlExportMode;
        /** Gets or sets the first day of week in the date picker */
        datePickerFirstDayOfWeek: StiFirstDayOfWeek;
        /** Gets or sets a value which allows touch zoom in the viewer. */
        allowTouchZoom: boolean;
        /** Obsolete. Please use the reportDisplayMode property instead. Should be removed in 2018.3 version. */
        htmlRenderMode: StiHtmlExportMode;
    }
}
declare module Stimulsoft.Viewer {
    class StiEmailOptions {
        /** Gets or sets a value which allows to display the Email dialog, or send Email with the default settings. */
        showEmailDialog: boolean;
        /** Gets or sets a value which allows to display the export dialog for Email, or export report for Email with the default settings. */
        showExportDialog: boolean;
        /** Gets or sets the default email address of the message created in the viewer. */
        defaultEmailAddress: string;
        /** Gets or sets the default subject of the message created in the viewer. */
        defaultEmailSubject: string;
        /** Gets or sets the default text of the message created in the viewer. */
        defaultEmailMessage: string;
    }
}
declare module Stimulsoft.Viewer {
    class StiExportsOptions {
        /** Gets or sets a value which allows store the export settings in the cookies. */
        storeExportSettings: boolean;
        /** Gets or sets a value which allows to display the export dialog, or to export with the default settings. */
        showExportDialog: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the report document file. */
        showExportToDocument: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the PDF format. */
        showExportToPdf: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the HTML format. */
        showExportToHtml: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the HTML5 format. */
        showExportToHtml5: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Word 2007-2010 format. */
        showExportToWord2007: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the Excel 2007-2010 format. */
        showExportToExcel2007: boolean;
        /** Gets or sets a value which indicates that the user can save the report from the viewer to the CSV format. */
        showExportToCsv: boolean;
    }
}
declare module Stimulsoft.Viewer {
    import Color = Stimulsoft.System.Drawing.Color;
    class StiToolbarOptions {
        /** Gets or sets a value which indicates that toolbar will be shown in the viewer. */
        visible: boolean;
        /** Gets or sets the display mode of the toolbar - simple or separated into upper and lower parts. */
        displayMode: StiToolbarDisplayMode;
        /** Gets or sets a color of the toolbar background. The default value is the theme color. */
        backgroundColor: Color;
        /** Gets or sets a color of the toolbar border. The default value is the theme color. */
        borderColor: Color;
        /** Gets or sets a color of the toolbar texts. */
        fontColor: Color;
        /** Gets or sets a value which indicates which font family will be used for drawing texts in the viewer. */
        fontFamily: string;
        /** Gets or sets the alignment of the viewer toolbar. */
        alignment: StiContentAlignment;
        /** Gets or sets a value which allows displaying or hiding toolbar buttons captions. */
        showButtonCaptions: boolean;
        /** Gets or sets a visibility of the Print button in the toolbar of the viewer. */
        showPrintButton: boolean;
        /** Gets or sets a visibility of the Open button in the toolbar of the viewer. */
        showOpenButton: boolean;
        /** Gets or sets a visibility of the Save button in the toolbar of the viewer. */
        showSaveButton: boolean;
        /** Gets or sets a visibility of the Send Email button in the toolbar of the viewer. */
        showSendEmailButton: boolean;
        /** Gets or sets a visibility of the Find button in the toolbar of the viewer. */
        showFindButton: boolean;
        /** Gets or sets a visibility of the Bookmarks button in the toolbar of the viewer. */
        showBookmarksButton: boolean;
        /** Gets or sets a visibility of the Parameters button in the toolbar of the viewer. */
        showParametersButton: boolean;
        /** Gets or sets a visibility of the Resources button in the toolbar of the viewer. */
        showResourcesButton: boolean;
        /** Gets or sets a visibility of the Editor button in the toolbar of the viewer. */
        showEditorButton: boolean;
        /** Gets or sets a visibility of the Full Screen button in the toolbar of the viewer. */
        showFullScreenButton: boolean;
        /** Gets or sets a visibility of the First Page button in the toolbar of the viewer. */
        showFirstPageButton: boolean;
        /** Gets or sets a visibility of the Prev Page button in the toolbar of the viewer. */
        showPreviousPageButton: boolean;
        /** Gets or sets a visibility of the current page control in the toolbar of the viewer. */
        showCurrentPageControl: boolean;
        /** Gets or sets a visibility of the Next Page button in the toolbar of the viewer. */
        showNextPageButton: boolean;
        /** Gets or sets a visibility of the Last Page button in the toolbar of the viewer. */
        showLastPageButton: boolean;
        /** Gets or sets a visibility of the Zoom control in the toolbar of the viewer. */
        showZoomButton: boolean;
        /** Gets or sets a visibility of the View Mode button in the toolbar of the viewer. */
        showViewModeButton: boolean;
        /** Gets or sets a visibility of the Design button in the toolbar of the viewer. */
        showDesignButton: boolean;
        /** Gets or sets a visibility of the About button in the toolbar of the viewer. */
        showAboutButton: boolean;
        /** Gets or sets a visibility of the Pin button in the toolbar of the viewer in mobile mode. */
        showPinToolbarButton: boolean;
        /** Gets or sets the default mode of the report print destination. */
        printDestination: StiPrintDestination;
        /** Gets or sets the mode of showing a report in the viewer - one page or the whole report. */
        viewMode: StiWebViewMode;
        multiPageWidthCount: number;
        multiPageHeightCount: number;
        private _zoom;
        /** Gets or sets the report showing zoom. The default value is 100. */
        zoom: number;
        /** Gets or sets a value which indicates that menu animation is enabled. */
        menuAnimation: boolean;
        /** Gets or sets the mode that shows menu of the viewer. */
        showMenuMode: StiShowMenuMode;
        /** Gets or sets a value which allows automatically hide the viewer toolbar in mobile mode. */
        autoHide: boolean;
    }
}
declare module Stimulsoft.Viewer {
    enum StiContentAlignment {
        Left = 0,
        Center = 1,
        Right = 2,
        Default = 3
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2,
        Mobile = 3
    }
    enum StiChartRenderType {
        Vector = 2,
        AnimatedVector = 3
    }
    enum StiPrintDestination {
        Default = 0,
        Pdf = 1,
        Direct = 2,
        WithPreview = 3
    }
    enum StiReportType {
        Auto = 0,
        Report = 1,
        Dashboard = 2
    }
    enum StiWebViewMode {
        SinglePage = 0,
        Continuous = 1,
        MultiplePages = 2,
        OnePage = 3,
        WholeReport = 4,
        MultiPage = 5
    }
    enum StiShowMenuMode {
        Click = 0,
        Hover = 1
    }
    enum StiZoomMode {
        PageWidth = -1,
        PageHeight = -2
    }
    enum StiExportAction {
        ExportReport = 1,
        SendEmail = 2
    }
    enum StiFirstDayOfWeek {
        Monday = 0,
        Sunday = 1
    }
    enum StiParametersPanelPosition {
        Top = 0,
        Left = 1
    }
    enum StiToolbarDisplayMode {
        Simple = 0,
        Separated = 1
    }
}
declare module Stimulsoft.Viewer {
    class StiEmailSettings {
        email: string;
        subject: string;
        message: string;
    }
}
declare module Stimulsoft.Viewer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiJsViewer {
        options: any;
        controls: any;
        reportParams: any;
        assignReport(report: StiReport): any;
        initAutoUpdateCache(jsText: any, jsObject: any): any;
        postAjax(url: string, data: any, callback?: any): any;
        postAction(action: string, bookmarkPage?: any, bookmarkAnchor?: any): any;
        postEmail(format: string, settingsObject: any): any;
        postExport(format: string, settingsObject: any, action: StiExportAction): any;
        postReportResource(resourceName: string, viewType: string): any;
        postPrint(action: string): any;
        postOpen(fileName: string, content: string): any;
        postInteraction(params: any): any;
        postDesign(): any;
        getReportParameters(action: string): any;
        viewer: StiViewer;
        InitializeErrorMessageForm(): any;
        updateVisibleState(): any;
        showParametersPanel(data: any, jsObject: any): any;
        constructor(parameters: any);
    }
    class StiViewer {
        drillDownReportCache: any;
        private _renderAfterCreate;
        onBeginProcessData: Function;
        onEndProcessData: Function;
        onPrintReport: Function;
        onBeginExportReport: Function;
        onEndExportReport: Function;
        onInteraction: Function;
        onEmailReport: Function;
        onDesignReport: Function;
        onShowReport: Function;
        onLoadDocument: Function;
        onGetReport: Function;
        onGetSubReport: Function;
        private reportCache;
        private _viewerId;
        readonly viewerId: string;
        private _options;
        readonly options: StiViewerOptions;
        private _jsObject;
        readonly jsObject: StiJsViewer;
        private _currentReportGuid;
        currentReportGuid: string;
        readonly reportTemplate: StiReport;
        report: StiReport;
        private _visible;
        visible: boolean;
        renderHtml(element?: string | HTMLElement): void;
        private invokeBeginProcessData;
        private invokeEndProcessData;
        private invokePrintReport;
        private invokeBeginExportReport;
        private invokeEndExportReport;
        private invokeInteraction;
        private invokeEmailReport;
        private invokeDesignReport;
        private invokeShowReport;
        private invokeLoadDocument;
        private invokeGetReport;
        private invokeOnGetSubReport;
        private callRemoteApi;
        private getReportPageAsync;
        private getPagesArray;
        private getReportFileName;
        showProcessIndicator(): void;
        hideProcessIndicator(): void;
        refreshViewer(): void;
        constructor(options?: StiViewerOptions, viewerId?: string, renderAfterCreate?: boolean);
    }
}
declare module Stimulsoft.Viewer {
    class StiViewerOptions {
        /** A class which controls settings of the viewer appearance. */
        appearance: StiAppearanceOptions;
        /** A class which controls settings of the viewer toolbar. */
        toolbar: StiToolbarOptions;
        /** A class which controls the export options. */
        exports: StiExportsOptions;
        /** A class which controls the export options. */
        email: StiEmailOptions;
        /** Gets or sets the width of the viewer. */
        width: string;
        /** Gets or sets the height of the viewer. */
        height: string;
        viewerId: string;
        reportDesignerMode: boolean;
        private requestStylesUrl;
        private productVersion;
        private actions;
        toParameters(): Object;
        private serializeObject;
    }
}

declare module Stimulsoft.Report.Check {
    class StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiAllowDoublePassAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiApplyGeneralTextFormat extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConversionContainerInPanelAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConversionContourTextInTextAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConversionSystemTextInTextAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteComponentAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiFixCrossLinePrimitiveAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNameComponentAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMinRowsInColumnsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMoveComponentToPageAreaAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMoveComponentToPrintablePageAreaAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteConnectionAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteDataRelationAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNameRelationAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteDataSourceAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNameDataSourceAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeleteLostPointsAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDeletePageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGenerateNewNamePageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLargeHeightAtPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiOrientationPageToLandscapeAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiOrientationPageToPortraitAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintHeadersFootersFromPreviousPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiResetPageNumberAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiSwitchWidthAndHeightOfPageAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiEditNameAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiEditPropertyAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGoToCodeAction extends StiAction {
        readonly name: string;
        readonly description: string;
        invoke(report: StiReport, element: any, elementName: string): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCheck {
        private _element;
        element: any;
        readonly previewVisible: boolean;
        readonly elementName: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        readonly objectType: StiCheckObjectType;
        readonly defaultStateEnabled: boolean;
        enabled: boolean;
        private _actions;
        readonly actions: StiAction[];
        processCheck(report: StiReport, obj: any): any;
        createPreviewImage(refElementImage: any, refHighlightedElementImage: any): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentCheck extends StiCheck {
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiAllowHtmlTagsInTextCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanBreakComponentInContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowComponentInContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowGrowToHeightComponentInContainerCheck extends StiComponentCheck {
        readonly defaultStateEnabled: boolean;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCanGrowWordWrapTextAndWysiwygCheck extends StiComponentCheck {
        readonly defaultStateEnabled: boolean;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterContainerWidthCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentBoundsAreOutOfBand extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentDataColumnCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtComponentCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiContainerInEngineV2Check extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiContourTextObsoleteCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCorruptedCrossLinePrimitiveCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCountDataDataSourceAtDataBandCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataSourcesForImageCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiFontMissingCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnContainerCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGrowToHeightOverlappingCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLocationOutsidePageCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        readonly isOutsidePage: boolean;
        readonly isOutsidePrintableArea: boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiMinRowsInColumnsCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNegativeSizesOfComponentsCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoConditionAtGroupCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameComponentCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnDoublePassCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiShowInsteadNullValuesCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiSystemTextObsoleteCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiTextColorEqualToBackColorCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiTextTextFormatCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        check(): boolean;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiUndefinedComponentCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVerySmallSizesOfComponentsCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiWidthHeightZeroComponentCheck extends StiComponentCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiWordWrapCanGrowTextDoesNotFitCheck extends StiComponentCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiConnectionCheck extends StiCheck {
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiUndefinedConnectionCheck extends StiConnectionCheck {
        private report;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataRelationCheck extends StiCheck {
        private dataBuilder;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDifferentAmountOfKeysInDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiKeysInAbsentDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiKeysNotFoundRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        private _columns;
        columns: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private isColumnsExist;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiKeysTypesMismatchDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        private _columns;
        columns: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private isColumnsExist;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        private _dataSources;
        dataSources: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameInSourceDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiSourcesInAbsentDataRelationCheck extends StiDataRelationCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataColumnCheck extends StiCheck {
        private dataBuilder;
        readonly previewVisible: boolean;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCalculatedColumnRecursionCheck extends StiDataColumnCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private checkForRecursion;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDataSourceCheck extends StiCheck {
        private dataBuilder;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameDataSourceCheck extends StiDataSourceCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNameInSourceDataSourceCheck extends StiDataSourceCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiUndefinedDataSourceCheck extends StiDataSourceCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    import StiDatabase = Stimulsoft.Report.Dictionary.StiDatabase;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    class StiUsedResourceHelper {
        static getDatabasesUsedResource(report: StiReport, resource: StiResource): StiDatabase[];
        static getComponentsUsedResource(report: StiReport, resource: StiResource): StiComponent[];
        private static getImageComponentsUsedResource;
        private static getRichTextComponentsUsedResource;
        private static getReportsUsedResource;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPageCheck extends StiCheck {
        readonly previewVisible: boolean;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiColumnsWidthGreaterPageWidthCheck extends Stimulsoft.Report.Check.StiPageCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiComponentStyleIsNotFoundAtPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiCrossGroupHeaderNotEqualToCrossGroupFooterOnPageCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiGroupHeaderNotEqualToGroupFooterOnPageCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLargeHeightAtPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiPointPrimitive = Stimulsoft.Report.Components.StiPointPrimitive;
    class StiLostPointsOnPageCheck extends StiPageCheck {
        readonly previewVisible: boolean;
        private readonly page;
        readonly shortMessage: string;
        readonly longMessage: string;
        private _lostPointsNames;
        lostPointsNames: string;
        readonly status: StiCheckStatus;
        static getLostPointsOnPage(page: StiPage): StiPointPrimitive[];
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiNoNamePageCheck extends StiPageCheck {
        private readonly page;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiOrientationPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintHeadersAndFootersFromPreviousPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiPrintOnPreviousPageCheck2 extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiResetPageNumberCheck extends StiPageCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private getPageCount;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiReportCheck extends StiCheck {
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDuplicatedNameCheck extends StiReportCheck {
        readonly elementName: string;
        readonly previewVisible: boolean;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private _isDataSource;
        isDataSource: boolean;
        private dataBuilder;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiDuplicatedNameInSourceInDataRelationReportCheck extends StiReportCheck {
        readonly previewVisible: boolean;
        private _relationsNames;
        relationsNames: string;
        private _relationsNameInSource;
        relationsNameInSource: string;
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiIsFirstPageIsLastPageDoublePassCheck extends StiReportCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiIsFirstPassIsSecondPassCheck extends StiReportCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiReportRenderingMessageCheck extends StiReportCheck {
        readonly shortMessage: string;
        private _longMessage;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        setMessage(message: string): void;
        processCheck(report: StiReport, msg: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiTotalPageCountDoublePassCheck extends StiReportCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private check;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVariableCheck extends StiCheck {
        readonly previewVisible: boolean;
        readonly objectType: StiCheckObjectType;
        readonly elementName: string;
    }
}
declare module Stimulsoft.Report.Check {
    class StiVariableRecursionCheck extends StiVariableCheck {
        readonly shortMessage: string;
        readonly longMessage: string;
        readonly status: StiCheckStatus;
        private checkForRecursion;
        processCheck(report: StiReport, obj: any): any;
    }
}
declare module Stimulsoft.Report.Check {
    enum StiCheckStatus {
        ReportRenderingMessage = 0,
        Information = 1,
        Warning = 2,
        Error = 3
    }
    enum StiCheckObjectType {
        Report = 0,
        Page = 1,
        Component = 2,
        Database = 3,
        DataSource = 4,
        DataRelation = 5,
        DataColumn = 6,
        Variable = 7
    }
}
declare module Stimulsoft.Report.Check {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCheckEngine {
        private invokeFinishCheckingReport;
        private invokeStartCheckingPages;
        private invokeCheckingPages;
        private invokeFinishCheckingPages;
        private invokeStartCheckingComponents;
        private invokeCheckingComponents;
        private invokeFinishCheckingComponents;
        private invokeStartCheckingDatabases;
        private invokeCheckingDatabases;
        private invokeFinishCheckingDatabases;
        private invokeStartCheckingDataSource;
        private invokeCheckingDataSource;
        private invokeFinishCheckingDataSource;
        private invokeStartCheckingRelations;
        private invokeCheckingRelations;
        private invokeFinishCheckingRelations;
        private invokeStartCheckingVariables;
        private invokeCheckingVariables;
        private invokeFinishCheckingVariables;
        private static _checks;
        static readonly checks: StiCheck[];
        private _progressValue;
        readonly progressValue: number;
        private _progressMaximum;
        readonly progressMaximum: number;
        private _progressInformation;
        readonly progressInformation: string;
        private static createChecks;
        checkReport(report: StiReport): StiCheck[];
        private static checkObject;
        constructor();
    }
}
declare module Stimulsoft.Report.Check {
    class StiCheckHelper {
        private _errorsCount;
        readonly errorsCount: number;
        private _warningsCount;
        readonly warningsCount: number;
        private _informationMessagesCount;
        readonly informationMessagesCount: number;
        private _reportRenderingMessagesCount;
        readonly reportRenderingMessagesCount: number;
        private _checks;
        readonly checks: StiCheck[];
        private _reportRenderingMessagesChecks;
        readonly reportRenderingMessagesChecks: StiCheck[];
        readonly isMessagesPresent: boolean;
        buildChecks(report: StiReport): void;
        buildReportRenderingMessages(report: StiReport): void;
    }
}
declare module Stimulsoft.Report.Check {
    class StiLocalizationExt {
        static languages: any;
        static English: any;
        private static _cultureName;
        static cultureName: string;
        static addLocalizationFile(filePath: string, load?: boolean, language?: string): string;
        static setLocalizationFile(filePath: string, onlyThis?: boolean): void;
        static loadLocalization(localizationXml: any, extension?: boolean): string;
        static loadLocalizationFile(filePath: string): string;
        private static loadLocalizationXmlInternal;
        static get(category: string, key: string): string;
    }
}

declare module Stimulsoft.Designer {
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    class StiAppearanceOptions {
        /** Gets or sets a default value of unit in the designer. */
        defaultUnit: StiReportUnitType;
        /** Gets or sets the type of the designer interface. */
        interfaceType: StiInterfaceType;
        /** Gets or sets a value which indicates that animation is enabled. */
        showAnimation: boolean;
        /** Gets or sets a visibility of the save dialog of the designer. */
        showSaveDialog: boolean;
        /** Gets or sets a value which indicates that show or hide tooltips. */
        showTooltips: boolean;
        /** Gets or sets a value which indicates that show or hide tooltips help icon. */
        showTooltipsHelp: boolean;
        /** Gets or sets a value which indicates which indicates that the designer is displayed in full screen mode. */
        fullScreenMode: boolean;
        /** Gets or sets a visibility of the localization control of the designer. */
        private _showLocalization;
        showLocalization: boolean;
        /** Allow the designer to change the window title. */
        allowChangeWindowTitle: boolean;
        /** Gets or sets a visibility of the properties grid in the designer. */
        showPropertiesGrid: boolean;
        /** Gets or sets a visibility of the report tree in the designer. */
        showReportTree: boolean;
        /** Gets or sets a position of the properties grid in the designer. */
        propertiesGridPosition: StiPropertiesGridPosition;
        private _zoom;
        /** Gets or sets the report showing zoom. The default value is 100. */
        zoom: number;
    }
}
declare module Stimulsoft.Designer {
    class StiBandsOptions {
        /** Gets or sets a visibility of the ReportTitleBand item in the bands menu of the designer. */
        showReportTitleBand: boolean;
        /** Gets or sets a visibility of the ReportSummaryBand item in the bands menu of the designer. */
        showReportSummaryBand: boolean;
        /** Gets or sets a visibility of the PageHeaderBand item in the bands menu of the designer. */
        showPageHeaderBand: boolean;
        /** Gets or sets a visibility of the PageFooterBand item in the bands menu of the designer. */
        showPageFooterBand: boolean;
        /** Gets or sets a visibility of the GroupHeaderBand item in the bands menu of the designer. */
        showGroupHeaderBand: boolean;
        /** Gets or sets a visibility of the GroupFooterBand item in the bands menu of the designer. */
        showGroupFooterBand: boolean;
        /** Gets or sets a visibility of the HeaderBand item in the bands menu of the designer. */
        showHeaderBand: boolean;
        /** Gets or sets a visibility of the FooterBand item in the bands menu of the designer. */
        showFooterBand: boolean;
        /** Gets or sets a visibility of the ColumnHeaderBand item in the bands menu of the designer. */
        showColumnHeaderBand: boolean;
        /** Gets or sets a visibility of the ColumnFooterBand item in the bands menu of the designer. */
        showColumnFooterBand: boolean;
        /** Gets or sets a visibility of the DataBand item in the bands menu of the designer. */
        showDataBand: boolean;
        /** Gets or sets a visibility of the HierarchicalBand item in the bands menu of the designer. */
        showHierarchicalBand: boolean;
        /** Gets or sets a visibility of the ChildBand item in the bands menu of the designer. */
        showChildBand: boolean;
        /** Gets or sets a visibility of the EmptyBand item in the bands menu of the designer. */
        showEmptyBand: boolean;
        /** Gets or sets a visibility of the OverlayBand item in the bands menu of the designer. */
        showOverlayBand: boolean;
        /** Gets or sets a visibility of the Table item in the bands menu of the designer. */
        showTable: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiComponentsOptions {
        /** Gets or sets a visibility of the Text item in the components menu of the designer. */
        showText: boolean;
        /** Gets or sets a visibility of the TextInCells item in the components menu of the designer. */
        showTextInCells: boolean;
        /** Gets or sets a visibility of the RichText item in the components menu of the designer. */
        showRichText: boolean;
        /** Gets or sets a visibility of the Image item in the components menu of the designer. */
        showImage: boolean;
        /** Gets or sets a visibility of the BarCode item in the components menu of the designer. */
        showBarCode: boolean;
        /** Gets or sets a visibility of the Shape item in the components menu of the designer. */
        showShape: boolean;
        /** Gets or sets a visibility of the Panel item in the components menu of the designer. */
        showPanel: boolean;
        /** Gets or sets a visibility of the Clone item in the components menu of the designer. */
        showClone: boolean;
        /** Gets or sets a visibility of the CheckBox item in the components menu of the designer. */
        showCheckBox: boolean;
        /** Gets or sets a visibility of the SubReport item in the components menu of the designer. */
        showSubReport: boolean;
        /** Gets or sets a visibility of the ZipCode item in the components menu of the designer. */
        showZipCode: boolean;
        /** Gets or sets a visibility of the Chart item in the components menu of the designer. */
        showChart: boolean;
        /** Gets or sets a visibility of the Gauge item in the components menu of the designer. */
        showGauge: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiCrossBandsOptions {
        /** Gets or sets a visibility of the CrossTab item in the crossbands menu of the designer. */
        showCrossTab: boolean;
        /** Gets or sets a visibility of the CrossGroupHeaderBand item in the crossbands menu of the designer. */
        showCrossGroupHeaderBand: boolean;
        /** Gets or sets a visibility of the CrossGroupFooterBand item in the crossbands menu of the designer. */
        showCrossGroupFooterBand: boolean;
        /** Gets or sets a visibility of the CrossHeaderBand item in the crossbands menu of the designer. */
        showCrossHeaderBand: boolean;
        /** Gets or sets a visibility of the CrossFooterBand item in the crossbands menu of the designer. */
        showCrossFooterBand: boolean;
        /** Gets or sets a visibility of the CrossDataBand item in the crossbands menu of the designer. */
        showCrossDataBand: boolean;
    }
}
declare module Stimulsoft.Designer {
    class StiDictionaryOptions {
        /** Gets or sets a visibility of the other category in the new connection form. */
        showAdaptersInNewConnectionForm: boolean;
        /** Gets or sets a visibility of the dictionary in the designer. */
        showDictionary: boolean;
        /** Gets or sets a value of permissions for datasources in the designer. */
        dataSourcesPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for datasources in the designer. */
        dataConnectionsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for columns in the designer. */
        dataColumnsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for relations in the designer. */
        dataRelationsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for business objects in the designer. */
        businessObjectsPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for variables in the designer. */
        variablesPermissions: StiDesignerPermissions;
        /** Gets or sets a value of connections for resources in the designer. */
        resourcesPermissions: StiDesignerPermissions;
    }
}
declare module Stimulsoft.Designer {
    class StiToolbarOptions {
        /** Gets or sets a visibility of the preview button in the toolbar of the designer. */
        showPreviewButton: boolean;
        /** Gets or sets a visibility of the save button in the toolbar of the designer. */
        showSaveButton: boolean;
        /** Gets or sets a visibility of the about button in the toolbar of the designer. */
        showAboutButton: boolean;
        /** Gets or sets a visibility of the publish button in the toolbar of the designer. */
        showPublishButton: boolean;
        /** Gets or sets a visibility of the file menu of the designer. */
        showFileMenu: boolean;
        /** Gets or sets a visibility of the item New in the file menu. */
        showFileMenuNew: boolean;
        /** Gets or sets a visibility of the item Open in the file menu. */
        showFileMenuOpen: boolean;
        /** Gets or sets a visibility of the item Save in the file menu. */
        showFileMenuSave: boolean;
        /** Gets or sets a visibility of the item Save As in the file menu. */
        showFileMenuSaveAs: boolean;
        /** Gets or sets a visibility of the item Close in the file menu. */
        showFileMenuClose: boolean;
        /** Gets or sets a visibility of the item Exit in the file menu. */
        showFileMenuExit: boolean;
        /** Gets or sets a visibility of the item Report Setup in the file menu. */
        showFileMenuReportSetup: boolean;
        /** Gets or sets a visibility of the item Options in the file menu. */
        showFileMenuOptions: boolean;
        /** Gets or sets a visibility of the item Info in the file menu. */
        showFileMenuInfo: boolean;
        /** Gets or sets a visibility of the item About in the file menu. */
        showFileMenuAbout: boolean;
        showSetupToolboxButton: boolean;
        showNewPageButton: boolean;
    }
}
declare module Stimulsoft.Designer {
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiVirtualSource = Stimulsoft.Report.Dictionary.StiVirtualSource;
    import StiDataColumnsCollection = Stimulsoft.Report.Dictionary.StiDataColumnsCollection;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import StiReport = Stimulsoft.Report.StiReport;
    import Promise = Stimulsoft.System.Promise;
    import StiFileDatabase = Stimulsoft.Report.Dictionary.StiFileDatabase;
    import StiDataTransformation = Stimulsoft.Report.Dictionary.StiDataTransformation;
    class StiDictionaryHelper {
        private static databaseItem4;
        private static databaseItem1;
        private static dataTransformationCategoryItem;
        private static datasourceItem;
        static dataTransformationItem(dataTransformation: StiDataTransformation): any;
        private static columnItem;
        private static parameterItem;
        private static relationItem;
        private static businessObjectItem;
        private static variableItem;
        private static tableItem;
        private static functionItem;
        private static functionsCategoryItem;
        private static resourceItem;
        private static imagesGalleryItem;
        private static richTextGalleryItem;
        static getGroupColumnsProperty(dataSource: StiVirtualSource): string;
        static getResultsProperty(dataSource: StiVirtualSource): string;
        private static setGroupColumnsAndResultsProperty;
        private static getDataParameterTypes;
        private static getItemType;
        private static getItemKeyObject;
        private static getItems;
        private static createDataBaseByTypeName;
        private static createDataBaseByServiceName;
        private static createDataAdapterByTypeName;
        private static copyProperties;
        static getColumnsByTypeAndNameOfObject(report: StiReport, props: any): StiDataColumnsCollection;
        private static getDatabaseByName;
        private static updateColumns;
        private static updateParameters;
        private static getVariableBasicType;
        private static getVariableType;
        private static getValueByType;
        private static setDialogInfoItems;
        static getBusinessObjectByFullName(report: StiReport, fullName: string[]): StiBusinessObject;
        private static getAjaxDataFromDatabaseInformation;
        private static convertAjaxDatabaseInfoToDatabaseInfo;
        private static createDataStoreSourceFromParams;
        private static saveDataSourceParam;
        static getViewDataItemValue(item: Object, type: Stimulsoft.System.Type): any;
        static createNewDatabaseFromResource(report: StiReport, resource: StiResource): StiFileDatabase;
        static getNewDatabaseName(report: StiReport, fileName: string): string;
        private static isCategoryVariable;
        private static getVariableCategory;
        static removeTempSampleData(report: StiReport, dataGuid: string): void;
        private static applyParametersToSqlSourse;
        private static applyDataSourceProps;
        private static applyConnectionProps;
        private static applyColumnProps;
        private static applyParameterProps;
        private static applyRelationProps;
        private static dataSourceContainDataRelation;
        private static dataSourceContainNameInSource;
        private static applyBusinessObjectProps;
        private static applyVariableProps;
        private static applyResourceProps;
        static getIconTypeForColumn(column: StiDataColumn): StiImagesID;
        static getLockedCalcImageIDFromType(type: Stimulsoft.System.Type, inherited: boolean): StiImagesID;
        private static getDataColumnImageIdFromType;
        private static getTypeValueToString;
        private static getTypeVariableToString;
        static getTypeFromString(type: string): Stimulsoft.System.Type;
        static getDictionaryTree(report: StiReport): any;
        static getResourcesTree(report: StiReport): any[];
        static getFunctionsTree(report: StiReport): any[];
        static getSystemVariablesTree(report: StiReport): string[];
        private static getDataBasesTree;
        private static isExistInDatabases;
        private static getObjectsTreeByCategories;
        private static getBusinessObjectsTree;
        private static getChildBusinessObjectsTree;
        private static getVariablesTree;
        private static getColumnsTree1;
        private static getColumnsTree2;
        private static getColumnsTree3;
        private static getParametersTree;
        private static getRelationsTree3;
        private static getRelationsTree2;
        private static getRelationsTree4;
        static getConnectionTypes(report: StiReport, param: any, callbackResult: any, showAdaptersInNewConnectionForm?: boolean): void;
        static getDataAdapterTypes(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditConnection(report: StiReport, param: any, callbackResult: any): void;
        static deleteConnection(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditRelation(report: StiReport, param: any, callbackResult: any): void;
        static deleteRelation(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditColumn(report: StiReport, param: any, callbackResult: any): void;
        static deleteColumn(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditParameter(report: StiReport, param: any, callbackResult: any): void;
        static deleteParameter(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditDataSource(report: StiReport, param: any, callbackResult: any): void;
        static deleteDataSource(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObject(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariable(report: StiReport, param: any, callbackResult: any): void;
        static deleteVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static editVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createVariablesCategory(report: StiReport, param: any, callbackResult: any): void;
        static createOrEditResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static editBusinessObjectCategory(report: StiReport, param: any, callbackResult: any): void;
        static synchronizeDictionary(report: StiReport, param: any, callbackResult: any): void;
        static newDictionary(report: StiReport, param: any, callbackResult: any): void;
        static getAllConnectionsAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static retrieveColumnsAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getDatabaseDataAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static applySelectedData(report: StiReport, param: any, callbackResult: any): void;
        static testConnectionAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static runQueryScriptAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static viewDataAsync(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static createFieldOnDblClick(report: StiReport, param: any, callbackResult: any): void;
        static getParamsFromQueryString(report: StiReport, param: any, callbackResult: any): void;
        static getImagesGallery(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getRichTextGallery(report: StiReport, param: any, callbackResult: any): void;
        static getSampleConnectionString(report: StiReport, param: any, callbackResult: any): void;
        static createDatabaseFromResource(report: StiReport, param: any, callbackResult: any): void;
        static deleteAllDataSources(report: StiReport, param: any, callbackResult: any): void;
        static getVariableItemsFromDataColumn(report: StiReport, param: any, callbackResult: any): Promise<void>;
        static moveDictionaryItem(report: StiReport, param: any, callbackResult: any): void;
        static moveConnectionDataToResource(report: StiReport, param: any, callbackResult: any): void;
        static openDictionary(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    class StiEncodingHelper {
        static decodeString(str: string): string;
        static encode(str: string): string;
    }
}
declare module Stimulsoft.Designer {
    import IStiSeriesLabels = Stimulsoft.Report.Chart.IStiSeriesLabels;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiSvgData = Stimulsoft.Report.Export.StiSvgData;
    import IStiChart = Stimulsoft.Report.Chart.IStiChart;
    import IStiSeries = Stimulsoft.Report.Chart.IStiSeries;
    import IStiArea = Stimulsoft.Report.Chart.IStiArea;
    import IStiConstantLines = Stimulsoft.Report.Chart.IStiConstantLines;
    import IStiStrips = Stimulsoft.Report.Chart.IStiStrips;
    import IStiChartConditionsCollection = Stimulsoft.Report.Chart.IStiChartConditionsCollection;
    import IStiChartFiltersCollection = Stimulsoft.Report.Chart.IStiChartFiltersCollection;
    class StiChartHelper {
        static getChartProperties(chart: IStiChart): any;
        static getSeriesArray(chart: IStiChart): any[];
        static getSeries(series: IStiSeries): any;
        static getConditions(conditions: IStiChartConditionsCollection): any[];
        static getFilters(filters: IStiChartFiltersCollection): any[];
        static getTypesCollection(chart: IStiChart): any[];
        static getArea(chart: IStiChart): any;
        static getStyle(chart: IStiChart): any;
        static getMainProperties(chart: IStiChart): any;
        static getConstantLines(chart: IStiChart): any[];
        static getConstantLineProperties(constantLine: IStiConstantLines): any;
        static getStrips(chart: IStiChart): any[];
        static getStripsProperties(strip: IStiStrips): any;
        static getLabels(seriesLabels: IStiSeriesLabels): any;
        static getSeriesProperties(series: IStiSeries): any;
        static getAreaProperties(area: IStiArea): any;
        static getLabelsProperties(labels: IStiSeriesLabels): any;
        private static setConditionsValue;
        private static setFiltersValue;
        static getChartSampleSvg(svgData: StiSvgData, zoom: number): string;
        private static addDefaultSeries;
        static cloneChart(chart: IStiChart): IStiChart;
        private static getChartStyles;
        static addSeries(report: StiReport, param: any, callbackResult: any): void;
        static removeSeries(report: StiReport, param: any, callbackResult: any): void;
        static seriesMove(report: StiReport, param: any, callbackResult: any): void;
        static addConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static removeConstantLineOrStrip(report: StiReport, param: any, callbackResult: any): void;
        static constantLineOrStripMove(report: StiReport, param: any, callbackResult: any): void;
        static getLabelsContent(report: StiReport, param: any, callbackResult: any): void;
        static getTrendLineContent(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any, forStylesControl: boolean): void;
        static setLabelsType(report: StiReport, param: any, callbackResult: any): void;
        static setTrendLineType(report: StiReport, param: any, callbackResult: any): void;
        static setChartStyle(report: StiReport, param: any, callbackResult: any): void;
        static setChartPropertyValue(report: StiReport, param: any, callbackResult: any): void;
        static setContainerValue(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiChartElement = Stimulsoft.Report.Dashboard.IStiChartElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiChartElementHelper {
        private chartElement;
        private getChartElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getValueMeters;
        private setPropertySeriesType;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterFromContainer;
        private renameMeter;
        private setExpression;
        private setFunction;
        private removeMeter;
        private removeAllMeters;
        private moveMeter;
        private duplicateMeter;
        private insertMeters;
        private createNewItem;
        private setSeriesType;
        private static getChartElementStyles;
        static getStylesContent(report: StiReport, param: any): any[];
        constructor(chartElement: IStiChartElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiComboBoxElement = Stimulsoft.Report.Dashboard.IStiComboBoxElement;
    class StiComboBoxElementHelper {
        private comboBoxElement;
        private getComboBoxElementJSProperties;
        private getMeterHashItem;
        getMetersHash(): any;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private createNewItem;
        private renameMeter;
        private setDataColumn;
        private setPropertyValue;
        constructor(comboBoxElement: IStiComboBoxElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    class StiDashboardScalingHelper {
        static applyScalingToDashboard(dashboard: StiPage, prevWidth: number, prevHeight: number): void;
        private static getLevel;
        private static round;
        private static round2;
        private static getAllLocations;
        private static topUpFilterElements;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiOnlineMapElement = Stimulsoft.Report.Dashboard.IStiOnlineMapElement;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiOnlineMapElementHelper {
        private onlineMapElement;
        static getBingMapScriptAsync(element: IStiElement, showTitle: boolean): Promise<string>;
        private getOnlineMapElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getMeterByContainerName;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setExpression;
        private renameMeter;
        private updateOnlineMapElementProperties;
        private createNewItem;
        private setFunction;
        private setDataColumn;
        private moveMeter;
        constructor(onlineMapElement: IStiOnlineMapElement);
    }
}
declare module Stimulsoft.Designer {
    import Promise = Stimulsoft.System.Promise;
    import IStiDashboardInteraction = Stimulsoft.Report.Dashboard.IStiDashboardInteraction;
    import StiElementLayout = Stimulsoft.Report.Dashboard.StiElementLayout;
    import StiDataTopN = Stimulsoft.Data.Engine.StiDataTopN;
    import StiSimpleBorder = Stimulsoft.Base.Drawing.StiSimpleBorder;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    import StiInteraction = Stimulsoft.Report.Components.StiInteraction;
    import StiBaseCondition = Stimulsoft.Report.Components.StiBaseCondition;
    import StiCondition = Stimulsoft.Report.Components.StiCondition;
    import StiColorScaleCondition = Stimulsoft.Report.Components.StiColorScaleCondition;
    import StiIconSetCondition = Stimulsoft.Report.Components.StiIconSetCondition;
    import StiDataBarCondition = Stimulsoft.Report.Components.StiDataBarCondition;
    import StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
    import StiConditionPermissions = Stimulsoft.Report.Components.StiConditionPermissions;
    import StiConditionBorderSides = Stimulsoft.Report.Components.StiConditionBorderSides;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiBorder = Stimulsoft.Base.Drawing.StiBorder;
    import StiBrush = Stimulsoft.Base.Drawing.StiBrush;
    import StiSubReport = Stimulsoft.Report.Components.StiSubReport;
    import StiShape = Stimulsoft.Report.Components.StiShape;
    import StiRichText = Stimulsoft.Report.Components.StiRichText;
    import Font = Stimulsoft.System.Drawing.Font;
    import StiImage = Stimulsoft.Report.Components.StiImage;
    import RectangleD = Stimulsoft.System.Drawing.Rectangle;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import StiStylesCollection = Stimulsoft.Report.Styles.StiStylesCollection;
    class StiReportEdit {
        static setPropertyValue(report: StiReport, propertyName: string, owner: any, value: any, enumType?: Object): void;
        static getPropertyValue(propertyName: string, owner: any): Object;
        static getFiltersProperty(obj: any): any;
        static setFiltersProperty(obj: any, value: any): void;
        static lowerFirstChar(text: string): string;
        static lowerFirstCharPropertyNames(text: string): string;
        static upperFirstChar(text: string): string;
        static base64ToImage(base64String: string): Stimulsoft.System.Drawing.Image;
        static imageToBase64(image: Stimulsoft.System.Drawing.Image): string;
        static fontToStr(font: Font): string;
        static brushToStr(brush: StiBrush): string;
        static borderToStr(border: StiBorder): string;
        static simpleBorderToStr(border: StiSimpleBorder): string;
        static getStringFromColor(color: Color): string;
        static addComponentToPage(component: StiComponent, currentPage: StiPage): void;
        static getParentName(comp: StiComponent): string;
        static getParentIndex(comp: StiComponent): number;
        static getComponentIndex(component: StiComponent): number;
        static getAllChildComponents(component: StiComponent): string;
        static getPropsRebuildPage(report: StiReport, currentPage: StiPage): any;
        static getAllDbsElementsSvgContentsAsync(report: StiReport): Promise<any>;
        static getPageIndexes(report: StiReport): any;
        static setComponentRectWithOffset(comp: StiComponent, newCompRect: RectangleD, command: string, resizeType: string, compProps: any): void;
        static setComponentRect(component: StiComponent, rect: RectangleD, alignToGrid?: boolean): void;
        static getComponentRect(component: StiComponent): string;
        static getPageSize(page: StiPage): string;
        static getPageMargins(page: StiPage): string;
        static getAllComponentsPositions(report: StiReport, callbackResult: any): void;
        private static getIconSetItemObject;
        private static getIconSetItemFromObject;
        static strToColor(colorStr: string): Color;
        static strToNumber(value: string): number;
        static numberToStr(value: number): string;
        static strToBrush(value: string): StiBrush;
        static strToBorder(value: string): StiBorder;
        static strToSimpleBorder(value: string): StiSimpleBorder;
        static strToFont(value: string): Font;
        static strBordersToConditionBorderSidesObject(borders: string): StiConditionBorderSides;
        static strPermissionsToConditionPermissionsObject(strPermissions: string): StiConditionPermissions;
        static getReportFileName(report: StiReport): string;
        static createInfographicComponent(componentTypeArray: string): StiComponent;
        static createShapeComponent(componentTypeArray: string): StiComponent;
        private static createBarCodeComponent;
        private static applyStyleCollection;
        static applyStyles(comp: StiComponent, stylesCollection: StiStylesCollection): void;
        static getComponentMainProperties(component: StiComponent, zoom: number): any;
        static getTableCells(table: StiTable, zoom: number): any[];
        static getColumnFromColumnPath(columnPath: string, report: StiReport): StiDataColumn;
        static getImageContentForPaint(imageComp: StiImage): string;
        static getWatermarkImageContentForPaint(page: StiPage, pageProps: any): string;
        static addPrimitivePoints(addedComp: StiComponent, currentPage: StiPage): void;
        static removePrimitivePoints(removiedComp: StiComponent): void;
        static changeRectPrimitivePoints(changedComp: StiComponent, rect: RectangleD): void;
        static checkAllPrimitivePoints(page: StiPage): void;
        static isAlignedByGrid(component: StiComponent): boolean;
        static addSubReportPage(subReport: StiSubReport, callbackResult: any): void;
        static getColorsCollectionProperty(colors: Color[]): any[];
        static getAllProperties(component: StiComponent): any;
        static getRichTextProperty(component: StiRichText): string;
        static getSortDataProperty(object: any): string;
        private static getRelationNameByNameInSource;
        private static getSingleSort;
        static getFiltersObject(filters: StiFiltersCollection): any[];
        static getFilterDataProperty(component: StiBaseCondition | StiComponent): string;
        static getFilterOnProperty(component: StiBaseCondition | StiComponent): boolean;
        static getFilterModeProperty(component: StiBaseCondition | StiComponent): string;
        static getSvgContentAsync2(component: StiComponent, zoom?: number): Promise<string>;
        static getConditionsProperty(component: StiComponent): string;
        static getDataBarConditionObject(condition: StiDataBarCondition): any;
        static getIconSetConditionObject(condition: StiIconSetCondition): any;
        static getColorScaleConditionObject(condition: StiColorScaleCondition): any;
        static getHighlightConditionObject(condition: StiCondition): any;
        static getComponentHeaderSize(component: Object): string;
        static getInteractionProperty(interaction: StiInteraction): any;
        static getCrossTabFieldsProperties(crossTab: StiCrossTab): any[];
        static getEventsProperty(object_: any): any;
        static getSubReportParametersProperty(subReport: StiSubReport): any[];
        static getShapeTypeProperty(component: StiShape): string;
        static getElementLayoutProperty(layout: StiElementLayout): string;
        static getPreviewSettingsProperty(report: StiReport): any;
        static getTopNProperty(topN: StiDataTopN): any;
        static getOnlineMapContentAsync(component: StiComponent): Promise<string>;
        static getCultures(): any[];
        static getDashboardInteractionProperty(dashboardInteraction: IStiDashboardInteraction): any;
        static setAllProperties(component: StiComponent, props: any[]): void;
        static setSubReportPageProperty(component: Object, propertyValue: any): void;
        static setContainerProperty(component: StiComponent, propertyValue: string): void;
        static setShapeTypeProperty(component: StiComponent, shapeType: string): void;
        static setBarCodeTypeProperty(component: StiComponent, propValue: string): void;
        static setMarginsProperty(component: StiComponent, propertyValue: string): void;
        static setTextProperty(component: StiComponent, propertyValue: string): void;
        static setExcelValueProperty(component: StiComponent, propertyValue: string): void;
        static setExcelSheetProperty(component: StiComponent, propertyValue: string): void;
        static setElementLayoutProperty(component: any, propValue: any): void;
        static setPreviewSettingsProperty(report: StiReport, previewSettings: any, callbackResult: any): void;
        static setColorsCollectionProperty(object_: any, propertyName: string, propertyValue: any[]): void;
        static setTopNProperty(component: any, propertyValue: any): void;
        static setDashboardInteractionProperty(dashboardInteraction: IStiDashboardInteraction, propertyValue: any): void;
        static setRichTextProperty(component: StiComponent, propertyValue: string): void;
        static setTextFormatProperty(component: StiComponent, propertyValue: any, propertyName?: string): void;
        static setConditionProperty(component: StiComponent, propertyValue: string): void;
        private static getCorrectName;
        static setDataSourceProperty(component: any, propertyValue: string): void;
        static setDataRelationProperty(component: any, propertyValue: string): void;
        static setMasterComponentProperty(component: StiComponent, propertyValue: string): void;
        static setBusinessObjectProperty(component: StiComponent, propertyValue: string): void;
        static setSortDataProperty1(object: any, sortArray: any[]): void;
        static setSortDataProperty2(object: any, propertyValue: string): void;
        private static getSortArray;
        private static getColumnPathArray;
        private static getChildRelation;
        static setFilterDataProperty1(component: StiBaseCondition | any, filters: any[]): void;
        static setFilterDataProperty2(component: StiBaseCondition | any, propertyValue: string): void;
        private static filterFromObject;
        private static strToFilterDataType;
        private static strToFilterCondition;
        static setFilterOnProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setFilterModeProperty(component: StiBaseCondition | StiComponent, propertyValue: string): void;
        static setShiftModeProperty(component: any, propValue: any): void;
        static setRestrictionsProperty(component: StiComponent, propertyValue: string): void;
        static setAnchorProperty(component: StiComponent, propertyValue: string): void;
        static setConditionsProperty(component: StiComponent, propertyValue: string): void;
        static createHighlightCondition(conditionObject: any): StiBaseCondition;
        static createDataBarCondition(conditionObject: any): StiBaseCondition;
        static createColorScaleCondition(conditionObject: any): StiBaseCondition;
        static createIconSetCondition(conditionObject: any): StiBaseCondition;
        static setInteractionProperty(component: any, propertyValue: any): void;
        static setChartStyleProperty(component: any, propertyValue: any): void;
        static setMapStyleProperty(component: any, propertyValue: any): void;
        static setCrossTabStyleProperty(component: any, propertyValue: any): void;
        static setSubReportParametersProperty(component: any, propertyValue: any): void;
        static writeReportInObject(report: StiReport, zoom?: number): any;
        static writeReportInObject2(report: StiReport, attachedItems: any, zoom?: number): any;
        static createComponent(report: StiReport, param: any, callbackResult: any): void;
        static removeComponent(report: StiReport, param: any, callbackResult: any): void;
        static changeRectComponent(report: StiReport, param: any, callbackResult: any): void;
        static addPage(report: StiReport, param: any, callbackResult: any): void;
        static removePage(report: StiReport, param: any, callbackResult: any): void;
        static readAllPropertiesFromString(report: StiReport, param: any, callbackResult: any): void;
        static changeUnit(report: StiReport, unitName: string): void;
        static getPreviewPagesAsync(onResult: Function, designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static cloneReportForPreview(report: StiReport): StiReport;
        static setToClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static getFromClipboard(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static addReportToUndoArray(designer: StiDesigner, report: StiReport): void;
        static getUndoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static getRedoStep(designer: StiDesigner, currentReport: StiReport, param: any, callbackResult: any): StiReport;
        static renameComponent(report: StiReport, param: any, callbackResult: any): void;
        static saveComponentClone(designer: StiDesigner, component: StiComponent): void;
        static canceledEditComponent(designer: StiDesigner, currentReport: StiReport, param: any): void;
        static createTextComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static createComponentFromResource(report: StiReport, param: any, callbackResult: any): void;
        private static alignToMaxGrid;
        private static alignToGrid;
        static createDataComponentFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        static setReportProperties(report: StiReport, param: any, callbackResult: any): void;
        static getReportProperties(report: StiReport): any;
        static pageMove(report: StiReport, param: any, callbackResult: any): void;
        static alignToGridComponents(report: StiReport, param: any, callbackResult: any): void;
        static changeArrangeComponents(report: StiReport, param: any, callbackResult: any): void;
        static duplicatePage(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static setEventValue(report: StiReport, param: any, callbackResult: any): void;
        static changeSizeComponents(report: StiReport, param: any, callbackResult: any): void;
        static createMovingCopyComponent(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        static updateReportAliases(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): void;
        private static getPageTypeFromContent;
        static openPage(report: StiReport, param: any, callbackResult: any): void;
        static checkSvgContent(checkObject: any): Promise<void>;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiProgressElement = Stimulsoft.Report.Dashboard.IStiProgressElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiProgressElementHelper {
        private progressElement;
        private getProgressElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private setExpression;
        private renameMeter;
        private setFunction;
        private moveMeter;
        private createNewItem;
        private setDataColumn;
        private setPropertyValue;
        private static getProgressElementStyles;
        static getStylesContentAsync(report: StiReport, param: any): Promise<any[]>;
        constructor(progressElement: IStiProgressElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiGaugeElement = Stimulsoft.Report.Dashboard.IStiGaugeElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiGaugeElementHelper {
        private gaugeElement;
        private getGaugeElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        private getGaugeRanges;
        private getGaugeRangeItem;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private moveMeter;
        private setExpression;
        private renameMeter;
        private setFunction;
        private createNewItem;
        private setDataColumn;
        private setPropertyValue;
        private setPropertyValueToGaugeRange;
        private addGaugeRange;
        private removeGaugeRange;
        private static getGaugeElementStyles;
        static getStylesContentAsync(report: StiReport, param: any): Promise<any[]>;
        constructor(gaugeElement: IStiGaugeElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiRegionMapElement = Stimulsoft.Report.Dashboard.IStiRegionMapElement;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiRegionMapElementHelper {
        private regionMapElement;
        private getRegionMapElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        static getMapDataForJS(regionMapElement: IStiRegionMapElement): any[];
        private static allowGroup;
        private static allowColor;
        private getMeterByContainerName;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setExpression;
        private renameMeter;
        private createNewItem;
        private setFunction;
        private setDataColumn;
        private moveMeter;
        private setProperties;
        private updateMapData;
        static createMapComponentFromRegionMapElement(regionMapElement: IStiRegionMapElement): StiMap;
        private static getRegionMapStyles;
        static getStylesContent(report: StiReport, param: any): any[];
        constructor(regionMapElement: IStiRegionMapElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDashboardHelper {
        static addDashboard(report: StiReport, param: any, callbackResult: any): void;
        static getDashboardGridLinesColor(page: StiPage): Color;
        static getDashboardGridDotsColor(page: StiPage): Color;
        static getSelectionBorderColor(page: StiPage): Color;
        static getSelectionCornerColor(page: StiPage): Color;
        static getDashboardBackColor(page: StiPage): Color;
        static createDashboardElement(report: StiReport, typeComponent: string): StiComponent;
        static getDashboardStylesAsync(report: StiReport, param: any, callbackResult: any): Promise<any[]>;
        static getDashboardStyleSampleImageAsync(element: IStiElement, width: number, height: number): Promise<string>;
        static changeDashboardStyle(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiDatePickerElement = Stimulsoft.Report.Dashboard.IStiDatePickerElement;
    class StiDatePickerElementHelper {
        private datePickerElement;
        private getDatePickerElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private renameMeter;
        private createNewItem;
        private setDataColumn;
        private setPropertyValue;
        constructor(datePickerElement: IStiDatePickerElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiElement = Stimulsoft.Report.Dashboard.IStiElement;
    class StiElementDataFiltersHelper {
        private element;
        private readonly dataFilterElement;
        private getElementDataFiltersJSPropertiesAsync;
        private getDataFilterType;
        private getFiltersAsync;
        private getDataValuesFromDataPathAsync;
        executeJSCommandAsync(parameters: any, callbackResult: any): Promise<void>;
        private moveFilter;
        private removeFilter;
        private insertFilters;
        private setPropertyValue;
        constructor(element: IStiElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiImageElement = Stimulsoft.Report.Dashboard.IStiImageElement;
    class StiImageElementHelper {
        private imageElement;
        private getImageElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        constructor(imageElement: IStiImageElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import Promise = Stimulsoft.System.Promise;
    import IStiIndicatorElement = Stimulsoft.Report.Dashboard.IStiIndicatorElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiIndicatorElementHelper {
        private indicatorElement;
        private getIndicatorElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getMeterByContainerName;
        private moveMeter;
        private setPropertyValue;
        private setExpression;
        private renameMeter;
        private setFunction;
        private createNewItem;
        private setDataColumn;
        private static getIndicatorElementStyles;
        static getStylesContentAsync(report: StiReport, param: any): Promise<any[]>;
        constructor(indicatorElement: IStiIndicatorElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiListBoxElement = Stimulsoft.Report.Dashboard.IStiListBoxElement;
    class StiListBoxElementHelper {
        private listBoxElement;
        private getListBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private moveMeter;
        private createNewItem;
        private renameMeter;
        private setDataColumn;
        private setPropertyValue;
        constructor(listBoxElement: IStiListBoxElement);
    }
}
declare module Stimulsoft.Designer {
    import StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
    import StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
    import StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
    import StiCurrencyFormatService = Stimulsoft.Report.Components.TextFormats.StiCurrencyFormatService;
    import StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
    import StiTimeFormatService = Stimulsoft.Report.Components.TextFormats.StiTimeFormatService;
    import StiPercentageFormatService = Stimulsoft.Report.Components.TextFormats.StiPercentageFormatService;
    import StiBooleanFormatService = Stimulsoft.Report.Components.TextFormats.StiBooleanFormatService;
    import StiCustomFormatService = Stimulsoft.Report.Components.TextFormats.StiCustomFormatService;
    class StiTextFormatHelper {
        static commonTextFormatItem(service: StiFormatService): any;
        static generalTextFormatItem(service: StiGeneralFormatService): any;
        static numberTextFormatItem(service: StiNumberFormatService): any;
        static currencyTextFormatItem(service: StiCurrencyFormatService): any;
        static dateTextFormatItem(service: StiDateFormatService): any;
        static timeTextFormatItem(service: StiTimeFormatService): any;
        static percentageTextFormatItem(service: StiPercentageFormatService): any;
        static booleanTextFormatItem(service: StiBooleanFormatService): any;
        static customTextFormatItem(service: StiCustomFormatService): any;
        private static getStateProperty;
        static getCurrencySymbols(): string[];
        static getFormatService(properties: any): StiFormatService;
        static getTextFormatItem(service: StiFormatService): any;
        static getDateAndTimeFormats(category: string, service: StiFormatService): any[];
        static getTextFormatItems(): any;
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiPivotTableElement = Stimulsoft.Report.Dashboard.IStiPivotTableElement;
    class StiPivotTableElementHelper {
        private pivotTableElement;
        private getPivotTableElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setPropertyValue;
        private getMeterFromContainer;
        private setExpression;
        private setTopN;
        private renameMeter;
        private setFunction;
        private removeAllMeters;
        private removeMeter;
        private moveMeter;
        private duplicateMeter;
        private insertMeters;
        private createNewItem;
        private swapColumnsRows;
        constructor(pivotTableElement: IStiPivotTableElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import StiComponent = Stimulsoft.Report.Components.StiComponent;
    import IStiShapeElement = Stimulsoft.Report.Dashboard.IStiShapeElement;
    class StiShapeElementHelper {
        private shapeElement;
        static createShapeElement(componentTypeArray: string): StiComponent;
        static setShapeTypeProperty(comp: IStiShapeElement, propValue: any): void;
        static getShapeTypeProperty(comp: IStiShapeElement): string;
        private getShapeElementJSProperties;
        private setPropertyValue;
        executeJSCommand(parameters: any, callbackResult: any): void;
        constructor(shapeElement: IStiShapeElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiMeter = Stimulsoft.Base.Meters.IStiMeter;
    import IStiTableElement = Stimulsoft.Report.Dashboard.IStiTableElement;
    import IStiDashboard = Stimulsoft.Report.Dashboard.IStiDashboard;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiTableElementHelper {
        private tableElement;
        private getMeterItem;
        private getMetersItems;
        static getMeterFunctions(meter: IStiMeter, dashboard: IStiDashboard): any[];
        private getTableElementJSProperties;
        static getMeterLabel(meter: IStiMeter): string;
        private static getSparklinesType;
        static getMeterType(meter: IStiMeter): string;
        static getMeterTypeIcon(meter: IStiMeter): string;
        private static checkMeasureMeterTextFormat;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private removeAllMeters;
        private convertMeter;
        private moveMeter;
        private newMeter;
        private duplicateMeter;
        private setFunction;
        private changeSparklinesType;
        private setPropertyValue;
        static createTableElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(tableElement: IStiTableElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiTextElement = Stimulsoft.Report.Dashboard.IStiTextElement;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiTextElementHelper {
        private textElement;
        private getTextElementJSProperties;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private setProperty;
        private static removeTagsFromText;
        static createTextElementFromDictionary(report: StiReport, param: any, callbackResult: any): void;
        constructor(textElement: IStiTextElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiTreeViewBoxElement = Stimulsoft.Report.Dashboard.IStiTreeViewBoxElement;
    class StiTreeViewBoxElementHelper {
        private treeViewBoxElement;
        private getTreeViewBoxElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private removeAllMeters;
        private createNewItem;
        private insertMeters;
        private removeMeter;
        private renameMeter;
        private moveMeter;
        private duplicateMeter;
        private setPropertyValue;
        constructor(treeViewBoxElement: IStiTreeViewBoxElement);
    }
}
declare namespace Stimulsoft.Designer.Dashboards {
    import IStiTreeViewElement = Stimulsoft.Report.Dashboard.IStiTreeViewElement;
    class StiTreeViewElementHelper {
        private treeViewElement;
        private getTreeViewElementJSProperties;
        private getMeterHashItem;
        private getMetersHash;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private removeAllMeters;
        private insertMeters;
        private createNewItem;
        private removeMeter;
        private renameMeter;
        private moveMeter;
        private duplicateMeter;
        private setPropertyValue;
        constructor(treeViewElement: IStiTreeViewElement);
    }
}
declare module Stimulsoft.Designer {
    class StiAggregateFunctions {
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiBarCode = Stimulsoft.Report.BarCodes.StiBarCode;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiBarCodeHelper {
        static getBarCodeJSObject(barCode: StiBarCode): any;
        static getBarCodeProperties(barCode: StiBarCode): any;
        static applyBarCodeProperties(report: StiReport, param: any, callbackResult: any): void;
        static getBarCodeSampleImage(barCode: StiBarCode): string;
    }
}
declare module Stimulsoft.Designer {
    class StiCodePageHelper {
        static getDBaseCodePageItems(): any[];
        static getCsvCodePageItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiCrossField = Stimulsoft.Report.CrossTab.StiCrossField;
    import StiCrossTab = Stimulsoft.Report.CrossTab.StiCrossTab;
    class StiCrossTabHelper {
        private rowTotals;
        private colTotals;
        private sumHeaders;
        private createdTotals;
        private crossTab;
        private columnsContainer;
        private rowsContainer;
        private summaryContainer;
        private selectedDataSource;
        private selectedBusinessObject;
        private oldLeft;
        private oldTop;
        restorePositions(): void;
        executeJSCommand(parameters: any, callbackResult: any): void;
        private getContainerByName;
        getCrossTabResult(): any[];
        getCrossFieldJSProperies(crossField: StiCrossField): any;
        getFieldsPropertiesForJS(): any;
        static getColorStyles(): any[];
        private updateCrossTab;
        private createRowTotal;
        private createColTotal;
        private swapColumnsAndRows;
        private changeSummaryDirection;
        private copySummaryToRow;
        private copySummaryToColumn;
        private copyHeaderToSummary;
        private copyRowToColumn;
        private copyColumnToRow;
        private copyRowTotalToColumnTotal;
        private copyColumnTotalToRowTotal;
        private copyFieldToField;
        private convertColumnTotal;
        private convertRowTotal;
        private killRightTitle;
        constructor(crossTab: StiCrossTab);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiCultureHelper {
        static getItems(): any[];
        private static getHashtableObjectForJs;
        private static getGlobalizationContainerObject;
        static getReportGlobalizationStrings(report: StiReport): any[];
        static addReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static removeReportGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
        static getCultureSettingsFromReport(report: StiReport, param: any, callbackResult: any): void;
        static setCultureSettingsToReport(report: StiReport, param: any, callbackResult: any): void;
        static applyGlobalizationStrings(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare namespace Stimulsoft.Designer {
    import Promise = Stimulsoft.System.Promise;
    import StiDataTransformationColumn = Stimulsoft.Report.Dictionary.StiDataTransformationColumn;
    import StiDictionary = Stimulsoft.Report.Dictionary.StiDictionary;
    import StiDataActionRule = Stimulsoft.Data.Engine.StiDataActionRule;
    import StiDataTransformation = Stimulsoft.Report.Dictionary.StiDataTransformation;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiDataSortRule = Stimulsoft.Data.Engine.StiDataSortRule;
    import StiDataFilterRule = Stimulsoft.Data.Engine.StiDataFilterRule;
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDataTransformationHelper {
        static columnItem(column: StiDataTransformationColumn, dictionary?: StiDictionary, originalType?: string): any;
        private static actionRuleItem;
        private static getFuncs;
        static createTransformationColumnFromDataColumn(dataColumn: StiDataColumn): StiDataTransformationColumn;
        private static toSumExpression;
        private static toExpression;
        static getColumnFromJSColumnObject(columnObject: any): StiDataTransformationColumn;
        static getSortRuleFromJSSortRuleObject(sortRuleObject: any): StiDataSortRule;
        static getFilterRuleFromJSFilterRuleObject(filterRuleObject: any): StiDataFilterRule;
        static getActionRuleFromJSActionRuleObject(actionRuleObject: any): StiDataActionRule;
        private static getDataTableContent;
        private static getDataValue;
        private static getSortLabels;
        private static getFilterLabels;
        private static distinct;
        private static isValueCanBeFiltered;
        static getColumns(dataTransformation: StiDataTransformation): any[];
        static getSortRules(dataTransformation: StiDataTransformation): any[];
        static getFilterRules(dataTransformation: StiDataTransformation): any[];
        static getActionRules(dataTransformation: StiDataTransformation): any[];
        static applyProperties(dataTransformation: StiDataTransformation, dataSourceProps: any, report: StiReport): void;
        static getDataGridContentAsync(dataTransformation?: StiDataTransformation): Promise<any>;
        static getFilterItemsHelperAsync2(dataTransformation: StiDataTransformation, parameters: any): Promise<any>;
        static getFilterItemsHelperAsync(report: StiReport, parameters: any): Promise<any>;
        static executeJSCommandAsync(designer: StiDesigner, report: StiReport, param: any, callbackResult: any): Promise<void>;
        static getDataTransformationFromElementAsync(report: StiReport, param: any): Promise<StiDataTransformation>;
    }
}
declare module Stimulsoft.Designer {
    class StiDefaultConditions {
        static getItems(): any;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignReportHelper {
        private report;
        getReportToObject(): any;
        getPages(): any[];
        getPage(pageIndex: number): any;
        private getComponents;
        private getComponent;
        private getReportInfo;
        constructor(report: StiReport);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiDesignerOptionsHelper {
        static getDefaultDesignerOptions(): any;
        private static getCookie;
        static getDesignerOptions(): any;
        static applyDesignerOptionsToReport(designerOptions: any, report: StiReport): void;
    }
}
declare module Stimulsoft.Designer {
    class StiEmptyObject {
    }
}
declare module Stimulsoft.Designer {
    class StiFontNames {
        private static item;
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiFontResourceHelper {
        static addFontToReport(report: StiReport, resource: StiResource, resourceItem: any): void;
        static getBase64DataForCssFromResourceContent(resourceType: StiResourceType, content: number[]): string;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
    import StiVariable = Stimulsoft.Report.Dictionary.StiVariable;
    import Image = Stimulsoft.System.Drawing.Image;
    import StiResource = Stimulsoft.Report.Dictionary.StiResource;
    class StiGalleriesHelper {
        static getImageColumns(report: StiReport): StiDataColumn[];
        static getImageVariables(report: StiReport): StiVariable[];
        static getImageResources(report: StiReport): StiResource[];
        static getRichTextColumns(report: StiReport): StiDataColumn[];
        static getRichTextVariables(report: StiReport): StiVariable[];
        static getRichTextResources(report: StiReport): StiResource[];
        static getImageFromColumn(column: StiDataColumn, report: StiReport): Image;
        static isRtfColumn(column: StiDataColumn, report: StiReport): boolean;
        static getRichTextAsHtmlFromColumn(column: StiDataColumn, report: StiReport): string;
        static getHtmlTextFromText(text: string): string;
        static getHtmlStringFromRichTextItem(report: StiReport, itemObject: any): string;
        private static getResource;
        private static getVariable;
    }
}
declare module Stimulsoft.Designer {
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiContainer = Stimulsoft.Report.Components.StiContainer;
    class StiGroup extends StiContainer {
        toString2(application: string): string;
        static createFromString(text: string, application: string): StiGroup;
        static getSelectedComponents(isSelectedFinded: boolean, level: number, cont: StiContainer, allComps: StiComponentsCollection, lists: Hashtable): StiComponentsCollection;
        static getGroupFromPage(page: StiPage): StiGroup;
        private static resetSelection;
        private static getAllComps;
        insertIntoPage(page: StiPage): StiComponentsCollection;
        constructor();
    }
}
declare module Stimulsoft.Designer {
    class StiHatchStyles {
        private static item;
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    class StiIconSetArrays {
        static getItems(): any;
    }
}
declare module Stimulsoft.Designer {
    import StiPage = Stimulsoft.Report.Components.StiPage;
    import StiComponentsCollection = Stimulsoft.Report.Components.StiComponentsCollection;
    class StiInsertionComponents {
        static insertGroups(currentPage: StiPage, group: StiGroup): void;
        static insertComponents(currentPage: StiPage, comps: StiComponentsCollection, alignToGrid?: boolean): void;
        static insert(currentPage: StiPage, alignToGrid?: boolean): void;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiMap = Stimulsoft.Report.Maps.StiMap;
    class StiMapHelper {
        static getMapProperties(map: StiMap): any;
        static setMapProperties(report: StiReport, param: any, callbackResult: any): void;
        static updateMapData(report: StiReport, param: any, callbackResult: any): void;
        static getMapDataForJS(map: StiMap): any[];
        private static allowGroup;
        private static allowColor;
        static getStyle(map: StiMap): any;
        private static getMapStyles;
        static getMapSampleImage(map: StiMap, width: number, height: number, zoom: number): string;
        static setMapStyle(report: StiReport, param: any, callbackResult: any): void;
        static getStylesContent(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    class StiPaperSizes {
        static getItems(): any[];
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiPreviewHelper {
        static getPages(report: StiReport, pageNumber: number, zoom: number, designerId: string): any[];
        private static renderReportPage;
        private static renderPageParameters;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiReportCheckHelper {
        private static checkItem;
        private static checkActionItem;
        private static getActions;
        private static removeCheck;
        private static getChecksJSCollection;
        private static updateCurrentReport;
        private static createImage;
        private static getErrorsCount;
        private static buildReportRenderingMessages;
        static checkReport(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any, callbackFunc: any): void;
        static getCheckPreview(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static actionCheck(designer: StiDesigner, report: StiReport, parameters: any, callbackResult: any): void;
        static checkExpression(report: StiReport, parameters: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import Color = Stimulsoft.System.Drawing.Color;
    import StiResourceType = Stimulsoft.Report.Dictionary.StiResourceType;
    class StiResourcesHelper {
        static getReportThumbnailParameters(report: StiReport, zoom: number): string;
        static getHtmlColor(color: Color): string;
        static isPackedFile(content: number[]): boolean;
        static getStringContentForJSFromResourceContent(resourceType: StiResourceType, content: number[]): string;
        static getResourceContent(report: StiReport, param: any, callbackResult: any): void;
        static getResourceText(report: StiReport, param: any, callbackResult: any): void;
        static setResourceText(report: StiReport, param: any, callbackResult: any): void;
        static getResourceViewData(report: StiReport, param: any, callbackResult: any): void;
        static isFontResourceType(resourceType: StiResourceType): boolean;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiShapeHelper {
        static getShapeSampleImage(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiStyleConditionsCollection = Stimulsoft.Report.Styles.Conditions.StiStyleConditionsCollection;
    import StiStyleCondition = Stimulsoft.Report.Styles.Conditions.StiStyleCondition;
    class StiStylesHelper {
        private static getStyleProperties;
        static styleItem(style: StiBaseStyle): any;
        static setConditionTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setLocationProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setComponentTypeProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setPlacementProperty(styleCondition: StiStyleCondition, propertyValue: string): void;
        static setStyleConditionsProprty(style: StiBaseStyle, conditions: any[]): void;
        static getStyleConditionsProprty(conditions: StiStyleConditionsCollection): any[];
        static getStyles(report: StiReport): any[];
        private static generateNewName;
        static applyStyleProperties(style: StiBaseStyle, properties: any): void;
        static writeStylesToReport(report: StiReport, stylesCollection: any[]): void;
        private static changeStyleNameInReport;
        static updateStyles(report: StiReport, param: any, callbackResult: any): void;
        static addStyle(report: StiReport, param: any, callbackResult: any): void;
        static createStyleCollection(report: StiReport, param: any, callbackResult: any): void;
        static createStylesFromComponents(report: StiReport, param: any, callbackResult: any): void;
        static openStyle(report: StiReport, param: any, callbackResult: any): void;
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    import StiTable = Stimulsoft.Report.Components.Table.StiTable;
    import Hashtable = Stimulsoft.System.Collections.Hashtable;
    class StiTableHelper {
        private table;
        private zoom;
        executeJSCommand(parameters: Hashtable, callbackResult: Hashtable): void;
        private getFirstIndexX;
        private getLastIndexX;
        private getFirstIndexY;
        private getLastIndexY;
        private joinCells;
        private setSelectedCurrentCells;
        private getSelectedCellNames;
        private getSelectedCellsByNames;
        static getTableStyles(report: StiReport): any[];
        static getTableCellsProperties(table: StiTable, zoom: number): any[];
        private getTableCellsForJS;
        private convertTableCell;
        constructor(table: StiTable, zoom: number);
    }
}
declare module Stimulsoft.Designer {
    import DataTable = Stimulsoft.System.Data.DataTable;
    import StiDataSource = Stimulsoft.Report.Dictionary.StiDataSource;
    import StiBusinessObject = Stimulsoft.Report.Dictionary.StiBusinessObject;
    import Promise = Stimulsoft.System.Promise;
    class StiViewDataHelper {
        resultDataTable: DataTable;
        dataSource: StiDataSource;
        private businessObject;
        private fillLevel2;
        private fillLevel4;
        buildAsync(): Promise<void>;
        constructor(dataSource: StiDataSource, businessObject?: StiBusinessObject);
    }
}
declare module Stimulsoft.Designer {
    import StiReport = Stimulsoft.Report.StiReport;
    class StiWizardHelper {
        private static getGroupsFromDataSource;
        private static getColumnsFromDataSource;
        private static getSortFromDataSource;
        private static getFiltersFromDataSource;
        private static getTotalsFromDataSource;
        private static alignToMaxGrid;
        private static alignToGrid;
        static getReportFromWizardOptions(createdReport: StiReport, reportOptions: any, wizardDataSources: any): StiReport;
    }
}
declare module Stimulsoft.Designer {
    enum StiImagesID {
        BusinessObject = 0,
        CalcColumn = 1,
        CalcColumnBinary = 2,
        CalcColumnBool = 3,
        CalcColumnChar = 4,
        CalcColumnDateTime = 5,
        CalcColumnDecimal = 6,
        CalcColumnFloat = 7,
        CalcColumnImage = 8,
        CalcColumnInt = 9,
        CalcColumnString = 10,
        Class = 11,
        Close = 12,
        ColumnsOrder = 13,
        Connection = 14,
        ConnectionFail = 15,
        DataColumn = 16,
        DataColumnBinary = 17,
        DataColumnBool = 18,
        DataColumnChar = 19,
        DataColumnDateTime = 20,
        DataColumnDecimal = 21,
        DataColumnFloat = 22,
        DataColumnImage = 23,
        DataColumnInt = 24,
        DataColumnString = 25,
        DataSource = 26,
        DataSources = 27,
        DataStore = 28,
        DataTable = 29,
        DataTables = 30,
        Folder = 31,
        Format = 32,
        FormatBoolean = 33,
        FormatCurrency = 34,
        FormatDate = 35,
        FormatGeneral = 36,
        FormatNumber = 37,
        FormatPercentage = 38,
        FormatTime = 39,
        Function = 40,
        HtmlTag = 41,
        LabelType = 42,
        LockedCalcColumn = 43,
        LockedCalcColumnBinary = 44,
        LockedCalcColumnBool = 45,
        LockedCalcColumnChar = 46,
        LockedCalcColumnDateTime = 47,
        LockedCalcColumnDecimal = 48,
        LockedCalcColumnFloat = 49,
        LockedCalcColumnImage = 50,
        LockedCalcColumnInt = 51,
        LockedCalcColumnString = 52,
        LockedConnection = 53,
        LockedDataColumn = 54,
        LockedDataColumnBinary = 55,
        LockedDataColumnBool = 56,
        LockedDataColumnChar = 57,
        LockedDataColumnDateTime = 58,
        LockedDataColumnDecimal = 59,
        LockedDataColumnFloat = 60,
        LockedDataColumnImage = 61,
        LockedDataColumnInt = 62,
        LockedDataColumnString = 63,
        LockedDataSource = 64,
        LockedFolder = 65,
        LockedParameter = 66,
        LockedRelation = 67,
        LockedVariable = 68,
        LockedVariableBinary = 69,
        LockedVariableBool = 70,
        LockedVariableChar = 71,
        LockedVariableDateTime = 72,
        LockedVariableDecimal = 73,
        LockedVariableFloat = 74,
        LockedVariableImage = 75,
        LockedVariableInt = 76,
        LockedVariableString = 77,
        Namespace = 78,
        Parameter = 79,
        Property = 80,
        Queries = 81,
        Query = 82,
        RecentConnection = 83,
        Relation = 84,
        StoredProcedure = 85,
        StoredProcedures = 86,
        SystemVariable = 87,
        SystemVariableColumn = 88,
        SystemVariableGroupLine = 89,
        SystemVariableIsFirstPage = 90,
        SystemVariableIsFirstPageThrough = 91,
        SystemVariableIsLastPage = 92,
        SystemVariableIsLastPageThrough = 93,
        SystemVariableLine = 94,
        SystemVariableLineABC = 95,
        SystemVariableLineRoman = 96,
        SystemVariableLineThrough = 97,
        SystemVariablePageNofM = 98,
        SystemVariablePageNofMThrough = 99,
        SystemVariablePageNumber = 100,
        SystemVariablePageNumberThrough = 101,
        SystemVariableReportAlias = 102,
        SystemVariableReportAuthor = 103,
        SystemVariableReportChanged = 104,
        SystemVariableReportCreated = 105,
        SystemVariableReportDescription = 106,
        SystemVariableReportName = 107,
        SystemVariables = 108,
        SystemVariableTime = 109,
        SystemVariableToday = 110,
        SystemVariableTotalPageCount = 111,
        SystemVariableTotalPageCountThrough = 112,
        UndefinedConnection = 113,
        UndefinedDataSource = 114,
        Variable = 115,
        VariableBinary = 116,
        VariableBool = 117,
        VariableChar = 118,
        VariableDateTime = 119,
        VariableDecimal = 120,
        VariableFloat = 121,
        VariableImage = 122,
        VariableInt = 123,
        VariableString = 124,
        View = 125,
        Views = 126,
        LockedVariableListBool = 127,
        LockedVariableListChar = 128,
        LockedVariableListDateTime = 129,
        LockedVariableListDecimal = 130,
        LockedVariableListFloat = 131,
        LockedVariableListImage = 132,
        LockedVariableListInt = 133,
        LockedVariableListString = 134,
        LockedVariableRangeChar = 135,
        LockedVariableRangeDateTime = 136,
        LockedVariableRangeDecimal = 137,
        LockedVariableRangeFloat = 138,
        LockedVariableRangeInt = 139,
        LockedVariableRangeString = 140,
        VariableListBool = 141,
        VariableListChar = 142,
        VariableListDateTime = 143,
        VariableListDecimal = 144,
        VariableListFloat = 145,
        VariableListImage = 146,
        VariableListInt = 147,
        VariableListString = 148,
        VariableRangeChar = 149,
        VariableRangeDateTime = 150,
        VariableRangeDecimal = 151,
        VariableRangeFloat = 152,
        VariableRangeInt = 153,
        VariableRangeString = 154
    }
    enum StiDesignerPermissions {
        /** Deny all. */
        None = 0,
        /** Allows to create an item. */
        Create = 1,
        /** Allows to delete an item. */
        Delete = 2,
        /** Allows to modify an item. */
        Modify = 4,
        /** Allows to view an item. */
        View = 8,
        /** Allows modify and view an item. */
        ModifyView = 12,
        /** Allow any action with an item. */
        All = 15
    }
    enum StiInterfaceType {
        Auto = 0,
        Mouse = 1,
        Touch = 2
    }
    enum StiFirstDayOfWeek {
        Monday = 0,
        Sunday = 1
    }
    enum StiPropertiesGridPosition {
        Left = 0,
        Right = 1
    }
}
declare module Stimulsoft.Designer {
    import StiCheck = Stimulsoft.Report.Check.StiCheck;
    import StiReport = Stimulsoft.Report.StiReport;
    import StiReportUnitType = Stimulsoft.Report.StiReportUnitType;
    import StiViewer = Stimulsoft.Viewer.StiViewer;
    class StiJsDesigner {
        options: any;
        loc: any;
        designer: StiDesigner;
        assignReport(report: StiReport): any;
        SendCommandUpdateCache(): any;
        SendCommandLoadReportToViewer(): any;
        SendCommandCloseViewer(): any;
        SendCommandOpenReport(fileContent: any, fileName: string, reportParams: any, filePath?: string): any;
        ExecuteCommandFromStack(): any;
        Sen(evt: any): any;
        ActionExitDesigner(): any;
        InitializeAboutPanel(): any;
        InitializeProcessImage(): any;
        InitializeErrorMessageForm(): any;
        ActionOpenReport(): any;
        SendCommandSaveStyle(stylesCollection: any[]): any;
        SendCommandSavePage(pageIndex: string): any;
        SendCommandSaveDictionary(): any;
        GetFontNamesItems(): any;
        AddCustomFontsCss(customFontsCss: string): any;
        InitializeSelectDataForm(func: any): any;
        InitializeImageForm(func: any): any;
        RunWizard(wizardType: string): any;
        InitializeFileMenu(): any;
        constructor(parameters: any);
    }
    class StiDesigner {
        private _renderAfterCreate;
        private viewState;
        undoLevel: number;
        private callbackResult;
        private viewerOptions;
        viewer: StiViewer;
        onBeginProcessData: Function;
        onEndProcessData: Function;
        onCreateReport: Function;
        onOpenReport: Function;
        onSaveReport: Function;
        onSaveAsReport: Function;
        onPreviewReport: Function;
        onExit: Function;
        onGetSubReport: Function;
        private _designerId;
        readonly designerId: string;
        private _options;
        readonly options: StiDesignerOptions;
        private _jsObject;
        readonly jsObject: StiJsDesigner;
        private _report;
        report: StiReport;
        private _reportGuid;
        reportGuid: string;
        private _renderedReport;
        renderedReport: StiReport;
        private _clipboardId;
        clipboardId: string;
        private _clipboard;
        clipboard: string;
        private _stylesClipboard;
        stylesClipboard: any;
        private _undoArrayId;
        undoArrayId: string;
        private _undoArray;
        undoArray: any[];
        private _componentCloneId;
        componentCloneId: string;
        private _componentClone;
        componentClone: any;
        private _reportCheckers;
        reportCheckers: StiCheck[];
        defaultUnit: StiReportUnitType;
        private _visible;
        visible: boolean;
        private _element;
        renderHtml(element?: string | HTMLElement): void;
        private invokeBeginProcessData;
        private invokeEndProcessData;
        private invokeOnGetSubReport;
        private invokeCreateReport;
        private invokeOpenReport;
        private invokeSaveReport;
        private invokeSaveAsReport;
        private invokePreviewReport;
        private invokeExit;
        private getNewReport;
        private getNewDashboard;
        private getReportFileName;
        private static asyncPromise;
        private raiseCallbackEventAsync;
        constructor(options?: StiDesignerOptions, designerId?: string, renderAfterCreate?: boolean);
    }
}
declare module Stimulsoft.Designer {
    import StiViewerOptions = Stimulsoft.Viewer.StiViewerOptions;
    class StiDesignerOptions {
        /** A class which controls settings of the designer appearance. */
        appearance: StiAppearanceOptions;
        /** A class which controls settings of the designer toolbar. */
        toolbar: StiToolbarOptions;
        /** A class which controls settings of the bands. */
        bands: StiBandsOptions;
        /** A class which controls settings of the cross-bands. */
        crossBands: StiCrossBandsOptions;
        /** A class which controls settings of the components. */
        components: StiComponentsOptions;
        /** A class which controls settings of the dictionary. */
        dictionary: StiDictionaryOptions;
        /** Gets or sets the width of the designer. */
        width: string;
        /** Gets or sets the height of the designer. */
        height: string;
        viewerOptions: StiViewerOptions;
        mobileDesignerId: string;
        private productVersion;
        toParameters(): Object;
        private serializeObject;
    }
}
